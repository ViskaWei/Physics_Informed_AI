# AI方向 - 编程题（第2/3题）题目(ZhContent) + 题解(TextSol)

> 生成时间：1/2/2026, 1:57:16 PM

## 2025年12月17日-AI方向

### 第2题-使用线性回归预测手机售价（P4532）
- 链接：https://codefun2000.com/p/P4532

> 页面标题：#P4532. 第2题-使用线性回归预测手机售价

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

手机的售价跟手机的软硬件特性有关系。硬件规格越高、软件特性越丰富，则手机给消费者提供的价值越大，同时手机的售价越高。我们在市面上收集了若干款手机，从硬件能力、系统流畅度、AIAIAI能力333个方面对这些手机进行打分，并记录这些手机的分数和售价。请你使用最小二乘法建立线性回归模型，对这3个特征和手机售价的关系进行线性回归，然后预测若干款待上市的手机型号应该卖多少价钱。
该题目的数据保证最小二乘法有解析解。建议使用正规方程法，即矩阵求解。如果使用梯度下降法，请迭代至预测值的小数点后第一位稳定不变，以保证精度满足题目要求。
输入描述
第111行，正整数KKK，已知的手机个数。
第222行，KKK个手机的特征和售价记录，均为整数。用空格分割，一共4K4K4K数字是售个数字。每444个数字为一组，第111-333个数字为特征值,第4个数字是售价。。
第333行，正整数NNN，待估价的手机数量。
第444行，NNN个手机型号对应的特征，均为整数。用空格分割，一共3N3N3N个数字。每333个数字为一组，分别为333个特征值。
输出描述
NNN个正整数，代表每个手机的价格，使用空格分割，四舍五入取整数。
样例1
输入

10
86 99 20 3595 175 171 90 6596 194 42 47 4691 192 172 26 5927 44 20 168 4169 61 138 64 4348 161 42 85 4791 197 181 99 7126 170 55 95 5208 26 158 142 5231
2
159 135 173 120 144 59

输出
7116 5120

说明
已知101010台手机的评分和售价，以第111台手机型号为例，硬件能力评分为868686、系统流畅度评分为999999、AI能力评分为202020，售价为359535953595。以此类推。
需要求解222台手机的预期售价，其中第111台手机的硬件能力评分为159159159、系统流畅度评分为135135135、AI能力评分为173173173，使用正规方程法求解，得到的预期售价求整结果是711671167116。以此类推。
样例2
输入
4
30 23 24 1999 55 53 46 2999 68 85 78 3999 113 90 103 4999
1
126 114 143

输出
6009

说明
已知444台手机的评分和售价，以第111台手机为例，硬件能力评分为303030、系统流畅度评分为232323、AIAIAI能力评分为242424，售价为199919991999。以此类推。需要求解111台手机的预期售价，这台手机的硬件能力评分为126126126、系统流畅度评分为114114114、AIAIAI能力评分为143143143，使用正规方程法求解，得到的预期售价的求整结果是600960096009。

#### TextSol

解题思路
本题是一个多元线性回归建模问题：已知 KKK 部手机的三项评分特征与售价，要求拟合出线性关系，并用该关系预测新手机的价格。
1. 线性模型建立
设第 iii 个样本的三维特征为 x(i)=(x1(i),x2(i),x3(i))x^{(i)}=(x^{(i)}_1,x^{(i)}_2,x^{(i)}_3)x(i)=(x1(i)​,x2(i)​,x3(i)​)，对应售价为 y(i)y^{(i)}y(i)。
假设售价与特征满足线性关系：
$y^{(i)} = w_0 + w_1 x^{(i)}_1 + w_2 x^{(i)}_2 + w_3 x^{(i)}_3$
其中 w0w_0w0​ 是偏置项，w1,w2,w3w_1,w_2,w_3w1​,w2​,w3​ 是三个特征的权重。
为方便统一表示，把偏置并入特征，定义扩展特征：
$\tilde{x}^{(i)} = (1, x^{(i)}_1, x^{(i)}_2, x^{(i)}_3)$，参数向量为 W=(w0,w1,w2,w3)W=(w_0,w_1,w_2,w_3)W=(w0​,w1​,w2​,w3​)，则：
y(i)=W⋅x~(i)y^{(i)} = W \cdot \tilde{x}^{(i)}y(i)=W⋅x~(i)
2. 最小二乘目标
由于样本通常不能被一条直线（超平面）完全拟合，我们用最小二乘法，让预测值与真实值的平方误差之和最小：
$\min\limits_W \sum_{i=1}^{K}\left(W\cdot \tilde{x}^{(i)} - y^{(i)}\right)^2$
3. 求解方法（高斯消元/正规方程）
对上式求极值可得到一组线性方程（正规方程的结果），题目保证可解且数值稳定时，可以直接通过解线性方程组得到 WWW。工程实现上，不必显式写出复杂矩阵形式，只需构造一个 4×44\times 44×4 的系数矩阵和长度为 444 的常数向量，然后使用 高斯消元（Gauss Elimination） 求解：

扫描所有样本，累加得到系数矩阵中的各项（相当于统计不同特征乘积的和）
用高斯消元解出 w0,w1,w2,w3w_0,w_1,w_2,w_3w0​,w1​,w2​,w3​
对每个待预测手机特征代入 y=w0+w1x1+w2x2+w3x3y = w_0+w_1x_1+w_2x_2+w_3x_3y=w0​+w1​x1​+w2​x2​+w3​x3​ 输出结果

复杂度分析
设：

已知手机数量为 (K)
特征维度为常数 4（含偏置）

时间复杂度

构造矩阵与计算 (X^T X)：(O(K))
矩阵求逆（4×4）：(O(1))
预测 (N) 台手机：(O(N))

总时间复杂度：(O(K + N))
空间复杂度

存储矩阵 (X, Y) 以及中间矩阵，规模固定

空间复杂度：(O(1))
代码实现
Python
import sys
import math

def linear_regression_predict(K, train_data, N, test_data):
# X 是 K×4 矩阵，Y 是 K×1 向量
X = []
Y = []
idx = 0
for _ in range(K):
x1, x2, x3, y = train_data[idx:idx+4]
idx += 4
X.append([1.0, x1, x2, x3])
Y.append(y)

# 计算 X^T * X 和 X^T * Y
XT_X = [[0.0]*4 for _ in range(4)]
XT_Y = [0.0]*4
for i in range(K):
for a in range(4):
XT_Y[a] += X[i][a] * Y[i]
for b in range(4):
XT_X[a][b] += X[i][a] * X[i][b]

# 高斯消元法求解 (X^T X)W = X^T Y
# 构造增广矩阵
A = [XT_X[i] + [XT_Y[i]] for i in range(4)]

# 消元
for i in range(4):
pivot = A[i][i]
for j in range(i, 5):
A[i][j] /= pivot
for k in range(4):
if k != i:
factor = A[k][i]
for j in range(i, 5):
A[k][j] -= factor * A[i][j]

W = [A[i][4] for i in range(4)]

# 预测
res = []
idx = 0
for _ in range(N):
x1, x2, x3 = test_data[idx:idx+3]
idx += 3
y_pred = W[0] + W[1]*x1 + W[2]*x2 + W[3]*x3
res.append(str(int(round(y_pred))))
return res

def main():
data = sys.stdin.read().strip().split()
pos = 0
K = int(data[pos]); pos += 1
train_data = list(map(int, data[pos:pos+4*K]))
pos += 4*K
N = int(data[pos]); pos += 1
test_data = list(map(int, data[pos:pos+3*N]))

ans = linear_regression_predict(K, train_data, N, test_data)
print(" ".join(ans))

if __name__ == "__main__":
main()

Java
import java.util.Scanner;

public class Main {

// 使用正规方程法进行线性回归预测
static long[] predict(int K, int[] train, int N, int[] test) {
double[][] XT_X = new double[4][4];
double[] XT_Y = new double[4];

// 构造 X^T X 和 X^T Y
int idx = 0;
for (int i = 0; i < K; i++) {
double[] x = new double[]{1, train[idx], train[idx+1], train[idx+2]};
double y = train[idx+3];
idx += 4;

for (int a = 0; a < 4; a++) {
XT_Y[a] += x[a] * y;
for (int b = 0; b < 4; b++) {
XT_X[a][b] += x[a] * x[b];
}
}
}

// 构造增广矩阵
double[][] A = new double[4][5];
for (int i = 0; i < 4; i++) {
System.arraycopy(XT_X[i], 0, A[i], 0, 4);
A[i][4] = XT_Y[i];
}

// 高斯消元
for (int i = 0; i < 4; i++) {
double pivot = A[i][i];
for (int j = i; j < 5; j++) {
A[i][j] /= pivot;
}
for (int k = 0; k < 4; k++) {
if (k != i) {
double factor = A[k][i];
for (int j = i; j < 5; j++) {
A[k][j] -= factor * A[i][j];
}
}
}
}

double[] W = new double[4];
for (int i = 0; i < 4; i++) {
W[i] = A[i][4];
}

// 预测
long[] res = new long[N];
idx = 0;
for (int i = 0; i < N; i++) {
double x1 = test[idx++];
double x2 = test[idx++];
double x3 = test[idx++];
double y = W[0] + W[1]*x1 + W[2]*x2 + W[3]*x3;
res[i] = Math.round(y);
}
return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int K = sc.nextInt();
int[] train = new int[4*K];
for (int i = 0; i < 4*K; i++) train[i] = sc.nextInt();
int N = sc.nextInt();
int[] test = new int[3*N];
for (int i = 0; i < 3*N; i++) test[i] = sc.nextInt();

long[] ans = predict(K, train, N, test);
for (int i = 0; i < ans.length; i++) {
if (i > 0) System.out.print(" ");
System.out.print(ans[i]);
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 使用正规方程法进行线性回归
vector<long long> predict(int K, vector<int>& train, int N, vector<int>& test) {
double XT_X[4][4] = {0};
double XT_Y[4] = {0};

int idx = 0;
for (int i = 0; i < K; i++) {
double x[4] = {1.0, (double)train[idx], (double)train[idx+1], (double)train[idx+2]};
double y = train[idx+3];
idx += 4;

for (int a = 0; a < 4; a++) {
XT_Y[a] += x[a] * y;
for (int b = 0; b < 4; b++) {
XT_X[a][b] += x[a] * x[b];
}
}
}

// 增广矩阵
double A[4][5];
for (int i = 0; i < 4; i++) {
for (int j = 0; j < 4; j++) A[i][j] = XT_X[i][j];
A[i][4] = XT_Y[i];
}

// 高斯消元
for (int i = 0; i < 4; i++) {
double pivot = A[i][i];
for (int j = i; j < 5; j++) A[i][j] /= pivot;
for (int k = 0; k < 4; k++) {
if (k != i) {
double factor = A[k][i];
for (int j = i; j < 5; j++) {
A[k][j] -= factor * A[i][j];
}
}
}
}

double W[4];
for (int i = 0; i < 4; i++) W[i] = A[i][4];

vector<long long> res(N);
idx = 0;
for (int i = 0; i < N; i++) {
double x1 = test[idx++];
double x2 = test[idx++];
double x3 = test[idx++];
double y = W[0] + W[1]*x1 + W[2]*x2 + W[3]*x3;
res[i] = llround(y);
}
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int K;
cin >> K;
vector<int> train(4*K);
for (int i = 0; i < 4*K; i++) cin >> train[i];

int N;
cin >> N;
vector<int> test(3*N);
for (int i = 0; i < 3*N; i++) cin >> test[i];

vector<long long> ans = predict(K, train, N, test);
for (int i = 0; i < ans.size(); i++) {
if (i) cout << " ";
cout << ans[i];
}
return 0;
}

---

### 第2题-数字卡牌小游戏（P4535）
- 链接：https://codefun2000.com/p/P4535

> 页面标题：#P4535. 第2题-数字卡牌小游戏

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

解题思路
把原数组转为前缀和：pre[0]=0，pre[i]=papers[0..i-1]之和。任意连续子段 [l..r] 的和为：
sum = pre[r+1] - pre[l]。
要求 left <= sum <= right，等价于对每个 j = r+1，统计之前的 i < j 中有多少个 pre[i] 落在区间：
pre[i] ∈ [ pre[j]-right , pre[j]-left ]。
所以问题变成：按顺序枚举 pre[j]，动态维护已出现的前缀和值集合，支持“统计某个数值区间内的出现次数”。
做法：对所有 pre 做坐标压缩，用树状数组维护出现次数；区间计数用二分把值域区间映射成下标区间，再用树状数组前缀和相减得到答案。
复杂度分析

时间复杂度：O(n log n)（排序压缩 O(n log n)，每个前缀两次二分+两次树状数组 O(log n)）
空间复杂度：O(n)（前缀和、压缩数组、树状数组）

代码实现
Python
import sys
from bisect import bisect_left, bisect_right

class BIT:
def __init__(self, n):
self.n = n
self.bit = [0] * (n + 1)

def add(self, i, v):
# 树状数组单点加
while i <= self.n:
self.bit[i] += v
i += i & -i

def sum(self, i):
# 前缀和 [1..i]
s = 0
while i > 0:
s += self.bit[i]
i -= i & -i
return s

def count_subarrays_in_range(arr, left, right):
n = len(arr)
pre = [0] * (n + 1)
for i in range(n):
pre[i + 1] = pre[i] + arr[i]

# 坐标压缩：只需要压缩所有前缀和本身
vals = sorted(set(pre))
bit = BIT(len(vals))

ans = 0
# 先加入 pre[0]=0
bit.add(bisect_left(vals, 0) + 1, 1)

for j in range(1, n + 1):
pj = pre[j]
# 需要统计 pre[i] ∈ [pj-right, pj-left]
lo = pj - right
hi = pj - left

# idx_hi = <=hi 的个数（0..m），idx_lo = <lo 的个数（0..m）
idx_hi = bisect_right(vals, hi)
idx_lo = bisect_left(vals, lo)

# 区间计数 = 前缀计数差
ans += bit.sum(idx_hi) - bit.sum(idx_lo)

# 加入当前前缀和
bit.add(bisect_left(vals, pj) + 1, 1)

return ans

def main():
data = sys.stdin.read().strip().split()
n = int(data[0])
arr = list(map(int, data[1:1 + n]))
left = int(data[1 + n])
right = int(data[2 + n])
print(count_subarrays_in_range(arr, left, right))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {

// 树状数组（Fenwick）
static class BIT {
int n;
long[] bit;
BIT(int n) {
this.n = n;
this.bit = new long[n + 1];
}
void add(int i, long v) {
// 单点加
while (i <= n) {
bit[i] += v;
i += i & -i;
}
}
long sum(int i) {
// 前缀和 [1..i]
long s = 0;
while (i > 0) {
s += bit[i];
i -= i & -i;
}
return s;
}
}

// lowerBound：第一个 >= x 的位置（0..len）
static int lowerBound(long[] a, long x) {
int l = 0, r = a.length;
while (l < r) {
int m = (l + r) >>> 1;
if (a[m] >= x) r = m;
else l = m + 1;
}
return l;
}

// upperBound：第一个 > x 的位置（0..len）
static int upperBound(long[] a, long x) {
int l = 0, r = a.length;
while (l < r) {
int m = (l + r) >>> 1;
if (a[m] > x) r = m;
else l = m + 1;
}
return l;
}

static long countSubarraysInRange(int[] arr, long left, long right) {
int n = arr.length;
long[] pre = new long[n + 1];
for (int i = 0; i < n; i++) {
pre[i + 1] = pre[i] + arr[i];
}

// 坐标压缩：排序去重所有前缀和
long[] tmp = Arrays.copyOf(pre, pre.length);
Arrays.sort(tmp);
int m = 0;
for (int i = 0; i < tmp.length; i++) {
if (i == 0 || tmp[i] != tmp[i - 1]) tmp[m++] = tmp[i];
}
long[] vals = Arrays.copyOf(tmp, m);

BIT bit = new BIT(m);
long ans = 0;

// 加入 pre[0]=0
int pos0 = lowerBound(vals, 0) + 1;
bit.add(pos0, 1);

for (int j = 1; j <= n; j++) {
long pj = pre[j];
long lo = pj - right;
long hi = pj - left;

// idxHi：<=hi 的个数；idxLo：<lo 的个数
int idxHi = upperBound(vals, hi);
int idxLo = lowerBound(vals, lo);

// 区间计数 = 前缀计数差
ans += bit.sum(idxHi) - bit.sum(idxLo);

// 加入当前前缀和
int pos = lowerBound(vals, pj) + 1;
bit.add(pos, 1);
}

return ans;
}

public static void main(String[] args) throws Exception {
// 默认输入合法，使用 BufferedReader 简洁读取
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringBuilder sb = new StringBuilder();
String line;
while ((line = br.readLine()) != null) sb.append(line).append(' ');
String[] parts = sb.toString().trim().split("\\s+");

int idx = 0;
int n = Integer.parseInt(parts[idx++]);
int[] arr = new int[n];
for (int i = 0; i < n; i++) arr[i] = Integer.parseInt(parts[idx++]);
long left = Long.parseLong(parts[idx++]);
long right = Long.parseLong(parts[idx++]);

System.out.println(countSubarraysInRange(arr, left, right));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 树状数组（Fenwick）
struct BIT {
int n;
vector<long long> bit;
BIT(int n): n(n), bit(n + 1, 0) {}

void add(int i, long long v) {
// 单点加
for (; i <= n; i += i & -i) bit[i] += v;
}

long long sum(int i) {
// 前缀和 [1..i]
long long s = 0;
for (; i > 0; i -= i & -i) s += bit[i];
return s;
}
};

long long count_subarrays_in_range(const vector<int>& a, long long left, long long right) {
int n = (int)a.size();
vector<long long> pre(n + 1, 0);
for (int i = 0; i < n; i++) pre[i + 1] = pre[i] + a[i];

// 坐标压缩：所有前缀和排序去重
vector<long long> vals = pre;
sort(vals.begin(), vals.end());
vals.erase(unique(vals.begin(), vals.end()), vals.end());

BIT bit((int)vals.size());
long long ans = 0;

// 加入 pre[0]=0
int pos0 = (int)(lower_bound(vals.begin(), vals.end(), 0LL) - vals.begin()) + 1;
bit.add(pos0, 1);

for (int j = 1; j <= n; j++) {
long long pj = pre[j];
long long lo = pj - right;
long long hi = pj - left;

// idxHi：<=hi 的个数；idxLo：<lo 的个数（都是 0..m）
int idxHi = (int)(upper_bound(vals.begin(), vals.end(), hi) - vals.begin());
int idxLo = (int)(lower_bound(vals.begin(), vals.end(), lo) - vals.begin());

// 区间计数 = 前缀计数差
ans += bit.sum(idxHi) - bit.sum(idxLo);

// 加入当前前缀和
int pos = (int)(lower_bound(vals.begin(), vals.end(), pj) - vals.begin()) + 1;
bit.add(pos, 1);
}

return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
vector<int> a(n);
for (int i = 0; i < n; i++) cin >> a[i];
long long left, right;
cin >> left >> right;

cout << count_subarrays_in_range(a, left, right) << "\n";
return 0;
}

题目描述
今天，小明的数学老师带来了一叠数字卡牌，每张卡牌上标有数字，有正有负也有零。老师打乱了卡牌顺序，并将牌面展示出来。接着老师在黑板上写下了一个闭区间范围 [left, right]。
老师对小明说：“你可以从这叠卡牌中任意抽取一叠，起始位置不限，抽取的张数不限，但是有个要求，你抽取出的卡牌，牌面加起来的和需要落在黑板上的区间范围内。小明，你算算看，一共能有几种抽取方法？”
小明听完，眼冒金星。你能帮助小明写个程序，算出有几种方法吗？
输入描述

第一行：纸牌数量 n（1 < n <= 10000）
第二行：纸牌数组 papers[]（-255 <= papers[i] <= 255），共 n 个整数
第三行：目标闭区间的左值 left 与右值 right（-2550000 <= left <= right <= 2550000）

输出描述

一个整数，表示满足条件的抽取方法种类数。

样例1
输入：
4
1 -1 1 -1
0 0

输出：
4

解释：
共有4张纸牌，牌面数字为1，-1，1，-1，方法为取第1张到2张，取第2张到第3张，取第3张到4张，取第1到4张，共4种
样例2
输入：
3
-3 4 -2
-3 2

输出：
5

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 3, 119ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-奶茶店的超级收益日（P4524）
- 链接：https://codefun2000.com/p/P4524

> 页面标题：#P4524. 第2题-奶茶店的超级收益日

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

商场新开了一家奶茶店，店长 AAA 每天统计当天的收入，连续统计 nnn 天，用以查看收入的趋势。如果某一天的收入比后面第一天的两倍收入还多，则认为这一天是超级收益日。要求计算这段时间内这样的超圾收益日有多少天。
输入描述
第一行输入一个数字，表示统计的天数，天数的范围为 [0,1000][0,1000][0,1000]
第二行输入一串数字，为一段时间内每天的收入情况，可表示为整数数组，数组规模与天数对应，收入的取值范围为 [0,100000][0,100000][0,100000]
输出描述
超级收益日的天数，为整数
样例1
输入
5
2 4 3 5 1

输出
3

说明
共 555 天的收入情况，其中第 222 天收入 444 ，大于第 555 天收入 1∗21*21∗2 ；第 333 天收入 333 ，大于第 555 天收入 1∗21*21∗2 ；
第 444 天收入 555 ，大于第 555 天收入 1∗21*21∗2 。所以有 333 天为超级收入日。
样例2
输入
5
1 3 2 3 1

输出
2

说明
共 555 天的收入情况，其中第 222 天收入 333 ，大于第 555 天收入 1∗21*21∗2 ; 第 444 天收入 333 ，大于第 555 天收入 121212 。所以有 222 天为超级收入日。

#### TextSol

解题思路
题意：
给出连续 (n) 天的收入数组 a[0..n-1]。
如果某一天 i 的收入 a[i] 大于它后面某一天收入的两倍（存在 j > i，使得 a[i] > 2 * a[j]），则这一天为“超级收益日”。
问在这段时间里共有多少个超级收益日。
关键观察：

对于某一天 i，要找是否存在某个 j>i 满足 a[i] > 2*a[j]。
若把 i 之后所有天的最小收入记作 min_suffix[i+1]，则
是否为超级收益日 等价于：
a[i] > 2 * min_suffix[i+1]。
因为如果对最小的收入都不大于两倍，对其他更大的收入就更不可能大于两倍。

算法（从右往左单次扫描 + 维护后缀最小值）：

特殊情况：若 n<=1，没有后面一天，答案为 0。

从最后一天开始，维护变量 suffixMin 表示“当前天之后所有天的最小收入”。

初始化：suffixMin = a[n-1]，最后一天一定不是超级收益日。

从倒数第二天开始往前遍历 i = n-2 ... 0：

若 a[i] > 2 * suffixMin，说明存在后面某天收入不超过 suffixMin，当前天一定是超级收益日，计数 cnt++。
然后更新 suffixMin = min(suffixMin, a[i])，为前面更早的天做准备。

输出计数 cnt。

使用的算法思想：
线性扫描 + 后缀最小值（类似单调思路），一次遍历即可完成判断。
复杂度分析

时间复杂度：
只需从右向左遍历数组一次，时间复杂度为 O(n)。
空间复杂度：
只使用若干辅助变量（计数器、后缀最小值），额外空间为 O(1)。

代码实现
Python
# 功能函数：统计超级收益日的天数
def count_super_days(arr):
n = len(arr)
# 不足两天，不可能有超级收益日
if n <= 1:
return 0

# 后缀最小值，初始为最后一天的收入
suffix_min = arr[-1]
count = 0

# 从倒数第二天开始往前遍历
for i in range(n - 2, -1, -1):
# 判断当前天是否大于后面某天收入的两倍
if arr[i] > 2 * suffix_min:
count += 1
# 更新后缀最小值
if arr[i] < suffix_min:
suffix_min = arr[i]

return count

if __name__ == "__main__":
import sys

data = list(map(int, sys.stdin.read().split()))
if not data:
# 无输入直接结束
sys.exit(0)

n = data[0]                  # 天数
incomes = data[1:1 + n]      # 每天的收入数组

# 调用功能函数并输出结果
ans = count_super_days(incomes)
print(ans)

Java
import java.util.Scanner;

public class Main {

// 功能函数：统计超级收益日的天数
public static int countSuperDays(int[] a) {
int n = a.length;
if (n <= 1) {
// 不足两天，直接返回 0
return 0;
}

int suffixMin = a[n - 1]; // 后缀最小值，初始为最后一天
int count = 0;

// 从倒数第二天开始往前遍历
for (int i = n - 2; i >= 0; i--) {
// 判断当前天是否大于后面某天收入的两倍
if (a[i] > 2 * suffixMin) {
count++;
}
// 更新后缀最小值
if (a[i] < suffixMin) {
suffixMin = a[i];
}
}

return count;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取天数
if (!sc.hasNextInt()) {
sc.close();
return;
}
int n = sc.nextInt();

// 读取每天的收入
int[] incomes = new int[n];
for (int i = 0; i < n; i++) {
incomes[i] = sc.nextInt();
}
sc.close();

// 调用功能函数并输出结果
int ans = countSuperDays(incomes);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 功能函数：统计超级收益日的天数
int countSuperDays(const vector<int> &a) {
int n = (int)a.size();
if (n <= 1) {
// 不足两天，没有超级收益日
return 0;
}

int suffixMin = a[n - 1]; // 后缀最小值，初始为最后一天
int count = 0;

// 从倒数第二天开始往前遍历
for (int i = n - 2; i >= 0; --i) {
// 判断当前天是否为超级收益日
if (a[i] > 2 * suffixMin) {
count++;
}
// 更新后缀最小值
if (a[i] < suffixMin) {
suffixMin = a[i];
}
}

return count;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
// 读取天数
if (!(cin >> n)) {
return 0;
}

// 读取每天的收入
vector<int> incomes(n);
for (int i = 0; i < n; ++i) {
cin >> incomes[i];
}

// 调用功能函数并输出结果
int ans = countSuperDays(incomes);
cout << ans << "\n";

return 0;
}

---

### 第3题-模型量化最小误差（P4533）
- 链接：https://codefun2000.com/p/P4533

> 页面标题：#P4533. 第3题-模型量化最小误差

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一个深度神经网络中，网络的权重通常以浮点数的形式存储。为了减少内存占用和提高计算效率，需要将这些浮点数量化为整数,例如可通过int(Wfloat∗28)int (W _{float }*2^8)int(Wfloat​∗28)将一个小于111的浮点数量化为INT8INT8INT8。
假设我们有一组[N,H][N,H][N,H]的模型权重，其中：NNN表示网络的层数，HHH表示每一层的维度。现在需要将网络权重进行量化，已知权重已经过预处理缩放到合适的值，可通过Wq=int(Wfloat∗2Qi)W_q=int(W_{float} *2^{Q_i})Wq​=int(Wfloat​∗2Qi​)直接量化到对应的比特位QiQ_iQi​，同时定义量化误差为$\Delta = \left| W_{\text{float}} - \frac{W_q}{2q_i} \right|$
同一层选用的量化比特是相同的，不同层之间可选择不同的量化比特。定义整个模型每一层的量化比特数为[Q1,Q2,...,QN][Q_1,Q_2,...,Q_N][Q1​,Q2​,...,QN​],并限定 Qi∈[2,4,8]Q_i∈ [2,4,8]Qi​∈[2,4,8]，为了保证整体空间压缩足够小，需满足∑i=1NQi≤Qmax\sum_{i=1}^{N} Q_i \leq Q_{\text{max}}∑i=1N​Qi​≤Qmax​。请给出最优的量化方案，使得所有层的量化误差总和最小。
输入描述
第一行:N,H,QmaxN,H,Q_{max}N,H,Qmax​
接下来NNN行是模型权重，每行HHH个系数，系数间用空格分隔(0<N<=300，0<H<=100，0<Qmax<=2400)(0<N<=300，0<H<=100，0<Q_{max} <=2400)(0<N<=300，0<H<=100，0<Qmax​<=2400)
输出描述
请输出在最优方案下，整个网络的最小总量化误差。请将答案*100100100后取整输出(例如最小总量化误差为12.34567812.34567812.345678时，输出123412341234)
样例1
输入
3 10 6
0.669342691379556 0.6232664728193106 0.009648814115477689 0.25655923835608296 0.8542091541905418 0.22734652633918107 0.3856022177718754 0.4735219607872916 0.7352822546717339 0.8810700172773613
0.8998864964296006 0.5355025966489801 0.9114305820079228 0.7237159502129922 0.8114010729538255 0.5647698690173886 0.5656036144842292 0.2915636526042238 0.4633626072815791 0.4933586717844284
0.5681407125745037 0.972337640852664 0.33248445308239827 0.8870229039214033 0.2869760304712957 0.5912444652782809 0.2513253965878265 0.8945001503120086 0.7217848272492855 0.21360959764416299

输出
384

说明
N=3,H=10,∑Qi=6N=3,H=10,\sum Q_i=6N=3,H=10,∑Qi​=6
每层只能使用2比特量化，量化误差分别为1.365,1.260,1.2191.365,1.260,1.2191.365,1.260,1.219,总量化误差3.8443.8443.844,*100100100后输出整数为384384384。
样例2
输入
3 10 24
0.669342691379556 0.6232664728193106 0.009648814115477689 0.25655923835608296 0.8542091541905418 0.22734652633918107 0.3856022177718754 0.4735219607872916 0.7352822546717339 0.8810700172773613
0.8998864964296006 0.5355025966489801 0.9114305820079228 0.7237159502129922 0.8114010729538255 0.5647698690173886 0.5656036144842292 0.2915636526042238 0.4633626072815791 0.4933586717844284
0.5681407125745037 0.972337640852664 0.33248445308239827 0.8870229039214033 0.2869760304712957 0.5912444652782809 0.2513253965878265 0.8945001503120086 0.7217848272492855 0.21360959764416299

输出
5

说明
N=3,H=10,∑Qi=24N=3,H=10,\sum Q_i=24N=3,H=10,∑Qi​=24
每层只能使用888比特量化，量化误差分别为0.018,0.018,0.020.018,0.018,0.020.018,0.018,0.02,总量化误差0.0560.0560.056,*100100100后输出整数为555。

#### TextSol

解题思路
本题本质是一个 带约束的最优化问题，可以转化为 多重选择的动态规划（Multiple Choice Knapsack）。
1. 问题拆解

网络共有 N 层，每层有 H 个权重
每一层只能选择一种量化比特数
Qi∈2,4,8
Q_i \in {2, 4, 8}
Qi​∈2,4,8
整体约束：
∑i=1NQi≤Qmax⁡
\sum_{i=1}^N Q_i \le Q_{\max}
∑i=1N​Qi​≤Qmax​
目标：最小化所有层的量化误差总和

2. 单层量化误差的计算（预处理）
对于某一层 i，如果选择量化比特 Q：
Wq=int(Wfloat×2Q)W_q = \text{int}(W_{\text{float}} \times 2^Q)
Wq​=int(Wfloat​×2Q)
量化还原后为：
W^=Wq2Q\hat{W} = \frac{W_q}{2^Q}
W^=2QWq​​
该层的总误差为：
$$\text{err}[i][Q] = \sum_{j=1}^{H} \left| W_{i,j} - \hat{W}_{i,j} \right|$$由于 Q 只有 {2,4,8} 三种取值，我们可以 预先计算 每一层在三种量化比特下的误差。
3. 动态规划建模
状态定义
设：
$$dp[i][q] = \text{前 } i \text{ 层，总比特数为 } q \text{ 时的最小误差}$$状态转移
对于第 i 层，尝试选择 {2,4,8} 中的一种：
$$dp[i][q] = \min \Big(
dp[i-1][q-2] + err[i][2],;
dp[i-1][q-4] + err[i][4],;
dp[i-1][q-8] + err[i][8]
\Big)$$前提是 q - Q >= 0。
初始化

dp[0][0] = 0
其他状态初始化为极大值

最终答案
min⁡q≤Qmax⁡dp[N][q]
\min_{q \le Q_{\max}} dp[N][q]
minq≤Qmax​​dp[N][q]
4. 输出处理
题目要求输出：
⌊最小误差×100⌋
\lfloor \text{最小误差} \times 100 \rfloor
⌊最小误差×100⌋
复杂度分析
时间复杂度

误差预处理：
O(N×H×3)O(N \times H \times 3)O(N×H×3)
动态规划：
O(N×Qmax⁡×3)O(N \times Q_{\max} \times 3)O(N×Qmax​×3)

空间复杂度

使用滚动数组优化后：
O(Qmax⁡)O(Q_{\max})O(Qmax​)

代码实现
Python
import math
import sys

def solve():
data = sys.stdin.read().strip().split()
idx = 0

N = int(data[idx]); idx += 1
H = int(data[idx]); idx += 1
Qmax = int(data[idx]); idx += 1

# 读取权重
weights = []
for _ in range(N):
layer = []
for _ in range(H):
layer.append(float(data[idx]))
idx += 1
weights.append(layer)

# 预计算每一层在 2/4/8 bit 下的误差
bits = [2, 4, 8]
err = [[0.0]*3 for _ in range(N)]

for i in range(N):
for k, Q in enumerate(bits):
scale = 2 ** Q
e = 0.0
for w in weights[i]:
wq = int(w * scale)
wr = wq / scale
e += abs(w - wr)
err[i][k] = e

INF = 1e100
dp = [INF] * (Qmax + 1)
dp[0] = 0.0

# 动态规划
for i in range(N):
ndp = [INF] * (Qmax + 1)
for q in range(Qmax + 1):
if dp[q] >= INF:
continue
for k, Q in enumerate(bits):
if q + Q <= Qmax:
ndp[q + Q] = min(ndp[q + Q], dp[q] + err[i][k])
dp = ndp

ans = min(dp)
print(int(ans * 100))

if __name__ == "__main__":
solve()

Java
import java.io.*;
import java.util.*;

public class Main {

static double solve(int N, int H, int Qmax, double[][] w) {
int[] bits = {2, 4, 8};
double[][] err = new double[N][3];

// 预处理误差
for (int i = 0; i < N; i++) {
for (int k = 0; k < 3; k++) {
int Q = bits[k];
double scale = 1 << Q;
double e = 0.0;
for (int j = 0; j < H; j++) {
int wq = (int)(w[i][j] * scale);
double wr = wq / scale;
e += Math.abs(w[i][j] - wr);
}
err[i][k] = e;
}
}

double INF = 1e100;
double[] dp = new double[Qmax + 1];
Arrays.fill(dp, INF);
dp[0] = 0.0;

// 动态规划
for (int i = 0; i < N; i++) {
double[] ndp = new double[Qmax + 1];
Arrays.fill(ndp, INF);
for (int q = 0; q <= Qmax; q++) {
if (dp[q] >= INF) continue;
for (int k = 0; k < 3; k++) {
int Q = bits[k];
if (q + Q <= Qmax) {
ndp[q + Q] = Math.min(ndp[q + Q], dp[q] + err[i][k]);
}
}
}
dp = ndp;
}

double ans = INF;
for (int q = 0; q <= Qmax; q++) {
ans = Math.min(ans, dp[q]);
}
return ans;
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);

int N = sc.nextInt();
int H = sc.nextInt();
int Qmax = sc.nextInt();

double[][] w = new double[N][H];
for (int i = 0; i < N; i++) {
for (int j = 0; j < H; j++) {
w[i][j] = sc.nextDouble();
}
}

double ans = solve(N, H, Qmax, w);
System.out.println((int)(ans * 100));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, H, Qmax;
cin >> N >> H >> Qmax;

vector<vector<double>> w(N, vector<double>(H));
for (int i = 0; i < N; i++) {
for (int j = 0; j < H; j++) {
cin >> w[i][j];
}
}

vector<int> bits = {2, 4, 8};
vector<vector<double>> err(N, vector<double>(3, 0.0));

// 预处理误差
for (int i = 0; i < N; i++) {
for (int k = 0; k < 3; k++) {
int Q = bits[k];
double scale = 1 << Q;
double e = 0.0;
for (int j = 0; j < H; j++) {
int wq = (int)(w[i][j] * scale);
double wr = wq / scale;
e += fabs(w[i][j] - wr);
}
err[i][k] = e;
}
}

const double INF = 1e100;
vector<double> dp(Qmax + 1, INF);
dp[0] = 0.0;

// 动态规划
for (int i = 0; i < N; i++) {
vector<double> ndp(Qmax + 1, INF);
for (int q = 0; q <= Qmax; q++) {
if (dp[q] >= INF) continue;
for (int k = 0; k < 3; k++) {
int Q = bits[k];
if (q + Q <= Qmax) {
ndp[q + Q] = min(ndp[q + Q], dp[q] + err[i][k]);
}
}
}
dp.swap(ndp);
}

double ans = *min_element(dp.begin(), dp.end());
cout << (int)(ans * 100) << "\n";

return 0;
}

---

### 第3题-文件夹排序（P4536）
- 链接：https://codefun2000.com/p/P4536

> 页面标题：#P4536. 第3题-文件夹排序

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

文件夹命名经常会使用字符+数字混合命名,为了方便查看，希望文件夹排序时可以按字符序+数字值综合排序。
给定nnn个文件夹名称，每个文件夹名称为v[i]v[i]v[i]，请按照字符从小到大(a−zA−Z)(a-zA-Z)(a−zA−Z)及数字值从小到大的顺序排序，输出排序后的文件夹名称。
排序规则:
1.从左到右依次比较，区分大小写，字母从a−zA−Za-zA-Za−zA−Z顺序排列
2.连续的数字字符整体转为整数后按从小到大排列，如001001001转为数字111后排序
3.字母和数字比较时数字在前，例，'testcase1testcase1testcase1'和'testcasefailtestcasefailtestcasefail'排序时'testcase1testcase1testcase1'在前
4.如一个文件夹名称是另一个文件夹名称的前缀子串，则长度短的子串排在前，例:'testcase,testcase001testcase,testcase001testcase,testcase001'排序时'testcasetestcasetestcase'在前
5.两个文件夹名称排序相同时，不改变输入顺序，这里相同包括数字字符不同但转成整数后值相同，例:'testcase1testcase1testcase1'和'testcase001testcase001testcase001'排序时二者相同，保持输入顺序，'testcase1testcase1testcase1'在前
输入描述
1,第111行：nnn，代表输入文件夹名称个数，范围[1,100][1,100][1,100]
2.第2行：v[0]v[0]v[0]代表第111个文件夹名称，名称只包合大小写字母和数字字符，长度[1,127][1,127][1,127]，连续的数字字符数量不超过999
3.第n+1第n+1第n+1行:v[n−1]v[n-1]v[n−1], 代表第nnn个文件夹名称，名称只包含大小写字母和数字字符,长度[1,127][1,127][1,127],连续的数字字符数量不超过999
输出描述
按行输出排序后的文件夹名称
样例1
输入
3
ts1tc1
ts1tc01
ts0tc1

输出
ts0tc1
ts1tc1
ts1tc01

说明
第111行输入333,表示有333个文件夹
第333行起分别输入333个文件夹名称'ts0tc1ts0tc1ts0tc1'，'ts1tc1ts1tc1ts1tc1'，'ts1tc01ts1tc01ts1tc01'排序时'tststs'部分一致，后续'000' '111' '111' 转为数字对应0,1,10,1,10,1,1,按规则排序，'ts0tc1ts0tc1ts0tc1'排第111，'ts1tc1ts1tc1ts1tc1'排经2，'ts1tc01ts1tc01ts1tc01'排第333
样例2
输入
2
testcase10
testcase9

输出
testcase9
testcase10

说明
第111行输入222，表示有222个文件夹
第222行起分别输入222个文件夹名称'testcase10testcase10testcase10','testcase9testcase9testcase9'，排序时'testcasetestcasetestcase' 部分一致，然后看最后的数字部分，9<109<109<10，按数字由小到大排序，'testcase9testcase9testcase9'在前
输出:
testcase9testcase9testcase9
testcase10testcase10testcase10
样例3
输入
3
ts09sc1
ts01tc1
ts010tc12

输出
ts01tc1
ts09tc1
ts010tc12

#### TextSol

解题思路
把每个文件夹名从左到右切分成一串“比较单元”：

遇到字母：按单个字符作为单元，直接用 ASCII（'A'<'Z'<'a'<'z'）比较
遇到连续数字：整段数字作为一个单元，转换成整数值比较（忽略前导 0）

然后用“自然排序”的比较方法从左到右逐单元比较：

单元类型不同：数字单元 < 字母单元
都是字母：按 ASCII 值比较
都是数字：按整数值比较（值相同则继续比较后续单元，不因前导 0 再分胜负）
比到一方结束：若一个是另一个的前缀，短的排前
完全比不出差异：视为相同，保持输入顺序（稳定排序）

相关算法：自定义比较器 + 稳定排序（或在比较相等时用原下标保证稳定）。
复杂度分析
设单个字符串长度为 L（≤127），数量为 n（≤100）。

预处理切分：每个字符串 O(L)
排序比较：每次比较最坏 O(L)，排序 O(n log n) 次比较
时间复杂度：O(n·L + n log n · L)
空间复杂度：O(n·L)（存储切分结果）

代码实现
Python
import sys
from functools import cmp_to_key

def tokenize(s):
# 切分为：数字段(0, value) 或 字符(1, ascii)
tokens = []
i, n = 0, len(s)
while i < n:
c = s[i]
if '0' <= c <= '9':
j = i
while j < n and '0' <= s[j] <= '9':
j += 1
# 连续数字转整数（忽略前导0），题目保证长度<=9
tokens.append((0, int(s[i:j])))
i = j
else:
tokens.append((1, ord(c)))
i += 1
return tokens

def cmp_items(a, b):
ta, tb = a[1], b[1]
i = 0
while i < len(ta) and i < len(tb):
type_a, val_a = ta[i]
type_b, val_b = tb[i]
if type_a != type_b:
return -1 if type_a < type_b else 1  # 数字(0)在前，字母(1)在后
if val_a != val_b:
return -1 if val_a < val_b else 1
i += 1
# 前缀规则：短的在前
if len(ta) != len(tb):
return -1 if len(ta) < len(tb) else 1
# 完全相同：稳定排序保持输入顺序
return 0

def solve(names):
items = [(s, tokenize(s)) for s in names]
items.sort(key=cmp_to_key(cmp_items))  # Python排序稳定
return [x[0] for x in items]

def main():
data = sys.stdin.read().split()
n = int(data[0])
names = data[1:1+n]
ans = solve(names)
sys.stdout.write("\n".join(ans))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {

static class Token {
int type; // 0: 数字段, 1: 字符
int val;  // 数字值 或 ASCII值
Token(int type, int val) {
this.type = type;
this.val = val;
}
}

static class Item {
String s;
ArrayList<Token> tokens;
int idx; // 原始下标，用于保证稳定
Item(String s, ArrayList<Token> tokens, int idx) {
this.s = s;
this.tokens = tokens;
this.idx = idx;
}
}

static ArrayList<Token> tokenize(String s) {
ArrayList<Token> tokens = new ArrayList<>();
int i = 0, n = s.length();
while (i < n) {
char c = s.charAt(i);
if (c >= '0' && c <= '9') {
int j = i;
while (j < n) {
char d = s.charAt(j);
if (d < '0' || d > '9') break;
j++;
}
// 连续数字转整数（忽略前导0），长度<=9，不会溢出int
int val = Integer.parseInt(s.substring(i, j));
tokens.add(new Token(0, val));
i = j;
} else {
tokens.add(new Token(1, (int)c)); // ASCII比较
i++;
}
}
return tokens;
}

static int compareTokens(ArrayList<Token> a, ArrayList<Token> b) {
int i = 0;
while (i < a.size() && i < b.size()) {
Token ta = a.get(i), tb = b.get(i);
if (ta.type != tb.type) {
return ta.type < tb.type ? -1 : 1; // 数字(0)在前
}
if (ta.val != tb.val) {
return ta.val < tb.val ? -1 : 1;
}
i++;
}
// 前缀：短的在前
if (a.size() != b.size()) return a.size() < b.size() ? -1 : 1;
return 0;
}

static List<String> solve(List<String> names) {
ArrayList<Item> items = new ArrayList<>();
for (int i = 0; i < names.size(); i++) {
String s = names.get(i);
items.add(new Item(s, tokenize(s), i));
}

// Java 的 Collections.sort 对对象是稳定的；这里仍用 idx 兜底保证稳定
Collections.sort(items, new Comparator<Item>() {
public int compare(Item x, Item y) {
int c = compareTokens(x.tokens, y.tokens);
if (c != 0) return c;
return x.idx - y.idx; // 规则5：保持输入顺序
}
});

ArrayList<String> ans = new ArrayList<>();
for (Item it : items) ans.add(it.s);
return ans;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine().trim());
ArrayList<String> names = new ArrayList<>();
for (int i = 0; i < n; i++) {
names.add(br.readLine().trim());
}
List<String> ans = solve(names);
StringBuilder sb = new StringBuilder();
for (int i = 0; i < ans.size(); i++) {
sb.append(ans.get(i));
if (i + 1 < ans.size()) sb.append('\n');
}
System.out.print(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

struct Token {
int type; // 0: 数字段, 1: 字符
int val;  // 数字值 或 ASCII值
};

struct Item {
string s;
vector<Token> tokens;
int idx; // 原始下标（可选兜底）
};

vector<Token> tokenize(const string& s) {
vector<Token> tokens;
int i = 0, n = (int)s.size();
while (i < n) {
char c = s[i];
if (c >= '0' && c <= '9') {
int j = i;
while (j < n && s[j] >= '0' && s[j] <= '9') j++;
// 连续数字转整数（忽略前导0），题目保证<=9位
int val = 0;
for (int k = i; k < j; k++) val = val * 10 + (s[k] - '0');
tokens.push_back({0, val});
i = j;
} else {
tokens.push_back({1, (int)(unsigned char)c}); // ASCII比较
i++;
}
}
return tokens;
}

int compareTokens(const vector<Token>& a, const vector<Token>& b) {
int i = 0;
while (i < (int)a.size() && i < (int)b.size()) {
if (a[i].type != b[i].type) return a[i].type < b[i].type ? -1 : 1; // 数字在前
if (a[i].val != b[i].val) return a[i].val < b[i].val ? -1 : 1;
i++;
}
// 前缀：短的在前
if (a.size() != b.size()) return a.size() < b.size() ? -1 : 1;
return 0;
}

vector<string> solve(const vector<string>& names) {
vector<Item> items;
items.reserve(names.size());
for (int i = 0; i < (int)names.size(); i++) {
items.push_back({names[i], tokenize(names[i]), i});
}

// 稳定排序：比较相同则保持输入顺序（规则5）
stable_sort(items.begin(), items.end(), [](const Item& x, const Item& y) {
int c = compareTokens(x.tokens, y.tokens);
return c < 0; // 相等时返回false，交给 stable_sort 保持顺序
});

vector<string> ans;
ans.reserve(items.size());
for (auto &it : items) ans.push_back(it.s);
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
vector<string> names(n);
for (int i = 0; i < n; i++) cin >> names[i];

vector<string> ans = solve(names);
for (int i = 0; i < (int)ans.size(); i++) {
cout << ans[i] << "\n";
}
return 0;
}

---

### 第3题-学生最多分成多少块（P4525）
- 链接：https://codefun2000.com/p/P4525

> 页面标题：#P4525. 第3题-学生最多分成多少块

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

两队学生拿着号码牌，排成 111 队，选择队伍中连续的几个学生将他们按照号码牌就地 升序 排序之后连接起来，使得连接的结果和直接整体按升序排列后的结果一致
输入描述
一组正整数数组
如：555 444 333 222 111，数组长度为【1,5001,5001,500】
输出描述
最多将学生分成多少块
样例1
输入
2 1 3 4 4 5

输出
5

说明
分成 [2,1],[3],[4],[4],[5][2,1],[3],[4],[4],[5][2,1],[3],[4],[4],[5] 可以得到最多的块数。
样例2
输入
5 4 3 2 1

输出
1

说明
将数组分成 222 块或者更多块，都无法得到所需的结果。
例如，分成 [5,4],[3,2,1][5,4],[3,2,1][5,4],[3,2,1] 的结果是 [4,5,1,2,3][4, 5,1,2,3][4,5,1,2,3]，这不是有序的数组。

#### TextSol

解题思路
题意：给定一组正整数，允许把数组切成若干连续的“块”，对每一块单独排序后再按原顺序拼接，要求拼接后的整个数组是从小到大有序，问最多能切成多少块。
核心想法：

设在位置 i 后面切一刀（左边是 0..i 这一块，右边是 i+1..n-1）。
若想切在这里合法，那么左边块里最大的数一定不能大于右边所有数中最小的数，否则排序后左块仍会有元素比右块大，拼接后整体不会有序。
因此，切分条件是：
max( arr[0..i] ) <= min( arr[i+1..n-1] )

实现步骤（贪心 + 前后缀预处理）：

预处理前缀最大数组 preMax[i] = max(arr[0..i])。

预处理后缀最小数组 sufMin[i] = min(arr[i..n-1])。

从左到右枚举每个可能的切点 i = 0..n-2：

如果 preMax[i] <= sufMin[i+1]，说明可以在 i 后面切一刀，块数加一。

最终块数 = “合法切点数 + 1”。（至少有一块）

复杂度分析

时间复杂度：

计算前缀最大 O(n)，
计算后缀最小 O(n)，
扫描所有切点 O(n)，
整体为 O(n)。

空间复杂度：

需要两个长度为 n 的辅助数组 preMax 和 sufMin，
故为 O(n)。

在 n ≤ 500 的数据范围内完全足够。
代码实现
Python
import sys

# 功能函数：计算最多能分成多少块
def max_chunks(arr):
n = len(arr)
if n == 0:
return 0

# 前缀最大值
pre_max = [0] * n
cur = arr[0]
for i in range(n):
if arr[i] > cur:
cur = arr[i]
pre_max[i] = cur

# 后缀最小值
suf_min = [0] * n
cur = arr[-1]
for i in range(n - 1, -1, -1):
if arr[i] < cur:
cur = arr[i]
suf_min[i] = cur

# 统计合法切点
cnt = 0
for i in range(n - 1):
if pre_max[i] <= suf_min[i + 1]:
cnt += 1

return cnt + 1  # 块数 = 切点数 + 1

def main():
# 读取所有整数，视为一个数组
data = sys.stdin.read().split()
if not data:
return
arr = list(map(int, data))

ans = max_chunks(arr)
print(ans)

if __name__ == "__main__":
main()

Java
import java.util.*;

// ACM 风格主类
public class Main {

// 功能函数：计算最多能分成多少块
public static int maxChunks(int[] arr) {
int n = arr.length;
if (n == 0) return 0;

int[] preMax = new int[n]; // 前缀最大值
int[] sufMin = new int[n]; // 后缀最小值

// 计算前缀最大值
int cur = arr[0];
for (int i = 0; i < n; i++) {
if (arr[i] > cur) cur = arr[i];
preMax[i] = cur;
}

// 计算后缀最小值
cur = arr[n - 1];
for (int i = n - 1; i >= 0; i--) {
if (arr[i] < cur) cur = arr[i];
sufMin[i] = cur;
}

// 统计合法切点
int cnt = 0;
for (int i = 0; i < n - 1; i++) {
if (preMax[i] <= sufMin[i + 1]) {
cnt++;
}
}

return cnt + 1; // 块数 = 切点数 + 1
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
List<Integer> list = new ArrayList<>();

// 读入所有整数，视为一个数组
while (sc.hasNextInt()) {
list.add(sc.nextInt());
}
sc.close();

if (list.isEmpty()) return;

int n = list.size();
int[] arr = new int[n];
for (int i = 0; i < n; i++) {
arr[i] = list.get(i);
}

int ans = maxChunks(arr);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 功能函数：计算最多能分成多少块
int maxChunks(const vector<int>& arr) {
int n = (int)arr.size();
if (n == 0) return 0;

vector<int> preMax(n), sufMin(n);

// 计算前缀最大值
int cur = arr[0];
for (int i = 0; i < n; ++i) {
if (arr[i] > cur) cur = arr[i];
preMax[i] = cur;
}

// 计算后缀最小值
cur = arr[n - 1];
for (int i = n - 1; i >= 0; --i) {
if (arr[i] < cur) cur = arr[i];
sufMin[i] = cur;
}

// 统计合法切点
int cnt = 0;
for (int i = 0; i < n - 1; ++i) {
if (preMax[i] <= sufMin[i + 1]) {
++cnt;
}
}

return cnt + 1; // 块数 = 切点数 + 1
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

vector<int> arr;
int x;

// 读入所有整数，视为一个数组
while (cin >> x) {
arr.push_back(x);
}

if (arr.empty()) return 0;

int ans = maxChunks(arr);
cout << ans << "\n";

return 0;
}

---

## 2025年12月3日-AI方向

### 第2题-基于剪枝的神经网络模型压缩（P4518）
- 链接：https://codefun2000.com/p/P4518

> 页面标题：#P4518. 第2题-基于剪枝的神经网络模型压缩

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在端侧设备部署神经网络模型时，需解决模型参数量过大的问题。本题目要求实现神经网络模型的结构化剪枝，通过移除冗余输入通道降低模型复杂度，同时保持分类性能。给定输入矩阵 XXX 、模型权重 WWW 以及剪枝比例 ratioratioratio，对 WWW 进行结构化剪枝，并使用剪枝后的结果计算模型预测结果。以下是相关计算流程及指标定义说明。

输入矩阵: XXX (维度: n×dn×dn×d， nnn 为样本数，ddd 为输入特征数)

权重矩阵: WWW (维度:d×cd×cd×c，ccc 为输出类别数)

计算过程:

线性变换: h=XWh=XWh=XW(维度:n×cn×cn×c)
SoftmaxSoftmaxSoftmax 激活 : y=softmax(h)y= softmax(h)y=softmax(h)(输出概率分布)
预测标签: label=arglabel = arglabel=arg max(y)max(y)max(y)

剪枝目标 : 对权重矩阵 WWW 按行剪枝(移除整行权重)，剪枝率为 ratioratioratio，剪枝指标为 L1L1L1 范数。
提示:
1、y=softmax(h)y= softmax(h)y=softmax(h) 其中 $y_{i j}=\frac{\exp \left(h_{i j}-\max \left(h_{i}\right)\right)}{\sum_{j} \exp \left(h_{i j}-\max \left(h_{i}\right)\right)}$ ，按行计算概率分布，每个元系减去最大值防止外溢,
2、labeli=argmax(yi)label_i = argmax(y_i)labeli​=argmax(yi​) 按行计算，输出每行最大值对应的列下标，范围为 [0,c)[0,c)[0,c) 。
1.剪枝定义

按行剪枝 : 移除权重矩阵 WWW 中不重要的行(对应输入特征)，保留重要行。

物理意义 : 移除对输出影响较小的输入特征，压缩模型输入维度。

剪枝后维度：

权重矩阵 W′W'W′ 维度：(d−k)×c(d-k)×c(d−k)×c ( kkk 为剪枝行数)。
输入矩阵 X′X'X′ 维度: n×(d−k)n×(d-k)n×(d−k) (需移除对应特征列)。

2.剪枝指标

L1L1L1 范数:对权重矩阵 W 的每一行计算绝对值之和。

第 iii 行的 L1L1L1 范数: $\left\|W_{i,:}\right\|_{1}=\sum_{j=1}^{c}\left|W_{i j}\right|$

剪枝规则 : 保留 L1 范数较大的行(重要性高)，移除 L1 范数较小的行(重要性低)。

3.剪枝步骤
1.计算每行 L1L1L1 范数：$row\_norms=[\left\|W_{0,:}\right\|_{1},\left\|W_{i,:}\right\|_{1},...\left\|W_{d-1,:}\right\|_{1}]$
2.确定剪枝行数: k=⌊ratio×d⌋k = \lfloor ratio \times d \rfloork=⌊ratio×d⌋ (需剪掉的行数)
3.选择 L1L1L1 范数最小的 kkk 行移除，得到剪枝后权重矩阵 W′W'W′ 。
4.调整输入矩阵 XXX :移除与剪枝行对应的列，得到 X’X’X’ 。
说明:
k=⌊ratio×d⌋k = \lfloor ratio \times d \rfloork=⌊ratio×d⌋
表示 kkk 是向下取整后的结果。如果 ratio>0ratio>0ratio>0 并且向下取整后 kkk 为 000 ，则取 kkk 为 111 (至少剪枝 111 行)
输入描述
输入内容如下：
第一行三个整数：nnn ddd ccc
接下来 nnn 行，每行 ddd 个浮点数：XXX 矩阵
接下来 ddd 行，每行 ccc 个浮点数：WWW 矩阵
最后一行：剪枝率 ratioratioratio
输入范围：
1、1<=n,d,c<=641<= n, d, c <= 641<=n,d,c<=64
2、0<=ratio<=1.00 <= ratio <= 1.00<=ratio<=1.0
输出描述
输出为使用剪枝后矩阵计算得到的预测 labellabellabel 结果。
样例1
输入
4 5 2
1.89 1.88 0.87 0.19 0.62
0.75 0.75 1.45 0.24 0.65
1.26 0.4 0.69 0.54 0.93
0.11 0.61 0.25 1.47 1.96
0.89 2.44
0.97 2.61
2.24 0.72
1.64 0.38
2.29 0.69
0.3

输出
1 0 1 0

说明
样例2
输入
2 2 2
1.0 2.0
3.0 4.0
0.1 0.2
0.3 0.4
0.5

输出
1 1

说明
表示 XXX 矩阵为:
1.01.01.0 2.02.02.0
3.03.03.0 4.04.04.0
WWW 矩阵为：
0.10.10.1 0.20.20.2
0.30.30.3 0.40.40.4
剪枝率 ratioratioratio 为 0.50.50.5

#### TextSol

解题思路
题目本质是：

先对权重矩阵 (W) 做按行的结构化剪枝（整行去掉），根据每行的 L1 范数决定保留与删除哪些输入特征；
然后用剪枝后的矩阵 (X')、(W') 做线性变换并预测类别。

1. 剪枝部分

对于每一行 (i)（对应第 (i) 个输入特征）计算：
∣Wi,:∣∗1=∑∗j=0c−1∣Wij∣|W_{i,:}|*1 = \sum*{j=0}^{c-1} |W_{ij}|
∣Wi,:​∣∗1=∑∗j=0c−1∣Wij​∣

剪枝行数：
k=⌊ratio×d⌋k = \lfloor ratio \times d \rfloor
k=⌊ratio×d⌋
如果 (ratio > 0) 且 (k = 0)，则令 (k = 1)，保证至少剪掉 1 行。

将所有行按 L1 范数从小到大排序，取前 (k) 行作为“要删除”的行。

对应删除：

在权重矩阵中删除这些行，得到 (W')（维度 (d−k)×c(d-k) \times c(d−k)×c）。
在输入矩阵中删除对应的列，得到 (X')（维度 n×(d−k)n \times (d-k)n×(d−k)）。

实现上可以这样做：

先计算 row_norms[i]，长度为 d。
建立一个下标数组 idx = [0, 1, ..., d-1]，按照 row_norms[idx[i]] 升序排序。
前 k 个下标加入一个“剪掉集合”，剩下的就是要保留的行（列）。

2. 前向计算与预测
剪枝后，线性部分为：
$$h = X' W' \quad (n \times (d-k)) \cdot ((d-k) \times c) = n \times c$$第 (i) 行第 (j) 列：
$$h_{ij} = \sum_{t=0}^{d-k-1} X'*{i,t} \cdot W'*{t,j}$$逻辑上，题目给出了 softmax：
$$y = \text{softmax}(h), \quad \text{label}*i = \arg\max_j y*{ij}$$但注意：

softmax 是对每个分量做单调递增变换，且不改变各维之间的大小关系。
因此：
$$\arg\max_j \text{softmax}(h_{i,:}) = \arg\max_j h_{ij}$$
也就是说，为了得到预测标签，我们完全可以跳过 softmax 的显式计算，直接对每行的 (h) 做 argmax 即可。
这样实现更简单，也避免不必要的指数运算和数值问题。
步骤总结：

用保留的特征索引，计算每个样本到每个类别的加权和 h[i][j]。
对每行 i 找到最大值所在的列下标 j，即为该样本的预测标签。
将所有 label 以空格分隔输出一行。

代码实现
Python
import sys

def structured_pruning_prediction(n, d, c, X, W, ratio):
# 1. 计算每行 L1 范数
row_norms = []
for i in range(d):
s = 0.0
for j in range(c):
s += abs(W[i][j])
row_norms.append(s)

# 2. 计算剪枝行数 k
k = int(ratio * d)  # 向下取整
if ratio > 0 and k == 0:
k = 1  # 至少剪一行

# 3. 找到 L1 范数最小的 k 行（要剪掉的行）
indices = list(range(d))
indices.sort(key=lambda idx: row_norms[idx])  # 按范数从小到大排序
prune_set = set(indices[:k])  # 要剪掉的下标集合

# 4. 构造保留的特征索引（按原顺序）
keep_indices = [i for i in range(d) if i not in prune_set]
kept_d = len(keep_indices)

# 5. 使用保留特征计算 h = X' W'
# 为了节省空间，这里不显式构造 X'、W'，直接根据 keep_indices 访问原矩阵
labels = []
for i in range(n):
# scores[j] 表示样本 i 对类别 j 的线性得分 h_ij
scores = [0.0] * c
for t in range(kept_d):
feat_idx = keep_indices[t]
x_val = X[i][feat_idx]
if x_val == 0.0:
continue
for j in range(c):
scores[j] += x_val * W[feat_idx][j]

# 6. 对每行 scores 求 argmax，得到预测标签
max_j = 0
max_val = scores[0]
for j in range(1, c):
if scores[j] > max_val:
max_val = scores[j]
max_j = j
labels.append(max_j)

return labels

def main():
data = sys.stdin.read().strip().split()
if not data:
return

ptr = 0
n = int(data[ptr]); ptr += 1
d = int(data[ptr]); ptr += 1
c = int(data[ptr]); ptr += 1

# 读取 X 矩阵
X = []
for _ in range(n):
row = []
for _ in range(d):
row.append(float(data[ptr]))
ptr += 1
X.append(row)

# 读取 W 矩阵
W = []
for _ in range(d):
row = []
for _ in range(c):
row.append(float(data[ptr]))
ptr += 1
W.append(row)

# 读取 ratio
ratio = float(data[ptr]); ptr += 1

labels = structured_pruning_prediction(n, d, c, X, W, ratio)
print(" ".join(str(x) for x in labels))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {

// 按行剪枝并进行预测的函数
public static int[] structuredPruningPrediction(int n, int d, int c,
double[][] X, double[][] W,
double ratio) {
// 1. 计算每行 L1 范数
double[] rowNorms = new double[d];
for (int i = 0; i < d; i++) {
double s = 0.0;
for (int j = 0; j < c; j++) {
s += Math.abs(W[i][j]);
}
rowNorms[i] = s;
}

// 2. 计算剪枝行数 k
int k = (int) Math.floor(ratio * d);
if (ratio > 0 && k == 0) {
k = 1; // 至少剪一行
}

// 3. 找到 L1 范数最小的 k 行
Integer[] idx = new Integer[d];
for (int i = 0; i < d; i++) {
idx[i] = i;
}
Arrays.sort(idx, new Comparator<Integer>() {
@Override
public int compare(Integer a, Integer b) {
if (rowNorms[a] < rowNorms[b]) return -1;
else if (rowNorms[a] > rowNorms[b]) return 1;
else return 0;
}
});

boolean[] prune = new boolean[d];
for (int i = 0; i < k; i++) {
prune[idx[i]] = true;
}

// 4. 构造保留特征的下标数组
int keptCount = d - k;
int[] keepIndices = new int[keptCount];
int pos = 0;
for (int i = 0; i < d; i++) {
if (!prune[i]) {
keepIndices[pos++] = i;
}
}

// 5. 计算 h = X' W' 并直接做 argmax
int[] labels = new int[n];
for (int i = 0; i < n; i++) {
double[] scores = new double[c];
// 线性计算：只用保留的特征
for (int t = 0; t < keptCount; t++) {
int featIdx = keepIndices[t];
double xVal = X[i][featIdx];
if (xVal == 0.0) continue;
for (int j = 0; j < c; j++) {
scores[j] += xVal * W[featIdx][j];
}
}
// 6. 对 scores 求 argmax
int bestIdx = 0;
double bestVal = scores[0];
for (int j = 1; j < c; j++) {
if (scores[j] > bestVal) {
bestVal = scores[j];
bestIdx = j;
}
}
labels[i] = bestIdx;
}

return labels;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

if (!sc.hasNext()) {
sc.close();
return;
}

int n = sc.nextInt();
int d = sc.nextInt();
int c = sc.nextInt();

// 读取 X 矩阵
double[][] X = new double[n][d];
for (int i = 0; i < n; i++) {
for (int j = 0; j < d; j++) {
X[i][j] = sc.nextDouble();
}
}

// 读取 W 矩阵
double[][] W = new double[d][c];
for (int i = 0; i < d; i++) {
for (int j = 0; j < c; j++) {
W[i][j] = sc.nextDouble();
}
}

// 读取 ratio
double ratio = sc.nextDouble();
sc.close();

int[] labels = structuredPruningPrediction(n, d, c, X, W, ratio);

// 输出结果，一行空格分隔
StringBuilder sb = new StringBuilder();
for (int i = 0; i < labels.length; i++) {
if (i > 0) sb.append(' ');
sb.append(labels[i]);
}
System.out.println(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 按行结构化剪枝并预测的函数
vector<int> structuredPruningPrediction(int n, int d, int c,
const vector<vector<double>>& X,
const vector<vector<double>>& W,
double ratio) {
// 1. 计算每行 L1 范数
vector<double> rowNorms(d, 0.0);
for (int i = 0; i < d; ++i) {
double s = 0.0;
for (int j = 0; j < c; ++j) {
s += fabs(W[i][j]);
}
rowNorms[i] = s;
}

// 2. 计算剪枝行数 k
int k = static_cast<int>(floor(ratio * d));
if (ratio > 0 && k == 0) {
k = 1; // 至少剪一行
}

// 3. 找到 L1 范数最小的 k 行
vector<int> idx(d);
for (int i = 0; i < d; ++i) idx[i] = i;
sort(idx.begin(), idx.end(), [&](int a, int b) {
return rowNorms[a] < rowNorms[b];
});

vector<bool> prune(d, false);
for (int i = 0; i < k; ++i) {
prune[idx[i]] = true;
}

// 4. 构造保留特征的下标
vector<int> keepIndices;
keepIndices.reserve(d - k);
for (int i = 0; i < d; ++i) {
if (!prune[i]) keepIndices.push_back(i);
}
int keptCount = (int)keepIndices.size();

// 5. 计算 h = X' W' 并求 argmax
vector<int> labels(n);
for (int i = 0; i < n; ++i) {
vector<double> scores(c, 0.0);
// 线性计算
for (int t = 0; t < keptCount; ++t) {
int featIdx = keepIndices[t];
double xVal = X[i][featIdx];
if (xVal == 0.0) continue;
for (int j = 0; j < c; ++j) {
scores[j] += xVal * W[featIdx][j];
}
}
// 6. 求 argmax
int bestIdx = 0;
double bestVal = scores[0];
for (int j = 1; j < c; ++j) {
if (scores[j] > bestVal) {
bestVal = scores[j];
bestIdx = j;
}
}
labels[i] = bestIdx;
}

return labels;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, d, c;
if (!(cin >> n >> d >> c)) {
return 0;
}

// 读取 X 矩阵
vector<vector<double>> X(n, vector<double>(d));
for (int i = 0; i < n; ++i) {
for (int j = 0; j < d; ++j) {
cin >> X[i][j];
}
}

// 读取 W 矩阵
vector<vector<double>> W(d, vector<double>(c));
for (int i = 0; i < d; ++i) {
for (int j = 0; j < c; ++j) {
cin >> W[i][j];
}
}

// 读取 ratio
double ratio;
cin >> ratio;

vector<int> labels = structuredPruningPrediction(n, d, c, X, W, ratio);

// 输出一行，空格分隔
for (int i = 0; i < (int)labels.size(); ++i) {
if (i > 0) cout << ' ';
cout << labels[i];
}
cout << '\n';

return 0;
}

---

### 第2题-栈大小峰值计算（P4521）
- 链接：https://codefun2000.com/p/P4521

> 页面标题：#P4521. 第2题-栈大小峰值计算

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一系列函数调用关系和调用所需开辟的栈内存大小，输出
1.系统运行时所需开辟的最大栈大小(栈空间是函数调用链上所需栈内存的总和)
2.满足开辟栈内存最大时，调用链长度的最大长度(有多个调用关系时输出最长调用链上的函数个数值)
输入描述
输入函数的调用关系和所需开辟的栈大小，输入第一行为调用关系数目从第二行开始为调用关系每行一个;
例如:
222
000 111 128128128
111 222 128128128
表示有两个调用关系:函数 000 调用函数 111 ，开辟 128128128 字节栈，函数 111 调用函数 222 ，开辟 128128128 字节栈
调用关系可如下图表示:

约束:
1.函数的 ididid 取值范围为 0<=id<=9990<= id <=9990<=id<=999
2.栈大小的范围为 8<=size<=102408<= size<=102408<=size<=10240
3.调用关系的总个数 <=1000<= 1000<=1000
输出描述
1.如果出现递归(环状的调用关系)，输出 −1-1−1
2.如果找到分配的最大栈的调用关系时，输出两个值，第一个值表示最大分配的栈内存的值，第二个值表示满足栈内存最大时，调用链的最大长度，使用空格分割
样例1
输入
3
0 1 128
1 2 128
2 0 128

输出
-1

说明
输入的函数调用关系中存在递归，输出 −1-1−1
样例2
输入
3
0 1 128
1 2 128
1 3 32

输出
256 3

说明
000 111 222 的调用关系会开辟 256256256 字节栈内存
000 111 333 的调用关系会开辟 160160160 字节栈内存
000 111 222 的调用关系开辟的栈内存最大，调用关系长度最长为 333，所以输出: 256256256 333

#### TextSol

解题思路

建图与输入

每一行 a b size 表示：函数 a 调用函数 b，这次调用需要 size 字节的栈内存。
这就是一张 有向图，边权为栈大小。
函数编号范围为 0~999，总边数 ≤ 1000。

检测递归（有向环）

题目说如果存在递归（函数调用有环），直接输出 -1。

对有向图做 拓扑排序（Kahn 算法）：

统计所有点入度，把入度为 0 的点入队。
不断出队、删边、更新入度并加入新的入度为 0 的点。
最后如果被弹出的点数 < 图中实际点数，则说明图中存在有向环。

一旦有环，立刻输出 -1，结束。

在 DAG 中求最大栈大小与相应最长调用链

图无环后，是一张 DAG。

定义状态（以某个函数为“调用链最后一个函数”）：

dpSum[u]：以 u 结尾的调用链的最大栈内存和（即边权之和）。
dpLen[u]：在上述最大栈内存方案下，调用链中函数个数（节点数）。

初始化：

对于出现过的每个函数 u，先认为它单独一个函数：dpSum[u] = 0，dpLen[u] = 1。

按拓扑序遍历所有点 u，对每条边 u -> v，边权为 w：

候选链：从 u 的最佳链再调用 v：

candSum = dpSum[u] + w
candLen = dpLen[u] + 1

用字典序比较更新 v：

如果 candSum > dpSum[v]，更新；
如果 candSum == dpSum[v] 且 candLen > dpLen[v]，也更新（同样栈大小时要更长的函数个数）。

遍历所有出现过的点，取：

最大的 dpSum 作为系统运行时需要开辟的最大栈大小；
在该最大栈大小下对应的最大 dpLen 作为调用链上的函数个数。

输出

若存在环，输出：-1
否则输出：最大栈大小 最大调用链函数个数，中间空格分隔。

核心算法：

拓扑排序检测有向环；
在 DAG 上的最长路径（带权 + 次要关键字为路径长度）DP。

复杂度分析

设函数点数为 V（最多 1000），调用关系数为 E（最多 1000）。

拓扑排序：时间复杂度 O(V + E)，空间复杂度 O(V + E)。

DAG 上 DP：同样 O(V + E) 时间、O(V) 额外空间。

总体：

时间复杂度：O(V + E)，在数据范围内非常充足。
空间复杂度：O(V + E)。

代码实现
Python
import sys
from collections import deque

# 计算最大栈大小和最长调用链长度的函数
def solve():
data = sys.stdin.read().split()
if not data:
return
m = int(data[0])  # 调用关系条数

MAX_ID = 1000  # 函数 id 范围 0~999
adj = [[] for _ in range(MAX_ID)]  # 邻接表：adj[u] = [(v, w), ...]
indeg = [0] * MAX_ID              # 入度
exist = [False] * MAX_ID          # 该函数是否出现过

idx = 1
for _ in range(m):
u = int(data[idx]); v = int(data[idx + 1]); w = int(data[idx + 2])
idx += 3
adj[u].append((v, w))
indeg[v] += 1
exist[u] = True
exist[v] = True

# 统计真正存在的函数个数
node_count = sum(1 for x in exist if x)

# 拓扑排序（Kahn），同时检测是否有环
q = deque()
for i in range(MAX_ID):
if exist[i] and indeg[i] == 0:
q.append(i)

topo = []
while q:
u = q.popleft()
topo.append(u)
for v, w in adj[u]:
indeg[v] -= 1
if indeg[v] == 0 and exist[v]:
q.append(v)

if len(topo) != node_count:
# 图中存在有向环 => 递归
print(-1)
return

# DAG 上 DP 求最长路径（以栈大小为主关键字，长度为次关键字）
dpSum = [0] * MAX_ID  # 最大栈大小
dpLen = [0] * MAX_ID  # 在该栈大小下的最大函数个数
for i in range(MAX_ID):
if exist[i]:
dpLen[i] = 1  # 单独一个函数

for u in topo:
for v, w in adj[u]:
candSum = dpSum[u] + w
candLen = dpLen[u] + 1
if candSum > dpSum[v] or (candSum == dpSum[v] and candLen > dpLen[v]):
dpSum[v] = candSum
dpLen[v] = candLen

# 找到整体最优答案
bestSum = 0
bestLen = 0
for i in range(MAX_ID):
if exist[i]:
if dpSum[i] > bestSum or (dpSum[i] == bestSum and dpLen[i] > bestLen):
bestSum = dpSum[i]
bestLen = dpLen[i]

print(bestSum, bestLen)

if __name__ == "__main__":
solve()

Java
import java.util.*;

// 主类名必须为 Main
public class Main {

// 边结构，表示一条调用关系
static class Edge {
int to;   // 终点函数 id
int w;    // 调用栈大小
Edge(int to, int w) {
this.to = to;
this.w = w;
}
}

// 计算并输出结果的函数
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNextInt()) {
return;
}
int m = sc.nextInt();  // 调用关系条数

final int MAX_ID = 1000;  // 函数 id 范围 0~999

ArrayList<Edge>[] g = new ArrayList[MAX_ID];
for (int i = 0; i < MAX_ID; i++) {
g[i] = new ArrayList<>();
}

int[] indeg = new int[MAX_ID];   // 入度
boolean[] exist = new boolean[MAX_ID];  // 该函数是否出现过

for (int i = 0; i < m; i++) {
int u = sc.nextInt();
int v = sc.nextInt();
int w = sc.nextInt();
g[u].add(new Edge(v, w));
indeg[v]++;
exist[u] = true;
exist[v] = true;
}

// 统计真正存在的函数个数
int nodeCount = 0;
for (int i = 0; i < MAX_ID; i++) {
if (exist[i]) nodeCount++;
}

// 拓扑排序（Kahn 算法）
Queue<Integer> q = new LinkedList<>();
for (int i = 0; i < MAX_ID; i++) {
if (exist[i] && indeg[i] == 0) {
q.offer(i);
}
}

int[] topo = new int[nodeCount]; // 存拓扑序
int idx = 0;
while (!q.isEmpty()) {
int u = q.poll();
topo[idx++] = u;
for (Edge e : g[u]) {
int v = e.to;
indeg[v]--;
if (indeg[v] == 0 && exist[v]) {
q.offer(v);
}
}
}

if (idx != nodeCount) {
// 有向图中存在环 => 递归
System.out.println(-1);
return;
}

// DAG 上 DP
int[] dpSum = new int[MAX_ID];  // 最大栈大小
int[] dpLen = new int[MAX_ID];  // 最大函数个数
for (int i = 0; i < MAX_ID; i++) {
if (exist[i]) {
dpLen[i] = 1; // 单独一个函数
}
}

for (int i = 0; i < nodeCount; i++) {
int u = topo[i];
for (Edge e : g[u]) {
int v = e.to;
int w = e.w;
int candSum = dpSum[u] + w;
int candLen = dpLen[u] + 1;
if (candSum > dpSum[v] || (candSum == dpSum[v] && candLen > dpLen[v])) {
dpSum[v] = candSum;
dpLen[v] = candLen;
}
}
}

int bestSum = 0;
int bestLen = 0;
for (int i = 0; i < MAX_ID; i++) {
if (!exist[i]) continue;
if (dpSum[i] > bestSum || (dpSum[i] == bestSum && dpLen[i] > bestLen)) {
bestSum = dpSum[i];
bestLen = dpLen[i];
}
}

System.out.println(bestSum + " " + bestLen);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算最大栈大小和最长调用链长度的函数
int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m;
if (!(cin >> m)) {
return 0;
}

const int MAX_ID = 1000; // 函数 id 范围 0~999
vector<pair<int, int>> adj[MAX_ID]; // 邻接表：{终点, 栈大小}
int indeg[MAX_ID] = {0};            // 入度
bool exist[MAX_ID] = {false};       // 该函数是否出现过

for (int i = 0; i < m; ++i) {
int u, v, w;
cin >> u >> v >> w;
adj[u].push_back({v, w});
indeg[v]++;
exist[u] = exist[v] = true;
}

// 统计真正存在的函数个数
int nodeCount = 0;
for (int i = 0; i < MAX_ID; ++i) {
if (exist[i]) nodeCount++;
}

// 拓扑排序（Kahn 算法）
queue<int> q;
for (int i = 0; i < MAX_ID; ++i) {
if (exist[i] && indeg[i] == 0) {
q.push(i);
}
}

vector<int> topo;
topo.reserve(nodeCount);
while (!q.empty()) {
int u = q.front();
q.pop();
topo.push_back(u);
for (auto &e : adj[u]) {
int v = e.first;
indeg[v]--;
if (indeg[v] == 0 && exist[v]) {
q.push(v);
}
}
}

if ((int)topo.size() != nodeCount) {
// 存在有向环 => 递归
cout << -1 << "\n";
return 0;
}

// DAG 上 DP
int dpSum[MAX_ID] = {0}; // 最大栈大小
int dpLen[MAX_ID] = {0}; // 最大函数个数
for (int i = 0; i < MAX_ID; ++i) {
if (exist[i]) dpLen[i] = 1; // 单独一个函数
}

for (int u : topo) {
for (auto &e : adj[u]) {
int v = e.first;
int w = e.second;
int candSum = dpSum[u] + w;
int candLen = dpLen[u] + 1;
if (candSum > dpSum[v] || (candSum == dpSum[v] && candLen > dpLen[v])) {
dpSum[v] = candSum;
dpLen[v] = candLen;
}
}
}

int bestSum = 0;
int bestLen = 0;
for (int i = 0; i < MAX_ID; ++i) {
if (!exist[i]) continue;
if (dpSum[i] > bestSum || (dpSum[i] == bestSum && dpLen[i] > bestLen)) {
bestSum = dpSum[i];
bestLen = dpLen[i];
}
}

cout << bestSum << " " << bestLen << "\n";
return 0;
}

---

### 第3题-智能客户分群与新用户定位(KMeans均衡分区版)（P4519）
- 链接：https://codefun2000.com/p/P4519

> 页面标题：#P4519. 第3题-智能客户分群与新用户定位(KMeans均衡分区版)

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某大型企业在运营智能营销平台，需对数干位老客户根据购买偏好数据进行自动化人群分群，以便实现高度针对性的商品推荐和精准推广。然而公司规定每个群组容量需尽可能均衡，避免资源失衡。因此，你需要帮平台开发自动化分群与新用户智能归属方案，具体需求如下：
1.采用 KMeansKMeansKMeans 变种聚类，将所有客户分为 KKK 个群组，且保证每组人数相等或只相差 111 。
2.当人数无法均分时，将多出来的客户依次分配给聚类中心编号更小的组，确保分配唯一。
3.对于新客户数据，利用最终分群中心点，确定其最合适归属的群组。
具体描述
1.客户输入：有 NNN 位已注册客户，每位客户的购买习惯由 MMM 个正整数特征描述。
2.分群个数：分为 KKK 个群组 (2≤K≤min(20,N))(2≤K≤min(20,N))(2≤K≤min(20,N)) 。
3.初始聚类中心：为输入前 KKK 个客户的数据。
4.聚类算法流程

每一轮分配，依次处理每个客户(客户编号从小到大，即输入顺序)。

对于每个客户，计算其到每个中心的欧几里得距离(如有多个中心距离同为最小，选中心编号更小者)。

客户被分配到距离自己最近且该组未满规定容量的中心;若容量已满，则分配给下一个最近、编号更小的可收组。

群组容量分配规则为：每组分配人数为 ⌊N/K⌋ 或「N/K ⌉\lfloor N / K\rfloor \text { 或「N/K }\rceil⌊N/K⌋ 或「N/K ⌉ ，多出的依次分配给编号较小的中心组；例如 N=11,K=3N=11,K=3N=11,K=3，则各组容量为 [4,4,3][4,4,3][4,4,3] 。

每一轮分配结束后，更新聚类中心为各自组内所有成员特征均值（向下取整）。

若所有客户分配及聚类中心均未发生变化，则算法终止。

5.输出中心排序：最终输出 KKK 个中心点的特征，按字典序升序排列
6.新用户归属：给定新客户的特征后，判定其归属到与其距离最近的聚类中心(如距离相等，优先字典序最小的中心)，输出其中心编号(排序后中心中的序号，从 111 开始)。
输入描述
输入格式

第 111 行：NNN MMM KKK (空格分隔)

第 222 ~ N+1N+1N+1 行：每行 MMM 个非负整数，表示一个客户的特征

第 N+2N+2N+2 行：MMM 个非负整数，为新客户的特征

输入参数范围

2≤K≤min(20,N)2 ≤K ≤ min(20, N)2≤K≤min(20,N)
1≤N≤20001≤N ≤20001≤N≤2000
1≤M≤101≤M≤101≤M≤10
0≤0≤0≤ 特征值 ≤104≤10^4≤104

输出描述
输出格式

前 KKK 行：每行 MMM 个整数，表示聚类中心的特征，按字典序升序排列
第 K+1K+1K+1 行：新客户归属的中心编号(按字典序排序后的位置，111 为首位)

样例1
输入
4 1 2
0
10
0
10
5

输出
0
10
1

说明

聚类目标人数为 [1,1][1,1][1,1]，前两组各 111 人。
按题算法唯一执行，中心结果唯一。
新客户同时与多个中心点等距离，字典序优先，分到第一组。

样例2
输入
8 2 3
10 10
12 9
11 11
100 100
102 99
97 98
50 51
53 49
45 46

输出
11 10
51 50
99 99
2

说明

聚类目标人数为 [3,3,2][3,3,2][3,3,2] ，前两组各 333 人，最后 111 组 222 人。

按题算法唯一执行，中心结果唯一。

新客户 [45[45[45 46]46]46] 归属中间分组，输出 222 。

提示
1.欧几里得距离(Euclidean distance)

对于两个 MMM 维特征的客户 AAA 和 B(A=[a1,a2,…,aM]，B=[b1,b2,…,bM])B(A=[a_1,a_2,…,a_M ]，B=[b_1,b_2,…,b_M ])B(A=[a1​,a2​,…,aM​]，B=[b1​,b2​,…,bM​])，它们之间的欧几里得距离定义为：$\sqrt{\left(a_{1}-b_{1}\right)^{2}+\left(a_{2}-b_{2}\right)^{2}+\cdots+\left(a_{M}-b_{M}\right)^{2}}$

建议先计算平方和，再进行平方根(或用于距离大小比较时可直接用平方和，省略开方，顺序不会影响)。

2.均衡分组(Balanced partitioning)

若 NNN 个客户分到 KKK 组，原则上每组应有 q=⌊N/K⌋q=\lfloor N / K\rfloorq=⌊N/K⌋人。若 NNN 不能被 KKK 整除，则有 (N(N(N modmodmod k)k)k) 个组会多一人。多出的名额分配给编号较小的分组。

3.字典序(Lexicographical order)

多维特征排序时，先比较第 111 维，若相同比第 222 维，依此类推。例如：[2,3,4]<[2,4,1]<[5,0,0][2,3,4]< [2,4,1]< [5,0,0][2,3,4]<[2,4,1]<[5,0,0] 。

4.唯一性规则说明

每个客户依次(输入顺序)分配到当前距离自己最近、且该组人数没到上限的中心，如有多个距离同为最小，选择中心编号最小(即输入时编号更小)的中心。

分组人数严格按照上面的第二点分配，保证每组人数最多相差 111 ，且人数多的始终是中心编号更小的组。

5.新客户KNN归属

将新客户特征与所有最终中心比距离，归属最近中心的分组。

若距离有多个中心同为最小，分到字典序最小的中心

#### TextSol

解题思路
1. 整体算法
本题本质是一个带容量约束的 KMeans 聚类 + 新样本最近中心归属问题：

已有 N 个客户，每个是 M 维非负整数特征；

需要分成 K 个簇，并且每个簇人数尽量均衡（容量上限提前固定）；

聚类过程类似 KMeans：

用前 K 个样本作为初始中心；
反复执行「按当前中心分配 → 重新计算中心」直到收敛；

聚类完成后：

将 K 个中心按字典序排序并输出；
对新用户，用“最近中心 + 字典序优先”来决定归属中心，并输出其在排序后的位置。

这里的关键在于：分配阶段的容量约束和选择规则与普通 KMeans 不同。
2. 容量（目标人数）计算
先计算每个簇最大容量（题目保证最终都是满的）：

设

q = N // K（每组至少 q 人）
r = N % K（前 r 个组多一个人）

则组 0..K-1 的目标容量为：

若 i < r，容量为 q + 1
否则容量为 q

例如：N = 11, K = 3 → q = 3, r = 2 → 容量 [4, 4, 3]。
这样就保证：

每组人数只差 0 或 1；
人数更多的一定是编号更小的组（前面的组先拿到额外名额）。

3. 聚类迭代过程（变种 KMeans）

初始化中心

直接把前 K 个客户的特征当作初始中心 centers[0..K-1]。

一次分配轮次（Assignment Step）
依次处理每个客户 i = 0..N-1：

计算它到每个中心 k 的欧氏距离的平方（不必开根号，比较大小即可）：
$$dist^2 = \sum_{d=0}^{M-1} (x_{i,d} - center_{k,d})^2$$

对所有簇 (k) 按 (距离, k) 升序排序（先比距离，再比簇编号）；

从排序后的簇中，找到第一个未达容量上限的簇，把客户 i 分给它：

如果最优簇已满，则尝试下一个距离最近的簇；
总会找到一个，因为整体容量之和就是 N。

这样就满足了：

优先选择距离最近的中心；
距离相等时，优先中心编号更小；
容量被严格限制在预先计算好的上限。

更新中心（Update Step）
分配完成后，对每个簇 k：

累加该簇内所有客户在各维度的特征和；
再对每维特征做整数平均（向下取整）：$$center_{k,d} = \left\lfloor \frac{\sum x_{i,d}}{\text{簇内人数}} \right\rfloor$$

终止条件（收敛）

如果本轮分配得到的 assign[] 与上一轮完全一样，
且本轮计算出的 centers[][] 也与上一轮完全一样，
则认为算法收敛，终止循环。
否则继续下一轮。

注：状态空间有限（中心取值有限、分配方式有限），最终一定会收敛。

4. 输出中心 + 新用户归属

中心排序
收敛后得到最终 K 个中心。
按字典序升序排序：

先比第 1 维，不同则小者在前；
相同再比第 2 维，以此类推。

输出排序后的 K 行中心向量。

新用户归属（KNN 到中心）
用排序后的中心数组 sorted_centers 对新用户进行一次简单的「最近中心判断」：

对每个中心 c，计算新用户与其的欧氏距离平方；

选择距离最小的中心；

如果有多个中心距离相等，则优先选择字典序更小的中心。

因为我们已经按照字典序排序，所以在遍历中“先出现”的中心自然就是字典序更小的；

输出该中心在排序数组中的位置（1 开始编号）。

代码实现
Python
import sys
from math import inf

# 计算两点间欧氏距离的平方
def dist2(a, b):
s = 0
for x, y in zip(a, b):
diff = x - y
s += diff * diff
return s

def balanced_kmeans(customers, K):
N = len(customers)
M = len(customers[0])

# 计算每个簇的目标容量
base = N // K
rem = N % K
capacity = [base + (1 if i < rem else 0) for i in range(K)]

# 初始中心：前 K 个客户
centers = [customers[i][:] for i in range(K)]

# 初始分配，全部设为 -1
assign = [-1] * N

while True:
# 新一轮分配
new_assign = [-1] * N
sizes = [0] * K

# 按客户编号从小到大分配
for i in range(N):
point = customers[i]

# 计算到每个中心的距离
dist_list = []
for k in range(K):
d2 = dist2(point, centers[k])
dist_list.append((d2, k))

# 按 (距离, 中心编号) 排序
dist_list.sort()

# 找到第一个未满容量的中心
for _, k in dist_list:
if sizes[k] < capacity[k]:
new_assign[i] = k
sizes[k] += 1
break

# 根据新分配结果更新中心
new_centers = [[0] * M for _ in range(K)]
counts = [0] * K
for i in range(N):
c = new_assign[i]
counts[c] += 1
for d in range(M):
new_centers[c][d] += customers[i][d]

for k in range(K):
# 每个簇一定有容量，所以 counts[k] > 0
for d in range(M):
new_centers[k][d] //= counts[k]

# 判断是否收敛（分配和中心都不变）
if new_assign == assign and new_centers == centers:
centers = new_centers
assign = new_assign
break
else:
centers = new_centers
assign = new_assign

return centers

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
N = int(next(it))
M = int(next(it))
K = int(next(it))

customers = []
for _ in range(N):
point = [int(next(it)) for _ in range(M)]
customers.append(point)

new_customer = [int(next(it)) for _ in range(M)]

# 执行均衡 KMeans
centers = balanced_kmeans(customers, K)

# 按字典序排序中心
centers.sort()

# 输出中心
out_lines = []
for c in centers:
out_lines.append(" ".join(str(x) for x in c))

# 新用户归属：最近中心，距离相等时字典序更小（排序后自然满足）
best_idx = 0
best_dist = dist2(new_customer, centers[0])
for i in range(1, K):
d2 = dist2(new_customer, centers[i])
if d2 < best_dist:
best_dist = d2
best_idx = i
# 若距离相等，由于中心已按字典序排序，保留原来的较小下标即可

out_lines.append(str(best_idx + 1))

sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {

// 计算两点欧氏距离的平方
public static long dist2(int[] a, int[] b) {
long s = 0;
for (int i = 0; i < a.length; i++) {
long diff = (long)a[i] - (long)b[i];
s += diff * diff;
}
return s;
}

// 均衡 KMeans 主过程
public static int[][] balancedKMeans(int[][] customers, int K) {
int N = customers.length;
int M = customers[0].length;

// 计算容量
int base = N / K;
int rem = N % K;
int[] capacity = new int[K];
for (int i = 0; i < K; i++) {
capacity[i] = base + (i < rem ? 1 : 0);
}

// 初始中心：前 K 个客户
int[][] centers = new int[K][M];
for (int k = 0; k < K; k++) {
for (int d = 0; d < M; d++) {
centers[k][d] = customers[k][d];
}
}

int[] assign = new int[N];
for (int i = 0; i < N; i++) assign[i] = -1;

while (true) {
int[] newAssign = new int[N];
for (int i = 0; i < N; i++) newAssign[i] = -1;
int[] sizes = new int[K];

// 分配每个客户
for (int i = 0; i < N; i++) {
int[] point = customers[i];

long[] dist = new long[K];
for (int k = 0; k < K; k++) {
dist[k] = dist2(point, centers[k]);
}

// 根据距离和中心编号选择未满容量的中心
boolean[] used = new boolean[K];
while (true) {
int best = -1;
for (int k = 0; k < K; k++) {
if (used[k]) continue;
if (best == -1 || dist[k] < dist[best] ||
(dist[k] == dist[best] && k < best)) {
best = k;
}
}
used[best] = true;
if (sizes[best] < capacity[best]) {
newAssign[i] = best;
sizes[best]++;
break;
}
// 如果这个中心已满，则继续找下一个最近的
}
}

// 根据新分配更新中心
int[][] newCenters = new int[K][M];
int[] counts = new int[K];
for (int i = 0; i < N; i++) {
int c = newAssign[i];
counts[c]++;
for (int d = 0; d < M; d++) {
newCenters[c][d] += customers[i][d];
}
}

for (int k = 0; k < K; k++) {
for (int d = 0; d < M; d++) {
newCenters[k][d] /= counts[k];
}
}

// 判断是否收敛
boolean sameAssign = true;
for (int i = 0; i < N; i++) {
if (newAssign[i] != assign[i]) {
sameAssign = false;
break;
}
}

boolean sameCenter = true;
for (int k = 0; k < K && sameCenter; k++) {
for (int d = 0; d < M; d++) {
if (newCenters[k][d] != centers[k][d]) {
sameCenter = false;
break;
}
}
}

centers = newCenters;
assign = newAssign;

if (sameAssign && sameCenter) {
break;
}
}

return centers;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String firstLine = br.readLine();
if (firstLine == null || firstLine.trim().isEmpty()) return;
String[] parts = firstLine.trim().split("\\s+");
int N = Integer.parseInt(parts[0]);
int M = Integer.parseInt(parts[1]);
int K = Integer.parseInt(parts[2]);

int[][] customers = new int[N][M];
for (int i = 0; i < N; i++) {
String line = br.readLine();
while (line != null && line.trim().isEmpty()) {
line = br.readLine();
}
String[] arr = line.trim().split("\\s+");
for (int j = 0; j < M; j++) {
customers[i][j] = Integer.parseInt(arr[j]);
}
}

int[] newCustomer = new int[M];
String line = br.readLine();
while (line != null && line.trim().isEmpty()) {
line = br.readLine();
}
String[] arr = line.trim().split("\\s+");
for (int j = 0; j < M; j++) {
newCustomer[j] = Integer.parseInt(arr[j]);
}

// 执行均衡 KMeans
int[][] centers = balancedKMeans(customers, K);

// 按字典序排序中心
java.util.Arrays.sort(centers, (a, b) -> {
for (int i = 0; i < a.length; i++) {
if (a[i] != b[i]) return a[i] - b[i];
}
return 0;
});

StringBuilder sb = new StringBuilder();
// 输出中心
for (int k = 0; k < K; k++) {
for (int d = 0; d < M; d++) {
if (d > 0) sb.append(' ');
sb.append(centers[k][d]);
}
sb.append('\n');
}

// 新用户归属
long bestDist = dist2(newCustomer, centers[0]);
int bestIdx = 0;
for (int i = 1; i < K; i++) {
long d2 = dist2(newCustomer, centers[i]);
if (d2 < bestDist) {
bestDist = d2;
bestIdx = i;
}
// 若距离相等，因排序后字典序递增，保留较小下标即可
}

sb.append(bestIdx + 1).append('\n');

System.out.print(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算两点欧氏距离的平方
long long dist2(const vector<int> &a, const vector<int> &b) {
long long s = 0;
for (size_t i = 0; i < a.size(); i++) {
long long diff = (long long)a[i] - (long long)b[i];
s += diff * diff;
}
return s;
}

// 均衡 KMeans 主过程
vector<vector<int>> balancedKMeans(const vector<vector<int>> &customers, int K) {
int N = (int)customers.size();
int M = (int)customers[0].size();

// 计算容量
int base = N / K;
int rem = N % K;
vector<int> capacity(K);
for (int i = 0; i < K; i++) {
capacity[i] = base + (i < rem ? 1 : 0);
}

// 初始中心：前 K 个客户
vector<vector<int>> centers(K, vector<int>(M));
for (int k = 0; k < K; k++) {
centers[k] = customers[k];
}

vector<int> assign(N, -1);

while (true) {
vector<int> newAssign(N, -1);
vector<int> sizes(K, 0);

// 分配每个客户
for (int i = 0; i < N; i++) {
const vector<int> &point = customers[i];

vector<long long> dist(K);
for (int k = 0; k < K; k++) {
dist[k] = dist2(point, centers[k]);
}

vector<bool> used(K, false);
while (true) {
int best = -1;
for (int k = 0; k < K; k++) {
if (used[k]) continue;
if (best == -1 || dist[k] < dist[best] ||
(dist[k] == dist[best] && k < best)) {
best = k;
}
}
used[best] = true;
if (sizes[best] < capacity[best]) {
newAssign[i] = best;
sizes[best]++;
break;
}
// 否则继续找下一个最近且未满的中心
}
}

// 更新中心
vector<vector<long long>> sum(K, vector<long long>(M, 0));
vector<int> counts(K, 0);

for (int i = 0; i < N; i++) {
int c = newAssign[i];
counts[c]++;
for (int d = 0; d < M; d++) {
sum[c][d] += customers[i][d];
}
}

vector<vector<int>> newCenters(K, vector<int>(M));
for (int k = 0; k < K; k++) {
for (int d = 0; d < M; d++) {
newCenters[k][d] = (int)(sum[k][d] / counts[k]);
}
}

// 判断是否收敛
bool sameAssign = true;
for (int i = 0; i < N; i++) {
if (newAssign[i] != assign[i]) {
sameAssign = false;
break;
}
}

bool sameCenter = true;
for (int k = 0; k < K && sameCenter; k++) {
for (int d = 0; d < M; d++) {
if (newCenters[k][d] != centers[k][d]) {
sameCenter = false;
break;
}
}
}

centers.swap(newCenters);
assign.swap(newAssign);

if (sameAssign && sameCenter) {
break;
}
}

return centers;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, M, K;
if (!(cin >> N >> M >> K)) {
return 0;
}

vector<vector<int>> customers(N, vector<int>(M));
for (int i = 0; i < N; i++) {
for (int j = 0; j < M; j++) {
cin >> customers[i][j];
}
}

vector<int> newCustomer(M);
for (int j = 0; j < M; j++) {
cin >> newCustomer[j];
}

// 执行均衡 KMeans
vector<vector<int>> centers = balancedKMeans(customers, K);
int dim = M;

// 按字典序排序中心
sort(centers.begin(), centers.end(), [dim](const vector<int> &a, const vector<int> &b) {
for (int i = 0; i < dim; i++) {
if (a[i] != b[i]) return a[i] < b[i];
}
return false;
});

// 输出中心
for (int k = 0; k < K; k++) {
for (int d = 0; d < M; d++) {
if (d) cout << ' ';
cout << centers[k][d];
}
cout << "\n";
}

// 新用户归属
long long bestDist = dist2(newCustomer, centers[0]);
int bestIdx = 0;
for (int i = 1; i < K; i++) {
long long d2 = dist2(newCustomer, centers[i]);
if (d2 < bestDist) {
bestDist = d2;
bestIdx = i;
}
// 若距离相等，排序后字典序小的在前，保留原下标即可
}

cout << (bestIdx + 1) << "\n";

return 0;
}

---

### 第3题-找出优先级最高的连续子包集合（P4522）
- 链接：https://codefun2000.com/p/P4522

> 页面标题：#P4522. 第3题-找出优先级最高的连续子包集合

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

网络侧需要给手机发送一个码流，一个码流由多个子包组成。例如:码流 333 444 555 666，该码流中含有四个子包，子包 IDIDID 分别为 3、4、5、63、4、5、63、4、5、6 。
给定一个整数数组 numsnumsnums 用于保存这条码流子包 IDIDID ，另有一个正整数 kkk 需要找出长度为 kkk 且优先级最高 的 子包 IDIDID 集合。
在子包 IDIDID 集合 aaa 和子包 IDIDID 集合 bbb 的 第一个不相同的位置上，如果 aaa 中的数字大于于 bbb 中对应的数字，那么我们称子包 IDIDID 集合 aaa 比子包 IDIDID 集合 bbb (相同长度下)优先级更高。
例如，[2,5,8][2,5,8][2,5,8] 比 [2,4,9][2,4,9][2,4,9] 优先级更高，在第一个不相同的位置，也就是第个位置上，555 大于 444 。
输入描述
先输入码流，包含多个用 101010 进制正整数表示的子包 IDIDID ，每个子包 IDIDID 之间用空格隔开，最大支持编号从 000 开始的 500500500 种不同的子包
再输入需要找出的优先级最高的子包长度
注:子包 IDIDID 的先后顺序不可变更，但可删除或者不删除中间的子包 IDIDID
输出描述
最高优先级的子包 IDIDID 集合，每个子包 IDIDID 用空格隔开
样例1
输入
0x2 0x2
1

输出
error

说明
仅支持 101010 进制数，输入中带有字母，打印 errorerrorerror
样例2
输入
6 3 2 4 4 3 8 5
4

输出
6 4 8 5

说明
在所有可能的长度为 444 的子包 IDIDID 集合中，666 444 888 555 的优先级最高。
样例3
输入
5 7 4 8
2

输出
7 8

说明
在所有可能的长度为 222 的子包 IDIDID 集合 [5,7],[5,4],[5,8],[7,4],[7,8],[4,8][5,7],[5,4],[5,8],[7,4],[7,8],[4,8][5,7],[5,4],[5,8],[7,4],[7,8],[4,8] 中，[7,8][7,8][7,8] 的优先级最高。
提示
第一行码流最大长度: 200020002000
子包 IDIDID 范围: 0<=nums[i]<5000<=nums[i] < 5000<=nums[i]<500
子包长度范围: 1<=k<=nums.length1<=k<=nums.length1<=k<=nums.length
以上数字只考虑 101010 进制数，不考虑其他，输入内容中带有非数字或者其他错误时打印 errorerrorerror

#### TextSol

解题思路
题意：给定一串子包 ID（顺序不能改变），从中删去若干个子包，保留 恰好 k 个，得到的长度为 k 的子包集合按字典序（从左到右比较大小）要尽量大。
如果在第一个不同的位置上，集合 a 的数字大于集合 b 的数字，则 a 的优先级更高。
这就是“在数组中选出长度为 k 的字典序最大子序列”的经典问题，可以用 贪心 + 单调栈 来做。
做法：

假设总长度为 n，需要删掉的元素个数为 drop = n - k。

从左到右依次扫描每个子包 ID：

维护一个栈（用数组或列表实现），栈中保存当前已经选择的子包 ID。

对于当前元素 x：

当 drop > 0 且栈不空且栈顶元素小于 x 时，
就可以把栈顶弹出（相当于删掉之前选的这个更小的 ID），drop--。
之后把 x 压入栈。

所有元素扫描完后，如果栈长度大于 k，就只保留前 k 个（因为可能没删够，但多的放在后面，截断即可）。

栈中前 k 个元素就是字典序最大的长度为 k 的子序列。

此外，题目要求只接受 10 进制数字：

第一行和第二行中若出现非数字非空格字符（如 0x2 中的 x），则直接输出 error。

复杂度分析
设码流长度为 n。

时间复杂度：每个元素最多入栈一次、出栈一次，故为 O(n)。
空间复杂度：栈最多存下 n 个元素，故为 O(n)（结果长度为 k，k ≤ n）。

代码实现
Python
# 功能函数：返回长度为 k 的字典序最大子序列
def max_subsequence(nums, k):
n = len(nums)
drop = n - k  # 还能删除的个数
stack = []
for x in nums:
# 贪心：当前元素更大且还能删除之前的元素，就弹栈
while drop > 0 and stack and stack[-1] < x:
stack.pop()
drop -= 1
stack.append(x)
# 可能还没删够，多余的在后面，直接截断
return stack[:k]

def is_valid_line(s):
# 只允许数字和空白字符
for ch in s:
if not (ch.isdigit() or ch.isspace()):
return False
return True

def main():
try:
line1 = input().strip()
except EOFError:
print("error")
return

if not line1 or not is_valid_line(line1):
print("error")
return

try:
line2 = input().strip()
except EOFError:
print("error")
return

if not line2 or not is_valid_line(line2):
print("error")
return

# 解析子包 ID 列表
nums = list(map(int, line1.split()))
# 解析 k
k = int(line2)
ans = max_subsequence(nums, k)
# 按空格输出
print(" ".join(str(x) for x in ans))

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import java.util.ArrayList;

public class Main {

// 功能函数：返回长度为 k 的字典序最大子序列
public static int[] maxSubsequence(int[] nums, int k) {
int n = nums.length;
int drop = n - k;          // 还能删除的个数
int[] stack = new int[n];  // 用数组模拟栈
int top = 0;               // 栈中元素个数

for (int x : nums) {
// 贪心：当前元素更大且还能删除之前的元素，就弹栈
while (drop > 0 && top > 0 && stack[top - 1] < x) {
top--;
drop--;
}
stack[top++] = x;
}

// 只需要前 k 个
int[] res = new int[k];
System.arraycopy(stack, 0, res, 0, k);
return res;
}

// 检查一行是否只包含数字和空白
public static boolean isValidLine(String s) {
for (int i = 0; i < s.length(); i++) {
char ch = s.charAt(i);
if (!Character.isDigit(ch) && !Character.isWhitespace(ch)) {
return false;
}
}
return true;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

String line1 = br.readLine();
if (line1 == null || line1.trim().isEmpty() || !isValidLine(line1)) {
System.out.println("error");
return;
}

String line2 = br.readLine();
if (line2 == null || line2.trim().isEmpty() || !isValidLine(line2)) {
System.out.println("error");
return;
}

// 解析子包 ID 列表
StringTokenizer st = new StringTokenizer(line1);
ArrayList<Integer> list = new ArrayList<Integer>();
while (st.hasMoreTokens()) {
list.add(Integer.parseInt(st.nextToken()));
}
int n = list.size();
int[] nums = new int[n];
for (int i = 0; i < n; i++) {
nums[i] = list.get(i);
}

// 解析 k
int k;
try {
k = Integer.parseInt(line2.trim());
} catch (NumberFormatException e) {
System.out.println("error");
return;
}
int[] ans = maxSubsequence(nums, k);
// 输出
StringBuilder sb = new StringBuilder();
for (int i = 0; i < ans.length; i++) {
if (i > 0) sb.append(' ');
sb.append(ans[i]);
}
System.out.println(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 功能函数：返回长度为 k 的字典序最大子序列
vector<int> maxSubsequence(const vector<int>& nums, int k) {
int n = (int)nums.size();
int drop = n - k;        // 还能删除的个数
vector<int> st;          // 当作栈使用
st.reserve(n);

for (int x : nums) {
// 贪心：当前元素更大且还能删除之前的元素，就弹栈
while (drop > 0 && !st.empty() && st.back() < x) {
st.pop_back();
--drop;
}
st.push_back(x);
}

// 只取前 k 个
if ((int)st.size() > k) {
st.resize(k);
}
return st;
}

// 检查一行是否只包含数字和空白
bool isValidLine(const string& s) {
for (char ch : s) {
if (!isdigit((unsigned char)ch) && !isspace((unsigned char)ch)) {
return false;
}
}
return true;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line1;
if (!getline(cin, line1)) {
cout << "error\n";
return 0;
}
if (line1.empty() || !isValidLine(line1)) {
cout << "error\n";
return 0;
}

string line2;
if (!getline(cin, line2)) {
cout << "error\n";
return 0;
}
if (line2.empty() || !isValidLine(line2)) {
cout << "error\n";
return 0;
}

// 解析子包 ID 列表
stringstream ss(line1);
vector<int> nums;
int x;
while (ss >> x) {
nums.push_back(x);
}

// 解析 k
int k;
stringstream ss2(line2);
if (!(ss2 >> k)) {
cout << "error\n";
return 0;
}
vector<int> ans = maxSubsequence(nums, k);

// 输出
for (int i = 0; i < (int)ans.size(); ++i) {
if (i) cout << ' ';
cout << ans[i];
}
cout << '\n';
return 0;
}

---

## 2025年11月20日-留学生AI方向

### 第2题-Vision Transformer中的Patch Embdding层实现（P4481）
- 链接：https://codefun2000.com/p/P4481

> 页面标题：#P4481. 第2题-Vision Transformer中的Patch Embdding层实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

VisionVisionVision Transformer(ViT)Transformer(ViT)Transformer(ViT) 是视觉领域应用非常广泛的基础网络结构，经典的 ViTViTViT 结构如图所示，
其包含了 PatchPatchPatch＆PositionPositionPosition embedding、Transformerembedding、Transformerembedding、Transformer EncoderEncoderEncoder 等多个关键模块组成。这几个模块中，将图像分割为固定大小的 patchpatchpatch 并进行线性嵌入是一个关键步骤，也即 PatchPatchPatch EmbeddingEmbeddingEmbedding 层，其主要实现步骤为：
StepStepStep 111：将输入图像分割为多个非重叠的 patchpatchpatch ，也即将图片切分为 N∗NN*NN∗N 个 patchpatchpatch ，如 3∗33*33∗3 个 2D2D2D 图像块；
StepStepStep 222：将每个 patchpatchpatch 展平为向量，也即将每个切分后的 2D2D2D PatchPatchPatch 展平为 1D1D1D 向量;
StepStepStep 333：对展平的 patchpatchpatch 进行线性变换(嵌入)，也即对每个展平后的 1D1D1D 向量做一个线性变换，使用一个可学习的权重矩阵 EEE 和 偏置向量 BBB 进行线性变换，公式为：Z=X∗E+bZ=X*E+bZ=X∗E+b
StepStepStep 444：添加可学习的位置编码；
请根据以上提示步骤，实现 PatchPatchPatch EmbeddingEmbeddingEmbedding 层。
特别注意：本实现过程中，无法使用深度学习框架，如 pytorch、tensorflowpytorch、tensorflowpytorch、tensorflow 等
输入描述
输入参数包括：imp_size、patch_size、channel、embedding_dimimp\_size、patch\_size、channel、embedding\_dimimp_size、patch_size、channel、embedding_dim，分别表示：
图像尺寸（图像长、宽默认相等）img_sizeimg\_sizeimg_size ；
patchpatchpatch 大小 patch_sizepatch\_sizepatch_size ；
图像通道数 channelschannelschannels ；
嵌入维度 embedding_dimembedding\_dimembedding_dim
输出描述
输出 patch_embeddingpatch\_embeddingpatch_embedding 后的维度信息 embedding_shapeembedding\_shapeembedding_shape，其中需要包含 cisciscis tokentokentoken，具体可见样例。
样例1
输入
448 32 3 384

输出
197 384

说明
输入：448448448 323232 333 384384384
分别表示：
图像尺寸（图像长、宽默认相等）img_size=448img\_size=448img_size=448 ；
patchpatchpatch 大小 patch_size=32patch\_size=32patch_size=32 ；
图像通道数 channels=3channels=3channels=3 ；
嵌入维度 embedding_dim=384embedding\_dim=384embedding_dim=384
输出：197197197 384384384
分别表示：
经过 patch_embeddingpatch\_embeddingpatch_embedding 层后得到的 embedding_shapeembedding\_shapeembedding_shape ，其中第一维 197197197 表示 patchpatchpatch token+cistoken+cistoken+cis tokentokentoken ，第二维表示 patch_embeddingpatch\_embeddingpatch_embedding 后的 enbeddingenbeddingenbedding 维度
样例2
输入
224 16 3 768

输出
197 768

说明
输入：224224224 161616 333 768768768
分别表示：
图像尺寸（图像长、宽默认相等）img_size=224img\_size=224img_size=224 ；
patchpatchpatch 大小 patch_size=16patch\_size=16patch_size=16 ；
图像通道数 channels=3channels=3channels=3 ；
嵌入维度 embedding_dim=768embedding\_dim=768embedding_dim=768
输出：197197197 768768768
分别表示：
经过 patch_embeddingpatch\_embeddingpatch_embedding 层后得到的 embedding_shapeembedding\_shapeembedding_shape ，其中第一维 197197197 表示 patchpatchpatch token+cistoken+cistoken+cis tokentokentoken ，第二维表示 patch_embeddingpatch\_embeddingpatch_embedding 后的 enbeddingenbeddingenbedding 维度

#### TextSol

解题思路
Patch Embedding 的本质是一个分块 + 展开 + 线性变换的过程，可以理解为对图像做一次“卷积核为 patch，步长为 patch_size 的卷积 + reshape”，再加上一个 cls token。这里我们只需要计算输出向量序列的维度，而不是具体做矩阵运算。
设输入参数为：

图像尺寸：img_size（高 = 宽）
patch 大小：patch_size
通道数：channel
嵌入维度：embedding_dim

1. 计算 patch 的个数
图像被均匀切成大小为 patch_size × patch_size 的不重叠 patch：

每一维上的 patch 个数：
N=img_sizepatch_sizeN = \frac{\text{img\_size}}{\text{patch\_size}}
N=patch_sizeimg_size​

总 patch 数目：
$$\text{num\_patches} = N \times N = \left(\frac{\text{img\_size}}{\text{patch\_size}}\right)^2$$

题目默认输入是合法的，所以可以认为 img_size 能整除 patch_size。
2. 展开并线性变换
每个 patch 的原始维度为：
$$\text{patch\_dim} = \text{patch\_size} \times \text{patch\_size} \times \text{channel}$$线性嵌入用一个权重矩阵 EEE 和偏置 bbb：

EEE 的形状：patch_dim×embedding_dim\text{patch\_dim} \times \text{embedding\_dim}patch_dim×embedding_dim
bbb 的形状：embedding_dim\text{embedding\_dim}embedding_dim

对每个 patch 展开后的向量 XXX 做线性变换：
Z=X×E+bZ = X \times E + b
Z=X×E+b
因此每个 patch 最终变成一个长度为 embedding_dim 的向量。
所有 patch 经过线性变换后得到：
(num_patches, embedding_dim)(\text{num\_patches},\ \text{embedding\_dim})
(num_patches, embedding_dim)
3. 添加 CLS Token
ViT 会额外添加一个可学习的 cls token，其维度和单个 patch 的嵌入相同，为 (embedding_dim,)。
拼接到序列前面之后，序列长度变为：
num_tokens=num_patches+1\text{num\_tokens} = \text{num\_patches} + 1
num_tokens=num_patches+1
因此最终的 patch embedding 输出维度（不含 batch 维）为：
$$\text{embedding\_shape} = (\text{num\_patches} + 1,\ \text{embedding\_dim})$$4. 套用样例
样例输入：448 32 3 384

每边 patch 数：N=448/32=14N = 448 / 32 = 14N=448/32=14
总 patch 数：num_patches=142=196\text{num\_patches} = 14^2 = 196num_patches=142=196
加 cls token：num_tokens=196+1=197\text{num\_tokens} = 196 + 1 = 197num_tokens=196+1=197
每个 token 维度：384

所以输出为：
embedding_shape=(197, 384)\text{embedding\_shape} = (197,\ 384)
embedding_shape=(197, 384)
即：197 384
代码实现
Python
# 计算 Patch Embedding 输出维度的函数
def get_embedding_shape(img_size, patch_size, channel, embedding_dim):
# 每一维上的 patch 个数
num_per_dim = img_size // patch_size
# 总的 patch 个数
num_patches = num_per_dim * num_per_dim
# 加上一个 cls token
num_tokens = num_patches + 1
# 返回 (序列长度, 嵌入维度)
return num_tokens, embedding_dim

def main():
# 读取输入：img_size patch_size channel embedding_dim
img_size, patch_size, channel, embedding_dim = map(int, input().split())
# 调用函数计算结果
tokens, dim = get_embedding_shape(img_size, patch_size, channel, embedding_dim)
# 按题目要求输出
print(tokens, dim)

if __name__ == "__main__":
main()

Java
import java.util.Scanner;

public class Main {

// 计算 Patch Embedding 输出维度的函数
public static int[] getEmbeddingShape(int imgSize, int patchSize, int channel, int embeddingDim) {
// 每一维上的 patch 个数
int numPerDim = imgSize / patchSize;
// 总的 patch 个数
int numPatches = numPerDim * numPerDim;
// 加上一个 cls token
int numTokens = numPatches + 1;
// 返回 (序列长度, 嵌入维度)
return new int[]{numTokens, embeddingDim};
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
// 读取输入：img_size patch_size channel embedding_dim
int imgSize = sc.nextInt();
int patchSize = sc.nextInt();
int channel = sc.nextInt();
int embeddingDim = sc.nextInt();
sc.close();

// 计算结果
int[] res = getEmbeddingShape(imgSize, patchSize, channel, embeddingDim);

// 按题目要求输出
System.out.println(res[0] + " " + res[1]);
}
}

C++
#include <iostream>
using namespace std;

// 计算 Patch Embedding 输出维度的函数
void getEmbeddingShape(int img_size, int patch_size, int channel, int embedding_dim,
int &num_tokens, int &dim_out) {
// 每一维上的 patch 个数
int num_per_dim = img_size / patch_size;
// 总的 patch 个数
int num_patches = num_per_dim * num_per_dim;
// 加上一个 cls token
num_tokens = num_patches + 1;
// 嵌入维度不变
dim_out = embedding_dim;
}

int main() {
int img_size, patch_size, channel, embedding_dim;
// 读取输入：img_size patch_size channel embedding_dim
cin >> img_size >> patch_size >> channel >> embedding_dim;

int tokens, dim;
// 调用函数计算输出维度
getEmbeddingShape(img_size, patch_size, channel, embedding_dim, tokens, dim);

// 按题目要求输出
cout << tokens << " " << dim << endl;

return 0;
}

---

### 第2题-一顿大餐的菜品选择方式（P4478）
- 链接：https://codefun2000.com/p/P4478

> 页面标题：#P4478. 第2题-一顿大餐的菜品选择方式

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你来到食堂想大吃一顿。你将在全荤、半荤、素中各挑选一种菜品，且所挑选菜品的食材不能重复，请你计算
菜品选择方式
输入描述
食堂的所有餐线的菜单
第111行是：NNN，其中NNN为所有菜品数量,范围(0,100](0,100](0,100]
第222行是：ID1 T1 DI1 DI2 DI3 DI4ID_1\ T_1 \ DI_1\ DI_2\ DI_3\ DI_4ID1​ T1​ DI1​ DI2​ DI3​ DI4​,其中ID1ID_1ID1​:为第1个菜品的菜品名，范围(0,100](0,100](0,100]。T1T_1T1​为菜品类型，111表示全荤、222表示半荤、333表示素。DI1...DI4DI_1...DI_4DI1​...DI4​分别为第111个菜品的第111种到第444种食材，食材不会重复,范围[0,100][0,100][0,100]，000表示占位，无食材。
第N+1N+1N+1行是:IDN TN DN1 DN2 DN3 DN4ID_N\  T_N\ DN_1\ DN_2\ DN_3\ DN_4IDN​ TN​ DN1​ DN2​ DN3​ DN4​，其中IDNID_NIDN​为第NNN个菜品的菜品名。TNT_NTN​为菜品类型。DN1...DN4DN_1...DN_4DN1​...DN4​分别为第NNN个菜品的第111种到第444种食材
输出描述
菜品选择的所有方式列表，列表优先按照全荤菜品名升序排序，其次半荤菜品名升序排序，再次兼菜品名升序
排序
每行格式:全荤菜品名 半荤菜品名 素菜品名
无法选择请输出−1-1−1
样例1
输入
1
1 1 1 2 3 4

输出
-1

说明
仅有111个菜，无法按要求挑选
样例2
输入
6
2 2 5 6 7 8
3 3 9 10 11 12
4 2 1 2 3 0
5 1 5 0 7 8
1 1 1 2 3 4
6 1 1 2 3 4

输出
1 2 3
5 4 3
6 2 3

说明
总共有666种菜品。
菜品名222，半荤，食材5、6、7、85、6、7、85、6、7、8
菜品名333，素，食材9、10、11、129、10、11、129、10、11、12
菜品名444，半荤，食材1、2、31、2、31、2、3
菜品名555，全荤，食材5、7、85、7、85、7、8
菜品名111，全荤，食材1、2、3、41、2、3、41、2、3、4
菜品名666，全荤，食材1、2、3、41、2、3、41、2、3、4
菜品1、菜品4、菜品6食材有相同的部分，不能同时选择。
菜品2和菜品5食材有相同的部分，不能同时选择。
可选择的方式有5+4+3,1+2+3,6+2+35+4+3,1+2+3,6+2+35+4+3,1+2+3,6+2+3  333种。且根据升序排序要求输出
1 2 31\ 2\ 31 2 3
5 4 35\ 4\ 35 4 3
6 2 36\ 2\ 36 2 3
样例3
输入
4
1 1 1 2 3 4
2 2 5 6 7 8
3 3 9 10 11 12
4 2 13 14 15 16

输出
1 2 3
1 4 3

说明
总共有444种菜品
菜品名111，全荤，食材1、2、3、41、2、3、41、2、3、4
菜品名222，半荤，食材5、6、7、85、6、7、85、6、7、8
菜品名333，素，食材9、10、11、129、10、11、129、10、11、12
菜品名444，半荤，食材13、14、15、1613、14、15、1613、14、15、16
由于食材都不重复。
可选择的方式有1+2+3,1+4+31+2+3,1+4+31+2+3,1+4+3    222种
提示
由于中餐的博大精深。
同样的食材选择可做出不同的菜品。但同一个菜品名一定是同样的食材

#### TextSol

解题思路
你要在食堂的菜品中各选出一份
全票菜（type=1）、半票菜（type=2）、素菜（type=3），
要求这三份菜里出现的食材编号不能有重复。每个菜最多 4 种食材，0 表示没有食材。
输入给出了 N 个菜：
ID, T, D1, D2, D3, D4

ID 为菜品编号
T 为菜品类型 1/2/3
D1..D4 为这道菜的食材编号（>0 有效，0 表示空）

输出：所有满足要求的三菜组合列表，每行
全票菜ID 半票菜ID 素菜ID
排序规则为：

先按全票菜 ID 升序
若相同，再按半票菜 ID 升序
若还相同，再按素菜 ID 升序
若不存在任何合法组合，输出 -1。

核心算法（暴力枚举 + 分类）

读入所有菜品，按类型分成三组：full（全票）、half（半票）、veg（素菜）。

对每个菜，只保留非 0 的食材，存成一个小数组 / 向量。

暴力枚举三重循环：

枚举全票菜 F
枚举半票菜 H
枚举素菜 V

对当前三道菜，检查食材是否两两有交集：

写一个函数 share(A, B)，如果两菜的任意一个食材编号相同，则返回 true。

组合合法当且仅当：

!share(F, H) && !share(F, V) && !share(H, V)

对于每个合法组合，把 (F.id, H.id, V.id) 加入答案数组。

对答案数组按字典序排序（即按上面的三重关键字排序）。

按顺序输出所有组合；若数组为空，输出 -1。

由于每道菜最多 4 个食材，检查两菜是否冲突最多比较 16 次，常数很小，直接暴力足够。
复杂度分析
设全票菜数量为 A，半票菜数量为 B，素菜数量为 C，总菜数 N ≤ 100。

三重枚举：O(A * B * C)，最坏情况下 A, B, C 都是 O(N)，复杂度 O(N^3)。
每次冲突检查是常数级（最多 16 次比较）。

所以总体时间复杂度 O(N^3)（这里 N ≤ 100，可以轻松通过）。
空间复杂度：只存菜品和所有答案，都是 O(N + 答案数量)，在数据范围内完全可行。
代码实现
Python
import sys

# 菜品结构：id, type, ingredients(只保存非0食材)
class Dish:
def __init__(self, did, tp, ing):
self.id = did
self.tp = tp
self.ing = ing

# 判断两道菜是否有相同食材
def share(d1, d2):
for x in d1.ing:
for y in d2.ing:
if x == y:
return True
return False

# 核心功能：返回所有合法组合 (fid, hid, vid)
def solve(dishes):
full = []
half = []
veg = []

# 按类型分类
for d in dishes:
if d.tp == 1:
full.append(d)
elif d.tp == 2:
half.append(d)
elif d.tp == 3:
veg.append(d)

res = []

# 三重枚举所有组合
for f in full:
for h in half:
if share(f, h):  # 先剪枝：全票与半票冲突则跳过
continue
for v in veg:
# 三两两不冲突才是合法组合
if share(f, v) or share(h, v):
continue
res.append((f.id, h.id, v.id))

# 按 (全票ID, 半票ID, 素菜ID) 升序排序
res.sort()
return res

def main():
data = list(map(int, sys.stdin.read().split()))
if not data:
return
it = iter(data)

n = next(it)
dishes = []

# 读取所有菜品
for _ in range(n):
did = next(it)
tp = next(it)
tmp_ing = [next(it) for _ in range(4)]
ing = [x for x in tmp_ing if x > 0]  # 去掉为0的占位
dishes.append(Dish(did, tp, ing))

ans = solve(dishes)

out_lines = []
if not ans:
out_lines.append("-1\n")
else:
for fid, hid, vid in ans:
out_lines.append(f"{fid} {hid} {vid}\n")

sys.stdout.write("".join(out_lines))

if __name__ == "__main__":
main()

Java
import java.util.*;

// ACM 风格主类
public class Main {

// 菜品结构
static class Dish {
int id;         // 菜品编号
int type;       // 菜品类型 1/2/3
int[] ing;      // 有效食材列表（不含0）

Dish(int id, int type, int[] ing) {
this.id = id;
this.type = type;
this.ing = ing;
}
}

// 判断两道菜是否有相同食材
static boolean share(Dish a, Dish b) {
for (int x : a.ing) {
for (int y : b.ing) {
if (x == y) {
return true;
}
}
}
return false;
}

// 核心功能：返回所有合法组合
static List<int[]> solve(List<Dish> dishes) {
List<Dish> full = new ArrayList<>();
List<Dish> half = new ArrayList<>();
List<Dish> veg = new ArrayList<>();

// 按类型分类
for (Dish d : dishes) {
if (d.type == 1) {
full.add(d);
} else if (d.type == 2) {
half.add(d);
} else if (d.type == 3) {
veg.add(d);
}
}

List<int[]> res = new ArrayList<>();

// 三重枚举所有组合
for (Dish f : full) {
for (Dish h : half) {
if (share(f, h)) { // 先检查这两道菜
continue;
}
for (Dish v : veg) {
if (share(f, v) || share(h, v)) {
continue;
}
res.add(new int[]{f.id, h.id, v.id});
}
}
}

// 按 (全票ID, 半票ID, 素菜ID) 排序
Collections.sort(res, new Comparator<int[]>() {
@Override
public int compare(int[] a, int[] b) {
if (a[0] != b[0]) {
return a[0] - b[0];
}
if (a[1] != b[1]) {
return a[1] - b[1];
}
return a[2] - b[2];
}
});

return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

if (!sc.hasNextInt()) {
return; // 无输入直接结束
}

int n = sc.nextInt();
List<Dish> dishes = new ArrayList<>();

// 读取n个菜品
for (int i = 0; i < n; i++) {
int id = sc.nextInt();
int type = sc.nextInt();
int[] tmp = new int[4];
for (int j = 0; j < 4; j++) {
tmp[j] = sc.nextInt();
}
// 过滤掉0，只保留真正的食材
int cnt = 0;
for (int x : tmp) {
if (x > 0) {
cnt++;
}
}
int[] ing = new int[cnt];
int idx = 0;
for (int x : tmp) {
if (x > 0) {
ing[idx++] = x;
}
}
dishes.add(new Dish(id, type, ing));
}

List<int[]> ans = solve(dishes);

if (ans.isEmpty()) {
System.out.println("-1");
} else {
for (int[] arr : ans) {
System.out.println(arr[0] + " " + arr[1] + " " + arr[2]);
}
}

sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 菜品结构体
struct Dish {
int id;                 // 菜品编号
int type;               // 菜品类型 1/2/3
vector<int> ing;        // 食材列表（不含0）
};

// 判断两道菜是否有相同食材
bool share(const Dish &a, const Dish &b) {
for (int x : a.ing) {
for (int y : b.ing) {
if (x == y) return true;
}
}
return false;
}

// 核心功能：返回所有合法组合
vector<tuple<int,int,int>> solve(const vector<Dish> &dishes) {
vector<Dish> full, half, veg;

// 按类型分类
for (const auto &d : dishes) {
if (d.type == 1) full.push_back(d);
else if (d.type == 2) half.push_back(d);
else if (d.type == 3) veg.push_back(d);
}

vector<tuple<int,int,int>> res;

// 三重枚举所有组合
for (const auto &f : full) {
for (const auto &h : half) {
if (share(f, h)) continue; // 先剪枝
for (const auto &v : veg) {
if (share(f, v) || share(h, v)) continue;
res.emplace_back(f.id, h.id, v.id);
}
}
}

// 默认按 (first, second, third) 字典序排序
sort(res.begin(), res.end());
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
if (!(cin >> n)) {
return 0; // 无输入
}

vector<Dish> dishes;
dishes.reserve(n);

// 读取所有菜品
for (int i = 0; i < n; ++i) {
int id, type;
cin >> id >> type;
vector<int> ing;
for (int j = 0; j < 4; ++j) {
int x;
cin >> x;
if (x > 0) ing.push_back(x); // 丢弃0
}
dishes.push_back(Dish{id, type, ing});
}

vector<tuple<int,int,int>> ans = solve(dishes);

if (ans.empty()) {
cout << -1 << "\n";
} else {
for (auto &t : ans) {
int fid, hid, vid;
tie(fid, hid, vid) = t;
cout << fid << " " << hid << " " << vid << "\n";
}
}

return 0;
}

---

### 第3题-带Padding的卷积计算（P4482）
- 链接：https://codefun2000.com/p/P4482

> 页面标题：#P4482. 第3题-带Padding的卷积计算

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

卷积计算是人工智应用的常见计算操作，在深度学习中，卷积一般使用无核翻转的方式，通过如下公式计算:
$(S \cdot K)(i, j)-\sum_{m} \sum_{n} S(i+m, j+n) \cdot K(m, n)$
其中:
SSS 是输入图像(或二维信号)
KKK 是卷积核(或滤波器)
(i,j)(i,j)(i,j) 是输出图像的坐标
(m,n)(m,n)(m,n) 是卷积核的坐标
所谓 PaddingPaddingPadding 是根据卷积的尺寸，在输入图像外围填充若干圈 000 ，确保卷积计算后的辅出数据尺寸与原始输入一致。
如：

输入描述
第一行 为输入卷积尺寸 m∗mm*mm∗m 和图像尺寸 n∗nn*nn∗n，mmm 为大于 111 的奇数，nnn 为大于 111 的整数
然后是卷积矩阵数据，共 mmm 行，每行为卷积核的某一行，值的取值范围 [−10,10][-10,10][−10,10] 整数
最后是图像数据，共 nnn 行，每行为图像数据的某一行，值的取值范围 [0,255][0,255][0,255] 整数

如：

3 3
1 0 -1
1 0 -1
1 0 -1
1 2 3
4 5 6
7 8 9

输出描述
输出为带 paddingpaddingpadding 卷积操作后结果数据，大小为输入图像的尺寸 n∗nn*nn∗n ，如：

-7 -4 7
-15 -6 15
-13 -4 13

样例1
输入
3 5
-5 4 0
0 -3 -2
3 2 0
231 112 85 120 114
154 237 168 55 35
203 204 160 70 7
194 32 36 99 181
64 185 251 30 115

输出
-609 430 552 26 -107
394 -737 98 440 -25
-13 -108 -965 -538 503
294 195 371 -366 -543
214 -1899 -829 -106 -119

样例2
输入
3 5
1 0 -1
1 0 -1
1 0 -1
3 2 5 4 8
1 8 2 4 1
3 7 5 2 9
8 2 1 4 3
1 5 7 2 8

输出
-10 -3 2 -2 8
-17 -5 7 -6 10
-17 4 7 -5 10
-14 -1 6 -7 8
-7 1 1 -3 6

#### TextSol

解题思路
本题要求实现二维卷积 + 零填充（padding），并且题面明确说明是“无核翻转”的卷积，本质上就是二维相关运算（cross-correlation）：
对每个输出像素 (i,j)(i,j)(i,j)，让卷积核以 (i,j)(i,j)(i,j) 为中心覆盖在原图上，做逐元素乘加；超出边界的位置视为 0（即在图像外层补零）。
设：

卷积核尺寸：m×mm \times mm×m，且 mmm 为奇数（方便居中）
图像尺寸：n×nn \times nn×n
核心公式（按题意“无核翻转”）：

$$(S * K)(i, j) = \sum_{u=0}^{m-1} \sum_{v=0}^{m-1} S'(i + u - t,\, j + v - t)\cdot K(u, v)$$其中：

t=m−12t = \frac{m-1}{2}t=2m−1​ 为卷积核“半径”，即中心偏移
S′S'S′ 为对原图 SSS 进行零填充后的概念扩展：索引越界时视为 0

在实现时有两种等价写法：

显式构造一个 (n+2t)×(n+2t)(n+2t) \times (n+2t)(n+2t)×(n+2t) 的新数组，把原图放在中间，其余补 0，再做普通卷积。
不新建数组，在计算时判断坐标是否越界，越界就跳过（视为 0）。

为了节省空间，本题更适合使用方法 2：
对每个输出位置 (i,j)(i,j)(i,j)：

初始化 sum = 0

枚举卷积核坐标 (u, v)，范围 0 .. m-1

将其映射到图像坐标：

x = i + u - t
y = j + v - t

若 0 <= x < n 且 0 <= y < n，则 sum += image[x][y] * kernel[u][v]

最后 ans[i][j] = sum

按行输出结果即可。
代码实现
Python 实现
import sys

# 卷积函数，输入核 kernel 和图像 img，返回卷积结果
def convolve2d(kernel, img):
m = len(kernel)          # 卷积核大小 m
n = len(img)             # 图像大小 n
t = m // 2               # 核的半径 (padding 策略使用)

# 初始化结果矩阵
res = [[0] * n for _ in range(n)]

# 遍历每一个输出像素 (i, j)
for i in range(n):
for j in range(n):
s = 0
# 遍历卷积核 (u, v)
for u in range(m):
for v in range(m):
x = i + u - t   # 映射到图像中的行坐标
y = j + v - t   # 映射到图像中的列坐标
# 判断是否在原图范围内，越界视为 0
if 0 <= x < n and 0 <= y < n:
s += img[x][y] * kernel[u][v]
res[i][j] = s
return res

def main():
data = list(map(int, sys.stdin.read().split()))
# 读入 m, n
m, n = data[0], data[1]
idx = 2

# 读入卷积核 m 行，每行 m 个数
kernel = []
for _ in range(m):
row = data[idx:idx + m]
idx += m
kernel.append(row)

# 读入图像 n 行，每行 n 个数
img = []
for _ in range(n):
row = data[idx:idx + n]
idx += n
img.append(row)

# 进行卷积计算
res = convolve2d(kernel, img)

# 按题目要求输出，行内用空格分隔
out_lines = []
for i in range(n):
out_lines.append(" ".join(str(x) for x in res[i]))
sys.stdout.write("\n".join(out_lines))

if __name__ == "__main__":
main()

Java 实现
import java.util.Scanner;

public class Main {

// 卷积函数，输入核 kernel 和图像 img，返回卷积结果
public static int[][] convolve2d(int[][] kernel, int[][] img) {
int m = kernel.length;     // 卷积核大小
int n = img.length;        // 图像大小
int t = m / 2;             // 核半径

int[][] res = new int[n][n];   // 结果矩阵

// 遍历输出矩阵中的每个位置
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
int sum = 0;
// 遍历卷积核
for (int u = 0; u < m; u++) {
for (int v = 0; v < m; v++) {
int x = i + u - t;  // 映射到图像行坐标
int y = j + v - t;  // 映射到图像列坐标
// 如果在图像范围内则累加
if (x >= 0 && x < n && y >= 0 && y < n) {
sum += img[x][y] * kernel[u][v];
}
}
}
res[i][j] = sum;
}
}

return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读入 m, n
int m = sc.nextInt();
int n = sc.nextInt();

// 读入卷积核
int[][] kernel = new int[m][m];
for (int i = 0; i < m; i++) {
for (int j = 0; j < m; j++) {
kernel[i][j] = sc.nextInt();
}
}

// 读入图像
int[][] img = new int[n][n];
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
img[i][j] = sc.nextInt();
}
}

// 进行卷积
int[][] res = convolve2d(kernel, img);

// 输出结果
StringBuilder sb = new StringBuilder();
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (j > 0) sb.append(' ');
sb.append(res[i][j]);
}
if (i < n - 1) sb.append('\n');
}
System.out.print(sb.toString());

sc.close();
}
}

C++ 实现
#include <iostream>
#include <vector>
using namespace std;

// 卷积函数，输入核 kernel 和图像 img，返回卷积结果
vector<vector<long long>> convolve2d(const vector<vector<long long>>& kernel,
const vector<vector<long long>>& img) {
int m = (int)kernel.size();    // 卷积核大小
int n = (int)img.size();       // 图像大小
int t = m / 2;                 // 核半径

vector<vector<long long>> res(n, vector<long long>(n, 0));

// 遍历每一个输出位置 (i, j)
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
long long sum = 0;
// 遍历卷积核 (u, v)
for (int u = 0; u < m; ++u) {
for (int v = 0; v < m; ++v) {
int x = i + u - t; // 映射到图像行坐标
int y = j + v - t; // 映射到图像列坐标
// 判断是否在图像范围内部，越界视为 0
if (x >= 0 && x < n && y >= 0 && y < n) {
sum += img[x][y] * kernel[u][v];
}
}
}
res[i][j] = sum;
}
}

return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m, n;
// 读入 m, n
if (!(cin >> m >> n)) {
return 0;
}

// 读入卷积核
vector<vector<long long>> kernel(m, vector<long long>(m));
for (int i = 0; i < m; ++i) {
for (int j = 0; j < m; ++j) {
cin >> kernel[i][j];
}
}

// 读入图像
vector<vector<long long>> img(n, vector<long long>(n));
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
cin >> img[i][j];
}
}

// 进行卷积
vector<vector<long long>> res = convolve2d(kernel, img);

// 输出结果
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
if (j > 0) cout << ' ';
cout << res[i][j];
}
if (i + 1 < n) cout << '\n';
}

return 0;
}

---

### 第3题-查找最短可对称分割子数组（P4479）
- 链接：https://codefun2000.com/p/P4479

> 页面标题：#P4479. 第3题-查找最短可对称分割子数组

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

已知数组 AAA，数组 AAA 内元素为带符号整数，希望在该数组内找到满足如下条件的子数组：
子数组可分为两个连续的子子数组，这两个子子数组长度可互不相同，但他们的元素和都为零
即满足对于子数组区间 [i,j)[i,j)[i,j), 存在中同元素 k(i<k<j)k(i<k<j)k(i<k<j), 使得 ∑[i,k)==∑[k,j)==0\sum [i,k) == \sum [k,j)==0∑[i,k)==∑[k,j)==0 ；
希望你找出所有满足上述条件数组中的长度最短的子数组。
输入描述
输入由两行组成:第一行包含一个数字 NNN ，代表数组的元素数量
第二行包含 NNN 个数字 Xi(0<=1<N)X_i(0<=1<N)Xi​(0<=1<N)，代表数组的元素内容
输入约束：
1.1<=N<=1061 <= N <= 10^61<=N<=106
2.−10000<=Xi<=10000-10000 <= X_i <= 10000−10000<=Xi​<=10000
输出描述
输出满足条件数组的最短长度 以及 该类数组的个数
如果不存在，分别输出 −1-1−1 和 −1-1−1
样例1
输入
5
1 -1 1 -1 1

输出
4 2

说明
注意同一个元素是允许出现再多个不同的子数组中的
本例子中有两种子数组分割方法
方案 111 : [1[1[1 −1][1-1] [1−1][1 −1]-1]−1] 111
方案 222 : 111 [−1[-1[−1 1][−11][-11][−1 1]1]1]
样例2
输入
7
0 100 1 300 2 10 0

输出
-1 -1

说明
找不到满足要求的子数组
样例3
输入
7
100 1 -1 3 -2 100

输出
5 -1

说明
子数组 {111 −1-1−1 333 −2-2−2 −1-1−1} 满足条件
其可分为两个满足条件的子子数组 {111 −1-1−1} 和 {333 −2-2−2 −1-1−1}

#### TextSol

解题思路
已知一个长度为 N 的整数数组 A（有正有负），我们要在其中找若干子数组，使得：

这个子数组可以被分成左右两个连续的非空子数组；
左右两个子数组的元素和都为 0；
在所有满足条件的子数组里，找出“长度最长”的长度 L，并统计长度为 L 的这类子数组有多少个；
若不存在这样的子数组，则输出 -1 -1。

把子数组区间写成 [l, r]，中间分割点为 k（左闭右闭）：

左段：[l, k]，右段：[k+1, r]
要求：sum(l..k) = 0 且 sum(k+1..r) = 0

前缀和 + 分组
设前缀和数组 pre[i] 表示前 i 个元素之和（pre[0] = 0，pre[i] = a[0]+...+a[i-1]），则

sum(l..k) = pre[k+1] - pre[l]
sum(k+1..r) = pre[r+1] - pre[k+1]

要两段都为 0，即

pre[k+1] = pre[l]
pre[r+1] = pre[k+1]

所以有：pre[l] = pre[k+1] = pre[r+1]，并且下标满足 l < k+1 < r+1，也就是一组三个严格递增的前缀和下标，且值相同。
因此：
一个满足条件的子数组 [l, r] 等价于存在一个前缀和值 v，在它的所有出现位置中有三个下标 i < j < t，使得

i = l
t = r+1
pre[i] = pre[j] = pre[t] = v
子数组长度 len = r - l + 1 = t - i

于是我们只需要在前缀和中，按“值”把所有下标分组，然后在每一组中寻找三元组即可。
第一步：求全局最大长度
对前缀和中某个值 v，假设它出现的位置为有序数组
P = [p0, p1, ..., p(m-1)]（已按下标从小到大）
只要 m >= 3，就必然存在满足条件的子数组，并且：

对这个值 v 的所有合法子数组中，长度最长的一定是使用最左和最右两个下标：[p0, p(m-1) - 1]
其长度为 len_v_max = p(m-1) - p0

原因：任意合法子数组由一对 (pi, pj)（j >= i+2）决定，长度 pj - pi，最大差值显然就是最左和最右的差。
因此：

计算所有前缀和，把每个位置下标加入到 map[pre] 的向量里；
对于每个 pre 值的向量 P，若 len(P) >= 3，计算 P.back() - P.front()；
所有这样的值中取最大值，记为 maxLen；若始终没有 len(P) >= 3，则答案为 -1 -1。

第二步：统计最大长度的子数组个数
现在 maxLen 已知，对每种前缀和值 v 及其位置数组 P，需要统计满足：

pj - pi = maxLen
j >= i + 2（保证中间存在至少一个下标）

的有序对 (i, j) 的个数。
注意到 P 是升序的，因此可以用 双指针 在线性时间内完成统计：

固定右指针 j 从左到右遍历；

左指针 i 也从左往右移动，并保持：

当 pj - pi > maxLen 时，向右移动 i，直到 pj - pi <= maxLen；

对于当前 j，若 j >= i+2 且 pj - pi == maxLen，那么存在且只存在这一对 (i, j) 符合条件（因为 P 严格递增，差值为 maxLen 的 i 只有一个），于是总答案加一。

对所有 v 的位置数组做一次双指针，整体还是线性级别。
复杂度分析
设数组长度为 N：

计算前缀和并建表：O(N)
第一遍扫描所有分组求最大长度：总元素数为 N+1，为 O(N)
第二遍双指针统计个数：同样是对所有前缀位置做线性扫描，为 O(N)

总时间复杂度：O(N)
总空间复杂度：O(N)（存储前缀和分组的下标）
在 N <= 10^6 的范围内可以通过。
代码实现
Python
import sys
from collections import defaultdict

# 功能函数：根据数组 a 计算最长长度和个数
def solve(a):
n = len(a)
mp = defaultdict(list)  # key: 前缀和, value: 该前缀和出现的所有下标
prefix = 0
mp[prefix].append(0)  # pre[0] = 0，对应下标 0

# 构建前缀和分组
for i in range(1, n + 1):
prefix += a[i - 1]
mp[prefix].append(i)

# 第一次遍历：找出最大长度
max_len = -1
for positions in mp.values():
m = len(positions)
if m >= 3:
cur_len = positions[-1] - positions[0]
if cur_len > max_len:
max_len = cur_len

# 如果不存在满足条件的子数组
if max_len < 0:
return -1, -1

# 第二次遍历：统计长度为 max_len 的子数组个数
count = 0
for positions in mp.values():
m = len(positions)
if m < 3:
continue
i = 0  # 左指针
for j in range(m):  # 右指针
# 保证差值不超过 max_len
while i + 2 <= j and positions[j] - positions[i] > max_len:
i += 1
# j 至少比 i 大 2，才能保证中间有元素
if j >= i + 2 and positions[j] - positions[i] == max_len:
count += 1

return max_len, count

def main():
data = sys.stdin.read().strip().split()
if not data:
return
n = int(data[0])
a = list(map(int, data[1:1 + n]))

max_len, count = solve(a)
print(max_len, count)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

/**
* ACM 风格主类
*/
public class Main {

// 功能函数：根据数组 a 计算最长长度和个数
private static long[] solve(int[] a) {
int n = a.length;

// 使用 HashMap<Long, ArrayList<Integer>> 存储每个前缀和的所有下标
HashMap<Long, ArrayList<Integer>> map = new HashMap<>();
long prefix = 0L;

ArrayList<Integer> list0 = new ArrayList<>();
list0.add(0);
map.put(prefix, list0); // 前缀和 0 在下标 0 出现

for (int i = 1; i <= n; i++) {
prefix += a[i - 1];
ArrayList<Integer> pos = map.get(prefix);
if (pos == null) {
pos = new ArrayList<>();
map.put(prefix, pos);
}
pos.add(i);
}

long maxLen = -1;

// 第一次遍历：求最大长度
for (ArrayList<Integer> pos : map.values()) {
int m = pos.size();
if (m >= 3) {
long curLen = (long) pos.get(m - 1) - (long) pos.get(0);
if (curLen > maxLen) {
maxLen = curLen;
}
}
}

if (maxLen < 0) {
return new long[]{-1, -1};
}

long count = 0;

// 第二次遍历：用双指针统计长度为 maxLen 的个数
for (ArrayList<Integer> pos : map.values()) {
int m = pos.size();
if (m < 3) {
continue;
}
int i = 0; // 左指针
for (int j = 0; j < m; j++) { // 右指针
// 控制差值不超过 maxLen
while (i + 2 <= j &&
(long) pos.get(j) - (long) pos.get(i) > maxLen) {
i++;
}
// j 至少比 i 大 2，且差值等于 maxLen
if (j >= i + 2 &&
(long) pos.get(j) - (long) pos.get(i) == maxLen) {
count++;
}
}
}

return new long[]{maxLen, count};
}

// 快速输入类（根据数据范围使用）
private static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;

FastScanner(InputStream is) {
in = is;
}

private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}

int nextInt() throws IOException {
int c;
do {
c = read();
if (c == -1) return -1;
} while (c <= ' ');

int sign = 1;
if (c == '-') {
sign = -1;
c = read();
}

int val = 0;
while (c > ' ') {
val = val * 10 + (c - '0');
c = read();
}
return val * sign;
}
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);

int n = fs.nextInt();
if (n == -1) {
return;
}
int[] a = new int[n];
for (int i = 0; i < n; i++) {
a[i] = fs.nextInt();
}

long[] ans = solve(a);
System.out.println(ans[0] + " " + ans[1]);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 功能函数：根据数组 a 计算最长长度和个数
pair<long long, long long> solve(const vector<int> &a) {
int n = (int)a.size();

// 使用 unordered_map<long long, vector<int>> 存储每个前缀和的所有下标
unordered_map<long long, vector<int>> mp;
mp.reserve(n * 2);          // 预留空间，减少扩容
mp.max_load_factor(0.7f);   // 降低装载因子，提高性能

long long prefix = 0;
mp[prefix].push_back(0);    // 前缀和 0 在下标 0 出现

for (int i = 1; i <= n; ++i) {
prefix += a[i - 1];
mp[prefix].push_back(i);
}

long long maxLen = -1;

// 第一次遍历：求最大长度
for (auto &kv : mp) {
const vector<int> &pos = kv.second;
int m = (int)pos.size();
if (m >= 3) {
long long curLen = (long long)pos[m - 1] - (long long)pos[0];
if (curLen > maxLen) {
maxLen = curLen;
}
}
}

if (maxLen < 0) {
return {-1, -1};
}

long long count = 0;

// 第二次遍历：用双指针统计长度为 maxLen 的子数组个数
for (auto &kv : mp) {
const vector<int> &pos = kv.second;
int m = (int)pos.size();
if (m < 3) continue;

int i = 0; // 左指针
for (int j = 0; j < m; ++j) { // 右指针
// 保证差值不超过 maxLen
while (i + 2 <= j &&
(long long)pos[j] - (long long)pos[i] > maxLen) {
++i;
}
// 需要 j 至少比 i 大 2，并且差值等于 maxLen
if (j >= i + 2 &&
(long long)pos[j] - (long long)pos[i] == maxLen) {
++count;
}
}
}

return {maxLen, count};
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
if (!(cin >> n)) {
return 0;
}
vector<int> a(n);
for (int i = 0; i < n; ++i) {
cin >> a[i];
}

auto ans = solve(a);
cout << ans.first << " " << ans.second << "\n";

return 0;
}

---

## 2025年11月19日-AI方向

### 第2题-终端款型聚类识别（P4475）
- 链接：https://codefun2000.com/p/P4475

> 页面标题：#P4475. 第2题-终端款型聚类识别

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某部门需要对终端的漫游业务体验进行保障，不同的终端对于网络的配置要求不同。现在需要通过终端的网络流量等特征，识别该终端的型号是什么。
通过包间隔时长、连接持续时长、漫游前信号强度及漫游后信号强度 444 个特征，对终端的型号进行聚类。已知终端型号类别为 KKK 类，采用 KmeansKmeansKmeans 算法进行聚类，识别终端类型，并输出各类型终端数量。
KmeansKmeansKmeans 算法说明:
初始化: kkk 个初始质心
分配:将每个数据点分配到距离最近的质心，形成 kkk 个簇。其中距离需要根据数据类型选择上文给定的度量方式
更新:用簇内所有点的均值，重新计算每个簇的质心
迭代:重复步骤 222 和 333 ，直到质心不再发生变化(质心移动值小于 10−810^{-8}10−8 )或达到最大迭代次数
本题说明:
1、给定数据集中，默认 KKK 类终端都存在，不存在某款型终端个数为 000 的场景;
2、为消除不同特征权重问题，给出数据均已做好归一化处理，并保留两位小数;
3、为消除随机性，初始 kkk 个质心统一采用给定数据集前 kkk 个点;
4、距离函数定义为: $d_{x, y}=\sqrt{\sum_{k=1}^{4}\left(x_{k}-y_{k}\right)^{2}}$
输入描述
第 111 行: kkk mmm nnn : kkk 代表终端款型聚类个数，mmm 代表终端数量，nnn 代表迭代次数;
第 222 行 ~ 第 m+1m+1m+1 行:每一行 444 列，分别代表某个终端的包间隔时长、连接持续时长、漫游前信号强度及漫游后信号强度 444 个变量
输出描述
输出 kkk 款终端数量，从小到大排序。
样例1
输入
3 20 1000
0.11 0.79 0.68 0.97
1.0 0.8 0.13 0.33
0.27 0.02 0.5 0.46
0.83 0.29 0.23 0.75
0.97 0.08 0.84 0.55
0.29 0.71 0.17 0.83
0.03 0.6 0.88 0.28
0.24 0.26 0.82 0.03
0.96 0.12 0.82 0.36
0.13 0.12 0.86 0.44
0.23 0.7 0.35 0.06
0.42 0.49 0.67 0.84
0.8 0.49 0.47 0.7
0.68 0.03 0.11 0.07
0.77 0.19 0.95 0.44
0.25 0.12 0.98 0.04
0.7 0.11 0.53 0.3
0.73 0.67 0.46 0.96
0.11 0.31 0.91 0.57
0.43 0.61 0.13 0.1

输出
4 6 10

说明
输入: 202020 个终端，其中包含 333 种款式，用 KmeansKmeansKmeans 算法最高选代 100010001000 次计算每款终端个数
输出: 333 款终端数量从小到大排序为 444 666 101010
样例2
输入
4 32 800
0.73 0.96 0.2 0.53
0.01 0.19 0.42 0.46
0.27 0.24 0.87 0.8
0.97 0.77 0.42 0.04
0.41 0.69 0.96 0.56
0.27 0.4 0.56 0.56
0.28 0.04 0.74 0.82
0.17 0.2 0.95 0.1
0.2 0.1 0.14 0.93
0.86 0.59 0.42 0.52
0.35 0.77 0.37 0.08
0.52 0.48 0.16 0.56
0.59 0.97 0.21 0.05
0.67 0.94 0.28 0.08
0.09 0.65 0.55 1.0
0.77 0.14 0.35 0.01
0.02 0.18 0.72 0.26
0.71 0.78 0.86 0.11
0.54 0.02 0.75 0.2
0.15 0.76 0.59 0.23
0.71 0.66 0.43 0.32
0.17 0.57 0.53 0.42
0.04 0.34 0.66 0.28
0.79 0.14 0.11 0.6
0.04 0.48 0.05 0.04
0.62 0.43 0.28 0.6
0.47 0.13 0.35 0.17
0.9 0.82 0.97 0.71
0.99 0.53 0.24 0.56
0.83 0.44 0.7 0.4
0.71 0.45 0.64 0.53
0.6 0.54 0.86 0.11

输出
6 8 9 9

说明
输入: 323232 个终端，其中包含 444 种款式，用 KmeansKmeansKmeans 算法最高迭代 800800800 次计算每款终端个数
输出: 444 款终端数量从小到大排序为 689968996899

#### TextSol

解题思路
本题本质是一个典型的 KMeans 聚类 问题：给定每个终端的 4 维特征（包间隔时长、连接持续时长、漫游前信号强度、漫游后信号强度），将这些终端划分成 K 个簇，每个簇对应一种终端款型，最后输出每个簇中终端数量（从小到大排序）。
1. KMeans 算法回顾与本题设定
KMeans 的标准流程为：

初始化质心

从数据集中选择 K 个点作为初始质心。
本题明确要求：初始化质心使用数据集中前 k 个点。

分配（Assignment）

对每个样本点，计算其到所有质心的距离，将该点分配给最近的质心所属的簇。

距离定义为 4 维欧氏距离：
d(x,y)=∑i=14(xi−yi)2d(x,y)=\sqrt{\sum_{i=1}^4 (x_i-y_i)^2}
d(x,y)=i=1∑4​(xi​−yi​)2​

实现时可直接用 平方距离（去掉根号），比较大小结果相同，少一次 sqrt，更高效：
d2(x,y)=∑i=14(xi−yi)2d^2(x,y)=\sum_{i=1}^4 (x_i-y_i)^2
d2(x,y)=i=1∑4​(xi​−yi​)2

更新质心（Update）

对每个簇，计算簇内所有样本的 4 维特征均值，将其作为新的质心：
μj=1∣Cj∣∑x∈Cjx\mu_j = \frac{1}{|C_j|}\sum_{x \in C_j} x
μj​=∣Cj​∣1​x∈Cj​∑​x

迭代与收敛条件

重复“分配 + 更新”步骤，直到：

质心移动距离足够小（本题要求：质心移动值 < 10−810^{-8}10−8），或
达到给定的最大迭代次数 n。

具体实现中，我们可以对每个质心计算新旧质心的平方距离，取所有质心中 最大移动量：
$$\text{move}_j = \sum_{i=1}^4(\mu_{j,i}^{\text{new}} - \mu_{j,i}^{\text{old}})^2$$若所有质心的最大移动量 < 10−810^{-8}10−8，则认为收敛。

空簇问题的处理

理论上，KMeans 可能会出现某个簇为空的情况。

本题说明中给出：数据集中 默认 K 类终端都存在。
但在迭代过程中仍有极小概率产生空簇，因此实现时可以做一个稳健处理：

若某个簇在当前分配中没有任何点（数量为 0），则 保持该簇的质心不变，避免除零错误。

最终输出

算法停止后，我们已经有每个终端的簇归属，统计每个簇内终端数量，得到长度为 K 的数组。
按题意要求，将这 K 个数量 从小到大排序，用空格分隔输出。

2. 实现要点

读入数据

第 1 行：k m n

k：簇的个数（终端款型数）
m：样本个数（终端数）
n：最大迭代次数

接下来 m 行，每行 4 个浮点数，表示该终端的 4 维特征（已归一化，保留两位小数）。

数据结构设计

points[m][4]：保存所有终端的 4 维特征。
centroids[k][4]：当前 k 个质心。
assign[m]：每个终端所属的簇编号（0 ~ k-1）。
clusterSize[k]：每个簇中点的个数。
sum[k][4]：每个簇中各维度特征之和，用于计算新质心。

初始化

centroids[i] = points[i] 对于 i ∈ [0, k-1]。

每次迭代流程

将 clusterSize 和 sum 清零。

遍历每个点：

依次计算该点到每个质心的 平方距离，找到最小值对应的簇 j。
assign[i] = j，clusterSize[j]++，并将当前点特征累加到 sum[j] 中。

使用 sum 和 clusterSize 更新每个质心：

若 clusterSize[j] > 0：

新质心 = sum[j][d] / clusterSize[j]。

若 clusterSize[j] == 0：

保持原质心不变。

同时在更新时，计算新旧质心之间的最大移动距离，用于判断收敛。

结束后统计结果

上一轮分配的 clusterSize 即为最终每个簇的点数。
将 clusterSize 拷贝到数组，排序，然后输出。

代码实现
Python 实现
import sys
import math

# 计算两点之间的平方欧氏距离（4 维）
def dist2(a, b):
s = 0.0
for i in range(4):
diff = a[i] - b[i]
s += diff * diff
return s

def kmeans(points, k, max_iter):
m = len(points)
# 初始化质心：前 k 个点
centroids = [points[i][:] for i in range(k)]
assign = [0] * m
cluster_size = [0] * k

for _ in range(max_iter):
# 分配步骤
for j in range(k):
cluster_size[j] = 0
sums = [[0.0] * 4 for _ in range(k)]

for i in range(m):
# 找到最近质心
best_idx = 0
best_dist = dist2(points[i], centroids[0])
for j in range(1, k):
d = dist2(points[i], centroids[j])
if d < best_dist:
best_dist = d
best_idx = j
assign[i] = best_idx
cluster_size[best_idx] += 1
# 累加簇内点特征
for t in range(4):
sums[best_idx][t] += points[i][t]

# 更新质心
max_move = 0.0
for j in range(k):
if cluster_size[j] > 0:
new_centroid = [sums[j][t] / cluster_size[j] for t in range(4)]
else:
# 若该簇为空，保持旧质心不变
new_centroid = centroids[j][:]

# 计算质心移动距离（平方）
move = dist2(centroids[j], new_centroid)
if move > max_move:
max_move = move
centroids[j] = new_centroid

# 收敛判断：最大质心移动小于 1e-8
if max_move < 1e-8:
break

# cluster_size 即为各簇最终数量
return cluster_size

def main():
data = sys.stdin.read().strip().split()
if not data:
return
k = int(data[0])
m = int(data[1])
max_iter = int(data[2])

points = []
idx = 3
for _ in range(m):
# 依次读入 4 个浮点数
row = list(map(float, data[idx:idx+4]))
idx += 4
points.append(row)

sizes = kmeans(points, k, max_iter)
sizes.sort()
print(" ".join(str(x) for x in sizes))

if __name__ == "__main__":
main()

Java 实现
import java.util.*;

// ACM 模式，主类名必须为 Main
public class Main {

// 计算两个 4 维点的平方欧氏距离
private static double dist2(double[] a, double[] b) {
double s = 0.0;
for (int i = 0; i < 4; i++) {
double diff = a[i] - b[i];
s += diff * diff;
}
return s;
}

// KMeans 聚类主函数
private static int[] kmeans(double[][] points, int k, int maxIter) {
int m = points.length;
double[][] centroids = new double[k][4];
int[] assign = new int[m];
int[] clusterSize = new int[k];

// 初始化质心：前 k 个点
for (int i = 0; i < k; i++) {
for (int d = 0; d < 4; d++) {
centroids[i][d] = points[i][d];
}
}

// 迭代
for (int it = 0; it < maxIter; it++) {
// 清空簇大小
for (int j = 0; j < k; j++) {
clusterSize[j] = 0;
}
// sums 用来累加每个簇的特征和
double[][] sums = new double[k][4];

// 分配每个点到最近的质心
for (int i = 0; i < m; i++) {
double bestDist = dist2(points[i], centroids[0]);
int bestIdx = 0;
for (int j = 1; j < k; j++) {
double d = dist2(points[i], centroids[j]);
if (d < bestDist) {
bestDist = d;
bestIdx = j;
}
}
assign[i] = bestIdx;
clusterSize[bestIdx]++;
for (int d = 0; d < 4; d++) {
sums[bestIdx][d] += points[i][d];
}
}

// 更新质心并计算最大移动距离
double maxMove = 0.0;
for (int j = 0; j < k; j++) {
double[] newCentroid = new double[4];
if (clusterSize[j] > 0) {
for (int d = 0; d < 4; d++) {
newCentroid[d] = sums[j][d] / clusterSize[j];
}
} else {
// 若簇为空，质心保持不变
for (int d = 0; d < 4; d++) {
newCentroid[d] = centroids[j][d];
}
}
double move = dist2(centroids[j], newCentroid);
if (move > maxMove) {
maxMove = move;
}
centroids[j] = newCentroid;
}

// 收敛条件
if (maxMove < 1e-8) {
break;
}
}

// clusterSize 即为每个簇的终端数量
return clusterSize;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNext()) {
return;
}
int k = sc.nextInt();
int m = sc.nextInt();
int maxIter = sc.nextInt();

double[][] points = new double[m][4];
for (int i = 0; i < m; i++) {
for (int d = 0; d < 4; d++) {
points[i][d] = sc.nextDouble();
}
}

int[] sizes = kmeans(points, k, maxIter);
Arrays.sort(sizes);
StringBuilder sb = new StringBuilder();
for (int i = 0; i < sizes.length; i++) {
if (i > 0) sb.append(' ');
sb.append(sizes[i]);
}
System.out.println(sb.toString());
}
}

C++ 实现
#include <bits/stdc++.h>
using namespace std;

// 计算两个 4 维点的平方欧氏距离
double dist2(const array<double, 4>& a, const array<double, 4>& b) {
double s = 0.0;
for (int i = 0; i < 4; ++i) {
double diff = a[i] - b[i];
s += diff * diff;
}
return s;
}

// KMeans 聚类主函数
vector<int> kmeans(const vector<array<double, 4>>& points, int k, int maxIter) {
int m = (int)points.size();
vector<array<double, 4>> centroids(k);
vector<int> assign(m, 0);
vector<int> clusterSize(k, 0);

// 初始化质心：前 k 个点
for (int i = 0; i < k; ++i) {
centroids[i] = points[i];
}

for (int it = 0; it < maxIter; ++it) {
// 清空簇信息
fill(clusterSize.begin(), clusterSize.end(), 0);
vector<array<double, 4>> sums(k);
for (int j = 0; j < k; ++j) {
for (int d = 0; d < 4; ++d) {
sums[j][d] = 0.0;
}
}

// 分配每个点到最近质心
for (int i = 0; i < m; ++i) {
double bestDist = dist2(points[i], centroids[0]);
int bestIdx = 0;
for (int j = 1; j < k; ++j) {
double d = dist2(points[i], centroids[j]);
if (d < bestDist) {
bestDist = d;
bestIdx = j;
}
}
assign[i] = bestIdx;
clusterSize[bestIdx]++;
for (int d = 0; d < 4; ++d) {
sums[bestIdx][d] += points[i][d];
}
}

// 更新质心并计算最大移动量
double maxMove = 0.0;
for (int j = 0; j < k; ++j) {
array<double, 4> newCentroid;
if (clusterSize[j] > 0) {
for (int d = 0; d < 4; ++d) {
newCentroid[d] = sums[j][d] / clusterSize[j];
}
} else {
// 若簇为空，质心保持不变
newCentroid = centroids[j];
}
double move = dist2(centroids[j], newCentroid);
if (move > maxMove) {
maxMove = move;
}
centroids[j] = newCentroid;
}

// 收敛判断
if (maxMove < 1e-8) {
break;
}
}

// clusterSize 即为最终每个簇的数量
return clusterSize;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int k, m, maxIter;
if (!(cin >> k >> m >> maxIter)) {
return 0;
}

vector<array<double, 4>> points(m);
for (int i = 0; i < m; ++i) {
for (int d = 0; d < 4; ++d) {
cin >> points[i][d];
}
}

vector<int> sizes = kmeans(points, k, maxIter);
sort(sizes.begin(), sizes.end());
for (int i = 0; i < (int)sizes.size(); ++i) {
if (i > 0) cout << ' ';
cout << sizes[i];
}
cout << '\n';

return 0;
}

---

### 第3题-Prompt上下文信息精简:找出二叉树中的最大值子树（P4476）
- 链接：https://codefun2000.com/p/P4476

> 页面标题：#P4476. 第3题-Prompt上下文信息精简:找出二叉树中的最大值子树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

描述: PromptPromptPrompt 应用面临的一个首要问题就是 TokenTokenToken 的长度和精确度问题，如何精简 PromptPromptPrompt 的 tokentokentoken 长度一直是大模型应用中的难题。假设 PromptPromptPrompt 的 tokentokentoken 序列是一颗二叉树，给定这样一颗二叉树，该二叉树的每个节点都有一个值，可以是正负值，也可以是 000 ，请返回该二又树的最大值子树。每颗子树的值为该子树所有节点值的和。
注意:
输入和输出数据的格式要求:(1)二叉树是完全二叉树;(2)二叉树节点数据是通过宽度优先搜索遍历获取;(3)遍历出的二叉树节点数据是以一维数组的形式存储。(4)如果一颗二叉树的左节点不存在，就以 nullnullnull 补齐。
举例:如果节点 AAA 和 BBB 是兄弟节点，它们两个的父节点是 CCC ，AAA 无子节点，BBB 有子节点 DDD 和 EEE ，那么这棵树的数组为 tree=[C,A,B,null,null,D,E]tree=[C,A,B,null,null,D,E]tree=[C,A,B,null,null,D,E];如果 BBB 只有左子节点 DDD ，则 tree=[C,A,B,null,null,D]tree =[C,A,B,null,null,D]tree=[C,A,B,null,null,D] ; 如果 BBB 只有右子节点 EEE ,则 tree=[C,A,B,null,null,null,E]tree =[C,A,B,null,null,null,E]tree=[C,A,B,null,null,null,E];
示例1

输入:[3,2,5][3,2,5][3,2,5]
输出: [3,2,5][3,2,5][3,2,5]
示例2

输入: [−5,−1,3,null,null,4,7][-5,-1,3,null,null,4,7][−5,−1,3,null,null,4,7]
输出: [3,4,7][3,4,7][3,4,7]
示例3

输入: [5,−1,3,null,null,4,7][5,-1,3,null,null,4,7][5,−1,3,null,null,4,7]
输出: [5,null,3,null,null,4,7][5,null,3,null,null,4,7][5,null,3,null,null,4,7]
输入描述
输入:二叉树是一颗完全二叉树，节点数据是通过宽度优先搜索遍历的，以一维数组结构表示，nullnullnull 代表为空的叶子节点。
以示例 222 为例，输入为 [−5,−1,3,null,null,4,7][-5,-1,3,null,null,4,7][−5,−1,3,null,null,4,7]，−1-1−1 节点虽然是叶子节点，但在完全二叉树中需要明确它的两个子节点，这两个子节点为 nullnullnull 。
输出描述
输出:输出最大值子树，也以宽度优先搜索完全二叉树后的数组结构表示的方式作为输出。
以示例 222 为例，由于 [−5,−1,3][-5,-1,3][−5,−1,3] 该子树为负值，不应当与子树 [3,4,7][3,4,7][3,4,7] 合一起，所以 [3,4,7][3,4,7][3,4,7] 是最大子树。
以示例 333 为例，最大值子树是 [5,null,3,null,null,4,7][5,null,3,null,null,4,7][5,null,3,null,null,4,7]，根节点 555 的所有左子树节点用 nullnullnull 补
齐。
样例1
输入
[-5,-1,3,null,null,4,7]

输出
[3,4,7]

说明
最大子树 max−sub−treemax-sub-treemax−sub−tree 是 [3,4,7][3,4,7][3,4,7]
样例2
输入
[-1,null,1,null,null,-1,-1,null,null,null,null,2,1,-3,-1,null,null,null,null,null,null,null,null,2,1,3,8]

输出
[1,-1,null,2,1,null,null,2,1,3,8]

说明
最大子树 max−sub−treemax-sub-treemax−sub−tree 是 [1,−1,null,2,1,null,null,2,1,3,8][1,-1,null,2,1,null,null,2,1,3,8][1,−1,null,2,1,null,null,2,1,3,8]

#### TextSol

解题思路
题目里“子树”的定义：

可以在一棵树中选择任意一个结点作为“根”；

对于这个根的左右子树，我们可以选择保留或裁掉：

如果某个子树对总和的贡献 ≤ 0，就可以整个裁掉（不保留这一支）；
只保留“贡献为正”的子树分支；

目标：找到和最大的“裁剪后子树”，并输出这棵裁剪后的子树（仍然用完全二叉树层序数组表示，被裁掉的分支用 null，最后去掉末尾多余的 null）。

这本质上就是“在树上找最大权连通子图（允许剪枝）”，非常经典的写法是 树形 DP + 可选子树：
一、数组表示的二叉树结构
与之前相同，输入是一棵“完全二叉树”的一维数组：

根：下标 0
左子：2 * i + 1
右子：2 * i + 2
null 表示该位置没有结点（空）

我们仍然先解析出：

vals[i]：结点值（对于 null，值随便填，反正不用）
valid[i]：该位置是否是一个真实结点（非 null）

二、核心 DP：允许裁剪子树的最大和
对每个真实结点 i，定义：

dp[i] = 以 i 为根，在允许删掉任意“贡献 ≤ 0 的子树”的前提下，
能得到的 最大子树和

状态转移（自底向上，从 n-1 到 0）：

如果 i 不是有效结点（valid[i] == false），

我们不以它为根建树，dp[i] 记为 0 即可（不会被真正使用）。

如果 i 是有效结点：

左子下标：l = 2*i + 1

右子下标：r = 2*i + 2

左子贡献：

如果 l 在范围内且 valid[l] == true，则可用 dp[l]
否则为 0

右子贡献同理

当前根的最佳和：
$$dp[i] = vals[i]
+ \max(0, \text{leftDp})
+ \max(0, \text{rightDp})$$

这里的 max(0, dp[child]) 正是“如果这个子树贡献为正，就保留；否则就整个裁掉”的含义。

计算完 dp[i] 后，我们用它去更新全局最大值：

维护：

bestSum：当前所有结点中最大的 dp[i]
bestRoot：达到 bestSum 的下标 i

最终：

bestRoot 就是那棵“最大值裁剪子树”的根
和为 bestSum

注意：如果整棵树都是负数，
这个 DP 仍然会选出某个单个结点（值最大的那个）作为答案。

三、如何还原“被裁剪后的子树”结构
有了 bestRoot 和整棵树的 dp[]，要构造输出数组：

从 bestRoot 开始做 BFS（广度优先），队列中保存：

(原数组下标 originalIndex, 新树下标 newIndex)
新树也用完全二叉树规则：左子 2*newIndex+1，右子 2*newIndex+2

对于队头 (oi, ni)：

确保结果数组 res 的长度大于 ni，不够就用 null（None）补齐

设置 res[ni] = vals[oi]

然后处理原树中 oi 的左右孩子：

child = 2 * oi + 1（左）或 2 * oi + 2（右）

条件：

child 在数组范围内
valid[child] == true（是真实结点）
且 dp[child] > 0（说明这棵子树被保留下来）

满足条件则将 (child, 2*ni+1 或 2*ni+2) 入队

如果 dp[child] <= 0，表示这棵子树被“剪掉”，在新树对应位置将保持为 null。

BFS 完成后，res 中有若干 null：

中间的 null 是被剪掉的子树位置，必须保留
末尾连续的 null 是“完全二叉树填充”的冗余，需要按题意 从尾部删掉

这样就得到最终输出
四、小结
和“必须保留所有后代”的版本不同，这里：

DP 转移多了 max(0, 子树和)，允许剪掉坏分支；
仍然是 O(n) 的一次自底向上的 DP；
再配合 BFS + 剪枝条件 dp[child] > 0 来还原树结构。

复杂度分析
设数组长度为 n：

计算 dp[i]（自底向上）：每个下标访问一次，O(n)
BFS 还原最大子树：每个被保留结点最多被访问一次，O(n)
去掉末尾多余的 null：O(n)

总体：

时间复杂度：O(n)

空间复杂度：O(n)

dp 数组 O(n)
valid / vals / 队列 / 结果数组 O(n)

代码实现
Python
import sys
from ast import literal_eval
from collections import deque

def max_pruned_subtree(arr):
n = len(arr)
if n == 0:
return []

# 标记每个位置是否为真实结点（非 None）
valid = [x is not None for x in arr]

# dp[i]：以 i 为根，允许裁掉贡献不为正的子树后，能得到的最大子树和
dp = [0] * n

best_sum = None  # 全局最大值
best_root = -1   # 对应的根下标

# 自底向上 DP
for i in range(n - 1, -1, -1):
if not valid[i]:
dp[i] = 0
continue

left = 2 * i + 1
right = 2 * i + 2

left_dp = dp[left] if left < n and valid[left] else 0
right_dp = dp[right] if right < n and valid[right] else 0

# 允许裁掉贡献不为正的子树
cur = arr[i]
if left_dp > 0:
cur += left_dp
if right_dp > 0:
cur += right_dp

dp[i] = cur

if best_sum is None or cur > best_sum:
best_sum = cur
best_root = i

if best_root == -1:
return []

# BFS 构造被裁剪后的最大子树（完全二叉树形式）
res = []
q = deque()
# 队列元素：(原数组下标, 新树下标)
q.append((best_root, 0))

while q:
oi, ni = q.popleft()

# 保证 res 长度足够
while len(res) <= ni:
res.append(None)

res[ni] = arr[oi]

left = 2 * oi + 1
right = 2 * oi + 2

# 左子树保留条件：存在、为真实结点、dp > 0
if left < n and valid[left] and dp[left] > 0:
q.append((left, 2 * ni + 1))
# 右子树保留条件：存在、为真实结点、dp > 0
if right < n and valid[right] and dp[right] > 0:
q.append((right, 2 * ni + 2))

# 去掉末尾多余的 None
while res and res[-1] is None:
res.pop()

return res

def main():
s = sys.stdin.readline().strip()
if not s:
return

# 将输入中的 'null' 替换为 Python 的 None，便于 literal_eval 解析
s = s.replace('null', 'None')
arr = literal_eval(s)  # 得到包含 int 和 None 的列表

ans = max_pruned_subtree(arr)

# 输出格式：[1,-1,null,2,...]
out = '[' + ','.join('null' if x is None else str(x) for x in ans) + ']'
print(out)

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

// 允许裁掉贡献不为正子树的最大子树
private static List<String> maxPrunedSubtree(int[] vals, boolean[] valid) {
int n = vals.length;
List<String> res = new ArrayList<>();
if (n == 0) return res;

long[] dp = new long[n];  // dp[i]：以 i 为根的最大裁剪子树和
long bestSum = Long.MIN_VALUE;
int bestRoot = -1;

// 自底向上 DP
for (int i = n - 1; i >= 0; i--) {
if (!valid[i]) {
dp[i] = 0;
continue;
}
int left = 2 * i + 1;
int right = 2 * i + 2;

long leftDp = (left < n && valid[left]) ? dp[left] : 0;
long rightDp = (right < n && valid[right]) ? dp[right] : 0;

long cur = vals[i];
if (leftDp > 0) cur += leftDp;
if (rightDp > 0) cur += rightDp;

dp[i] = cur;

if (cur > bestSum) {
bestSum = cur;
bestRoot = i;
}
}

if (bestRoot == -1) {
return res;
}

// BFS 构造裁剪后的子树
Queue<Integer> qOrig = new LinkedList<>(); // 原树下标队列
Queue<Integer> qNew = new LinkedList<>();  // 新树下标队列

qOrig.offer(bestRoot);
qNew.offer(0);

while (!qOrig.isEmpty()) {
int oi = qOrig.poll();
int ni = qNew.poll();

// 保证 res 长度足够，用 "null" 占位
while (res.size() <= ni) {
res.add("null");
}

res.set(ni, String.valueOf(vals[oi]));

int left = 2 * oi + 1;
int right = 2 * oi + 2;

// 左子树：存在且有效且 dp > 0 才保留
if (left < n && valid[left] && dp[left] > 0) {
qOrig.offer(left);
qNew.offer(2 * ni + 1);
}
// 右子树同理
if (right < n && valid[right] && dp[right] > 0) {
qOrig.offer(right);
qNew.offer(2 * ni + 2);
}
}

// 去掉末尾多余的 "null"
int last = res.size() - 1;
while (last >= 0 && "null".equals(res.get(last))) {
res.remove(last);
last--;
}

return res;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s = br.readLine();
if (s == null || s.trim().isEmpty()) {
return;
}
s = s.trim();

// 去掉首尾的 [ ]
if (s.startsWith("[")) s = s.substring(1);
if (s.endsWith("]")) s = s.substring(0, s.length() - 1);

s = s.trim();
if (s.isEmpty()) {
System.out.println("[]");
return;
}

String[] parts = s.split(",");
int n = parts.length;
int[] vals = new int[n];
boolean[] valid = new boolean[n];

for (int i = 0; i < n; i++) {
String p = parts[i].trim();
if (p.equals("null") || p.equals("None") || p.length() == 0) {
valid[i] = false;
} else {
valid[i] = true;
vals[i] = Integer.parseInt(p);
}
}

List<String> ans = maxPrunedSubtree(vals, valid);

// 输出：[a,b,null,...]
StringBuilder sb = new StringBuilder();
sb.append("[");
for (int i = 0; i < ans.size(); i++) {
if (i > 0) sb.append(",");
sb.append(ans.get(i));
}
sb.append("]");
System.out.println(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 允许裁剪非正贡献子树的最大子树
vector<string> maxPrunedSubtree(const vector<long long> &vals, const vector<bool> &valid) {
int n = (int)vals.size();
vector<string> res;
if (n == 0) return res;

vector<long long> dp(n, 0);  // dp[i]：以 i 为根的最大裁剪子树和
long long bestSum = LLONG_MIN;
int bestRoot = -1;

// 自底向上 DP
for (int i = n - 1; i >= 0; --i) {
if (!valid[i]) {
dp[i] = 0;
continue;
}
int left = 2 * i + 1;
int right = 2 * i + 2;

long long leftDp = (left < n && valid[left]) ? dp[left] : 0;
long long rightDp = (right < n && valid[right]) ? dp[right] : 0;

long long cur = vals[i];
if (leftDp > 0) cur += leftDp;
if (rightDp > 0) cur += rightDp;

dp[i] = cur;

if (cur > bestSum) {
bestSum = cur;
bestRoot = i;
}
}

if (bestRoot == -1) {
return res;
}

// BFS 构造裁剪后的子树（完全二叉树形式）
queue<int> qOrig, qNew;
qOrig.push(bestRoot);
qNew.push(0);

while (!qOrig.empty()) {
int oi = qOrig.front(); qOrig.pop();
int ni = qNew.front(); qNew.pop();

// 确保 res 长度足够，用 "null" 填充
while ((int)res.size() <= ni) {
res.push_back("null");
}

res[ni] = to_string(vals[oi]);

int left = 2 * oi + 1;
int right = 2 * oi + 2;

// 左子树：存在且有效且 dp > 0 才保留
if (left < n && valid[left] && dp[left] > 0) {
qOrig.push(left);
qNew.push(2 * ni + 1);
}
// 右子树同理
if (right < n && valid[right] && dp[right] > 0) {
qOrig.push(right);
qNew.push(2 * ni + 2);
}
}

// 去掉末尾多余的 "null"
int last = (int)res.size() - 1;
while (last >= 0 && res[last] == "null") {
res.pop_back();
--last;
}

return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string s;
if (!getline(cin, s)) {
return 0;
}

// 去掉首尾空白
while (!s.empty() && isspace((unsigned char)s.back())) s.pop_back();
int pos = 0;
while (pos < (int)s.size() && isspace((unsigned char)s[pos])) pos++;
s = s.substr(pos);

if (s.empty()) {
return 0;
}

// 去掉首尾的 [ ]
if (!s.empty() && s.front() == '[') s.erase(s.begin());
if (!s.empty() && s.back() == ']') s.pop_back();

// 再清理首尾空白
while (!s.empty() && isspace((unsigned char)s.back())) s.pop_back();
while (!s.empty() && isspace((unsigned char)s.front())) s.erase(s.begin());

if (s.empty()) {
cout << "[]\n";
return 0;
}

// 按逗号切分
vector<long long> vals;
vector<bool> valid;
string token;
stringstream ss(s);
while (getline(ss, token, ',')) {
int l = 0, r = (int)token.size() - 1;
while (l <= r && isspace((unsigned char)token[l])) l++;
while (r >= l && isspace((unsigned char)token[r])) r--;
if (l > r) {
// 空串，视为 null
valid.push_back(false);
vals.push_back(0);
continue;
}
string t = token.substr(l, r - l + 1);
if (t == "null" || t == "None") {
valid.push_back(false);
vals.push_back(0);
} else {
valid.push_back(true);
long long v = stoll(t);
vals.push_back(v);
}
}

vector<string> ans = maxPrunedSubtree(vals, valid);

// 输出为 [a,b,c] 格式
cout << "[";
for (int i = 0; i < (int)ans.size(); ++i) {
if (i > 0) cout << ",";
cout << ans[i];
}
cout << "]\n";

return 0;
}

---

## 2025年11月12日-AI方向

### 第2题-全连接层INT8非对称量化实现（P4464）
- 链接：https://codefun2000.com/p/P4464

> 页面标题：#P4464. 第2题-全连接层INT8非对称量化实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

【背景】在移动设备部署深度学习模型时，浮点运算会消耗大量计算资源。通过 INT8 非对称量化，可将全连接层的浮点运算转化为整数运算，显著提高推理速度。实际应用中：

量化后模型大小缩小 4 倍（32bit→8bit）
整数运算指令比浮点指令快 2-4 倍
广泛应用于移动端 NLP 模型（如 BERT 最后一层分类头）
在物联网设备上可降低能耗并减少内存占用

【题目要求】请实现以下功能：

量化和全连接层计算：对输入向量 x 和权重矩阵 W 执行 INT8 非对称量化，使用量化后的整数值 xquantx_{quant}xquant​和WquantW_{quant}Wquant​ 进行全连接层计算，输出计算结果。为简化起见，本题中全连接层不考虑偏置。
计算量化误差：对量化的整数进行反量化得到 xdequantx_{dequant}xdequant​和 WdequantW_{dequant}Wdequant​并进行全连接层计算，与原始浮点 x、W 的全连接层计算结果进行比较，计算两个全连接层输出之间的均方误差（MSE），并将 MSE × 100000 后四舍五入后输出。

【算法原理】
1、INT8 非对称量化：
1）尺度：scalev=(max(v)−min(v))/255scale_v=(max(v)-min(v))/255scalev​=(max(v)−min(v))/255，当max(v)==min(v) max(v)==min(v)max(v)==min(v)，即张量 v 的所有值相等时，scalev=0scale_v=0scalev​=0。
2）量化，对张量 v（向量 x 或矩阵 W）进行量化得到vquantv_{quant}vquant​，量化后的整数区间为 [-128,127]：
$v_{quant} = clamp(round((v - min(v))/scale_v) - 128, -128,127)$
，当scalev=0时量化结果为vquant=−128当 scale_v = 0 时量化结果为v_{quant} = -128  当scalev​=0时量化结果为vquant​=−128。
其中 round () 采用就近取偶。
$\text{round}(x)= \begin{cases}  \lfloor x \rfloor, & \{x\} < \frac{1}{2}, \\ \lfloor x \rfloor + 1, & \{x\} > \frac{1}{2}, \\ 2 \cdot \lfloor \frac{x+1}{2} \rfloor, & \{x\} = \frac{1}{2}. \end{cases}$
其中：{x}=x−⌊x⌋\{x\} = x - \lfloor x \rfloor{x}=x−⌊x⌋，⌊x⌋\lfloor x \rfloor⌊x⌋ 表示向下取整。
$\text{clamp}(t, lo, hi)= \begin{cases}  lo, & t < lo \\ hi, & t > hi \\ t, & else \end{cases}$
3）反量化，对 vquantv_{\text{quant}}vquant​ 进行反量化后得到 vdequantv_{\text{dequant}}vdequant​：
$v_{\text{dequant}} = (v_{\text{quant}} + 128) \cdot \text{scale}_v + \min(v)$，当 scalev=0\text{scale}_v = 0scalev​=0 时，反量化值 vdequant=min⁡(v)v_{\text{dequant}} = \min(v)vdequant​=min(v)，即为原始输入的最小值。
2、全连接层计算，以输入向量xxx和权重矩阵WWW为例，全连接层输出Y。
Y=x⋅WTY = x\cdot W^TY=x⋅WT
3、量化误差，计算原始浮点输入的全连接层输出 YfloatY_{\text{float}}Yfloat​ 和反量化数据的全连接层输出 YdequantY_{\text{dequant}}Ydequant​ 之间的均方误差（MSE）：
$MSE = \frac{1}{m} \sum_{i=0}^{m-1} (Y_{\text{float},i} - Y_{\text{dequant},i})^2$，m 为权重矩阵的行数。
输入描述
第一行: n (输入向量 x 的维度)第二行: n 个浮点数 (输入向量 x)第三行: m n (权重矩阵 W 的维度)接下来 m 行：每行 n 个浮点数 (权重矩阵 W)
输出描述
第一行: m 个整数 (使用量化数据 xquantx_{quant}xquant​和 WquantW_{quant}Wquant​计算的全连接层输出)
第二行: 1 个整数 (量化误差 MSE，注意是 MSE × 100000 后四舍五入输出整数)
样例1
输入
3
1.0 2.0 3.0
2 3
0.1 0.2 0.3
0.4 0.5 0.6

输出
13082 12929
0

说明
3 # n=3 (输入向量维度)
1.0 2.0 3.0 # x = [1.0, 2.0, 3.0]
2 3 # m=2, n=3 (权重矩阵 2×3)
0.1 0.2 0.3 # W 第 1 行 = [0.1, 0.2, 0.3]
0.4 0.5 0.6 # W 第 2 行 = [0.4, 0.5, 0.6]
量化输入向量 X: xquantx_{quant}xquant​= [-128, 0, 127]
量化权重矩阵 W: WquantW_{quant}Wquant​= [[-128, -77, -26], [25, 76, 127]]
量化域整数运算：输出第一行结果: 13082 12929
计算MSE
原始浮点输出:
Y_float [0] = 1.0×0.1 + 2.0×0.2 + 3.0×0.3 = 0.1 + 0.4 + 0.9 = 1.4
Y_float [1] = 1.0×0.4 + 2.0×0.5 + 3.0×0.6 = 0.4 + 1.0 + 1.8 = 3.2
反量化后: Y_dequant = Y_float
MSE: 输出第二行结果: 0
样例2
输入
7
0.3 -1.1 2.2 -3.3 4.4 -5.5 6.6
3 7
0.2 -0.3 0.4 -0.1 0 0.5 -0.6
-1.5 1.2 -0.9 0.6 -0.3 0.1 0
3 -2 1 -0.5 0.25 -0.125 0.0625

输出
-5476 -7406 8954
933

说明
7 # n=7 (输入向量维度)
0.3 -1.1 2.2 -3.3 4.4 -5.5 6.6 # x = [0.3, -1.1, 2.2, -3.3, 4.4, -5.5, 6.6]
3 7 # m=3, n=7 (权重矩阵 3×7)
0.2 -0.3 0.4 -0.1 0 0.5 -0.6 # W 第 1 行
-1.5 1.2 -0.9 0.6 -0.3 0.1 0 # W 第 2 行
3 -2 1 -0.5 0.25 -0.125 0.0625 # W 第 3 行
输出:
量化域整数运算输出: -5476 -7406 8954
MSE 输出: 933

#### TextSol

解题思路
本题要求将输入向量与权重矩阵分别做 INT8 非对称量化（per-tensor），用量化后的整数直接做全连接（矩阵–向量乘），并用反量化后的结果评估与原始浮点计算之间的误差。
核心要点如下：

量化（asymmetric, INT8）
对张量 vvv（可为向量 xxx 或矩阵 WWW）做 per-tensor 量化：

尺度（scale）
$$\text{scale}_v = \frac{\max(v)-\min(v)}{255},\quad \text{若}\ \max(v)=\min(v)\ \text{则}\ \text{scale}_v=0$$

量化到 [−128,127][-128,127][−128,127]
$$v_{\text{quant}}=\text{clamp}\Big(\text{round}\Big(\frac{v-\min(v)}{\text{scale}_v}\Big)-128,\,-128,\,127\Big)$$其中 round 采用就近取偶（Banker’s Rounding）。当 scalev=0\text{scale}_v=0scalev​=0 时，直接令 vquant=−128v_{\text{quant}}=-128vquant​=−128。

反量化（dequant）
$$v_{\text{dequant}} = (v_{\text{quant}}+128)\cdot \text{scale}_v + \min(v)$$当 scalev=0\text{scale}_v=0scalev​=0 时，令 vdequant=min⁡(v)v_{\text{dequant}}=\min(v)vdequant​=min(v)。

全连接层计算
设输入为 x∈Rnx\in\mathbb{R}^nx∈Rn，权重 W∈Rm×nW\in\mathbb{R}^{m\times n}W∈Rm×n，输出
Y=x⋅W⊤∈RmY = x\cdot W^{\top}\in\mathbb{R}^m
Y=x⋅W⊤∈Rm

整数路径输出（第一行）：用 xquantx_{\text{quant}}xquant​ 与 WquantW_{\text{quant}}Wquant​ 直接做整数点积，得到 mmm 个整数。不添加偏置。

误差评估路径：分别将 xquant,Wquantx_{\text{quant}}, W_{\text{quant}}xquant​,Wquant​ 反量化为 xdequant,Wdequantx_{\text{dequant}}, W_{\text{dequant}}xdequant​,Wdequant​，再做浮点全连接得到 YdequantY_{\text{dequant}}Ydequant​。与原始浮点 YfloatY_{\text{float}}Yfloat​ 做均方误差
$$\text{MSE}=\frac{1}{m}\sum_{i=0}^{m-1}\big(Y_{\text{float},i}-Y_{\text{dequant},i}\big)^2$$输出时取 round(MSE×100000)\text{round}(\text{MSE}\times 100000)round(MSE×100000)，此处按“四舍五入”（half-up）。

实现细节

xxx 与 WWW 分别独立计算 min⁡,max⁡,scale\min,\max,\text{scale}min,max,scale（per-tensor 量化）。
量化时采用就近取偶；MSE 放大后采用四舍五入（half-up）。
矩阵乘法按行做点积；整数输出建议用较大整型累加避免溢出。

代码实现
Python
import sys
import math

def quantize_tensor(values):
"""对一维列表进行INT8非对称量化，返回(q, scale, vmin)"""
vmin = min(values)
vmax = max(values)
if vmax == vmin:
# scale为0：全量化为-128
return [-128] * len(values), 0.0, vmin
scale = (vmax - vmin) / 255.0
q = []
for v in values:
t = (v - vmin) / scale  # 落在[0,255]
rq = round(t)           # 就近取偶
iv = int(rq) - 128
if iv < -128:
iv = -128
elif iv > 127:
iv = 127
q.append(iv)
return q, scale, vmin

def dequantize_tensor(q, scale, vmin):
"""反量化一维列表"""
if scale == 0.0:
return [vmin] * len(q)
return [(qi + 128) * scale + vmin for qi in q]

def fc_int_output(xq, Wq, n):
"""使用量化后的整数做全连接：返回长度m的整数输出"""
m = len(Wq) // n
y = []
for i in range(m):
s = 0
base = i * n
for j in range(n):
s += xq[j] * Wq[base + j]
y.append(s)
return y

def fc_float_output(x, W, n):
"""浮点全连接：返回长度m的浮点输出"""
m = len(W) // n
y = []
for i in range(m):
s = 0.0
base = i * n
for j in range(n):
s += x[j] * W[base + j]
y.append(s)
return y

def round_half_up(x):
"""四舍五入到最近整数（正数half-up，MSE>=0安全）"""
return int(math.floor(x + 0.5))

def main():
data = sys.stdin.read().strip().split()
it = iter(data)

n = int(next(it))
x = [float(next(it)) for _ in range(n)]

m = int(next(it)); n2 = int(next(it))  # 题面保证维度合法
W = []
for _ in range(m):
for _ in range(n):
W.append(float(next(it)))

# 量化（x 与 W 分别 per-tensor）
xq, sx, xmin = quantize_tensor(x)
Wq, sw, wmin = quantize_tensor(W)

# 整数路径输出
y_int = fc_int_output(xq, Wq, n)

# 误差评估：反量化 -> 浮点全连接
x_d = dequantize_tensor(xq, sx, xmin)
W_d = dequantize_tensor(Wq, sw, wmin)
y_float = fc_float_output(x, W, n)
y_deq = fc_float_output(x_d, W_d, n)

# MSE × 100000 四舍五入
msz = len(y_float)
mse = sum((y_float[i] - y_deq[i]) ** 2 for i in range(msz)) / msz
mse_scaled = round_half_up(mse * 100000.0)

# 输出
print(' '.join(str(v) for v in y_int))
print(mse_scaled)

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

// 要求：ACM风格；类名Main；不用快读库，使用常规BufferedReader+StringTokenizer
public class Main {

// 量化结果结构体
static class QuantRes {
int[] q;
double scale;
double vmin;
QuantRes(int[] q, double scale, double vmin) {
this.q = q; this.scale = scale; this.vmin = vmin;
}
}

// INT8 非对称量化（就近取偶：Math.rint）
static QuantRes quantize(double[] v) {
double vmin = v[0], vmax = v[0];
for (double val : v) { if (val < vmin) vmin = val; if (val > vmax) vmax = val; }
if (vmax == vmin) {
int[] q = new int[v.length];
for (int i = 0; i < v.length; i++) q[i] = -128;
return new QuantRes(q, 0.0, vmin);
}
double scale = (vmax - vmin) / 255.0;
int[] q = new int[v.length];
for (int i = 0; i < v.length; i++) {
double t = (v[i] - vmin) / scale;
long rq = Math.round(Math.rint(t)); // rint为就近取偶，round包一层得到long
int iv = (int) rq - 128;
if (iv < -128) iv = -128;
else if (iv > 127) iv = 127;
q[i] = iv;
}
return new QuantRes(q, scale, vmin);
}

// 反量化
static double[] dequantize(int[] q, double scale, double vmin) {
double[] r = new double[q.length];
if (scale == 0.0) {
for (int i = 0; i < q.length; i++) r[i] = vmin;
return r;
}
for (int i = 0; i < q.length; i++) r[i] = (q[i] + 128) * scale + vmin;
return r;
}

// 整数全连接：xq(1×n) 与 Wq(m×n扁平) -> m个整数
static long[] fcInt(int[] xq, int[] Wq, int n, int m) {
long[] y = new long[m];
for (int i = 0; i < m; i++) {
long s = 0L;
int base = i * n;
for (int j = 0; j < n; j++) s += (long) xq[j] * (long) Wq[base + j];
y[i] = s;
}
return y;
}

// 浮点全连接：x(1×n) 与 W(m×n扁平) -> m个浮点
static double[] fcFloat(double[] x, double[] W, int n, int m) {
double[] y = new double[m];
for (int i = 0; i < m; i++) {
double s = 0.0;
int base = i * n;
for (int j = 0; j < n; j++) s += x[j] * W[base + j];
y[i] = s;
}
return y;
}

// 四舍五入（half-up）到最近整数，MSE非负可直接使用
static long roundHalfUp(double v) {
return (long) Math.floor(v + 0.5);
}

public static void main(String[] args) throws Exception {
FastIn in = new FastIn();

int n = in.nextInt();
double[] x = new double[n];
for (int i = 0; i < n; i++) x[i] = in.nextDouble();

int m = in.nextInt();
int n2 = in.nextInt(); // 题面保证合法

double[] W = new double[m * n];
for (int i = 0; i < m; i++)
for (int j = 0; j < n; j++)
W[i * n + j] = in.nextDouble();

// 量化
QuantRes qx = quantize(x);
QuantRes qW = quantize(W);

// 整数输出
long[] yInt = fcInt(qx.q, qW.q, n, m);

// 反量化 -> 浮点全连接
double[] xDeq = dequantize(qx.q, qx.scale, qx.vmin);
double[] WDeq = dequantize(qW.q, qW.scale, qW.vmin);
double[] yFloat = fcFloat(x, W, n, m);
double[] yDeq = fcFloat(xDeq, WDeq, n, m);

// MSE × 100000 四舍五入
double mse = 0.0;
for (int i = 0; i < m; i++) {
double d = yFloat[i] - yDeq[i];
mse += d * d;
}
mse /= m;
long mseScaled = roundHalfUp(mse * 100000.0);

// 输出
StringBuilder sb = new StringBuilder();
for (int i = 0; i < m; i++) {
if (i > 0) sb.append(' ');
sb.append(yInt[i]);
}
System.out.println(sb.toString());
System.out.println(mseScaled);
}

// 简洁输入工具：BufferedReader + StringTokenizer
static class FastIn {
BufferedReader br;
StringTokenizer st;
FastIn() { br = new BufferedReader(new InputStreamReader(System.in)); }
String next() throws IOException {
while (st == null || !st.hasMoreElements()) {
String line = br.readLine();
if (line == null) return null;
st = new StringTokenizer(line);
}
return st.nextToken();
}
int nextInt() throws IOException { return Integer.parseInt(next()); }
double nextDouble() throws IOException { return Double.parseDouble(next()); }
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 就近取偶（Banker's rounding）
static long long round_half_even(double x) {
double f = floor(x);
double frac = x - f;
if (frac < 0.5) return (long long)f;
if (frac > 0.5) return (long long)f + 1;
// frac == 0.5，取偶
long long fl = (long long)f;
if ((fl % 2LL) == 0LL) return fl;
return fl + 1LL;
}

// 四舍五入（half-up），MSE非负
static long long round_half_up(double v) {
return (long long)floor(v + 0.5);
}

// 量化（返回 q, scale, vmin）
static void quantize(const vector<double>& v, vector<int>& q, double& scale, double& vmin) {
double vmax = v[0];
vmin = v[0];
for (double x : v) { if (x < vmin) vmin = x; if (x > vmax) vmax = x; }
if (vmax == vmin) {
scale = 0.0;
q.assign(v.size(), -128);
return;
}
scale = (vmax - vmin) / 255.0;
q.resize(v.size());
for (size_t i = 0; i < v.size(); ++i) {
double t = (v[i] - vmin) / scale; // in [0,255]
long long rq = round_half_even(t);
long long iv = rq - 128;
if (iv < -128) iv = -128;
else if (iv > 127) iv = 127;
q[i] = (int)iv;
}
}

// 反量化
static void dequantize(const vector<int>& q, double scale, double vmin, vector<double>& out) {
out.resize(q.size());
if (scale == 0.0) {
for (size_t i = 0; i < q.size(); ++i) out[i] = vmin;
return;
}
for (size_t i = 0; i < q.size(); ++i) out[i] = (q[i] + 128) * scale + vmin;
}

// 整数全连接：xq(1×n) 与 Wq(m×n扁平) -> m个整数(long long)
static void fc_int(const vector<int>& xq, const vector<int>& Wq, int n, int m, vector<long long>& y) {
y.assign(m, 0LL);
for (int i = 0; i < m; ++i) {
long long s = 0;
int base = i * n;
for (int j = 0; j < n; ++j) s += 1LL * xq[j] * Wq[base + j];
y[i] = s;
}
}

// 浮点全连接：x 与 W(m×n扁平)
static void fc_float(const vector<double>& x, const vector<double>& W, int n, int m, vector<double>& y) {
y.assign(m, 0.0);
for (int i = 0; i < m; ++i) {
double s = 0.0;
int base = i * n;
for (int j = 0; j < n; ++j) s += x[j] * W[base + j];
y[i] = s;
}
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
if (!(cin >> n)) return 0;
vector<double> x(n);
for (int i = 0; i < n; ++i) cin >> x[i];

int m, n2;
cin >> m >> n2;
vector<double> W(m * n);
for (int i = 0; i < m; ++i)
for (int j = 0; j < n; ++j)
cin >> W[i * n + j];

// 量化
vector<int> xq, Wq;
double sx, xmin, sw, wmin;
quantize(x, xq, sx, xmin);
quantize(W, Wq, sw, wmin);

// 整数输出
vector<long long> y_int;
fc_int(xq, Wq, n, m, y_int);

// 反量化并浮点全连接
vector<double> x_deq, W_deq, y_float, y_deq;
dequantize(xq, sx, xmin, x_deq);
dequantize(Wq, sw, wmin, W_deq);
fc_float(x, W, n, m, y_float);
fc_float(x_deq, W_deq, n, m, y_deq);

// MSE × 100000 四舍五入
double mse = 0.0;
for (int i = 0; i < m; ++i) {
double d = y_float[i] - y_deq[i];
mse += d * d;
}
mse /= m;
long long mse_scaled = round_half_up(mse * 100000.0);

// 输出
for (int i = 0; i < m; ++i) {
if (i) cout << ' ';
cout << y_int[i];
}
cout << "\n" << mse_scaled << "\n";
return 0;
}

---

### 第2题-无人机物流配送路径规划（P4467）
- 链接：https://codefun2000.com/p/P4467

> 页面标题：#P4467. 第2题-无人机物流配送路径规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

一家物流公司正在开发无人机配送系统。无人机需要从仓库出发，将包裹配送到指定的客户地点。配送区域被划分为一个二维网格，无人机每次可以向上、下、左、右四个方向移动一步。由于电池容量限制，无人机最多只能连续飞行kkk步，之后必须降落在充电站充电（如果没有充电站，则无法继续飞行）。请编写一个程序，计算无人机从起点到终点的最短路径长度。如果无法到达客户地点，返回 −1- 1−1。
输入描述
配送区域大小：二维矩阵行数mmm，列数nnn，mmm和nnn的取值范围[1,1000]
配送区域表示：矩阵的大小为m×nm \times nm×n，数值代表的意义如下：000 表示可飞行的空地。111 表示障碍物（如建筑物、树木等），无人机不能通过。222 表示充电站，无人机可以在此停留并充电。

起点：一个长度为 2 的列表，表示仓库的坐标start_row, start_col\text{start\_row, start\_col}start_row, start_col，左上角坐标为(0,0)(0,0)(0,0)
终点：一个长度为 2 的列表，表示客户地点的坐标destination_row, destination_col\text{destination\_row, destination\_col}destination_row, destination_col
k：无人机最多可以连续飞行的步数。取值范围[1,100000]
输出描述
返回无人机从仓库到客户地点的最短路径长度。如果无法到达客户地点，返回 −1- 1−1。
样例1
输入
3 3
0 0 0
0 2 0
0 0 0
0 0
2 2
2

输出
4

说明
矩阵行数为 3，列数为 3
矩阵第一行为0 0 0
矩阵第二行为0 2 0
矩阵第三行为0 0 0
起点坐标为0 0
终点坐标为2 2
最多连续飞行步数为 2
无人机从(0, 0)出发，路径如下：
(0,0)→(0,1)(0, 0) \to (0, 1)(0,0)→(0,1)：步数 = 1，剩余可飞行步数 = 1
(0,1)→(1,1)(0, 1) \to (1, 1)(0,1)→(1,1)：步数 = 2，剩余可飞行步数 = 0
(1,1)(1, 1)(1,1)是充电站，进入充电站后，剩余可飞行步数重置为 2
(1,1)→(2,1)(1, 1) \to (2, 1)(1,1)→(2,1)：步数 = 3，剩余可飞行步数 = 1
(2,1)→(2,2)(2, 1) \to (2, 2)(2,1)→(2,2)：步数 = 4，剩余可飞行步数 = 0
最短路径长度为 4
样例2
输入
3 3
0 0 0
1 1 1
0 0 0
0 0
2 2
2

输出
-1

说明
矩阵行数为 3，列数为 3
矩阵第一行为0 0 0
矩阵第二行为1 1 1
矩阵第三行为0 0 0
起点坐标为0 0
终点坐标为2 2
最多连续飞行步数为 2
无人机从(0, 0)出发，最多只能连续飞行 2 步，但到达(0, 2)后无法继续前进，因为没有充电站，所以无法到达(2, 2)。返回 - 1

#### TextSol

解题思路

使用 BFS（广度优先搜索） 在网格上按步数分层扩展，首次到达终点即为最短路。
状态：(r, c, rem)，rem 为还能连续飞行的步数；初始为 k。
每次上下左右移动一步：rem-1；若落到充电站（值为 2），则把 rem 重置为 k。
剪枝：为每个格子 (r,c) 维护 best[r][c] = 到达该格子时见过的最大 rem。
若新到达的 rem <= best[r][c]，则该状态被更优状态支配，直接丢弃。
这样既保证最短步数，又控制状态数量；输入按空格分隔整数逐个读取，适配你给的样例格式。

复杂度分析

最坏上界 O(m*n*k)；由于每格只在 rem 变大时才更新，实际接近 O(m*n)。
空间复杂度 O(m*n)（best 与队列）。

代码实现
Python
# 读取格式：全部按整数读取，支持以空格分隔的行
# 功能：BFS + 续航状态，落在充电站就把 rem 置为 k
import sys, re
from collections import deque

def shortest_path(m, n, grid, sr, sc, tr, tc, k):
best = [[-1]*n for _ in range(m)]
q = deque()
best[sr][sc] = k
q.append((sr, sc, k, 0))  # r,c,rem,dist
dirs = [(1,0),(-1,0),(0,1),(0,-1)]
while q:
r, c, rem, dist = q.popleft()
if r == tr and c == tc:
return dist
if rem == 0 and grid[r][c] != 2:  # 没电且不在充电站，无法继续
continue
for dr, dc in dirs:
nr, nc = r+dr, c+dc
if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] != 1:
new_rem = k if grid[nr][nc] == 2 else rem - 1
if new_rem > best[nr][nc]:
best[nr][nc] = new_rem
q.append((nr, nc, new_rem, dist+1))
return -1

def main():
data = list(map(int, re.findall(r'-?\d+', sys.stdin.read())))
it = iter(data)
m = next(it); n = next(it)
grid = [[next(it) for _ in range(n)] for _ in range(m)]
sr, sc = next(it), next(it)
tr, tc = next(it), next(it)
k = next(it)
print(shortest_path(m, n, grid, sr, sc, tr, tc, k))

if __name__ == "__main__":
main()

Java
// 说明：使用自写的快速整数读取（兼容空格/换行/其它字符），适配“0 0 0”这种行。
// BFS + 剩余步数剪枝；类名 Main，ACM 风格。
import java.io.*;
import java.util.*;

public class Main {

// 简洁快读：读取下一个整数，跳过所有非数字字符
static class FastReader {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastReader(InputStream is){ in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
int nextInt() throws IOException {
int c, sign = 1, x = 0;
do { c = read(); } while (c != -1 && c <= ' '); // 跳过空白
if (c == '-') { sign = -1; c = read(); }
for (; c > ' '; c = read()) x = x * 10 + (c - '0');
return x * sign;
}
}

static int bfs(int[][] g, int sr, int sc, int tr, int tc, int k) {
int m = g.length, n = g[0].length;
int[][] best = new int[m][n];
for (int i = 0; i < m; i++) Arrays.fill(best[i], -1);
ArrayDeque<int[]> q = new ArrayDeque<>();
best[sr][sc] = k;
q.add(new int[]{sr, sc, k, 0}); // r,c,rem,dist

int[] dr = {1,-1,0,0};
int[] dc = {0,0,1,-1};

while (!q.isEmpty()) {
int[] cur = q.poll();
int r = cur[0], c = cur[1], rem = cur[2], dist = cur[3];
if (r == tr && c == tc) return dist;
if (rem == 0 && g[r][c] != 2) continue;

for (int d = 0; d < 4; d++) {
int nr = r + dr[d], nc = c + dc[d];
if (nr < 0 || nr >= m || nc < 0 || nc >= n) continue;
if (g[nr][nc] == 1) continue; // 障碍
int newRem = (g[nr][nc] == 2) ? k : rem - 1;
if (newRem > best[nr][nc]) {
best[nr][nc] = newRem;
q.add(new int[]{nr, nc, newRem, dist + 1});
}
}
}
return -1;
}

public static void main(String[] args) throws Exception {
FastReader fr = new FastReader(System.in);
int m = fr.nextInt(), n = fr.nextInt();
int[][] grid = new int[m][n];
for (int i = 0; i < m; i++)
for (int j = 0; j < n; j++)
grid[i][j] = fr.nextInt();   // 逐个整数读取，适配“0 0 0”格式

int sr = fr.nextInt(), sc = fr.nextInt();
int tr = fr.nextInt(), tc = fr.nextInt();
int k  = fr.nextInt();

System.out.println(bfs(grid, sr, sc, tr, tc, k));
}
}

C++
// 说明：直接用 >> 读取整数（忽略空白），逐个读 m*n 个网格数，完全适配“0 0 0”格式。
// BFS + 剩余步数剪枝；ACM 风格。
#include <bits/stdc++.h>
using namespace std;

int bfs(const vector<vector<int>>& g, int sr, int sc, int tr, int tc, int k) {
int m = g.size(), n = g[0].size();
vector<vector<int>> best(m, vector<int>(n, -1));
queue<array<int,4>> q; // r,c,rem,dist
best[sr][sc] = k;
q.push({sr, sc, k, 0});
const int dr[4] = {1,-1,0,0};
const int dc[4] = {0,0,1,-1};

while (!q.empty()) {
auto cur = q.front(); q.pop();
int r = cur[0], c = cur[1], rem = cur[2], dist = cur[3];
if (r == tr && c == tc) return dist;
if (rem == 0 && g[r][c] != 2) continue;

for (int d = 0; d < 4; ++d) {
int nr = r + dr[d], nc = c + dc[d];
if (nr < 0 || nr >= m || nc < 0 || nc >= n) continue;
if (g[nr][nc] == 1) continue;          // 障碍不可过
int newRem = (g[nr][nc] == 2) ? k : rem - 1;
if (newRem > best[nr][nc]) {
best[nr][nc] = newRem;
q.push({nr, nc, newRem, dist + 1});
}
}
}
return -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m, n;
if (!(cin >> m >> n)) return 0;
vector<vector<int>> grid(m, vector<int>(n));
for (int i = 0; i < m; ++i)
for (int j = 0; j < n; ++j)
cin >> grid[i][j];

int sr, sc, tr, tc, k;
cin >> sr >> sc >> tr >> tc >> k;

cout << bfs(grid, sr, sc, tr, tc, k) << '\n';
return 0;
}

---

### 第2题-火情蔓延预测（P4450）
- 链接：https://codefun2000.com/p/P4450

> 页面标题：#P4450. 第2题-火情蔓延预测

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你负责开发一个火灾监控预警系统，在二维网格中，每个网格可以是空地 (0)(0)(0) 或不同类型的可燃物( 111 到 kkk 的正整数，数值对应燃烧时间)。火势从初始着火点开始，蔓延规则为:可燃物被点燃后，需经过其燃烧时间才能向四周蔓延。求监控点被点燃的最早时间，若无法被点燃或监控点是空地，返回 −1-1−1 。
输入描述
输入内容:
1.二维监控区域 gridsgridsgrids，其空间 sizesizesize 为 m×n(0<m<=100,0<n<=100)m×n(0<m<=100,0<n<=100)m×n(0<m<=100,0<n<=100)，如 4×34×34×3 区域空间 [[0,1,2],[1,2,1],[1,1,1],[1,0,1]][[0,1,2],[1,2,1],[1,1,1],[1,0,1]][[0,1,2],[1,2,1],[1,1,1],[1,0,1]]，000 表示空地，其余表示可燃物燃烧时间;
2.着火点坐标 firesfiresfires，由多个二维坐标点组成 [x,y](0<=x<m,0<=y<n)[x,y](0<=x<m,0<=y<n)[x,y](0<=x<m,0<=y<n)，着火点数量少于 555 ，如: [[0,0],[0,1]][[0,0],[0,1]][[0,0],[0,1]]
3.监控点坐标 monitormonitormonitor ,单个二维坐标点 [a,b](0<=a<m,0<=b<n)[a,b](0<=a<m,0<=b<n)[a,b](0<=a<m,0<=b<n)，如: [2,2][2,2][2,2]
输入格式:
第 111 行:矩阵 sizesizesize，mmm nnn，用空格分隔
第 2−m+12-m+12−m+1 行:二维矩阵内容，每行代表矩阵的一行数据，每个数据空格分隔
第 m+2m+2m+2 行:着火点坐标，含多个着火点，用空格分隔，000 000 222 000 表示 222 个着火点 [0,0][0,0][0,0] 与 [2,0][2,0][2,0]
第 m+3m+3m+3 行:监控点坐标,单个着火点，用空格分隔
输出描述
输出:几分钟后火情蔓延至监控坐标 monitormonitormonitor ,不会着火返回 −1-1−1
样例1
输入
3 3
1 0 0
0 3 1
1 0 2
0 0 2 0
2 2

输出
-1

说明
[2,0][2,0][2,0] 坐标位置的着火点无法蔓延
[0,0][0,0][0,0] 坐标位置的着火点无法蔓延
[2,2][2,2][2,2] 坐标不会着火，返回 −1-1−1
样例2
输入
3 3
1 2 0
0 3 1
1 0 2
0 0 2 0
2 2

输出
7

说明
[2,0][2,0][2,0] 坐标位置的着火点无法蔓延
[0,0][0,0][0,0] 坐标位置的着火点 −>[0,1]->[0,1]−>[0,1] 花费时间 111
−>[1,1]->[1,1]−>[1,1] 花费时间 222
−>[1,2]->[1,2]−>[1,2] 花费时间 333
−>[2,2]->[2,2]−>[2,2] 花费时间 111
一共花费时间 777

#### TextSol

解题思路

将网格视作有向图的点，每个可燃单元格的燃烧时间就是它向外蔓延到相邻格子的“边权”。
若从 u=(x,y) 蔓延到相邻 v，则 time[v] = time[u] + burn(u)，其中 burn(u)=grids[x][y]。空地 0 不可被点燃也不能继续蔓延。
初始有多个起火点，均在时刻 0 被点燃，属于多源最短路问题。
用 Dijkstra（优先队列） 从所有起火点同时出发，维护每个格子被点燃的最早时刻 dist。
扩展仅在四联通方向（上/下/左/右）进行。最终答案为监控点 (a,b) 的 dist[a][b]；若该点为 0 或不可达，返回 -1。

要点：

多源：把所有起火点以距离 0 入堆。
边权取当前格子的燃烧时间，而非目标格子的时间。
监控点是空地时直接 -1。

复杂度分析

设网格大小为 m×n。
Dijkstra 时间复杂度 O(mn log(mn))，空间复杂度 O(mn)，满足题目规模（m,n ≤ 100）。

代码实现
Python
# -*- coding: utf-8 -*-
import sys
import heapq

# 功能函数：返回监控点最早着火时间
def earliest_fire_time(grids, fires, monitor):
m, n = len(grids), len(grids[0])
a, b = monitor
# 监控点是空地，永远不会着火
if grids[a][b] == 0:
return -1

INF = 10**18
dist = [[INF] * n for _ in range(m)]
pq = []

# 多源起点：所有着火点时刻为0
for x, y in fires:
if 0 <= x < m and 0 <= y < n:
dist[x][y] = 0
heapq.heappush(pq, (0, x, y))

dirs = [(-1,0),(1,0),(0,-1),(0,1)]
while pq:
t, x, y = heapq.heappop(pq)
if t != dist[x][y]:
continue
# 当前格子为0则不能蔓延
if grids[x][y] == 0:
continue
for dx, dy in dirs:
nx, ny = x + dx, y + dy
if 0 <= nx < m and 0 <= ny < n and grids[nx][ny] != 0:
nt = t + grids[x][y]  # 由当前格子燃烧完成后蔓延
if nt < dist[nx][ny]:
dist[nx][ny] = nt
heapq.heappush(pq, (nt, nx, ny))

return -1 if dist[a][b] >= INF else dist[a][b]

# 读一行网格（兼容“用空格分隔”或紧凑字符串如 031 的写法；默认每格为0~9）
def parse_row(line, n):
line = line.strip()
if " " in line:
nums = list(map(int, line.split()))
return nums
# 紧凑无空格：逐字符解析
return [int(c) for c in line][:n]

def main():
data = sys.stdin.readline().strip()
if not data:
return
m, n = map(int, data.split())
grids = []
for _ in range(m):
line = sys.stdin.readline()
row = parse_row(line, n)
grids.append(row)

# 读取着火点：一行若干整数，按 (x y) 成对出现
fires_line = sys.stdin.readline().strip()
fire_nums = list(map(int, fires_line.split())) if fires_line else []
fires = [(fire_nums[i], fire_nums[i+1]) for i in range(0, len(fire_nums), 2)]

# 读取监控点
a, b = map(int, sys.stdin.readline().split())
print(earliest_fire_time(grids, fires, (a, b)))

if __name__ == "__main__":
main()

Java
// -*- coding: utf-8 -*-
import java.io.*;
import java.util.*;

// ACM 风格主类
public class Main {

// 功能函数：Dijkstra 多源最短路
static int earliestFireTime(int[][] g, List<int[]> fires, int a, int b) {
int m = g.length, n = g[0].length;
if (g[a][b] == 0) return -1; // 监控点为空地

long INF = (long)1e18;
long[][] dist = new long[m][n];
for (int i = 0; i < m; i++) Arrays.fill(dist[i], INF);

PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(o -> o[0]));
for (int[] f : fires) {
int x = f[0], y = f[1];
if (0 <= x && x < m && 0 <= y && y < n) {
dist[x][y] = 0;
pq.offer(new long[]{0, x, y});
}
}

int[] dx = {-1, 1, 0, 0};
int[] dy = {0, 0, -1, 1};

while (!pq.isEmpty()) {
long[] cur = pq.poll();
long t = cur[0];
int x = (int)cur[1], y = (int)cur[2];
if (t != dist[x][y]) continue;
if (g[x][y] == 0) continue; // 空地不蔓延
for (int k = 0; k < 4; k++) {
int nx = x + dx[k], ny = y + dy[k];
if (nx >= 0 && nx < m && ny >= 0 && ny < n && g[nx][ny] != 0) {
long nt = t + g[x][y]; // 由当前格子蔓延
if (nt < dist[nx][ny]) {
dist[nx][ny] = nt;
pq.offer(new long[]{nt, nx, ny});
}
}
}
}

return dist[a][b] >= INF ? -1 : (int)dist[a][b];
}

// 解析一行网格（支持空格分隔或无空格如 031）
static int[] parseRow(String line, int n) {
line = line.trim();
if (line.contains(" ")) {
String[] ss = line.split("\\s+");
int[] row = new int[n];
for (int i = 0; i < n; i++) row[i] = Integer.parseInt(ss[i]);
return row;
} else {
int[] row = new int[n];
for (int i = 0; i < n && i < line.length(); i++) row[i] = line.charAt(i) - '0';
return row;
}
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] hw = br.readLine().trim().split("\\s+");
int m = Integer.parseInt(hw[0]), n = Integer.parseInt(hw[1]);

int[][] g = new int[m][n];
for (int i = 0; i < m; i++) {
String line = br.readLine();
while (line != null && line.trim().isEmpty()) line = br.readLine();
g[i] = parseRow(line, n);
}

// 着火点：按 (x y) 成对出现
String firesLine = br.readLine();
List<int[]> fires = new ArrayList<>();
if (firesLine != null && firesLine.trim().length() > 0) {
String[] ss = firesLine.trim().split("\\s+");
for (int i = 0; i + 1 < ss.length; i += 2) {
fires.add(new int[]{Integer.parseInt(ss[i]), Integer.parseInt(ss[i + 1])});
}
}

String[] ab = br.readLine().trim().split("\\s+");
int a = Integer.parseInt(ab[0]), b = Integer.parseInt(ab[1]);

System.out.println(earliestFireTime(g, fires, a, b));
}
}

C++
// -*- coding: utf-8 -*-
#include <bits/stdc++.h>
using namespace std;

// 功能函数：Dijkstra 多源最短路
int earliest_fire_time(const vector<vector<int>>& g,
const vector<pair<int,int>>& fires,
int a, int b) {
int m = g.size(), n = g[0].size();
if (g[a][b] == 0) return -1; // 监控点为空地

const long long INF = (long long)4e18;
vector<vector<long long>> dist(m, vector<long long>(n, INF));
typedef tuple<long long,int,int> Node;
priority_queue<Node, vector<Node>, greater<Node>> pq;

// for (auto [x, y] : fires)  ->  C++11 写法
for (size_t i = 0; i < fires.size(); ++i) {
int x = fires[i].first, y = fires[i].second;
if (0 <= x && x < m && 0 <= y && y < n) {
dist[x][y] = 0;
pq.emplace(0LL, x, y);
}
}

int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

while (!pq.empty()) {
// auto [t, x, y] = pq.top(); -> C++11 写法
Node cur = pq.top(); pq.pop();
long long t = std::get<0>(cur);
int x = std::get<1>(cur);
int y = std::get<2>(cur);

if (t != dist[x][y]) continue;
if (g[x][y] == 0) continue; // 空地不蔓延
for (int k = 0; k < 4; ++k) {
int nx = x + dx[k], ny = y + dy[k];
if (nx>=0 && nx<m && ny>=0 && ny<n && g[nx][ny] != 0) {
long long nt = t + g[x][y]; // 由当前格子蔓延
if (nt < dist[nx][ny]) {
dist[nx][ny] = nt;
pq.emplace(nt, nx, ny);
}
}
}
}
return dist[a][b] >= INF ? -1 : (int)dist[a][b];
}

// 解析一行网格：支持空格分隔或紧凑字符串如 031（默认每格0~9）
vector<int> parse_row(const string& line, int n) {
vector<int> row;
string s = line;
if (s.find(' ') != string::npos || s.find('\t') != string::npos) {
istringstream iss(s);
int x;
while (iss >> x) row.push_back(x);
} else {
for (size_t i = 0; i < s.size(); ++i) {
char c = s[i];
if (!isspace((unsigned char)c)) row.push_back(c - '0');
}
}
if ((int)row.size() < n) row.resize(n, 0);   // 防越界，缺的补0
else if ((int)row.size() > n) row.resize(n);
return row;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m, n;
if (!(cin >> m >> n)) return 0;
string dummy;
getline(cin, dummy); // 吃掉行尾

vector<vector<int>> g(m, vector<int>(n, 0));
for (int i = 0; i < m; ++i) {
string line;
getline(cin, line);
while (!line.empty() &&
all_of(line.begin(), line.end(),
[](char c){ return isspace((unsigned char)c); })) {
getline(cin, line);
}
vector<int> row = parse_row(line, n);
for (int j = 0; j < n; ++j) g[i][j] = row[j];
}

// 读取着火点：一行若干整数，按 (x y) 成对
string firesLine;
getline(cin, firesLine);
while (!firesLine.empty() &&
all_of(firesLine.begin(), firesLine.end(),
[](char c){ return isspace((unsigned char)c); })) {
getline(cin, firesLine);
}
istringstream iss(firesLine);
vector<int> fs; int val;
while (iss >> val) fs.push_back(val);
vector<pair<int,int>> fires;
for (size_t i = 0; i + 1 < fs.size(); i += 2) fires.push_back(make_pair(fs[i], fs[i+1]));

// 读取监控点
string abLine;
getline(cin, abLine);
istringstream iss2(abLine);
int a, b; iss2 >> a >> b;

cout << earliest_fire_time(g, fires, a, b) << "\n";
return 0;
}

---

### 第3题-基于决策树的QAM调制符合检测（P4465）
- 链接：https://codefun2000.com/p/P4465

> 页面标题：#P4465. 第3题-基于决策树的QAM调制符合检测

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在无线通信中使用QAMQAMQAM调制将信息通过无线信号从发送端传递到接收端。QAMQAMQAM调制后的信号可以使用一个复数表示。16Q16Q16QAM调制会生成161616个不同的复数信号。在无线信号传输过程中，信号会受到高斯噪声污染，使得接收到的QAMQAMQAM信号与发送的QAMQAMQAM信号产生误差。该过程可以用如下公式表示：
Srx=Stx+nS_{rx} = S_{tx} + nSrx​=Stx​+n，其中，nnn为复数高斯噪声。
例如，一个发送16QAM16QAM16QAM调制符号为：
Stx=−1+1jS_{tx} = -1 + 1jStx​=−1+1j
传输过程中受到的噪声信号为：
n=0.38−1.2jn = 0.38 - 1.2jn=0.38−1.2j
接收到的16QAM16QAM16QAM调制符号为：
Srx=−0.62−0.2jS_{rx} = -0.62 - 0.2jSrx​=−0.62−0.2j
无线信号的符号检测过程，就是根据接收到的受噪声污染的QAMQAMQAM符号，判决输出其真实发送QAMQAMQAM符号。
下图所示为16QAM16QAM16QAM调制符号的星座图。图中，蓝色圆点表示发送的QAMQAMQAM符号，红色点表示受噪声污染后的接收QAMQAMQAM符号。
请使用CART决策树实现一个QAMQAMQAM符号检测器，完成16QAM16QAM16QAM调制的无线信号的接收检测。

要求：

根据输入的MMM个接收16QAM调制符号和真实标签构建CART决策树；
使用基尼系数（GiniGiniGini）作为划分标准；
决策树最大深度=555；
特征值切分点限制为{−3,−2,−1,0,1,2,3}\{-3,-2,-1,0,1,2,3\}{−3,−2,−1,0,1,2,3}；
输出训练集的GiniGiniGini系数；
输出验证QAMQAMQAM符号标签。

输入描述
第一行：一个整数 MMM ，表示训练样本集个数，取值范围[10~20]
接下来M行：两个实数 x1x1x1 ， x2x2x2 和一个整数 yyy ，以空格间隔。其中， x1x1x1 ， x2x2x2 分别表示复数QAM符号的实部和虚部，取值范围 [-10 ~ +10]，保留小数点后2位。 yyy 表示QAM符号的标签，取值范围[0~15]。
第 M+2M+2M+2 行：两个实数 x1x1x1 ， x2x2x2 ，分别表示测试用接收QAM符号的实部和虚部，取值范围 [-10 ~ +10]，保留小数点后2位。
输出描述
第一行：一个实数 GGG ，表示训练样本集合的Gini系数，四舍五入后保留小数点后4位。
第二行：一个整数 yyy ，表示测试QAM符号的分类标签。
样例1
输入
10
2.56 0.73 14
3.88 0.83 14
-0.32 2.93 7
-2.99 -3.56 0
3.36 -1.52 13
-2.70 -1.13 1
-0.57 0.97 6
2.71 3.22 15
2.35 -2.55 12
4.18 -1.25 13
-1.14 0.20

输出
0.8600
6

说明
上述输入第1行为训练样本集合中样本个数：10。
接下来10行为10个16QAM调制符号的接收信号（复数信号的实部、虚部），以及对应的原始发送符号的标签。
第12行为测试用的接收16QAM调制符号信号（复数信号的实部、虚部）。
输出第1行数值为使用这10个符号及对应原始符号标签作为训练样本集合，计算出的该集合Gini系数。数值四舍五入后保留四位小数。
输出第2行为基于上述构建的决策树对测试样本的原始发送符号标签的预测值。
样例2
输入
11
-3.24 0.96 2
2.79 0.95 14
2.99 -2.94 12
0.67 -2.55 8
-1.30 -0.71 5
0.73 -2.96 8
-3.04 1.30 2
-2.81 -0.68 1
2.88 3.33 15
-2.55 2.87 3
-1.01 -0.62 5
-3.24 -2.90

输出
0.8595
2

说明
上述输入第1行为训练样本集合中样本个数：11。
接下来11行为11个16QAM调制符号的接收信号（复数信号的实部、虚部），以及对应的原始发送符号的标签。
第13行为测试用的接收16QAM调制符号接收信号（复数信号的实部、虚部）。
输出第1行为使用这11个符号和对应的符号标签作为训练样本集合，计算出的该集合GiniGiniGini系数。数值四舍五入后保留四位小数。
输出第2行为基于上述构建的决策树对测试样本的原始发送符号标签的预测值。
提示
样本集合中的样本有KKK个类别，每个类别的样本，在样本集合中的概率分布为P=(P1,P2,...,PK)P = (P_1, P_2, ..., P_K)P=(P1​,P2​,...,PK​)
给定样本集合DDD，计算其GiniGiniGini系数时，首先需要计算出样本集合中每个类别出现的比例PiP_iPi​，然后基于如下GiniGiniGini系数计算公式计算：
Gini(D)=1−∑i=1KPi2Gini(D) = 1 - \sum_{i=1}^{K} P_i^2Gini(D)=1−∑i=1K​Pi2​
其中，PiP_iPi​是第iii类样本出现的比例，KKK是样本中总类别数。
CART树实现步骤：

特征及切分点选择

遍历样本所有特征，对每一个特征值的特征值进行排序，以相邻特征值的中值作为切分点，计算以该切分点将样本划分为D1D1D1和D2D2D2两个子集后的加权基尼系数。
加权GiniGiniGini系数计算公式为：
Giniweight=W1Gini(D1)+W2Gini(D2)Gini_{weight} = W_1Gini(D_1) + W_2Gini(D_2)Giniweight​=W1​Gini(D1​)+W2​Gini(D2​)
其中，W1W_1W1​为子集D1D1D1中样本在集合DDD中占比，W2W_2W2​为子集D2D2D2中样本在集合DDD中占比。

节点划分

选择使加权GiniGiniGini系数最小的特征和特征值切分点，将数据集划分为左右两个子集：左子集D1(<特征值划分点)D1(<特征值划分点)D1(<特征值划分点)和右子集D2(≥特征值划分点)D2(≥特征值划分点)D2(≥特征值划分点)。

递归构建树

对每个子集重复步骤1和2，直到满足停止条件（如节点样本数小于阈值，或达到最大深度）。

#### TextSol

解题思路
本题要求用 CART 决策树 在二维特征（实部 x1、虚部 x2）上完成 16QAM 符号标签的分类，并使用 Gini 系数作为划分标准，树的最大深度为 5，且切分点仅允许取自集合 {-3,-2,-1,0,1,2,3}。训练后需要输出：
1）训练样本集合的整体 Gini 系数；2）对给定测试点的预测标签。
相关算法与实现要点

节点不纯度（Gini）
对任意样本集合 DDD，令第 iii 类（标签）比例为 PiP_iPi​，则
Gini(D)=1−∑iPi2Gini(D)=1-\sum_i P_i^2
Gini(D)=1−i∑​Pi2​
训练集整体 Gini 直接按全部训练样本的标签频率计算一次即可。

候选划分

特征：两维 (x1,x2)(x1,x2)(x1,x2)。

切分点：限定在 {−3,−2,−1,0,1,2,3}\{-3,-2,-1,0,1,2,3\}{−3,−2,−1,0,1,2,3}。

对每个特征与每个切分点，按规则将样本分为：
左子集 D1={x∣xf<t}D_1=\{x\mid x_f < t\}D1​={x∣xf​<t}，右子集 D2={x∣xf≥t}D_2=\{x\mid x_f \ge t\}D2​={x∣xf​≥t}。

计算加权 Gini：
$$Gini_{weight}=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$

选择 加权 Gini 最小 且 两侧非空 的划分；若最优加权 Gini 未严格小于 当前集合的 Gini（或已纯/深度到限），则生成叶子结点。

叶子预测

叶子输出当前集合的多数类标签；若并列，取数值更小的标签，保证确定性。

构树

从根开始递归，深度上限为 5。
每个结点重复“枚举划分 → 选择最优 → 递归子树”的步骤。

预测

自根结点按“< 阈值走左，≥\ge≥ 阈值走右”到达叶子，输出叶子标签。

代码实现
Python
import sys
from collections import Counter

# 计算集合的 Gini 系数
def gini_of_labels(labels):
n = len(labels)
if n == 0:
return 0.0
cnt = Counter(labels)
s = 0.0
for c in cnt.values():
p = c / n
s += p * p
return 1.0 - s

# 多数类（并列取更小标签）
def majority_label(labels):
cnt = Counter(labels)
maxc = max(cnt.values())
candidates = [k for k, v in cnt.items() if v == maxc]
return min(candidates)

# 决策树结点
class Node:
def __init__(self):
self.is_leaf = True
self.label = 0
self.feature = -1
self.threshold = 0.0
self.left = None
self.right = None

# 递归建树
THRESHOLDS = [-3, -2, -1, 0, 1, 2, 3]

def build_tree(X, y, idxs, depth_left):
node = Node()
curr_labels = [y[i] for i in idxs]
curr_gini = gini_of_labels(curr_labels)
# 叶子条件：纯、深度用尽
if curr_gini == 0.0 or depth_left == 0:
node.is_leaf = True
node.label = majority_label(curr_labels)
return node

best_gini = float('inf')
best_f, best_t = -1, None
best_left, best_right = None, None

# 枚举特征与阈值
for f in [0, 1]:
for t in THRESHOLDS:
left = []
right = []
for i in idxs:
if X[i][f] < t:
left.append(i)
else:
right.append(i)
# 两侧必须非空
if len(left) == 0 or len(right) == 0:
continue
g_left = gini_of_labels([y[i] for i in left])
g_right = gini_of_labels([y[i] for i in right])
w = (len(left) / len(idxs)) * g_left + (len(right) / len(idxs)) * g_right
# 选择加权 Gini 更小的划分；平手时用更小特征、更小阈值保证确定性
if w < best_gini - 1e-12 or (abs(w - best_gini) <= 1e-12 and (f < best_f or (f == best_f and t < (best_t if best_t is not None else 0)))):
best_gini = w
best_f, best_t = f, t
best_left, best_right = left, right

# 若无有效提升则设为叶子
if best_left is None or best_gini >= curr_gini - 1e-12:
node.is_leaf = True
node.label = majority_label(curr_labels)
return node

# 划分并递归
node.is_leaf = False
node.feature = best_f
node.threshold = best_t
node.left = build_tree(X, y, best_left, depth_left - 1)
node.right = build_tree(X, y, best_right, depth_left - 1)
return node

def predict(root, x):
node = root
while not node.is_leaf:
if x[node.feature] < node.threshold:
node = node.left
else:
node = node.right
return node.label

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
M = int(next(it))
X = []
y = []
for _ in range(M):
x1 = float(next(it)); x2 = float(next(it)); yy = int(next(it))
X.append([x1, x2]); y.append(yy)
tx1 = float(next(it)); tx2 = float(next(it))
test = [tx1, tx2]

# 训练集整体 Gini
G = gini_of_labels(y)

# 训练 CART 树
idxs = list(range(M))
root = build_tree(X, y, idxs, depth_left=5)

# 预测
pred = predict(root, test)

# 输出
print(f"{G:.4f}")
print(pred)

if __name__ == "__main__":
main()

Java
import java.util.*;

/* ACM 风格主类名要求为 Main */
public class Main {

static class Node {
boolean isLeaf = true;
int label = 0;
int feature = -1;     // 0: x1, 1: x2
int threshold = 0;    // 阈值取自 {-3,-2,-1,0,1,2,3}
Node left = null, right = null;
}

static final int[] THRESH = {-3, -2, -1, 0, 1, 2, 3};
static int M;
static double[] X1, X2;
static int[] Y;

// 计算 labels 的 Gini
static double giniOfLabels(int[] idxs, int size) {
if (size == 0) return 0.0;
int[] cnt = new int[32]; // 标签范围 0..15，开大一点无妨
for (int i = 0; i < size; i++) cnt[Y[idxs[i]]]++;
double n = size;
double s = 0.0;
for (int c : cnt) {
if (c == 0) continue;
double p = c / n;
s += p * p;
}
return 1.0 - s;
}

// 多数类（并列取更小标签）
static int majorityLabel(int[] idxs, int size) {
int[] cnt = new int[32];
for (int i = 0; i < size; i++) cnt[Y[idxs[i]]]++;
int bestCnt = -1, bestLab = 0;
for (int lab = 0; lab <= 31; lab++) {
if (cnt[lab] > bestCnt) {
bestCnt = cnt[lab];
bestLab = lab;
} else if (cnt[lab] == bestCnt && cnt[lab] > 0 && lab < bestLab) {
bestLab = lab;
}
}
return bestLab;
}

static Node buildTree(int[] idxs, int size, int depthLeft) {
Node node = new Node();
double currGini = giniOfLabels(idxs, size);
if (currGini == 0.0 || depthLeft == 0) {
node.isLeaf = true;
node.label = majorityLabel(idxs, size);
return node;
}

double bestGini = Double.POSITIVE_INFINITY;
int bestF = -1, bestT = 0;
int[] bestLeft = null, bestRight = null;
int bestLeftSize = 0, bestRightSize = 0;

// 枚举特征与阈值
for (int f = 0; f < 2; f++) {
for (int t : THRESH) {
int[] left = new int[size];
int[] right = new int[size];
int ls = 0, rs = 0;
for (int i = 0; i < size; i++) {
int idx = idxs[i];
double v = (f == 0) ? X1[idx] : X2[idx];
if (v < t) left[ls++] = idx;
else right[rs++] = idx;
}
if (ls == 0 || rs == 0) continue;
double gLeft = giniOfLabels(left, ls);
double gRight = giniOfLabels(right, rs);
double w = (ls * 1.0 / size) * gLeft + (rs * 1.0 / size) * gRight;

if (w < bestGini - 1e-12 || (Math.abs(w - bestGini) <= 1e-12 && (f < bestF || (f == bestF && t < bestT)))) {
bestGini = w;
bestF = f;
bestT = t;
bestLeft = left; bestRight = right;
bestLeftSize = ls; bestRightSize = rs;
}
}
}

if (bestLeft == null || bestGini >= currGini - 1e-12) {
node.isLeaf = true;
node.label = majorityLabel(idxs, size);
return node;
}

node.isLeaf = false;
node.feature = bestF;
node.threshold = bestT;
node.left = buildTree(Arrays.copyOf(bestLeft, bestLeftSize), bestLeftSize, depthLeft - 1);
node.right = buildTree(Arrays.copyOf(bestRight, bestRightSize), bestRightSize, depthLeft - 1);
return node;
}

static int predict(Node root, double x1, double x2) {
Node p = root;
while (!p.isLeaf) {
double v = (p.feature == 0) ? x1 : x2;
if (v < p.threshold) p = p.left;
else p = p.right;
}
return p.label;
}

static double trainsetGini() {
int[] idxs = new int[M];
for (int i = 0; i < M; i++) idxs[i] = i;
return giniOfLabels(idxs, M);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
M = sc.nextInt();
X1 = new double[M];
X2 = new double[M];
Y = new int[M];
for (int i = 0; i < M; i++) {
X1[i] = sc.nextDouble();
X2[i] = sc.nextDouble();
Y[i] = sc.nextInt();
}
double tx1 = sc.nextDouble();
double tx2 = sc.nextDouble();

// 训练集整体 Gini
double G = trainsetGini();

// 建树
int[] idxs = new int[M];
for (int i = 0; i < M; i++) idxs[i] = i;
Node root = buildTree(idxs, M, 5);

// 预测
int pred = predict(root, tx1, tx2);

System.out.printf("%.4f\n", G);
System.out.println(pred);
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

struct Node {
bool isLeaf = true;
int label = 0;
int feature = -1;   // 0: x1, 1: x2
int threshold = 0;  // 取自 {-3,-2,-1,0,1,2,3}
Node *left = nullptr, *right = nullptr;
};

static const int THRESH[7] = {-3, -2, -1, 0, 1, 2, 3};

int M;
vector<double> X1, X2;
vector<int> Y;

// 计算集合 Gini
double giniOfLabels(const vector<int>& idxs) {
int n = (int)idxs.size();
if (n == 0) return 0.0;
int cnt[32] = {0};
for (int id : idxs) cnt[Y[id]]++;
double s = 0.0, nn = (double)n;
for (int i = 0; i < 32; ++i) if (cnt[i] > 0) {
double p = cnt[i] / nn;
s += p * p;
}
return 1.0 - s;
}

// 多数类（并列取更小标签）
int majorityLabel(const vector<int>& idxs) {
int cnt[32] = {0};
for (int id : idxs) cnt[Y[id]]++;
int bestCnt = -1, bestLab = 0;
for (int lab = 0; lab < 32; ++lab) {
if (cnt[lab] > bestCnt) {
bestCnt = cnt[lab];
bestLab = lab;
} else if (cnt[lab] == bestCnt && cnt[lab] > 0 && lab < bestLab) {
bestLab = lab;
}
}
return bestLab;
}

Node* buildTree(const vector<int>& idxs, int depthLeft) {
Node* node = new Node();
double currGini = giniOfLabels(idxs);
if (currGini == 0.0 || depthLeft == 0) {
node->isLeaf = true;
node->label = majorityLabel(idxs);
return node;
}

double bestGini = 1e100;
int bestF = -1, bestT = 0;
vector<int> bestLeft, bestRight;

// 枚举特征与阈值
for (int f = 0; f < 2; ++f) {
for (int t : THRESH) {
vector<int> left, right;
left.reserve(idxs.size());
right.reserve(idxs.size());
for (int id : idxs) {
double v = (f == 0) ? X1[id] : X2[id];
if (v < t) left.push_back(id);
else right.push_back(id);
}
if (left.empty() || right.empty()) continue;
double gLeft = giniOfLabels(left);
double gRight = giniOfLabels(right);
double w = (left.size() * 1.0 / idxs.size()) * gLeft
+ (right.size() * 1.0 / idxs.size()) * gRight;
if (w < bestGini - 1e-12 || (fabs(w - bestGini) <= 1e-12 && (f < bestF || (f == bestF && t < bestT)))) {
bestGini = w;
bestF = f; bestT = t;
bestLeft.swap(left);
bestRight.swap(right);
}
}
}

if (bestLeft.empty() || bestGini >= currGini - 1e-12) {
node->isLeaf = true;
node->label = majorityLabel(idxs);
return node;
}

node->isLeaf = false;
node->feature = bestF;
node->threshold = bestT;
node->left = buildTree(bestLeft, depthLeft - 1);
node->right = buildTree(bestRight, depthLeft - 1);
return node;
}

int predict(Node* root, double x1, double x2) {
Node* p = root;
while (!p->isLeaf) {
double v = (p->feature == 0) ? x1 : x2;
if (v < p->threshold) p = p->left;
else p = p->right;
}
return p->label;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int M_in;
if (!(cin >> M_in)) return 0;
M = M_in;
X1.resize(M); X2.resize(M); Y.resize(M);
for (int i = 0; i < M; ++i) {
cin >> X1[i] >> X2[i] >> Y[i];
}
double tx1, tx2;
cin >> tx1 >> tx2;

// 训练集整体 Gini
vector<int> allIdx(M);
iota(allIdx.begin(), allIdx.end(), 0);
double G = giniOfLabels(allIdx);

// 建树并预测
Node* root = buildTree(allIdx, 5);
int pred = predict(root, tx1, tx2);

cout.setf(std::ios::fixed); cout << setprecision(4) << G << "\n";
cout << pred << "\n";
return 0;
}

---

### 第3题-子数组最大绝对差和（P4468）
- 链接：https://codefun2000.com/p/P4468

> 页面标题：#P4468. 第3题-子数组最大绝对差和

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给你两个数组，请你返回这两个数组长度相同的非空子数组的最大绝对差和。数组的绝对差和是指两个长度相同的数组，对应位置的数值的差的绝对值，然后求和。例如：数组111为[1 2][1\ 2][1 2]，数组222为[3 4][3\ 4][3 4]，它们的绝对差和是∣1−3∣+∣2−4∣=2+2=4|1-3| + |2-4| = 2 + 2 = 4∣1−3∣+∣2−4∣=2+2=4。数组的非空子数组是通过删除数组中某些元素（可能不删除）后剩余节点组成的数组，且不能改变数组的相对顺序。比如：[2 3 5][2\ 3\ 5][2 3 5]是[1 2 3 4 5][1\ 2\ 3\ 4\ 5][1 2 3 4 5]的一个子数组，而数组[1 5 3][1\ 5\ 3][1 5 3]则不是，因为顺序与原数组不一致。
输入描述
第1行：N，M，NN，M，NN，M，N表示数组1的长度，MMM表示数组222的长度。N,M的范围是[1,500][1,500][1,500]
第2行：数组111中的存储的数，个数为NNN，数组中数值的范围是[−1000,100][-1000,100][−1000,100]
第3行：数组222中存储的数，个数为MMM，数组中数值的范围是[−1000,100][-1000,100][−1000,100]
输出描述
子数组的最大绝对差和
样例1
输入
3 3
1 3 5
2 4 6

输出
6

说明
子数组长度为1的子数组的差和如下：
第1个数组长度为1的子数组[1]，第2个数组长度为1的子数组[2]，绝对差和为∣1−2∣=1|1-2|=1∣1−2∣=1
第1个数组长度为1的子数组[1]，第2个数组长度为1的子数组[4]，绝对差和为∣1−4∣=3|1-4|=3∣1−4∣=3
第1个数组长度为1的子数组[1]，第2个数组长度为1的子数组[6]，绝对差和为∣1−6∣=5|1-6|=5∣1−6∣=5
第1个数组长度为1的子数组[3]，第2个数组长度为1的子数组[2]，绝对差和为∣3−2∣=1|3-2|=1∣3−2∣=1
第1个数组长度为1的子数组[3]，第2个数组长度为1的子数组[4]，绝对差和为∣3−4∣=1|3-4|=1∣3−4∣=1
第1个数组长度为1的子数组[3]，第2个数组长度为1的子数组[6]，绝对差和为∣3−6∣=3|3-6|=3∣3−6∣=3
第1个数组长度为1的子数组[5]，第2个数组长度为1的子数组[2]，绝对差和为∣5−2∣=3|5-2|=3∣5−2∣=3
第1个数组长度为1的子数组[5]，第2个数组长度为1的子数组[4]，绝对差和为∣5−4∣=1|5-4|=1∣5−4∣=1
第1个数组长度为1的子数组[5]，第2个数组长度为1的子数组[6]，绝对差和为∣5−6∣=1|5-6|=1∣5−6∣=1
子数组长度为2的子数组的差和如下：
第1个数组长度为2的子数组[1,3]，第2个数组长度为2的子数组[2,4]，绝对差和为∣1−2∣+∣3−4∣=2|1-2|+|3-4|=2∣1−2∣+∣3−4∣=2
第1个数组长度为2的子数组[1,3]，第2个数组长度为2的子数组[4,6]，绝对差和为∣1−4∣+∣3−6∣=6|1-4|+|3-6|=6∣1−4∣+∣3−6∣=6
第1个数组长度为2的子数组[1,5]，第2个数组长度为2的子数组[2,4]，绝对差和为∣1−2∣+∣5−4∣=2|1-2|+|5-4|=2∣1−2∣+∣5−4∣=2
第1个数组长度为2的子数组[1,5]，第2个数组长度为2的子数组[4,6]，绝对差和为∣1−4∣+∣5−6∣=4|1-4|+|5-6|=4∣1−4∣+∣5−6∣=4
第1个数组长度为2的子数组[3,5]，第2个数组长度为2的子数组[2,4]，绝对差和为∣3−2∣+∣5−4∣=2|3-2|+|5-4|=2∣3−2∣+∣5−4∣=2
第1个数组长度为2的子数组[3,5]，第2个数组长度为2的子数组[4,6]，绝对差和为∣3−4∣+∣5−6∣=2|3-4|+|5-6|=2∣3−4∣+∣5−6∣=2
子数组长度为3的子数组的差和如下：
第1个数组长度为3的子数组[1,3,5]，第2个数组长度为3的子数组[2,4,6]，绝对差和为∣1−2∣+∣3−4∣+∣5−6∣=3|1-2|+|3-4|+|5-6|=3∣1−2∣+∣3−4∣+∣5−6∣=3
从数组1中得到子数组[1,3,5]，从数组2中得到子数组[4,6]，得到他们的最大绝对差和为
∣1−4∣+∣3−6∣=6|1-4|+|3-6|=6∣1−4∣+∣3−6∣=6
样例2
输入
2 2
1 2
3 4

输出
4

说明
子数组长度为1的子数组的差和如下：
第1个数组长度为1的子数组[1]，第2个数组长度为1的子数组[3]，绝对差和为∣1−3∣=2|1-3|=2∣1−3∣=2
第1个数组长度为1的子数组[1]，第2个数组长度为1的子数组[4]，绝对差和为∣1−4∣=3|1-4|=3∣1−4∣=3
第1个数组长度为1的子数组[2]，第2个数组长度为1的子数组[3]，绝对差和为∣2−3∣=1|2-3|=1∣2−3∣=1
第1个数组长度为1的子数组[2]，第2个数组长度为1的子数组[4]，绝对差和为∣2−4∣=2|2-4|=2∣2−4∣=2
子数组长度为2的子数组的差和如下：
第1个数组长度为2的子数组[1,2]，第2个数组长度为2的子数组[3,4]，绝对差和为∣1−3∣+∣2−4∣=4|1-3|+|2-4|=4∣1−3∣+∣2−4∣=4
最终：
从数组1中得到子数组[1,2]，数组2中得到子数组[3,4]，得到它们的最大绝对差和为
∣1−3∣+∣2−4∣=4|1-3|+|2-4|=4∣1−3∣+∣2−4∣=4

#### TextSol

解题思路
我们需要在两个数组中各选出一个非空子数组（实际上是“子序列”——可以删掉若干元素但保持相对顺序），要求两者长度相同，使得
∑∣xi−yi∣\sum |x_i - y_i|
∑∣xi​−yi​∣
最大，其中 xix_ixi​ 是第一个数组子数组中的元素，yiy_iyi​ 是第二个数组子数组中的对应元素。
把问题看成一个二维网格：

行是数组 A 的下标，列是数组 B 的下标。
如果我们选择把 A[i] 和 B[j] 配对，就相当于在网格中从 (i-1, j-1) 走到 (i, j)，并获得收益 ∣A[i]−B[j]∣|A[i]-B[j]|∣A[i]−B[j]∣。
也可以选择跳过 A[i]（从 (i-1, j) 来）或跳过 B[j]（从 (i, j-1) 来），收益不变。

这就是一个典型的动态规划问题，形式与 LCS（最长公共子序列）类似，只是“匹配”两元素时得到的是权值 ∣A[i]−B[j]∣|A[i]-B[j]|∣A[i]−B[j]∣。
设 dp[i][j] 表示使用 A 的前 i 个元素、B 的前 j 个元素能得到的最大绝对差和，则有转移：

跳过 A[i]：dp[i-1][j]
跳过 B[j]：dp[i][j-1]
同时取 A[i] 与 B[j] 作为一对：dp[i-1][j-1] + abs(A[i] - B[j])

取三者最大即可：
dp[i][j] = max(dp[i-1][j],dp[i][j-1], dp[i-1][j-1] + |A[i]-B[j]|)
边界：dp[0][*] = dp[*][0] = 0（选空子数组的得分为 0）。因为任意一对元素的绝对值差都 ≥ 0，所以最终 dp[N][M] 一定对应某个非空子数组（即使允许空子数组也不会更优），直接输出即可。
复杂度分析

时间复杂度：状态有 N * M 个，每个状态 O(1) 转移，故时间复杂度为 O(N * M)，在 N,M ≤ 500 时完全可行。
空间复杂度：使用二维数组存 dp，空间复杂度为 O(N * M)，约 25 万个整数，内存足够。若需要也可优化为两行滚动数组，但本题不必。

代码实现
Python
import sys

# 功能函数：计算两个数组子数组的最大绝对差和
def max_abs_diff_sum(a, b):
n = len(a)
m = len(b)
# dp[i][j] 表示使用 a 前 i 个、b 前 j 个的最大绝对差和
dp = [[0] * (m + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
ai = a[i - 1]
for j in range(1, m + 1):
# 三种转移：跳过 a[i]、跳过 b[j]、匹配 a[i] 和 b[j]
dp[i][j] = max(
dp[i - 1][j],                    # 跳过 a[i]
dp[i][j - 1],                    # 跳过 b[j]
dp[i - 1][j - 1] + abs(ai - b[j - 1])  # 匹配一对
)
return dp[n][m]

def main():
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
return
# 读取 N, M
N = data[0]
M = data[1]
# 读取两个数组
a = data[2:2 + N]
b = data[2 + N:2 + N + M]

ans = max_abs_diff_sum(a, b)
print(ans)

if __name__ == "__main__":
main()

Java
import java.util.*;

// ACM 风格主类名必须为 Main
public class Main {

// 功能函数：计算两个数组子数组的最大绝对差和
public static int maxAbsDiffSum(int[] a, int[] b) {
int n = a.length;
int m = b.length;
// dp[i][j] 表示使用 a 前 i 个、b 前 j 个的最大绝对差和
int[][] dp = new int[n + 1][m + 1];

for (int i = 1; i <= n; i++) {
int ai = a[i - 1];
for (int j = 1; j <= m; j++) {
// 跳过 a[i]
int skipA = dp[i - 1][j];
// 跳过 b[j]
int skipB = dp[i][j - 1];
// 匹配 a[i] 和 b[j]
int match = dp[i - 1][j - 1] + Math.abs(ai - b[j - 1]);
// 三者取最大
dp[i][j] = Math.max(Math.max(skipA, skipB), match);
}
}

return dp[n][m];
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取 N, M
if (!sc.hasNextInt()) {
return;
}
int N = sc.nextInt();
int M = sc.nextInt();

int[] a = new int[N];
int[] b = new int[M];

// 读取数组 1
for (int i = 0; i < N; i++) {
a[i] = sc.nextInt();
}
// 读取数组 2
for (int i = 0; i < M; i++) {
b[i] = sc.nextInt();
}

int ans = maxAbsDiffSum(a, b);
System.out.println(ans);

sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 功能函数：计算两个数组子数组的最大绝对差和
int maxAbsDiffSum(const vector<int> &a, const vector<int> &b) {
int n = (int)a.size();
int m = (int)b.size();
// dp[i][j] 表示使用 a 前 i 个、b 前 j 个的最大绝对差和
vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

for (int i = 1; i <= n; ++i) {
int ai = a[i - 1];
for (int j = 1; j <= m; ++j) {
// 跳过 a[i]
int skipA = dp[i - 1][j];
// 跳过 b[j]
int skipB = dp[i][j - 1];
// 匹配 a[i] 和 b[j]
int match = dp[i - 1][j - 1] + abs(ai - b[j - 1]);
// 三者取最大
dp[i][j] = max(max(skipA, skipB), match);
}
}
return dp[n][m];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, M;
if (!(cin >> N >> M)) {
return 0;
}

vector<int> a(N), b(M);
// 读取数组 1
for (int i = 0; i < N; ++i) {
cin >> a[i];
}
// 读取数组 2
for (int i = 0; i < M; ++i) {
cin >> b[i];
}

int ans = maxAbsDiffSum(a, b);
cout << ans << "\n";

return 0;
}

---

### 第3题-计算地形蓄水量（P4451）
- 链接：https://codefun2000.com/p/P4451

> 页面标题：#P4451. 第3题-计算地形蓄水量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个表示地图的矩阵，其中元素表示地形海拔高度。当一个地形块在水平和垂直方向均被海拔高度更高的地形包围时，该地形即可蓄水。
矩阵范围之外为海拔为 000，无法蓄水。
要求计算整块地图的蓄水量
输入描述
第 111 行:MMM NNN
MMM 是矩阵的宽，范围是 [1,300][1,300][1,300]
NNN 是矩阵的高，范围是 [1,300][1,300][1,300]
第 222 到第 N+1N+1N+1 行:X1X2…XMX_1X_2…X_MX1​X2​…XM​,为矩阵第一行，每个元素的范围是 [−500,8000][-500,8000][−500,8000]
输出描述
输出 111 个数字，表示地图中的中蓄水量。每个地块面积为 111 ，累加所有可蓄水地块的可蓄水的高度
样例1
输入
1 1
-10

输出
10

说明
第 111 行 111 111 表示该矩阵长宽均为 111
仅有一块海波为 −10-10−10 的地形，蓄水量为 10∗1=1010*1=1010∗1=10
样例2
输入
2 2
-500 -500
-500 -500

输出
2000

说明
第 111 行 222 222 表示矩阵宽和高均为 222
第 222 到 333 行表示矩阵为
−500-500−500 −500-500−500
−500-500−500 −500-500−500
则每块地的海拔为 −500-500−500 ，在地形上看出一个深度为 500500500 的湖，蓄水量为 500∗4=2000500*4=2000500∗4=2000
样例3
输入
4 5
0 2 3 4
2 -1 -1 4
2 0 -1 3
4 4 4 4
4 0 0 1

输出
11

说明
第 111 行 444 555 表示矩阵的宽为 444 ，高为 555
矩阵中如下位置可以蓄水的地块中有 333 块海拔为 −1-1−1，111 块海拔为 000 。周围海拔最低处为 222 ，所以有 333 个地块可以蓄水 3,13,13,1 个地块蓄水 222 。因此蓄水量为 3+3+3+2=113+3+3+2=113+3+3+2=11
000 222 333 444
222 -1 -1 444
222 0 -1 333
444 444 444 444
444 000 000 111
样例4
输入
4 4
0 2 3 4
2 0 0 4
2 0 0 3
4 4 4 4

输出
8

说明
第一行 444 444 表示矩阵的宽和高均为 444
矩阵中如下位置可以蓄水的面积为 444 海拔为 000 ，周围海拔最低处为 222 ，因此蓄水量为 4∗2=84*2=84∗2=8
000 222 333 444
222 0 0 444
222 0 0 333
444 444 444 444
示例图:

#### TextSol

解题思路

本题题面给出矩阵外的海平面高度为 0。

关键想法：从外到内逐层“抬高”水位。把能和外界连通的最低挡水高度维护在一个最小堆里，始终从当前最低的“边界”向内扩展。

具体算法（最小堆 + BFS）

建一个最小堆，初始把四周边界格入堆，但其有效高度取 max(原高度, 0)（因为外侧是海平面 0）。
同时，边界上若高度为负，需要先补到 0，因此将 -height 加到答案（这些格与海相邻，直接被海水填平到 0）。

弹出堆顶 (h, x, y)，向四邻扩展：

若邻格高度 nh < h，则该邻格可蓄水 h - nh，并把它的有效高度提升为 h；
将邻格以 max(nh, h) 压入堆。

直到堆空，累加值即为总蓄水量。

正确性：最小堆保证每次以当前可达最低的边界水位推进，等价于从外海（高度 0）向内涨水，不会遗漏或重复计算。

复杂度分析

设矩阵大小为 N × M（题面 N, M ≤ 300）。
每个格子最多进堆一次，堆操作 log(NM)，故时间复杂度为 O(NM log(NM))。
需要一个访问标记矩阵与堆，空间复杂度为 O(NM)。
在数据范围内完全可行。

代码实现
Python
# ACM 风格：主函数处理输入输出，核心逻辑写在函数里
import sys
import heapq

def total_water(m, n, a):
# m: 列数(宽), n: 行数(高)
if m == 0 or n == 0:
return 0
visited = [[False] * m for _ in range(n)]
heap = []
ans = 0

# 1) 处理边界：海平面为0，边界负高先被填到0
for i in range(n):
for j in range(m):
if i == 0 or i == n - 1 or j == 0 or j == m - 1:
h = a[i][j]
if h < 0:
ans += -h  # 被海水直接填到0
eff = h if h > 0 else 0  # 有效高度与海平面取max
heap.append((eff, i, j))
visited[i][j] = True
heapq.heapify(heap)

# 2) 从外向内，用最小堆逐层抬高水位
dirs = [(1, 0), (-1, 0), (0, 1), (0, -1)]
while heap:
h, x, y = heapq.heappop(heap)
for dx, dy in dirs:
nx, ny = x + dx, y + dy
if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny]:
nh = a[nx][ny]
if h > nh:
ans += h - nh      # 可蓄水
nh = h             # 抬到边界水位
visited[nx][ny] = True
heapq.heappush(heap, (nh, nx, ny))
return ans

def main():
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
return
m, n = data[0], data[1]  # 题面：先宽M再高N
a = []
idx = 2
for _ in range(n):
row = data[idx:idx + m]
idx += m
a.append(row)
print(total_water(m, n, a))

if __name__ == "__main__":
main()

Java
// ACM 风格：类名 Main，主函数读写，核心逻辑在静态函数里
import java.io.*;
import java.util.*;

public class Main {
static long solve(int m, int n, int[][] a) {
boolean[][] vis = new boolean[n][m];
// 小根堆：[高度, x, y]
PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(o -> o[0]));
long ans = 0;

// 1) 边界入堆（与海平面0比较），边界负高先被海水填平
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
int h = a[i][j];
if (h < 0) ans += -(long)h;
int eff = Math.max(h, 0);
pq.offer(new int[]{eff, i, j});
vis[i][j] = true;
}
}
}

int[] dx = {1, -1, 0, 0};
int[] dy = {0, 0, 1, -1};

// 2) 从外向内扩展
while (!pq.isEmpty()) {
int[] cur = pq.poll();
int h = cur[0], x = cur[1], y = cur[2];
for (int k = 0; k < 4; k++) {
int nx = x + dx[k], ny = y + dy[k];
if (nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {
int nh = a[nx][ny];
if (h > nh) {
ans += (long)h - nh; // 蓄水量
nh = h;              // 抬到水位线
}
vis[nx][ny] = true;
pq.offer(new int[]{nh, nx, ny});
}
}
}
return ans;
}

public static void main(String[] args) throws Exception {
// 根据范围，BufferedReader + StringTokenizer 足够
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
int m = Integer.parseInt(st.nextToken()); // 宽
int n = Integer.parseInt(st.nextToken()); // 高
int[][] a = new int[n][m];
for (int i = 0; i < n; i++) {
st = new StringTokenizer(br.readLine());
for (int j = 0; j < m; j++) {
a[i][j] = Integer.parseInt(st.nextToken());
}
}
System.out.println(solve(m, n, a));
}
}

C++
// C++11 兼容版：不使用结构化绑定/tuple
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

struct Node {
int h, x, y;
};
struct Cmp {
bool operator()(const Node& a, const Node& b) const {
return a.h > b.h; // 小根堆：高度小的优先
}
};

long long solve(int m, int n, const vector<vector<int>>& a) {
if (m == 0 || n == 0) return 0;
vector<vector<int>> vis(n, vector<int>(m, 0));
priority_queue<Node, vector<Node>, Cmp> pq;
long long ans = 0;

// 边界入堆（海平面为0），边界负高先被海水填到0
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {
int h = a[i][j];
if (h < 0) ans += -(long long)h;
int eff = h > 0 ? h : 0;
pq.push(Node{eff, i, j});
vis[i][j] = 1;
}
}
}

int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};

// 从外向内扩展
while (!pq.empty()) {
Node cur = pq.top(); pq.pop();
int h = cur.h, x = cur.x, y = cur.y;
for (int k = 0; k < 4; ++k) {
int nx = x + dx[k], ny = y + dy[k];
if (nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny]) {
int nh = a[nx][ny];
if (h > nh) {
ans += (long long)h - nh; // 蓄水
nh = h;                   // 抬到水位线
}
vis[nx][ny] = 1;
pq.push(Node{nh, nx, ny});
}
}
}
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int m, n; // 先宽M，再高N
if (!(cin >> m >> n)) return 0;
vector<vector<int>> a(n, vector<int>(m));
for (int i = 0; i < n; ++i)
for (int j = 0; j < m; ++j)
cin >> a[i][j];

cout << solve(m, n, a) << "\n";
return 0;
}

---

## 2025年11月6日-留学生AI方向

### 第2题-医疗诊断模型的训练与更新（P4447）
- 链接：https://codefun2000.com/p/P4447

> 页面标题：#P4447. 第2题-医疗诊断模型的训练与更新

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某智能医疗平台正在研发一套基于人工智能的自动疾病辅助诊断系统。例如，该系统通过对患者多次填写的症状问卷数据进行分析，帮助医生快速判断患者属子健康、感冒还是肺炎三类之一、每位患者在就诊前需填写一个包含多个症状的问题序列(如咳歌、发热、咽痛等);每条问卷的症状项被嵌入为特征向量，形成一个长度为 LLL 的症状序列，每个症状的特征维度为 DDD 。这些离散症状特征经过预处理后输入到诊断系统中。系统采用一层 MLPMLPMLP 进行特征映射，再使用一层 MLPMLPMLP 作为分类器输出各症状的预测概率，为简化考虑，输出率无需进行 sottmaxsottmaxsottmax 归一化。同时，MLPMLPMLP 层也无偏置项。请实现以下输出:

前向推理:输出预测概率( KKK 个，例如 K=3K=3K=3 时表示分类为健康/感冒/肺炎的概率)，并取症状维度的平均值作为输出

LOSSLOSSLOSS 计算:输出 MSEMSEMSE 损失 LOSSLOSSLOSS ; 定义为，$L_{m s c}=\frac{1}{K} \sum_{i=1}^{K}\left(y_{i}-\hat{y}_{i}\right)^{2}$
其中 KKK 为类别数， y1y_1y1​ 为真实概率， y^i2\hat{y}_{i}^{2}y^​i2​ 表示预测械率。

权重更新:输出单次反向传播后的权重。更新采用 SGDSGDSGD 优化器，定义为:
$W_{\text {new }}=W_{\text {old }}-\eta \nabla_{w} L$
其中 η\etaη 为学习率。

输入描述
第 111 行:序列长度 L∈[1,10]L∈[1,10]L∈[1,10]、特征维度 D∈[1,10]D∈[1,10]D∈[1,10]、分类数 K∈[2,5]K ∈[2,5]K∈[2,5]、学习率 η∈[0,1]\eta∈[0,1]η∈[0,1]
第 222 行:真实概率，KKK 个数
第 333 行:输入序列, L×DL×DL×D 个数
第 444 行:MLPMLPMLP 参数 WmlpW_{mlp}Wmlp​，D×DD×DD×D 个数
第 555 行:分类层参数 WclsW_{cls}Wcls​，D×KD×KD×K 个数
输出描述
第 111 行: KKK 个类别的预测概率
第 222 行:MSEMSEMSE LOSSLOSSLOSS，111 个数
第 333 行:MLPMLPMLP 更新后的参数 WmlpW_{mlp}Wmlp​，D×DD×DD×D 个数
第 444 行:分类层更新后的参数 WclsW_{cls}Wcls​，D×KD×KD×K 个数
注:数据间用运号隔开，输出结果均保留 222 位小数
样例1
输入
4,2,5,1.0
0.10,0.20,0.30,0.25,0.15
0.0,1.0,-1.5,2.5,3.0,-0.5,0.7,0.3
0.6,-0.4,0.2,0.9
0.5,0.1,-0.3,0.8,0.0,-0.2,0.4,0.6,-0.5,1.0

输出
0.14,0.26,0.16,0.13,0.52
0.04
0.61,-0.48,0.21,0.78
0.49,0.09,-0.27,0.82,-0.07,-0.21,0.39,0.63,-0.48,0.92

说明
输入:
第 111 行:序列长度 L=4L=4L=4、特征维度 D=2D=2D=2 、分类数 K=5K=5K=5、学习率 η=1.0η=1.0η=1.0
第 222 行:表示真实标签三分类的概率分别为 0.10,0.20,0.30,0.25,0.150.10,0.20,0.30,0.25,0.150.10,0.20,0.30,0.25,0.15
第 333 行:输入序列数据内容，4×2=84×2=84×2=8 个数
第 444 行: MLPMLPMLP 参数 WmlpW_{mlp}Wmlp​，2×22×22×2 个数
第 555 行:分类层参数 WclsW_{cls}Wcls​，2×52×52×5 个数
输出:
第 111 行:五分类的预测概率分别为 0.14,0.26,0.16,0.13,0.520.14,0.26,0.16,0.13,0.520.14,0.26,0.16,0.13,0.52
第 222 行: MSELOSSMSELOSSMSELOSS 为 0.040.040.04
第 333 行: MLPMLPMLP 更新后的参数 WmlpW_{mlp}Wmlp​
第 444 行:分类层更新后的参数 WclsW_{cls}Wcls​
样例2
输入
2,2,3,0.1
1.0,0.0,0.0
1.0,2.0,3.0,4.0
1.0,1.0,1.0,1.0
1.0,0.0,0.0,1.0,0.0,0.0

输出
5.00,0.00,0.00
5.33
0.47,-0.53,-0.80,0.20
0.47,0.00,0.00,0.20,0.00,0.00

说明
输入:
第 111 行:序列长度 L=2L=2L=2、特征维度 D=2D=2D=2 、分类数 K=3K=3K=3、学习率 η=0.1η=0.1η=0.1
第 222 行:表示真实标签三分类的概率分别为 1.0、0.0、0.01.0、0.0、0.01.0、0.0、0.0
第 333 行:输入序列数据内容，2×2=42×2=42×2=4 个数
第 444 行: MLPMLPMLP 参数 WmlpW_{mlp}Wmlp​，2×22×22×2 个数
第 555 行:分类层参数 WclsW_{cls}Wcls​，2×32×32×3 个数
输出:
第 111 行:三分类的预测概率分别为 5.00、0.00、0.005.00、0.00、0.005.00、0.00、0.00
第 222 行: MSELOSSMSELOSSMSELOSS 为 5.335.335.33
第 333 行: MLPMLPMLP 更新后的参数 WmlpW_{mlp}Wmlp​
第 444 行:分类层更新后的参数 WclsW_{cls}Wcls​

#### TextSol

解题思路
该题要求实现一个极简的序列分类器：对长度为 L 的症状序列（每步维度 D）进行两层线性映射（均为无偏置的 MLP 层），得到每步的 K 维预测，再对“序列维度”取平均作为最终 K 类输出；损失函数为 MSE。随后基于单样本进行一次 SGD 更新，输出更新后的两层权重。

模型与前向传播

记第 t 步输入为向量 xt∈RDx_t\in\mathbb{R}^Dxt​∈RD。

第一层 MLP（无偏置）：
$$h_t \;=\; x_t W_{\text{mlp}},\quad W_{\text{mlp}}\in\mathbb{R}^{D\times D}$$

分类层（无偏置）：
$$p_t \;=\; h_t W_{\text{cls}},\quad W_{\text{cls}}\in\mathbb{R}^{D\times K}$$

序列平均作为最终输出（无需 softmax）：
$$\hat{y} \;=\; \frac{1}{L}\sum_{t=1}^{L} p_t \;\in\; \mathbb{R}^{K}$$

损失函数
采用均方误差：

$$L \;=\; \frac{1}{K}\sum_{i=1}^{K}(\hat{y}_i - y_i)^2$$
反向传播与梯度

令
$$g \;=\; \frac{\partial L}{\partial \hat{y}} \;=\; \frac{2}{K}(\hat{y}-y) \;\in\; \mathbb{R}^{K}$$

因 y^=1L∑tpt\hat{y}=\frac{1}{L}\sum_t p_ty^​=L1​∑t​pt​，有
$$\frac{\partial L}{\partial p_t} \;=\; \frac{1}{L}g \quad(\forall t)$$

对分类层：
$$\frac{\partial L}{\partial W_{\text{cls}}}
\;=\;
\sum_{t} h_t^\top \left(\frac{1}{L}g\right)
\;=\;
\left(\frac{1}{L}\sum_t h_t\right)^\top g
\;\;\in\mathbb{R}^{D\times K}$$记 hˉ=1L∑tht \bar{h}=\frac{1}{L}\sum_t h_thˉ=L1​∑t​ht​，则 ∂L/∂Wcls=hˉ⊤g\partial L/\partial W_{\text{cls}}=\bar{h}^\top g∂L/∂Wcls​=hˉ⊤g（外积）。

对第一层：
$$\frac{\partial L}{\partial h_t}
\;=\;
\left(\frac{1}{L}g\right) W_{\text{cls}}^\top
\;=\;
\frac{1}{L}\, (W_{\text{cls}}g) \;\in\; \mathbb{R}^{D}$$$$\frac{\partial L}{\partial W_{\text{mlp}}}
\;=\;
\sum_t x_t^\top \left(\frac{1}{L}\,W_{\text{cls}}g\right)
\;=\;
\left(\frac{1}{L}\sum_t x_t\right)^\top (W_{\text{cls}}g)
\;\;\in\mathbb{R}^{D\times D}$$记 xˉ=1L∑txt\bar{x}=\frac{1}{L}\sum_t x_txˉ=L1​∑t​xt​，  v=Wclsg\;v=W_{\text{cls}}gv=Wcls​g，则 ∂L/∂Wmlp=xˉ⊤v\partial L/\partial W_{\text{mlp}}=\bar{x}^\top v∂L/∂Wmlp​=xˉ⊤v（外积）。

SGD 更新

$$W_{\text{mlp}} \leftarrow W_{\text{mlp}} - \eta \frac{\partial L}{\partial W_{\text{mlp}}},\quad
W_{\text{cls}} \leftarrow W_{\text{cls}} - \eta \frac{\partial L}{\partial W_{\text{cls}}}$$
输出格式

第 1 行：y^\hat{y}y^​（K 个，保留 2 位小数，逗号分隔）
第 2 行：MSE（1 个，保留 2 位小数）
第 3 行：更新后的 WmlpW_{\text{mlp}}Wmlp​（按行展开 D×D，保留 2 位）
第 4 行：更新后的 WclsW_{\text{cls}}Wcls​（按行展开 D×K，保留 2 位）

复杂度分析

前向：计算所有 hth_tht​ 与 ptp_tpt​：
O(L⋅D2)O(L\cdot D^2)O(L⋅D2)（第一层） + O(L⋅D⋅K)O(L\cdot D\cdot K)O(L⋅D⋅K)（分类层）。
反向：
计算 ggg：O(K)O(K)O(K)；
计算 hˉ\bar{h}hˉ：O(L⋅D)O(L\cdot D)O(L⋅D)；
计算 ∂L/∂Wcls\partial L/\partial W_{\text{cls}}∂L/∂Wcls​：O(D⋅K)O(D\cdot K)O(D⋅K)；
计算 v=Wclsgv=W_{\text{cls}}gv=Wcls​g：O(D⋅K)O(D\cdot K)O(D⋅K)；
计算 xˉ\bar{x}xˉ：O(L⋅D)O(L\cdot D)O(L⋅D)；
计算 ∂L/∂Wmlp\partial L/\partial W_{\text{mlp}}∂L/∂Wmlp​：O(D2)O(D^2)O(D2)。
总体时间复杂度：O(L⋅D2+L⋅D⋅K)O(L\cdot D^2 + L\cdot D\cdot K)O(L⋅D2+L⋅D⋅K)，在题目约束下（均 ≤10）非常合适。
空间复杂度：存储输入与权重及中间量，主要为 O(L⋅D+D2+D⋅K)O(L\cdot D + D^2 + D\cdot K)O(L⋅D+D2+D⋅K)。

代码实现
Python
import sys
import ast

# 将一行形如 "1,2,3" 的输入安全解析为列表
def parse_line(line: str):
return list(ast.literal_eval("[" + line.strip() + "]"))

# 前向计算与一次SGD更新，返回(y_hat, loss, Wmlp_new, Wcls_new)
def solve_once(L, D, K, eta, y_true, seq_flat, Wmlp_flat, Wcls_flat):
# 还原形状
X = [seq_flat[i*D:(i+1)*D] for i in range(L)]           # L x D
Wmlp = [Wmlp_flat[i*D:(i+1)*D] for i in range(D)]       # D x D（按行）
Wcls = [Wcls_flat[i*K:(i+1)*K] for i in range(D)]       # D x K（按行）

# 前向：h_t = x_t @ Wmlp，p_t = h_t @ Wcls
H_sum = [0.0]*D
P_avg = [0.0]*K
for t in range(L):
x = X[t]  # 长度D
# h = x @ Wmlp
h = [0.0]*D
for j in range(D):
s = 0.0
for d in range(D):
s += x[d] * Wmlp[d][j]
h[j] = s
# 累加 H_sum
for j in range(D):
H_sum[j] += h[j]
# p = h @ Wcls
p = [0.0]*K
for k in range(K):
s = 0.0
for j in range(D):
s += h[j] * Wcls[j][k]
p[k] = s
# 累加到平均（最后再除以L）
for k in range(K):
P_avg[k] += p[k]
P_avg = [v / L for v in P_avg]  # 预测 \hat{y}

# 计算 MSE
loss = 0.0
for k in range(K):
diff = (P_avg[k] - y_true[k])
loss += diff * diff
loss /= K

# 反向：g = (2/K) * (y_hat - y_true)
g = [(2.0 / K) * (P_avg[k] - y_true[k]) for k in range(K)]

# dL/dWcls = ( (sum_t h_t)/L )^T * g   （外积）
H_bar = [v / L for v in H_sum]  # D
dWcls = [[H_bar[j] * g[k] for k in range(K)] for j in range(D)]

# v = Wcls @ g    （D）
v = [0.0]*D
for j in range(D):
s = 0.0
for k in range(K):
s += Wcls[j][k] * g[k]
v[j] = s

# dL/dWmlp = ( (sum_t x_t)/L )^T * v   （外积）
X_sum = [0.0]*D
for t in range(L):
for d in range(D):
X_sum[d] += X[t][d]
X_bar = [v_ / L for v_ in X_sum]  # D
dWmlp = [[X_bar[i] * v[j] for j in range(D)] for i in range(D)]

# SGD 更新
for i in range(D):
for j in range(D):
Wmlp[i][j] -= eta * dWmlp[i][j]
for j in range(D):
for k in range(K):
Wcls[j][k] -= eta * dWcls[j][k]

# 展平权重并返回
Wmlp_new = [Wmlp[i][j] for i in range(D) for j in range(D)]
Wcls_new = [Wcls[j][k] for j in range(D) for k in range(K)]
return P_avg, loss, Wmlp_new, Wcls_new

def fmt_line(arr):
return ",".join(f"{x:.2f}" for x in arr)

def main():
lines = [line for line in sys.stdin if line.strip() != ""]
# 读取五行
L, D, K, eta = parse_line(lines[0])
y_true = parse_line(lines[1])
seq_flat = parse_line(lines[2])
Wmlp_flat = parse_line(lines[3])
Wcls_flat = parse_line(lines[4])

y_hat, loss, Wmlp_new, Wcls_new = solve_once(L, D, K, eta, y_true, seq_flat, Wmlp_flat, Wcls_flat)

print(fmt_line(y_hat))
print(f"{loss:.2f}")
print(fmt_line(Wmlp_new))
print(fmt_line(Wcls_new))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

/**
* ACM风格主类：读取输入，计算一次前向、MSE与SGD更新，输出结果
*/
public class Main {
// 将一行形如 "1,2,3" 的字符串解析为 double 列表
static double[] parseLine(String line) {
String s = line.trim().replace(",", " ");
String[] parts = s.split("\\s+");
double[] res = new double[parts.length];
for (int i = 0; i < parts.length; i++) res[i] = Double.parseDouble(parts[i]);
return res;
}

// 外积：a(D) ^T * b(M) -> D x M
static double[][] outer(double[] a, double[] b) {
int D = a.length, M = b.length;
double[][] out = new double[D][M];
for (int i = 0; i < D; i++) {
for (int j = 0; j < M; j++) {
out[i][j] = a[i] * b[j];
}
}
return out;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

// 读取五行
double[] line1 = parseLine(br.readLine());
int L = (int) line1[0];
int D = (int) line1[1];
int K = (int) line1[2];
double eta = line1[3];

double[] yTrue = parseLine(br.readLine());
double[] seqFlat = parseLine(br.readLine());
double[] WmlpFlat = parseLine(br.readLine());
double[] WclsFlat = parseLine(br.readLine());

// 还原矩阵
double[][] X = new double[L][D];
for (int i = 0; i < L; i++) {
System.arraycopy(seqFlat, i * D, X[i], 0, D);
}
double[][] Wmlp = new double[D][D];
for (int i = 0; i < D; i++) {
System.arraycopy(WmlpFlat, i * D, Wmlp[i], 0, D);
}
double[][] Wcls = new double[D][K];
for (int i = 0; i < D; i++) {
System.arraycopy(WclsFlat, i * K, Wcls[i], 0, K);
}

// 前向
double[] Hsum = new double[D];
double[] Pavg = new double[K];

for (int t = 0; t < L; t++) {
// h = x @ Wmlp
double[] h = new double[D];
for (int j = 0; j < D; j++) {
double s = 0.0;
for (int d0 = 0; d0 < D; d0++) s += X[t][d0] * Wmlp[d0][j];
h[j] = s;
}
for (int j = 0; j < D; j++) Hsum[j] += h[j];

// p = h @ Wcls
double[] p = new double[K];
for (int k = 0; k < K; k++) {
double s = 0.0;
for (int j = 0; j < D; j++) s += h[j] * Wcls[j][k];
p[k] = s;
}
for (int k = 0; k < K; k++) Pavg[k] += p[k];
}
for (int k = 0; k < K; k++) Pavg[k] /= L;

// MSE
double loss = 0.0;
for (int k = 0; k < K; k++) {
double diff = Pavg[k] - yTrue[k];
loss += diff * diff;
}
loss /= K;

// g = (2/K)*(y_hat - y_true)
double[] g = new double[K];
for (int k = 0; k < K; k++) g[k] = (2.0 / K) * (Pavg[k] - yTrue[k]);

// dWcls = (Hsum/L)^T * g
double[] Hbar = new double[D];
for (int j = 0; j < D; j++) Hbar[j] = Hsum[j] / L;
double[][] dWcls = outer(Hbar, g);

// v = Wcls @ g  (D)
double[] v = new double[D];
for (int j = 0; j < D; j++) {
double s = 0.0;
for (int k = 0; k < K; k++) s += Wcls[j][k] * g[k];
v[j] = s;
}

// dWmlp = (Xsum/L)^T * v
double[] Xsum = new double[D];
for (int t = 0; t < L; t++) for (int d0 = 0; d0 < D; d0++) Xsum[d0] += X[t][d0];
double[] Xbar = new double[D];
for (int d0 = 0; d0 < D; d0++) Xbar[d0] = Xsum[d0] / L;

double[][] dWmlp = outer(Xbar, v);

// SGD更新
for (int i = 0; i < D; i++) for (int j = 0; j < D; j++) Wmlp[i][j] -= eta * dWmlp[i][j];
for (int j = 0; j < D; j++) for (int k = 0; k < K; k++) Wcls[j][k] -= eta * dWcls[j][k];

// 输出
StringBuilder sb = new StringBuilder();

// 第1行：预测
for (int k = 0; k < K; k++) {
sb.append(String.format(java.util.Locale.US, "%.2f", Pavg[k]));
if (k + 1 < K) sb.append(",");
}
System.out.println(sb.toString());

// 第2行：MSE
System.out.println(String.format(java.util.Locale.US, "%.2f", loss));

// 第3行：Wmlp（行优先）
sb.setLength(0);
for (int i = 0; i < D; i++) {
for (int j = 0; j < D; j++) {
sb.append(String.format(java.util.Locale.US, "%.2f", Wmlp[i][j]));
if (!(i == D - 1 && j == D - 1)) sb.append(",");
}
}
System.out.println(sb.toString());

// 第4行：Wcls（行优先，D×K）
sb.setLength(0);
for (int j = 0; j < D; j++) {
for (int k = 0; k < K; k++) {
sb.append(String.format(java.util.Locale.US, "%.2f", Wcls[j][k]));
if (!(j == D - 1 && k == K - 1)) sb.append(",");
}
}
System.out.println(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 解析一行形如 "1,2,3" 为 double 数组
static vector<double> parseLine(const string& line) {
string s;
s.reserve(line.size());
for (char c : line) s.push_back(c == ',' ? ' ' : c);
stringstream ss(s);
vector<double> res; double x;
while (ss >> x) res.push_back(x);
return res;
}

// 外积：a(D) ^T * b(M) -> D x M
static vector<vector<double>> outer(const vector<double>& a, const vector<double>& b) {
int D = (int)a.size(), M = (int)b.size();
vector<vector<double>> out(D, vector<double>(M, 0.0));
for (int i = 0; i < D; ++i)
for (int j = 0; j < M; ++j)
out[i][j] = a[i] * b[j];
return out;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line;

// 读取五行
getline(cin, line);
vector<double> v1 = parseLine(line);
int L = (int)v1[0], D = (int)v1[1], K = (int)v1[2];
double eta = v1[3];

getline(cin, line);
vector<double> yTrue = parseLine(line);

getline(cin, line);
vector<double> seqFlat = parseLine(line);

getline(cin, line);
vector<double> WmlpFlat = parseLine(line);

getline(cin, line);
vector<double> WclsFlat = parseLine(line);

// 还原矩阵
vector<vector<double>> X(L, vector<double>(D, 0.0));
for (int i = 0; i < L; ++i)
for (int j = 0; j < D; ++j)
X[i][j] = seqFlat[i*D + j];

vector<vector<double>> Wmlp(D, vector<double>(D, 0.0));
for (int i = 0; i < D; ++i)
for (int j = 0; j < D; ++j)
Wmlp[i][j] = WmlpFlat[i*D + j];

vector<vector<double>> Wcls(D, vector<double>(K, 0.0));
for (int i = 0; i < D; ++i)
for (int k = 0; k < K; ++k)
Wcls[i][k] = WclsFlat[i*K + k];

// 前向
vector<double> Hsum(D, 0.0), Pavg(K, 0.0);

for (int t = 0; t < L; ++t) {
// h = x @ Wmlp
vector<double> h(D, 0.0);
for (int j = 0; j < D; ++j) {
double s = 0.0;
for (int d0 = 0; d0 < D; ++d0) s += X[t][d0] * Wmlp[d0][j];
h[j] = s;
}
for (int j = 0; j < D; ++j) Hsum[j] += h[j];

// p = h @ Wcls
vector<double> p(K, 0.0);
for (int k = 0; k < K; ++k) {
double s = 0.0;
for (int j = 0; j < D; ++j) s += h[j] * Wcls[j][k];
p[k] = s;
}
for (int k = 0; k < K; ++k) Pavg[k] += p[k];
}
for (int k = 0; k < K; ++k) Pavg[k] /= L;

// MSE
double loss = 0.0;
for (int k = 0; k < K; ++k) {
double diff = Pavg[k] - yTrue[k];
loss += diff * diff;
}
loss /= K;

// g = (2/K)*(y_hat - y_true)
vector<double> g(K, 0.0);
for (int k = 0; k < K; ++k) g[k] = (2.0 / K) * (Pavg[k] - yTrue[k]);

// dWcls = (Hsum/L)^T * g
vector<double> Hbar(D, 0.0);
for (int j = 0; j < D; ++j) Hbar[j] = Hsum[j] / L;
vector<vector<double>> dWcls = outer(Hbar, g);

// v = Wcls @ g
vector<double> v(D, 0.0);
for (int j = 0; j < D; ++j) {
double s = 0.0;
for (int k = 0; k < K; ++k) s += Wcls[j][k] * g[k];
v[j] = s;
}

// dWmlp = (Xsum/L)^T * v
vector<double> Xsum(D, 0.0), Xbar(D, 0.0);
for (int t = 0; t < L; ++t)
for (int d0 = 0; d0 < D; ++d0)
Xsum[d0] += X[t][d0];
for (int d0 = 0; d0 < D; ++d0) Xbar[d0] = Xsum[d0] / L;

vector<vector<double>> dWmlp = outer(Xbar, v);

// SGD 更新
for (int i = 0; i < D; ++i)
for (int j = 0; j < D; ++j)
Wmlp[i][j] -= eta * dWmlp[i][j];
for (int j = 0; j < D; ++j)
for (int k = 0; k < K; ++k)
Wcls[j][k] -= eta * dWcls[j][k];

// 输出：四行
cout.setf(std::ios::fixed); cout<<setprecision(2);

// 第1行：预测
for (int k = 0; k < K; ++k) {
if (k) cout << ",";
cout << Pavg[k];
}
cout << "\n";

// 第2行：MSE
cout << loss << "\n";

// 第3行：Wmlp（行优先）
for (int i = 0; i < D; ++i) {
for (int j = 0; j < D; ++j) {
if (i || j) cout << ",";
cout << Wmlp[i][j];
}
}
cout << "\n";

// 第4行：Wcls（行优先）
for (int j = 0; j < D; ++j) {
for (int k = 0; k < K; ++k) {
if (j || k) cout << ",";
cout << Wcls[j][k];
}
}
cout << "\n";

return 0;
}

---

### 第3题-卷积操作（P4448）
- 链接：https://codefun2000.com/p/P4448

> 页面标题：#P4448. 第3题-卷积操作

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

卷积神经网络常用于图像分类、检测与分割等图像任务。多通道卷积的计算公式是卷积神经网络 (CNN)(CNN)(CNN) 中的核心运算，请用代码实现多通道卷积操作。
输入:
inputinputinput: 形状为 (C,H_in,W_in)(C,H\_in,W\_in)(C,H_in,W_in) 的输入张量，CCC 为输入通道数，H_inH\_inH_in 为输入高度，W_inW\_inW_in 为输入宽度
kernelkernelkernel: 形状为 (C,K_h,K_w)(C,K\_h,K\_w)(C,K_h,K_w) 的卷积核，CCC 为输入通道数(和 inputinputinput 的 CCC 数值相同)，K_hK\_hK_h 为输入高度，K_wK\_wK_w 为输入宽度
stridestridestride:卷积步长(大于等于 111 的整数)
其中
0<C<60<C<60<C<6
2<H_in<102<H\_in<102<H_in<10
2<W_in<102 <W\_in < 102<W_in<10
0<K_h<70<K\_h<70<K_h<7
0<K_w<70<K\_w<70<K_w<7
0<stride<40 < stride < 40<stride<4
0=<padding=<30 =< padding = < 30=<padding=<3
卷积操作过程说明:
1.填充:在输入张量的上下左右各填充 “000” ，填充后的形状为 (C,H_in+2padding,W_in+2padding)(C,H\_in+2padding,W\_in+2padding)(C,H_in+2padding,W_in+2padding)。
2 滑动窗口计算:从填充后的输入张量的左上角开始，按照 stridestridestride 步长滑动卷积核，每次取与卷积核形状相同的子区域。若剩余区域尺寸小于卷积核尺寸，则跳过该位置。
3,逐通道计算:对于每个子区域，将卷积核与对应位置的输入值逐通道相乘后求和(中间计算过程不做四舍五入)，得到输出张量的一个值，计算公式为:$\operatorname{output}(i, j)=\sum_{c=0}^{C-1} \sum_{m=0}^{K_{b}-1} \sum_{n=0}^{K_{n}-1} \text { input }_{c}(i \times \text { stride }+m, j \times \text { stride }+n) \times \operatorname{kernel}_{c}(m, n)$
4.输出结果:将所有子区域的计算结果组合成 (H_out,W_out)(H\_out,W\_out)(H_out,W_out) 的输出张量。
输出:
形状为 (H_out,W_out)(H\_out, W\_out)(H_out,W_out) 的 2D2D2D 数组，其中:
H_out=(H_in+2∗padding−k)//stride+1H\_out=(H\_in + 2 * padding -k) // stride + 1H_out=(H_in+2∗padding−k)//stride+1
W_out=(W_in+2∗padding−K)//stride+1W\_out= (W\_in + 2 * padding - K) // stride +1W_out=(W_in+2∗padding−K)//stride+1
注: ////// 代表除法后向下取整

上图为单通道卷积 paddingpaddingpadding 为 111，stridestridestride 为 111 时示意图，多通道卷积时还需对各通道进行求和，题中不再绘制示意图
输入描述
第一行 C,H_in,W_inC,H\_in, W\_inC,H_in,W_in 表示输入的张量的通道数、行数与列数;
接下来的 C×H_inC × H\_inC×H_in 行是此张量的元素值;
接下来一行 C,K_h,K_wC,K\_h,K\_wC,K_h,K_w 是卷积核的通道数、行数与列数;
接下来 C×H_inC×H\_inC×H_in是卷积核的元素值;
最后一行是 stridestridestride paddingpaddingpadding
输出描述
输出卷积后形状为 (H_out,W_out)(H\_out,W\_out)(H_out,W_out) 的特征图(二维矩阵)，元素均为整数。
样例1
输入
2 3 3
1 2 3
4 5 6
7 8 9
2 3 4
5 6 7
8 9 10
2 2 2
1 0
0 1
2 0
0 2
1 0

输出
22 28
40 46

说明
第一行 222 333 333 表示输入的张量为 222 通道，每个通道的行数和列数均为 333
第 2−42-42−4 行是此张量第一通道的元素值
第 5−75-75−7 行是此张量第二通道的元素值
第 888 行的 222 222 222 是卷积核的形状，其通道数与输入张量一致，都是 222 ，行数和列数都是 222
第 9、109、109、10 行是此卷积核第 111 通道的元素值
第 11、1211、1211、12 行是此卷积核第 222 通道的元素值
最后一行 222 111 代表卷积操作中卷积窗滑动的步长 stridestridestride 为 111 ，paddingpaddingpadding 为 000

计算过程:

输出尺寸: H_out=13+2×0−2+1=2,W_out=2H\_out=13+2×0-2+1=2,W\_out=2H_out=13+2×0−2+1=2,W_out=2

输出矩阵位置 (0,0)(0,0)(0,0) 的计算过程如下:
通道 111 :窗口 [[1,2],[4,5]]→(1×1)+(2×0)+(4×0)+(5×1)=6[[1,2],[4,5]]→(1×1)+(2×0)+(4×0)+(5×1)=6[[1,2],[4,5]]→(1×1)+(2×0)+(4×0)+(5×1)=6
通道 222 :窗口 [[2,3],[5,6]]→(2×2)+(3×0)+(5×0)+(6×2)=4+12=16[[2,3],[5,6]]→(2×2)+(3×0)+(5×0)+(6×2)=4+12=16[[2,3],[5,6]]→(2×2)+(3×0)+(5×0)+(6×2)=4+12=16
各通道求和: 6+16=226+16=226+16=22

输出矩阵位置 (0,1)(0,1)(0,1) 和 (1,0)(1,0)(1,0) 元素计算过程略。

位置 (1,1)(1,1)(1,1) 计算:
通道 111 :窗口 [[5,6],[8,9]]→(5×1)+(6×0)+(8×0)+(9×1)=14[[5,6],[8,9]]→(5×1)+(6×0)+(8×0)+(9×1)=14[[5,6],[8,9]]→(5×1)+(6×0)+(8×0)+(9×1)=14
通道 222 :窗口 [[6,71,[9,10]]→(6×2)+(7×0)+(9×0)+(10×2)=12+20=32[[6,71,[9,10]]→(6×2)+(7×0)+(9×0)+(10×2)=12+20=32[[6,71,[9,10]]→(6×2)+(7×0)+(9×0)+(10×2)=12+20=32
各通道总和: 14+32=4614+32=4614+32=46

#### TextSol

解题思路
多通道卷积是卷积神经网络（CNN）中的核心运算。其本质是：在每个滑动位置，将输入在所有通道上的同形窗口与对应通道的卷积核做元素乘加（逐通道累加），得到一个标量作为该位置的输出值。

填充（padding）
按题意在输入张量四周补零，得到形状为
(C, Hin+2p, Win+2p)(C,\, H_{in}+2p,\, W_{in}+2p)(C,Hin​+2p,Win​+2p) 的新张量（p=paddingp=paddingp=padding）。

滑动窗口（stride）
以步长 sss（s=strides=strides=stride）在高、宽方向移动卷积核窗口。仅当窗口完全落在填充后的输入内时才计算。输出尺寸为
$$H_{out}=\left\lfloor\frac{H_{in}+2p-K_h}{s}\right\rfloor+1,\quad
W_{out}=\left\lfloor\frac{W_{in}+2p-K_w}{s}\right\rfloor+1$$

逐通道累加（核心计算）
在位置 (i,j)(i,j)(i,j) 处的输出值：
$$\text{out}(i,j)=\sum_{c=0}^{C-1}\sum_{m=0}^{K_h-1}\sum_{n=0}^{K_w-1}
X_c(i\cdot s+m,\ j\cdot s+n)\cdot K_c(m,n)$$其中 XXX 为填充后的输入，KKK 为卷积核。中间计算用整数即可（题面输出也为整数）。

实现方法

读入参数与数据，构造三维输入与核。
先做零填充，得到新三维数组。
依据上式三重（或四重）循环完成滑动与乘加。
输出 Hout×WoutH_{out}\times W_{out}Hout​×Wout​ 的二维矩阵。

本题无需使用快速傅里叶等高级算法，直接按定义实现即可，参数规模很小（C≤6,Hin,Win<10C\le 6, H_{in},W_{in}<10C≤6,Hin​,Win​<10）。
复杂度分析

时间复杂度：
对每个输出位置做 C×Kh×KwC\times K_h\times K_wC×Kh​×Kw​ 次乘加，输出一共 Hout×WoutH_{out}\times W_{out}Hout​×Wout​ 个位置，
$$O\big(H_{out}\cdot W_{out}\cdot C\cdot K_h\cdot K_w\big)$$在题目约束下规模很小，完全可行。

空间复杂度：
需要存储填充后的输入 O(C⋅(Hin+2p)⋅(Win+2p))O(C\cdot (H_{in}+2p)\cdot (W_{in}+2p))O(C⋅(Hin​+2p)⋅(Win​+2p))，卷积核 O(C⋅Kh⋅Kw)O(C\cdot K_h\cdot K_w)O(C⋅Kh​⋅Kw​)，以及输出 O(Hout⋅Wout)O(H_{out}\cdot W_{out})O(Hout​⋅Wout​)。总体为
$$O\big(C(H_{in}+2p)(W_{in}+2p)+C K_h K_w+H_{out}W_{out}\big)$$同样很小，合理。

代码实现
Python
import sys

# 多通道卷积：输入input_tensor和kernel均为三维列表
def conv_multi_channel(input_tensor, kernel, stride, padding):
C = len(input_tensor)
Hin = len(input_tensor[0])
Win = len(input_tensor[0][0])

Kh = len(kernel[0])
Kw = len(kernel[0][0])

# 计算输出尺寸
Hout = (Hin + 2 * padding - Kh) // stride + 1
Wout = (Win + 2 * padding - Kw) // stride + 1

# 1) 先做零填充
Hp = Hin + 2 * padding
Wp = Win + 2 * padding
padded = [[[0 for _ in range(Wp)] for _ in range(Hp)] for _ in range(C)]
for c in range(C):
for i in range(Hin):
for j in range(Win):
padded[c][i + padding][j + padding] = input_tensor[c][i][j]

# 2) 按定义滑动窗口并逐通道累加
output = [[0 for _ in range(Wout)] for _ in range(Hout)]
for i in range(Hout):
for j in range(Wout):
s = 0
base_i = i * stride
base_j = j * stride
for c in range(C):
for m in range(Kh):
for n in range(Kw):
s += padded[c][base_i + m][base_j + n] * kernel[c][m][n]
output[i][j] = s
return output

def main():
data = []
for line in sys.stdin:
line = line.strip()
if line:
data.extend(map(int, line.split()))
ptr = 0

# 读输入张量
C, Hin, Win = data[ptr], data[ptr+1], data[ptr+2]; ptr += 3
input_tensor = []
for _ in range(C):
ch = []
for _ in range(Hin):
row = data[ptr:ptr+Win]; ptr += Win
ch.append(row)
input_tensor.append(ch)

# 读卷积核
Ck, Kh, Kw = data[ptr], data[ptr+1], data[ptr+2]; ptr += 3
# 题目保证 Ck == C
kernel = []
for _ in range(Ck):
ch = []
for _ in range(Kh):
row = data[ptr:ptr+Kw]; ptr += Kw
ch.append(row)
kernel.append(ch)

# 读 stride 和 padding
stride, padding = data[ptr], data[ptr+1]

# 计算卷积
out = conv_multi_channel(input_tensor, kernel, stride, padding)

# 输出
for i in range(len(out)):
print(" ".join(str(x) for x in out[i]))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {

// 多通道卷积：inputTensor、kernel均为三维数组 [C][H][W]
static int[][] convMultiChannel(int[][][] inputTensor, int[][][] kernel, int stride, int padding) {
int C = inputTensor.length;
int Hin = inputTensor[0].length;
int Win = inputTensor[0][0].length;

int Kh = kernel[0].length;
int Kw = kernel[0][0].length;

int Hout = (Hin + 2 * padding - Kh) / stride + 1;
int Wout = (Win + 2 * padding - Kw) / stride + 1;

// 1) 零填充
int Hp = Hin + 2 * padding, Wp = Win + 2 * padding;
int[][][] padded = new int[C][Hp][Wp];
for (int c = 0; c < C; c++) {
for (int i = 0; i < Hin; i++) {
for (int j = 0; j < Win; j++) {
padded[c][i + padding][j + padding] = inputTensor[c][i][j];
}
}
}

// 2) 滑动窗口并逐通道累加
int[][] output = new int[Hout][Wout];
for (int i = 0; i < Hout; i++) {
for (int j = 0; j < Wout; j++) {
int sum = 0;
int baseI = i * stride;
int baseJ = j * stride;
for (int c = 0; c < C; c++) {
for (int m = 0; m < Kh; m++) {
for (int n = 0; n < Kw; n++) {
sum += padded[c][baseI + m][baseJ + n] * kernel[c][m][n];
}
}
}
output[i][j] = sum;
}
}
return output;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读入输入张量
int C = sc.nextInt(), Hin = sc.nextInt(), Win = sc.nextInt();
int[][][] inputTensor = new int[C][Hin][Win];
for (int c = 0; c < C; c++) {
for (int i = 0; i < Hin; i++) {
for (int j = 0; j < Win; j++) {
inputTensor[c][i][j] = sc.nextInt();
}
}
}

// 读入卷积核
int Ck = sc.nextInt(), Kh = sc.nextInt(), Kw = sc.nextInt();
int[][][] kernel = new int[Ck][Kh][Kw];
for (int c = 0; c < Ck; c++) {
for (int i = 0; i < Kh; i++) {
for (int j = 0; j < Kw; j++) {
kernel[c][i][j] = sc.nextInt();
}
}
}

// stride 和 padding
int stride = sc.nextInt(), padding = sc.nextInt();

int[][] out = convMultiChannel(inputTensor, kernel, stride, padding);

// 输出
StringBuilder sb = new StringBuilder();
for (int i = 0; i < out.length; i++) {
for (int j = 0; j < out[0].length; j++) {
if (j > 0) sb.append(' ');
sb.append(out[i][j]);
}
sb.append('\n');
}
System.out.print(sb.toString());
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 多通道卷积：输入和核均为三维 vector [C][H][W]
vector<vector<int>> conv_multi_channel(const vector<vector<vector<int>>>& input_tensor,
const vector<vector<vector<int>>>& kernel,
int stride, int padding) {
int C = (int)input_tensor.size();
int Hin = (int)input_tensor[0].size();
int Win = (int)input_tensor[0][0].size();

int Kh = (int)kernel[0].size();
int Kw = (int)kernel[0][0].size();

int Hout = (Hin + 2 * padding - Kh) / stride + 1;
int Wout = (Win + 2 * padding - Kw) / stride + 1;

// 1) 零填充
int Hp = Hin + 2 * padding, Wp = Win + 2 * padding;
vector<vector<vector<int>>> padded(C, vector<vector<int>>(Hp, vector<int>(Wp, 0)));
for (int c = 0; c < C; ++c) {
for (int i = 0; i < Hin; ++i) {
for (int j = 0; j < Win; ++j) {
padded[c][i + padding][j + padding] = input_tensor[c][i][j];
}
}
}

// 2) 滑动窗口并逐通道累加
vector<vector<int>> output(Hout, vector<int>(Wout, 0));
for (int i = 0; i < Hout; ++i) {
for (int j = 0; j < Wout; ++j) {
int sum = 0;
int base_i = i * stride;
int base_j = j * stride;
for (int c = 0; c < C; ++c) {
for (int m = 0; m < Kh; ++m) {
for (int n = 0; n < Kw; ++n) {
sum += padded[c][base_i + m][base_j + n] * kernel[c][m][n];
}
}
}
output[i][j] = sum;
}
}
return output;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读入输入张量
int C, Hin, Win;
if (!(cin >> C >> Hin >> Win)) return 0;
vector<vector<vector<int>>> input_tensor(C, vector<vector<int>>(Hin, vector<int>(Win)));
for (int c = 0; c < C; ++c) {
for (int i = 0; i < Hin; ++i) {
for (int j = 0; j < Win; ++j) {
cin >> input_tensor[c][i][j];
}
}
}

// 读入卷积核
int Ck, Kh, Kw;
cin >> Ck >> Kh >> Kw;
vector<vector<vector<int>>> kernel(Ck, vector<vector<int>>(Kh, vector<int>(Kw)));
for (int c = 0; c < Ck; ++c) {
for (int i = 0; i < Kh; ++i) {
for (int j = 0; j < Kw; ++j) {
cin >> kernel[c][i][j];
}
}
}

int stride, padding;
cin >> stride >> padding;

// 计算卷积
auto out = conv_multi_channel(input_tensor, kernel, stride, padding);

// 输出
for (int i = 0; i < (int)out.size(); ++i) {
for (int j = 0; j < (int)out[0].size(); ++j) {
if (j) cout << ' ';
cout << out[i][j];
}
cout << '\n';
}
return 0;
}

---

## 2025年11月5日-AI方向

### 第2题-多目标推荐排序模型优化（P4441）
- 链接：https://codefun2000.com/p/P4441

> 页面标题：#P4441. 第2题-多目标推荐排序模型优化

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

多目标学习的推荐排序模型需同时预测点击率（CTRCTRCTR，Click−ThroughClick-ThroughClick−Through RateRateRate）和转化率（CVR，CVR，CVR，ConversionConversionConversion RateRateRate），可采用线性回归的方式完成多目标建模，常见方法包括共享特征权重但保留任务特定偏置；在此使用联合损失函数：$\text{Loss} = \text{MSE}_{\text{CTR}} + \alpha \cdot \text{MSE}_{\text{CVR}}$ 优化共享权重和两个偏置，其中，MSEMSEMSE 表示标准均方误差损失，α\alphaα 表示加权系数，权重和偏置初始值从 000 开始，返回迭代 NNN 次后的平均联合损失值乘以 101010 的 101010 次方后的四舍五入结果（注意是损失值结果，而非梯度的结果）。
输入描述
第一行，输入特征集合，1,2;3,4;5,61,2;3,4;5,61,2;3,4;5,6
第二行，预测的 ctr/cvrctr/cvrctr/cvr 指标集合，0.1,0.01;0.5,0.05;0.9,0.090.1,0.01;0.5,0.05;0.9,0.090.1,0.01;0.5,0.05;0.9,0.09
第三行，迭代次数 (iterationiterationiteration)，100010001000
第四行，学习率，0.010.010.01
第五行，加权系数，0.50.50.5
符号解释: 分号前后隔开不同的样本，逗号隔开样本内的不同值
输出描述
输出联合损失值 ∗10* 10∗10 的 101010 次方的结果为 130106913010691301069
样例1
输入
1,1,1;2,2,2;3,3,3
1,0.5;2,1.0;3,1.5
500
0.01
0.5

输出
27356237

说明
输出联合损失值 101010 的 101010 次方的结果为 273562372735623727356237
样例2
输入
1,2;3,4;5,6
0.1,0.01;0.5,0.05;0.9,0.09
1000
0.01
0.5

输出
1301069

说明
输出联合损失值 101010 的 101010 次方 的结果为 130106913010691301069

#### TextSol

No testdata at current.

解题思路
本题要求在多目标推荐系统中同时预测点击率（CTR）和转化率（CVR），使用一个共享特征权重的线性模型，通过最小化联合损失函数来优化模型参数。其核心思想是利用多任务学习（Multi-Task Learning）思想，让两个任务在共享信息的同时保留自身的差异。
整体过程可以分为以下几个步骤：

模型结构设计
使用一个共享的线性层（即相同的权重向量）来提取通用特征，同时为两个任务分别设置一个独立的偏置项。

CTR 和 CVR 的预测值都由同一组权重与输入特征相乘得到，但加上不同的偏置。
这种结构能够让两个任务在共享信息的同时保留一定的灵活性。

损失函数构建
分别计算 CTR 与 CVR 的预测误差（平方误差），并按给定的权重系数 α 进行加权求和，得到联合损失值。

当 α 较大时，模型会更关注 CVR 的优化；当 α 较小时，模型更偏向优化 CTR。

参数优化方法
使用批量梯度下降法（Batch Gradient Descent）更新参数。

每次迭代计算预测值与真实值的差异，得到梯度方向。
根据学习率对权重和偏置进行反向更新。
所有参数初始值设为 0，按给定的学习率和迭代次数更新。

结果计算与输出
在完成全部迭代后，重新计算一次最终的联合损失值。

将最终损失值乘以 10¹⁰ 并进行四舍五入。
输出结果为一个整数。

关键思想总结

利用多任务共享机制，提升模型对不同目标的综合学习能力。
通过联合损失函数平衡 CTR 与 CVR 的优化。
采用标准的线性回归与梯度下降优化方式，算法逻辑简单、可解释性强。

复杂度分析
设样本数为 nnn，特征维度为 ddd，迭代次数为 NNN。

时间复杂度：每次迭代需要一次前向与一次反向，均为 O(nd)O(nd)O(nd)。总计 O(Nnd)O(Nnd)O(Nnd)。
空间复杂度：存储 w\mathbf{w}w 与少量中间量，O(d)O(d)O(d)；外加输入数据 O(nd)O(nd)O(nd)。整体 O(nd)O(nd)O(nd)（若仅按模型参数计则 O(d)O(d)O(d)）。

代码实现
Python
from ast import literal_eval
from decimal import Decimal, ROUND_HALF_UP
import sys

def parse_matrix(line: str):
# 将形如 "1,2;3,4" 转换为 "[[1,2],[3,4]]" 再 literal_eval
s = '[[' + line.strip().replace(';', '],[') + ']]'
mat = literal_eval(s)
# 转为 float
return [[float(v) for v in row] for row in mat]

def train_and_loss(X, Y, iters, lr, alpha):
n = len(X)
d = len(X[0])
# 参数初始化为 0
w = [0.0] * d
b_ctr = 0.0
b_cvr = 0.0

for _ in range(iters):
# 前向计算
yhat_ctr = [sum(w[j] * X[i][j] for j in range(d)) + b_ctr for i in range(n)]
yhat_cvr = [sum(w[j] * X[i][j] for j in range(d)) + b_cvr for i in range(n)]
e_ctr = [yhat_ctr[i] - Y[i][0] for i in range(n)]
e_cvr = [yhat_cvr[i] - Y[i][1] for i in range(n)]

# 梯度计算
grad_w = [0.0] * d
for j in range(d):
s = 0.0
for i in range(n):
s += (e_ctr[i] + alpha * e_cvr[i]) * X[i][j]
grad_w[j] = (2.0 / n) * s
grad_b_ctr = (2.0 / n) * sum(e_ctr)
grad_b_cvr = alpha * (2.0 / n) * sum(e_cvr)

# 参数更新
for j in range(d):
w[j] -= lr * grad_w[j]
b_ctr -= lr * grad_b_ctr
b_cvr -= lr * grad_b_cvr

# 最终损失
yhat_ctr = [sum(w[j] * X[i][j] for j in range(d)) + b_ctr for i in range(n)]
yhat_cvr = [sum(w[j] * X[i][j] for j in range(d)) + b_cvr for i in range(n)]
mse_ctr = sum((yhat_ctr[i] - Y[i][0]) ** 2 for i in range(n)) / n
mse_cvr = sum((yhat_cvr[i] - Y[i][1]) ** 2 for i in range(n)) / n
loss = mse_ctr + alpha * mse_cvr
return loss

def main():
lines = [line.rstrip('\n') for line in sys.stdin if line.strip() != '']
fea_line = lines[0]
lbl_line = lines[1]
iters = int(lines[2])
lr = float(lines[3])
alpha = float(lines[4])

X = parse_matrix(fea_line)
Y = parse_matrix(lbl_line)  # 每个样本形如 [ctr, cvr]

loss = train_and_loss(X, Y, iters, lr, alpha)

# 四舍五入到整数（HALF_UP）
val = Decimal(str(loss)) * Decimal('10000000000')
ans = val.to_integral_value(rounding=ROUND_HALF_UP)
print(f"{ans}")

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;

public class Main {

// 训练与计算损失的外部函数
static double trainAndLoss(double[][] X, double[][] Y, int iters, double lr, double alpha) {
int n = X.length;
int d = X[0].length;

double[] w = new double[d];
double bCtr = 0.0;
double bCvr = 0.0;

for (int t = 0; t < iters; t++) {
double[] yhatCtr = new double[n];
double[] yhatCvr = new double[n];
double[] eCtr = new double[n];
double[] eCvr = new double[n];

for (int i = 0; i < n; i++) {
double dot = 0.0;
for (int j = 0; j < d; j++) dot += w[j] * X[i][j];
yhatCtr[i] = dot + bCtr;
yhatCvr[i] = dot + bCvr;
eCtr[i] = yhatCtr[i] - Y[i][0];
eCvr[i] = yhatCvr[i] - Y[i][1];
}

double[] gradW = new double[d];
for (int j = 0; j < d; j++) {
double s = 0.0;
for (int i = 0; i < n; i++) s += (eCtr[i] + alpha * eCvr[i]) * X[i][j];
gradW[j] = (2.0 / n) * s;
}
double gradBCtr = 0.0, gradBCvr = 0.0;
for (int i = 0; i < n; i++) {
gradBCtr += eCtr[i];
gradBCvr += eCvr[i];
}
gradBCtr = (2.0 / n) * gradBCtr;
gradBCvr = alpha * (2.0 / n) * gradBCvr;

for (int j = 0; j < d; j++) w[j] -= lr * gradW[j];
bCtr -= lr * gradBCtr;
bCvr -= lr * gradBCvr;
}

// 最终损失
double mseCtr = 0.0, mseCvr = 0.0;
for (int i = 0; i < n; i++) {
double dot = 0.0;
for (int j = 0; j < d; j++) dot += w[j] * X[i][j];
double e1 = (dot + bCtr) - Y[i][0];
double e2 = (dot + bCvr) - Y[i][1];
mseCtr += e1 * e1;
mseCvr += e2 * e2;
}
mseCtr /= n;
mseCvr /= n;
return mseCtr + alpha * mseCvr;
}

static double[][] parseMatrix(String line) {
// 将 "1,2;3,4" 切分为二维数组
String[] rows = line.trim().split(";");
int n = rows.length;
String[] firstCols = rows[0].split(",");
int d = firstCols.length;

double[][] mat = new double[n][d];
for (int i = 0; i < n; i++) {
String[] cols = rows[i].trim().split(",");
for (int j = 0; j < d; j++) {
mat[i][j] = Double.parseDouble(cols[j]);
}
}
return mat;
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
String feaLine = sc.nextLine().trim();
String lblLine = sc.nextLine().trim();
int iters = Integer.parseInt(sc.nextLine().trim());
double lr = Double.parseDouble(sc.nextLine().trim());
double alpha = Double.parseDouble(sc.nextLine().trim());

double[][] X = parseMatrix(feaLine);
double[][] Y = parseMatrix(lblLine); // 每行 [ctr, cvr]

double loss = trainAndLoss(X, Y, iters, lr, alpha);

// 四舍五入到整数（HALF_UP），输出 Loss * 1e10
BigDecimal bd = BigDecimal.valueOf(loss).multiply(BigDecimal.valueOf(1e10));
bd = bd.setScale(0, RoundingMode.HALF_UP);
System.out.println(bd.toPlainString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 训练与损失计算函数（批量梯度下降）
double trainAndLoss(const vector<vector<double>>& X,
const vector<vector<double>>& Y,
int iters, double lr, double alpha) {
int n = (int)X.size();
int d = (int)X[0].size();

vector<double> w(d, 0.0);
double bCtr = 0.0, bCvr = 0.0;

for (int t = 0; t < iters; ++t) {
vector<double> yhatCtr(n, 0.0), yhatCvr(n, 0.0);
vector<double> eCtr(n, 0.0), eCvr(n, 0.0);

for (int i = 0; i < n; ++i) {
double dot = 0.0;
for (int j = 0; j < d; ++j) dot += w[j] * X[i][j];
yhatCtr[i] = dot + bCtr;
yhatCvr[i] = dot + bCvr;
eCtr[i] = yhatCtr[i] - Y[i][0];
eCvr[i] = yhatCvr[i] - Y[i][1];
}

vector<double> gradW(d, 0.0);
for (int j = 0; j < d; ++j) {
double s = 0.0;
for (int i = 0; i < n; ++i) s += (eCtr[i] + alpha * eCvr[i]) * X[i][j];
gradW[j] = (2.0 / n) * s;
}
double gradBCtr = 0.0, gradBCvr = 0.0;
for (int i = 0; i < n; ++i) {
gradBCtr += eCtr[i];
gradBCvr += eCvr[i];
}
gradBCtr = (2.0 / n) * gradBCtr;
gradBCvr = alpha * (2.0 / n) * gradBCvr;

for (int j = 0; j < d; ++j) w[j] -= lr * gradW[j];
bCtr -= lr * gradBCtr;
bCvr -= lr * gradBCvr;
}

// 最终损失
double mseCtr = 0.0, mseCvr = 0.0;
for (int i = 0; i < n; ++i) {
double dot = 0.0;
for (int j = 0; j < d; ++j) dot += w[j] * X[i][j];
double e1 = (dot + bCtr) - Y[i][0];
double e2 = (dot + bCvr) - Y[i][1];
mseCtr += e1 * e1;
mseCvr += e2 * e2;
}
mseCtr /= n;
mseCvr /= n;
return mseCtr + alpha * mseCvr;
}

static vector<vector<double>> parseMatrix(const string& line) {
// 将 "a,b;c,d" 解析为二维 double 数组
vector<vector<double>> mat;
stringstream ssRow(line);
string row;
while (getline(ssRow, row, ';')) {
stringstream ssCol(row);
string val;
vector<double> r;
while (getline(ssCol, val, ',')) {
r.push_back(stod(val));
}
mat.push_back(r);
}
return mat;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string feaLine, lblLine, s3, s4, s5;
getline(cin, feaLine);
getline(cin, lblLine);
getline(cin, s3);
getline(cin, s4);
getline(cin, s5);

int iters = stoi(s3);
double lr = stod(s4);
double alpha = stod(s5);

vector<vector<double>> X = parseMatrix(feaLine);
vector<vector<double>> Y = parseMatrix(lblLine); // 每个样本 [ctr, cvr]

double loss = trainAndLoss(X, Y, iters, lr, alpha);

// 四舍五入输出 Loss * 1e10
long long ans = llround(loss * 1e10);
cout << ans << "\n";
return 0;
}

疑似题目有问题，尝试多种思路依然无法通过样例

---

### 第2题-搜索广告相关性分数（P4444）
- 链接：https://codefun2000.com/p/P4444

> 页面标题：#P4444. 第2题-搜索广告相关性分数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在搜索广告系统中，广告商希望他们的广告能够精准地展示给搜索相关关键词的用户。为了提高广告的相关性，系统需要计算广告与搜索关键词之间的相关性得分。一个关键的相关性指标与keywords在广告标题是否出现及出现的位置权重有关。出现在越靠近标题开头的关键词权重越高。
相关性得分计算规则:
1、计算匹配度分，如下是根据广告标题中关键词出现方式来计算匹配度分。规则如下:
1)有序子序列:对于搜索关键词 "redredred shoesshoesshoes"和广告标题 “buybuybuy redredred runningrunningrunning shoesshoesshoes onlineonlineonline"，关键词 "redredred"和“shoesshoesshoes" 在广告标题中形成了一个有序的子序列"redredred shoesshoesshoes"，匹配度得分为 X1X1X1;
2)无序子序列:对于搜索关键词"shoesshoesshoes redredred"和广告标题"buybuybuy redrunningredrunningredrunning shoesshoesshoes onlineonlineonline"，广告标题包括所有的 redredred 和 shoesshoesshoes 两个关键词，匹配度得分为 X2X2X2 ;.
3)匹配关键词占比权重: kkk 表示搜索关键词单词个数，iii 表示搜索关键词中与广告标题中单词匹配个数，对于搜索关键词"shoesshoesshoes redredred ororor blackblackblack" 和广告标题"buybuybuy redredred runningrunningrunning shoesshoesshoes onlineonlineonline"，搜索关键词的 k=4k=4k=4 ，其中 shoesshoesshoes 和 redredred 匹配广告标题中的 redredred 和 shoes，i=2shoes，i=2shoes，i=2，匹配度得分为 X3∗i/kX3*i/kX3∗i/k。
4)除上述场景外，其他情况匹配度为 X4X4X4 分。
其中根据业务实际相关性标准，XiXiXi 系数 ∈[1.0,0.8.0.6,0]∈[1.0,0.8.0.6,0]∈[1.0,0.8.0.6,0]
2、计算位置权重
1)本题位置权重根据广告标题长度按线性袁减函数计算，如长度为 555 的广告标题，位置权重为 [1.0,0.75,0.5,0.25,0][1.0,0.75,0.5,0.25,0][1.0,0.75,0.5,0.25,0] ; 即: sum(weight=1.0−(pos/(ads_tiltle_length−1)))possum(weight= 1.0-(pos/(ads\_tiltle\_length -1)))possum(weight=1.0−(pos/(ads_tiltle_length−1)))pos 代表单个关键词位置，从索引 000 开始
2)若存在多个关键词，位置权重取求和
3)广告标题存在多个相同关键词，取第一个关键词索引权重
3、计算相关性分数
相关性分数 === 匹配分 ∗*∗ 位置权重，保留 444 位小数，向下取整。
函数需要返回每个搜索关键词与广告之间的相关性得分(浮点数列表，保留 444 位小数，向下取整)，相关性得分根据关键词在标题匹配度及其位置权重计算得出。(说明:匹配时忽略大小写)
输入描述
输入:现在有广告标题和检索的关键词列表输入格式:ad_title丨keywords1丨keywords2丨keywords3丨keywordsNad\_title丨keywords1丨keywords2丨keywords3丨keywordsNad_title丨keywords1丨keywords2丨keywords3丨keywordsN
描述:以”丨丨丨"分割，首位为广告标题，其余为关键词列表，测试样例中均为英文单词或字符组成。输入的关键词个数小于 100100100
输出描述
每个关键词对应的相关行得分(得分个数等于关键词个数，即也小于 100100100;保留 444 位小数，向下取整)，中间用 丨丨丨 分隔。比如 1.0000丨1.4000丨0.0750丨0.00001.0000丨1.4000丨0.0750丨0.00001.0000丨1.4000丨0.0750丨0.0000
样例1
输入
Advanced Camera: Capture Life in Stunning Detail! Elevate Your Photography with Our Cutting-Edge Camera!|Camera|Camera Photography|digital phone|phone

输出
0.9231|1.2308丨0.0000丨0.0000

样例2
输入
buy red running shoes online!|red shoes|buy shoes running|shoes black|Phone

输出
1.0000|1.4000|0.0750|0.0000

#### TextSol

解题思路

整体流程

将广告标题与每个关键词短语统一转成小写，并按规则分词：只保留字母、数字与连字符-，其它符号替换为空格后再按空格切分。

预处理标题：长度为 n 的标题，其位置权重为线性衰减：

n==1 时权重为 [1.0]；
否则第 i 个单词（0-based）的权重 w[i] = 1 - i/(n-1)。
同时记录每个单词首次出现的位置（若标题中有重复词，按规则只取第一次）。

对每个关键词短语，设其词序列为 q，长度为 k，与标题匹配得到：

有序子序列：q 在标题中按顺序出现（可不连续）→ 匹配分 X1=1.0
无序包含：q 的所有词都在标题中但顺序不一致 → 匹配分 X2=0.8
部分匹配：仅有 i 个词在标题中 → 匹配分 X3 * (i/k)，其中 X3=0.6
其余：X4=0.0
（匹配忽略大小写）

位置权重求和：将 q 中出现在标题里的每个词，取其在标题中第一次出现的权重并求和。

最终相关性分数：score = 匹配分 * 位置权重和。按四舍五入保留 4 位小数。

涉及算法

字符串预处理与分词（正则/字符过滤）
有序子序列判定（双指针扫描标题一次）
线性函数计算位置权重并哈希表记录首次出现位置

复杂度分析

设标题长度为 n，关键词短语个数为 m，第 j 个短语长度为 k_j。
预处理标题：O(n)；每个短语：有序判定 O(n)，其余统计 O(k_j)。
总时间复杂度 O(n + m·n + Σk_j)，题目数据（m<100）下完全可行。
额外空间：权重数组与哈希表 O(n)。

代码实现
Python
# -*- coding: utf-8 -*-
# 题面功能写在外部函数，主函数只做输入输出

import sys
import re
from decimal import Decimal, ROUND_HALF_UP

# 分词：仅保留字母/数字/连字符-，其余替换为空格
def tokenize(s: str):
s = s.lower()
s = re.sub(r'[^a-z0-9\-]+', ' ', s)
return [w for w in s.split() if w]

# 计算单个关键词短语的得分
def calc_one_score(title_tokens, weights, first_pos, query: str) -> str:
q = tokenize(query)
n = len(title_tokens)
# 位置权重求和（仅对出现过的词求和，且取首次出现位置）
pos_sum = 0.0
for w in q:
if w in first_pos:
pos_sum += weights[first_pos[w]]

# 有序子序列判定（双指针）
ordered = False
if len(q) > 0:
i = 0
for t in title_tokens:
if i < len(q) and q[i] == t:
i += 1
ordered = (i == len(q))

# 统计包含情况
all_present = len(q) > 0 and all(w in first_pos for w in q)
match_cnt = sum(1 for w in q if w in first_pos)

# 匹配分
X1, X2, X3, X4 = 1.0, 0.8, 0.6, 0.0
if len(q) == 0:
base = 0.0
elif ordered and all_present:
base = X1
elif all_present:
base = X2
elif match_cnt > 0:
base = X3 * (match_cnt / len(q))
else:
base = X4

val = base * pos_sum
# 四舍五入保留4位小数
res = Decimal(val).quantize(Decimal('0.0001'), rounding=ROUND_HALF_UP)
return f"{res:.4f}"

# 计算整行输入的所有得分
def solve(line: str) -> str:
parts = line.strip().split('|')
title = parts[0]
queries = parts[1:]

title_tokens = tokenize(title)
n = len(title_tokens)
if n == 0:
return '|'.join(['0.0000' for _ in queries])

# 位置权重
if n == 1:
weights = [1.0]
else:
weights = [1.0 - i / (n - 1) for i in range(n)]

# 每个词的首次出现位置
first_pos = {}
for i, w in enumerate(title_tokens):
if w not in first_pos:
first_pos[w] = i

# 逐个短语计算分数
scores = [calc_one_score(title_tokens, weights, first_pos, q) for q in queries]
return '|'.join(scores)

if __name__ == "__main__":
line = sys.stdin.readline().rstrip('\n')
print(solve(line))

Java
// 题面功能写在外部函数，主函数只做输入输出
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;

public class Main {

// 分词：仅保留字母/数字/连字符-，其它替换为空格
static List<String> tokenize(String s) {
s = s.toLowerCase().replaceAll("[^a-z0-9\\-]+", " ");
String[] arr = s.trim().isEmpty() ? new String[0] : s.trim().split("\\s+");
return Arrays.asList(arr);
}

// 四舍五入到4位小数并输出字符串（保留末尾0）
static String format4(double v) {
BigDecimal bd = new BigDecimal(v);
bd = bd.setScale(4, RoundingMode.HALF_UP);
return bd.toPlainString();
}

// 计算单个关键词短语的得分
static String calcOneScore(List<String> titleTokens, double[] weights,
Map<String, Integer> firstPos, String query) {
List<String> q = tokenize(query);

// 位置权重求和
double posSum = 0.0;
for (String w : q) {
Integer idx = firstPos.get(w);
if (idx != null) posSum += weights[idx];
}

// 有序子序列判定（双指针）
boolean ordered = false;
if (!q.isEmpty()) {
int i = 0;
for (String t : titleTokens) {
if (i < q.size() && q.get(i).equals(t)) i++;
}
ordered = (i == q.size());
}

// 包含情况
boolean allPresent = !q.isEmpty();
int matchCnt = 0;
for (String w : q) {
if (firstPos.containsKey(w)) matchCnt++;
else allPresent = false;
}

// 匹配分
double X1 = 1.0, X2 = 0.8, X3 = 0.6, X4 = 0.0;
double base;
if (q.isEmpty()) base = 0.0;
else if (ordered && allPresent) base = X1;
else if (allPresent) base = X2;
else if (matchCnt > 0) base = X3 * ((double) matchCnt / q.size());
else base = X4;

double val = base * posSum;
return format4(val);
}

static String solve(String line) {
String[] parts = line.split("\\|", -1); // 保留空段
String title = parts[0];
List<String> queries = new ArrayList<>();
for (int i = 1; i < parts.length; i++) queries.add(parts[i]);

List<String> titleTokens = tokenize(title);
int n = titleTokens.size();
if (n == 0) {
String[] zero = new String[queries.size()];
Arrays.fill(zero, "0.0000");
return String.join("|", zero);
}

// 位置权重
double[] weights = new double[n];
if (n == 1) weights[0] = 1.0;
else {
for (int i = 0; i < n; i++) weights[i] = 1.0 - (double) i / (n - 1);
}

// 首次出现位置
Map<String, Integer> firstPos = new HashMap<>();
for (int i = 0; i < n; i++) {
String w = titleTokens.get(i);
if (!firstPos.containsKey(w)) firstPos.put(w, i);
}

// 逐个短语计算
List<String> res = new ArrayList<>();
for (String q : queries) res.add(calcOneScore(titleTokens, weights, firstPos, q));
return String.join("|", res);
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line = br.readLine();
System.out.println(solve(line));
}
}

C++
// 题面功能写在外部函数，主函数只做输入输出
#include <bits/stdc++.h>
using namespace std;

// 分词：仅保留字母/数字/连字符-，其余替换为空格
vector<string> tokenize(const string& s0) {
string s = s0;
vector<string> res;
for (char& c : s) {
char x = tolower((unsigned char)c);
if ((x >= 'a' && x <= 'z') || (x >= '0' && x <= '9') || x == '-') c = x;
else c = ' ';
}
string tmp;
stringstream ss(s);
while (ss >> tmp) res.push_back(tmp);
return res;
}

// 四舍五入到4位小数
double round4(double x) {
return floor(x * 10000.0 + 0.5) / 10000.0;
}

// 计算单个关键词短语的得分
string calcOneScore(const vector<string>& titleTokens, const vector<double>& weights,
const unordered_map<string,int>& firstPos, const string& query) {
vector<string> q = tokenize(query);

// 位置权重求和
double posSum = 0.0;
for (const string& w : q) {
auto it = firstPos.find(w);
if (it != firstPos.end()) posSum += weights[it->second];
}

// 有序子序列判定
bool ordered = false;
if (!q.empty()) {
size_t i = 0;
for (const string& t : titleTokens) {
if (i < q.size() && q[i] == t) ++i;
}
ordered = (i == q.size());
}

// 包含统计
bool allPresent = !q.empty();
int matchCnt = 0;
for (const string& w : q) {
if (firstPos.count(w)) ++matchCnt;
else allPresent = false;
}

// 匹配分
const double X1 = 1.0, X2 = 0.8, X3 = 0.6, X4 = 0.0;
double base;
if (q.empty()) base = 0.0;
else if (ordered && allPresent) base = X1;
else if (allPresent) base = X2;
else if (matchCnt > 0) base = X3 * ( (double)matchCnt / (double)q.size() );
else base = X4;

double val = base * posSum;
double v = round4(val);

// 固定4位小数输出
ostringstream oss;
oss.setf(std::ios::fixed);
oss << setprecision(4) << v;
return oss.str();
}

string solve(const string& line) {
// 按 | 分割（保留空段）
vector<string> parts;
string cur;
for (size_t i = 0; i <= line.size(); ++i) {
if (i == line.size() || line[i] == '|') {
parts.push_back(cur);
cur.clear();
} else cur.push_back(line[i]);
}

string title = parts[0];
vector<string> queries(parts.begin() + 1, parts.end());

vector<string> titleTokens = tokenize(title);
int n = (int)titleTokens.size();
if (n == 0) {
string out;
for (size_t i = 0; i < queries.size(); ++i) {
if (i) out += "|";
out += "0.0000";
}
return out;
}

// 位置权重
vector<double> weights(n, 1.0);
if (n > 1) {
for (int i = 0; i < n; ++i) weights[i] = 1.0 - (double)i / (double)(n - 1);
}

// 首次出现位置
unordered_map<string,int> firstPos;
for (int i = 0; i < n; ++i) if (!firstPos.count(titleTokens[i])) firstPos[titleTokens[i]] = i;

// 逐个短语计算
string out;
for (size_t i = 0; i < queries.size(); ++i) {
if (i) out += "|";
out += calcOneScore(titleTokens, weights, firstPos, queries[i]);
}
return out;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
string line;
getline(cin, line);
cout << solve(line) << "\n";
return 0;
}

---

### 第3题-须从规矩出方圆（P4442）
- 链接：https://codefun2000.com/p/P4442

> 页面标题：#P4442. 第3题-须从规矩出方圆

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

钟师傅对像素画（PixelPixelPixel ArtArtArt）有独特的品味理解，他最近沉迷于用胶带拼图形贴画面海报，但是竟然后发现，像素画，每个 pixelpixelpixel 的长宽都是固定的。

一种像素圆的画法是，将每个像素块看成一个独立正方形，如果正方形和圆的交集面积大于 10−1010^{-10}10−10，则涂黑像素块。例如左图就是一个典型 25×2525\times2525×25 像素圆。可以看到每个像素的行宽和列宽是相同的，它占用原图的 533/(25∗25)=0.8528=85.28%533/(25*25)=0.8528=85.28\%533/(25∗25)=0.8528=85.28% 范围。而 π/4≈78.5398%\pi/4\approx78.5398\%π/4≈78.5398% 。
钟师傅喜欢精确的圆，因此他决定设计一种新的像素屏，专门为画圆而生，每行的间距和列间距不需要一样，为此它可以画出更精确的圆。
具体来说，如果给定像素是M×MM\times MM×M，那么钟师傅需要给出M−1M-1M−1个行宽变量和M−1M-1M−1个列高变量，  记出{xi},{yi}\{x_i\},\{y_i\}{xi​},{yi​}
固定 x0=y0=0,xM−1=yM−1=1x_0=y_0=0,x_{M-1}=y_{M-1}=1x0​=y0​=0,xM−1​=yM−1​=1，然后以 x=xi,y=yix=x_i,y=y_ix=xi​,y=yi​ 作 2M−22M-22M−2条直线，将(0,0)−(1,1)(0,0)-(1,1)(0,0)−(1,1)这个正方形划分成M×MM\times MM×M个小矩形。每个矩形被涂色当且仅当这个矩形和以 (0.5,0.5)(0.5,0.5)(0.5,0.5) 为圆心，半径为 0.50.50.5 的单位圆交集面积 >10−10>10^{-10}>10−10 。
例如 M=25,xi=yi=i25M=25,x_i=y_i=\frac{i}{25}M=25,xi​=yi​=25i​ ，对应的像素逼近圆就是左图。
如果更精细地设置 xxx 和 yyy 的间距，就能得到更好的逼近，目标是在 MMM 固定的前提下，把染色块的面积量最小化。右图是一种更优的设定方案，具体数值参考样例。
钟师傅为了找到 M=25M=25M=25 的划分已经耗尽了全部心力，他希望你帮忙找到其他 MMM 的最优划分方案，特别的，为了方便计算，本题的 MMM 都是奇数。
输入描述
一行一个整数，MMM，输入保证 5≤M≤2005 \le M \le 2005≤M≤200，并且 MMM 是奇数。
输出描述
输出最优染色面积，精确到小数点后 444 位。
例如 M=25M=25M=25 的最优答案约为 0.8107678480.8107678480.810767848 ，那么四舍五入后，你应该输出 0.81080.81080.8108
样例1
输入
5

输出
0.8784

说明
M=5M=5M=5 的最优划分见下图：

面积约为 0.87841489310.87841489310.8784148931
划分方案：
x1=y1=0.08824681693923937x_1 = y_1 = 0.08824681693923937x1​=y1​=0.08824681693923937
x2=y2=0.2163464855861515x_2 = y_2 = 0.2163464855861515x2​=y2​=0.2163464855861515
x3=y3=0.7836535144138486x_3 = y_3 = 0.7836535144138486x3​=y3​=0.7836535144138486
x4=y4=0.911753183060766x_4 = y_4 = 0.911753183060766x4​=y4​=0.911753183060766
样例2
输入
25

输出
0.8108

说明
最优分布：
x1=y1=0.014219468994025153x_1 = y_1 = 0.014219468994025153x1​=y1​=0.014219468994025153
x2=y2=0.032278207527408176x_2 = y_2 = 0.032278207527408176x2​=y2​=0.032278207527408176
x3=y3=0.053248663959798335x_3 = y_3 = 0.053248663959798335x3​=y3​=0.053248663959798335
x4=y4=0.07678775198872612x_4 = y_4 = 0.07678775198872612x4​=y4​=0.07678775198872612
x5=y5=0.10277889747804814x_5 = y_5 = 0.10277889747804814x5​=y5​=0.10277889747804814
x6=y6=0.1312450507717095x_6 = y_6 = 0.1312450507717095x6​=y6​=0.1312450507717095
x7=y7=0.1623318383092049x_7 = y_7 = 0.1623318383092049x7​=y7​=0.1623318383092049
x8=y8=0.1963301205070792x_8 = y_8 = 0.1963301205070792x8​=y8​=0.1963301205070792
x9=y9=0.23374562325992837x_9 = y_9 = 0.23374562325992837x9​=y9​=0.23374562325992837
x10=y10=0.27547112225909104x_{10} = y_{10} = 0.27547112225909104x10​=y10​=0.27547112225909104
x11=y11=0.3232619881117089x_{11} = y_{11} = 0.3232619881117089x11​=y11​=0.3232619881117089
x12=y12=0.381605423707194x_{12} = y_{12} = 0.381605423707194x12​=y12​=0.381605423707194
x13=y13=0.618394576292806x_{13} = y_{13} = 0.618394576292806x13​=y13​=0.618394576292806
x14=y14=0.6767380118882911x_{14} = y_{14} = 0.6767380118882911x14​=y14​=0.6767380118882911
x15=y15=0.7245288777409089x_{15} = y_{15} = 0.7245288777409089x15​=y15​=0.7245288777409089
x16=y16=0.7662543767400716x_{16} = y_{16} = 0.7662543767400716x16​=y16​=0.7662543767400716
x17=y17=0.8036698794929208x_{17} = y_{17} = 0.8036698794929208x17​=y17​=0.8036698794929208
x18=y18=0.8376681616690795x_{18} = y_{18} = 0.8376681616690795x18​=y18​=0.8376681616690795
x19=y19=0.8687549492282904x_{19} = y_{19} = 0.8687549492282904x19​=y19​=0.8687549492282904
x20=y20=0.897221105219519x_{20} = y_{20} = 0.897221105219519x20​=y20​=0.897221105219519
x21=y21=0.9232122480112739x_{21} = y_{21} = 0.9232122480112739x21​=y21​=0.9232122480112739
x22=y22=0.94675136660420166x_{22} = y_{22} = 0.94675136660420166x22​=y22​=0.94675136660420166
x23=y23=0.9677217924725918x_{23} = y_{23} = 0.9677217924725918x23​=y23​=0.9677217924725918
x24=y24=0.9857805310059748x_{24} = y_{24} = 0.9857805310059748x24​=y24​=0.9857805310059748
提示

如果确定了所有 yiy_iyi​ 的值，那么 xix_ixi​ 的值也可以确定。考虑我们已经确定最优解需要用到轴线 y=ay=ay=a ，只要 aaa 不等于 0.50.50.5 ，那么 y=ay=ay=a 与圆会有两个交点 (b,a)(b,a)(b,a) 和 (c,a)(c,a)(c,a) ，那么最优解一定有轴线 x=bx=bx=b 和 x=cx=cx=c ，否则我们可以通过调整，得到面积更小的染色方案。即，可以通过 {yi}\{y_i\}{yi​} 确定潜在的 {xi}\{x_i\}{xi​} 。

这样我们可以列出式子，把最小化 lossXY({xi},{yi})lossXY(\{x_i\},\{y_i\})lossXY({xi​},{yi​}) 变成 lossY({yi})lossY(\{y_i\})lossY({yi​}) 的问题。而且 lossYlossYlossY 会有比较容易求导。

可以考虑用某些编程语言自带的优化求解器（例如 numpynumpynumpy），或者自己实现梯度下降等优化方式，完成最优解求解。

#### TextSol

题解思路
1. 对称化 + 角度参数化
圆心在 (12,12)(\tfrac12,\tfrac12)(21​,21​)，半径 r=12r=\tfrac12r=21​。最优网格一定关于水平 [0,r]×[0,r][0,r]\times[0,r][0,r]×[0,r] 里描述边界，再用对称扩展到整圆。
设我们在第一象限里取若干条水平线 y=rsin⁡θy=r\sin\thetay=rsinθ 与竖直线 x=rcos⁡θx=r\cos\thetax=rcosθ（θ∈(0,π4)\theta\in(0,\tfrac\pi4)θ∈(0,4π​)）。给定一组严格递增的角度
$$0<\theta_1<\theta_2<\cdots<\theta_p<\frac{\pi}{4},$$就得到一组“关键高度/宽度”
$$U=\bigl[r\sin\theta_1,\ldots,r\sin\theta_p\bigr]
\quad(+\ r/\sqrt2\text{ 若 }k\text{ 为奇})\quad
\cup\ \bigl[r\cos\theta_p,\ldots,r\cos\theta_1\bigr],$$并在两端补上 000 与 rrr。这里

MMM 为像素边长，令 k=M−12k=\frac{M-1}{2}k=2M−1​（第一象限中除去边界的“层数”），
p=⌊k2⌋p=\left\lfloor \frac{k}{2}\right\rfloorp=⌊2k​⌋ 是需要优化的角度个数；若 kkk 为奇，还需在中间插入 r/2r/\sqrt2r/2​（对应主对角线）。

关键事实（题面提示 1）： 若最优解使用了水平线 y=a≠r/2y=a\ne r/\sqrt2y=a=r/2​，则必有与圆的两个交点 (b,a)(b,a)(b,a), (c,a)(c,a)(c,a) 的竖线 x=b,x=cx=b,x=cx=b,x=c 同时出现，否则可微调使面积更小。因此用一组 {θi}\{\theta_i\}{θi​} 就能同时确定全部水平/竖直分割线。
2. 面积公式（四倍化）
把上述 UUU 排好序，并在首尾补上 000 与 rrr，得到 Ufull=[0,U,r]U_\text{full}=[0, U, r]Ufull​=[0,U,r]。
第一象限被分成 K+1K+1K+1 条水平条带（K=∣U∣K=|U|K=∣U∣），第 iii 条条带高为
Δyi=Ufull[i]−Ufull[i−1],\Delta y_i=U_\text{full}[i]-U_\text{full}[i-1],
Δyi​=Ufull​[i]−Ufull​[i−1],
对应可被“染色”的横向宽度上界等于和它关于主对角线镜像位置的“xxx-截距”，也就是
Xi=Ufull[K−i+2].X_i = U_\text{full}[K-i+2].
Xi​=Ufull​[K−i+2].
于是第一象限的像素覆盖面积为
S1/4=∑i=1K+1Δyi⋅Xi,S_{1/4}=\sum_{i=1}^{K+1}\Delta y_i\cdot X_i,
S1/4​=i=1∑K+1​Δyi​⋅Xi​,
全图面积为 S=4S1/4S=4S_{1/4}S=4S1/4​。
3. 优化：坐标下降 + 1D 黄金分割
把目标写成 S(θ1,…,θp)S(\theta_1,\ldots,\theta_p)S(θ1​,…,θp​)。我们采用坐标下降：依次固定其他角，只对 θi\theta_iθi​ 在合法区间 (θi−1,θi+1)(\theta_{i-1},\theta_{i+1})(θi−1​,θi+1​) 内做一维极小化。
一维极小化使用黄金分割搜索。反复扫若干轮，若一轮没有任何角更新则停止。

初值：θi=i+1p+1⋅π4\theta_i=\dfrac{i+1}{p+1}\cdot \dfrac{\pi}{4}θi​=p+1i+1​⋅4π​ 均匀分布。
收敛：通常数十轮内稳定，对 M≤200M\le200M≤200 足够。

4. 输出
用四舍五入到 4 位小数（HALF_UP） 输出最小面积。
复杂度

每次评估 total_area 为 O(K)=O(M)O(K)=O(M)O(K)=O(M)。
每轮对每个 θi\theta_iθi​ 做常数次函数评估（黄金分割 < ⁣120<\!120<120 次）。
总复杂度约 O(迭代轮数⋅p⋅120⋅M)O(\text{迭代轮数}\cdot p \cdot 120 \cdot M)O(迭代轮数⋅p⋅120⋅M)，对 M≤200M\le 200M≤200 运行很快。

Python 参考实现
import sys
import math
from decimal import Decimal, ROUND_HALF_UP

def build_U_from_thetas(thetas, r, k):

U = [r * math.sin(t) for t in thetas]
if k % 2 == 1:
U.append(r / math.sqrt(2.0))
U += [r * math.cos(t) for t in reversed(thetas)]
return [0.0] + U + [r]

def total_area(thetas, r, k):
U_full = build_U_from_thetas(thetas, r, k)
K = len(U_full) - 2  # because U_full = [0] + U + [r]
s = 0.0
# i in [1, K+1]
for i in range(1, K + 2):
dy = U_full[i] - U_full[i - 1]
x_cap = U_full[K - i + 2]
s += dy * x_cap
return 4.0 * s

def golden_section_minimize(f, lo, hi, max_it=120, tol=1e-13):
golden = (math.sqrt(5.0) - 1.0) / 2.0
a, b = lo, hi
c = b - golden * (b - a)
d = a + golden * (b - a)
fc, fd = f(c), f(d)
it = 0

while (b - a) > tol and it < max_it:
if fc > fd:
a, c, fc = c, d, fd
d = a + golden * (b - a)
fd = f(d)
else:
b, d, fd = d, c, fc
c = b - golden * (b - a)
fc = f(c)
it += 1

return (a + b) / 2.0

def optimize_thetas(M):
r = 0.5
k = (M - 1) // 2
p = k // 2

if p == 0:
return total_area([], r, k)

thetas = [ (i + 1) * (math.pi / 4.0) / (p + 1) for i in range(p) ]

# outer coordinate-descent rounds
for _ in range(30):
changed = False
for i in range(p):
lo = thetas[i - 1] + 1e-12 if i > 0 else 1e-12
hi = thetas[i + 1] - 1e-12 if i < p - 1 else (math.pi / 4.0) - 1e-12

def f(x):
tmp = list(thetas)
tmp[i] = x
return total_area(tmp, r, k)

new_theta = golden_section_minimize(f, lo, hi, max_it=120, tol=1e-13)
if abs(new_theta - thetas[i]) > 1e-15:
thetas[i] = new_theta
changed = True

if not changed:
break

return total_area(thetas, r, k)

def main():
M = int(sys.stdin.readline().strip())
ans = optimize_thetas(M)
out = Decimal(str(ans)).quantize(Decimal('0.0001'), rounding=ROUND_HALF_UP)
print(out)

if __name__ == "__main__":
main()

C++ 参考实现
#include <bits/stdc++.h>
using namespace std;

static inline double total_area_from_thetas(const vector<double>& thetas, double r, int k){
vector<double> U;
U.reserve(thetas.size()*2 + 1);
for(double t: thetas) U.push_back(r * sin(t));
if(k % 2 == 1) U.push_back(r / sqrt(2.0));
for(int i=(int)thetas.size()-1;i>=0;--i) U.push_back(r * cos(thetas[i]));

vector<double> F; F.reserve(U.size()+2);
F.push_back(0.0); for(double v: U) F.push_back(v); F.push_back(r);

int K = (int)F.size() - 2; // U.size()
double s = 0.0;
for(int i=1;i<=K+1;i++){
double dy = F[i] - F[i-1];
double xcap = F[K - i + 2];
s += dy * xcap;
}
return 4.0 * s;
}

static inline double golden_section_minimize(function<double(double)> f,
double lo, double hi,
int max_it=120, double tol=1e-13){
const double golden = (sqrt(5.0)-1.0)/2.0;
double a=lo, b=hi;
double c = b - golden*(b-a);
double d = a + golden*(b-a);
double fc = f(c), fd = f(d);
int it=0;
while((b-a)>tol && it<max_it){
if(fc > fd){
a = c; c = d; fc = fd;
d = a + golden*(b-a);
fd = f(d);
}else{
b = d; d = c; fd = fc;
c = b - golden*(b-a);
fc = f(c);
}
++it;
}
return (a+b)/2.0;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
int M;
if(!(cin>>M)) return 0;

double r = 0.5;
int k = (M - 1) / 2;
int p = k / 2;

vector<double> thetas;
if(p>0){
thetas.resize(p);
for(int i=0;i<p;i++){
thetas[i] = (i+1) * (M_PI/4.0) / (p+1);
}
for(int round=0; round<30; ++round){
bool changed=false;
for(int i=0;i<p;i++){
double lo = (i>0? thetas[i-1] : 0.0) + 1e-12;
double hi = (i<p-1? thetas[i+1] : M_PI/4.0) - 1e-12;

auto f = [&](double x){
auto tmp = thetas;
tmp[i] = x;
return total_area_from_thetas(tmp, r, k);
};

double new_theta = golden_section_minimize(f, lo, hi, 120, 1e-13);
if(fabs(new_theta - thetas[i]) > 1e-15){
thetas[i] = new_theta;
changed = true;
}
}
if(!changed) break;
}
}

double ans = total_area_from_thetas(thetas, r, k);

// 输出四舍五入到 4 位小数（HALF_UP）
// 用 i/o manipulators 即可满足，本题数据不会卡到精度奇点
cout.setf(std::ios::fixed);
cout<<setprecision(4)<<ans<<"\n";
return 0;
}

Java 参考实现
import java.io.*;
import java.math.*;
import java.util.*;

public class Main {

static double r = 0.5;

static double totalAreaFromThetas(double[] thetas, int k){
ArrayList<Double> U = new ArrayList<>();
for(double t: thetas) U.add(r * Math.sin(t));
if(k % 2 == 1) U.add(r / Math.sqrt(2.0));
for(int i=thetas.length-1;i>=0;--i) U.add(r * Math.cos(thetas[i]));

int K = U.size();
double[] F = new double[K+2];
F[0]=0.0;
for(int i=0;i<K;i++) F[i+1]=U.get(i);
F[K+1]=r;

double s = 0.0;
for(int i=1;i<=K+1;i++){
double dy = F[i] - F[i-1];
double xcap = F[K - i + 2];
s += dy * xcap;
}
return 4.0 * s;
}

static double goldenSectionMinimize(Function f, double lo, double hi, int maxIt, double tol){
double golden = (Math.sqrt(5.0)-1.0)/2.0;
double a=lo, b=hi;
double c = b - golden*(b-a);
double d = a + golden*(b-a);
double fc = f.apply(c), fd = f.apply(d);
int it=0;
while((b-a)>tol && it<maxIt){
if(fc > fd){
a = c; c = d; fc = fd;
d = a + golden*(b-a);
fd = f.apply(d);
}else{
b = d; d = c; fd = fc;
c = b - golden*(b-a);
fc = f.apply(c);
}
it++;
}
return (a+b)/2.0;
}

interface Function{
double apply(double x);
}

public static void main(String[] args) throws Exception{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int M = Integer.parseInt(br.readLine().trim());

int k = (M - 1) / 2;
int p = k / 2;

double[] thetas = new double[p];
for(int i=0;i<p;i++){
thetas[i] = (i+1) * (Math.PI/4.0) / (p+1);
}

for(int round=0; round<30; ++round){
boolean changed = false;
for(int i=0;i<p;i++){
final int idx = i;
double lo = (i>0? thetas[i-1] : 0.0) + 1e-12;
double hi = (i<p-1? thetas[i+1] : Math.PI/4.0) - 1e-12;

Function f = (double x) -> {
double[] tmp = thetas.clone();
tmp[idx] = x;
return totalAreaFromThetas(tmp, k);
};

double newTheta = goldenSectionMinimize(f, lo, hi, 120, 1e-13);
if (Math.abs(newTheta - thetas[i]) > 1e-15) {
thetas[i] = newTheta;
changed = true;
}
}
if(!changed) break;
}

double ans = totalAreaFromThetas(thetas, k);

// HALF_UP 到 4 位
BigDecimal out = new BigDecimal(ans).setScale(4, RoundingMode.HALF_UP);
System.out.println(out.toPlainString());
}
}

---

### 第3题-树的之字形路径数（P4445）
- 链接：https://codefun2000.com/p/P4445

> 页面标题：#P4445. 第3题-树的之字形路径数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个二叉树根节点 rootrootroot 和一个数值 nnn ，求路径和等于 nnn 的所有之字形路径的个数。
路径定义:从任意节点到叶子节点的所有节点序列
之字形路径:从任意节点出发，路径中的所有节点需满足如下条件，父节点->左子节点->右子节点->左子节点….…,或者是 父节点->右子节点->左子节点->右子节点->……，之字形路径要求三个节点起。

输入描述
第一行，树的节点个数，0<0<0< 节点数 <=1024<=1024<=1024
第二行，数组 value,value[i]value,value[i]value,value[i] 表示第 iii 个节点的值，value>=0value>=0value>=0。其中 −1-1−1 表示该节点不存在
第三行，目标路径之和 n,nn,nn,n 为 [0,10000][0,10000][0,10000]
二叉树创建规则:从上到下一层一层，按照从左到右的顺序进行构造
输出描述
输出符合路径和为 nnn 的之字形路径的个数，若不存在则返回 −1-1−1 。
样例1
输入
10
3 2 1 2 1 4 1 -1 -1 5
8

输出
2

说明
有两条路径和为 888 的之字形路径

样例2
输入
3
2 3 1
4

输出
-1

说明
树只有两层，不满足之字形路径的要求，返回 −1-1−1

#### TextSol

解题思路

按题意，数组按层序（从上到下一层、从左到右）构造二叉树，-1 表示该位置为空节点。

“路径”定义：从任意节点出发一直向下到叶子的节点序列；“之字形路径”要求边方向左右交替（或右左交替），并且至少包含 3 个节点。

做法：

先用队列按层序把树建出来。
枚举树中每个节点作为起点，各尝试两种首步方向：先向左或先向右。
之后沿着唯一确定的交替方向继续向下直到无法前进；只有到达叶子且长度≥3 才判定为一条合法路径，累加路径和与目标值比较。

相关算法：二叉树构造（层序）、DFS（沿固定方向交替向下）。

核心实现要点

从某起点出发后，路径方向被完全确定（例如“左→右→左→…”），因此递归/迭代时每层最多继续到一个子节点，复杂度可控。
统计总条数，若为 0 输出 -1。

复杂度分析

设节点数为 N，树高为 H。从每个节点最多沿两条交替路径向下，各自长度不超过 H，
时间复杂度 O(N * H)（平衡树近似 O(N log N)，退化链表 O(N^2)，题目上限 1024 可接受）。
额外空间为递归深度 O(H) 与构造时队列 O(W)（W 为某层宽度），总体 O(H) ~ O(N)。

代码实现
Python
# -*- coding: utf-8 -*-
# ACM 风格：主函数处理输入输出，功能写在外部函数中

import sys
from collections import deque

class Node:
def __init__(self, v):
self.v = v
self.l = None
self.r = None

def build_tree(arr):
"""按层序数组构造二叉树，-1 表示空"""
if not arr or arr[0] == -1:
return None
root = Node(arr[0])
q = deque([root])
i = 1
n = len(arr)
while q and i < n:
cur = q.popleft()
# 左孩子
if i < n:
val = arr[i]; i += 1
if val != -1:
cur.l = Node(val)
q.append(cur.l)
# 右孩子
if i < n:
val = arr[i]; i += 1
if val != -1:
cur.r = Node(val)
q.append(cur.r)
return root

def count_zigzag_sum(root, target):
"""统计路径和为 target 的之字形路径条数；为 0 返回 -1"""

def go(node, expect_left, acc, length):
"""
已经从起点走到 node，下一步期望方向为 expect_left。
acc 为已累加的和（不含 node 之前已更新），length 为已走节点数。
只在到达叶子且 length>=3 时计数。
"""
if node is None:
return 0
acc += node.v
length += 1
if node.l is None and node.r is None:
return 1 if (length >= 3 and acc == target) else 0
if expect_left:
return go(node.l, False, acc, length) if node.l else 0
else:
return go(node.r, True, acc, length) if node.r else 0

def dfs_all(node):
nonlocal ans
if node is None:
return
# 两种首步方向
if node.l:
ans += go(node.l, False, node.v, 1)
if node.r:
ans += go(node.r, True, node.v, 1)
dfs_all(node.l)
dfs_all(node.r)

ans = 0
dfs_all(root)
return ans if ans > 0 else -1

def main():
data = sys.stdin.read().strip().split()
if not data:
return
n = int(data[0])
arr = list(map(int, data[1:1 + n]))
target = int(data[1 + n])
root = build_tree(arr)
print(count_zigzag_sum(root, target))

if __name__ == "__main__":
main()

Java
// ACM 风格：主类 Main，主函数读写，功能在静态方法中
import java.util.*;

public class Main {

// 二叉树节点
static class Node {
int v;
Node l, r;
Node(int v) { this.v = v; }
}

// 按层序数组构造二叉树，-1 表示空
static Node buildTree(int[] a) {
if (a.length == 0 || a[0] == -1) return null;
Node root = new Node(a[0]);
Queue<Node> q = new ArrayDeque<>();
q.offer(root);
int i = 1;
while (!q.isEmpty() && i < a.length) {
Node cur = q.poll();
// 左孩子
if (i < a.length) {
int v = a[i++];
if (v != -1) {
cur.l = new Node(v);
q.offer(cur.l);
}
}
// 右孩子
if (i < a.length) {
int v = a[i++];
if (v != -1) {
cur.r = new Node(v);
q.offer(cur.r);
}
}
}
return root;
}

// 统计之字形路径和为 target 的条数；0 条返回 -1
static int countZigzagSum(Node root, int target) {
final int[] ans = new int[1];

// 继续沿指定交替方向向下
class Helper {
int go(Node node, boolean expectLeft, int acc, int len) {
if (node == null) return 0;
acc += node.v;
len += 1;
if (node.l == null && node.r == null) {
return (len >= 3 && acc == target) ? 1 : 0;
}
if (expectLeft) {
return (node.l != null) ? go(node.l, false, acc, len) : 0;
} else {
return (node.r != null) ? go(node.r, true, acc, len) : 0;
}
}
}
Helper helper = new Helper();

// 枚举所有起点
Deque<Node> stack = new ArrayDeque<>();
if (root != null) stack.push(root);
while (!stack.isEmpty()) {
Node cur = stack.pop();
if (cur.l != null) ans[0] += helper.go(cur.l, false, cur.v, 1);
if (cur.r != null) ans[0] += helper.go(cur.r, true, cur.v, 1);
if (cur.l != null) stack.push(cur.l);
if (cur.r != null) stack.push(cur.r);
}
return ans[0] > 0 ? ans[0] : -1;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 数据规模小，直接用 Scanner
if (!sc.hasNextInt()) return;
int n = sc.nextInt();
int[] arr = new int[n];
for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
int target = sc.nextInt();
Node root = buildTree(arr);
int ans = countZigzagSum(root, target);
System.out.println(ans);
sc.close();
}
}

C++
// ACM 风格：主函数处理输入输出，功能在外部函数
#include <bits/stdc++.h>
using namespace std;

struct Node {
int v;
Node *l, *r;
Node(int _v) : v(_v), l(nullptr), r(nullptr) {}
};

// 按层序数组构造二叉树，-1 表示空
Node* buildTree(const vector<int>& a) {
if (a.empty() || a[0] == -1) return nullptr;
Node* root = new Node(a[0]);
queue<Node*> q;
q.push(root);
int i = 1, n = (int)a.size();
while (!q.empty() && i < n) {
Node* cur = q.front(); q.pop();
// 左
if (i < n) {
int v = a[i++];
if (v != -1) {
cur->l = new Node(v);
q.push(cur->l);
}
}
// 右
if (i < n) {
int v = a[i++];
if (v != -1) {
cur->r = new Node(v);
q.push(cur->r);
}
}
}
return root;
}

// 继续沿交替方向向下
int go(Node* node, bool expectLeft, int acc, int len, int target) {
if (!node) return 0;
acc += node->v;
len += 1;
if (!node->l && !node->r) {
return (len >= 3 && acc == target) ? 1 : 0;
}
if (expectLeft) {
return node->l ? go(node->l, false, acc, len, target) : 0;
} else {
return node->r ? go(node->r, true, acc, len, target) : 0;
}
}

// 统计所有起点
int countZigzagSum(Node* root, int target) {
if (!root) return -1;
int ans = 0;
stack<Node*> st;
st.push(root);
while (!st.empty()) {
Node* cur = st.top(); st.pop();
if (cur->l) ans += go(cur->l, false, cur->v, 1, target);
if (cur->r) ans += go(cur->r, true,  cur->v, 1, target);
if (cur->l) st.push(cur->l);
if (cur->r) st.push(cur->r);
}
return ans > 0 ? ans : -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n;
if (!(cin >> n)) return 0;
vector<int> a(n);
for (int i = 0; i < n; ++i) cin >> a[i];
int target; cin >> target;
Node* root = buildTree(a);
cout << countZigzagSum(root, target) << "\n";
return 0;
}

---

## 2025年10月29日-AI方向

### 第2题-实体匹配结果合并问题（P4343）
- 链接：https://codefun2000.com/p/P4343

> 页面标题：#P4343. 第2题-实体匹配结果合并问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某业务部门有多个数据来源，现在需要对多个来源的实体数据进行去重、消歧、合并。有多个实体匹配系统（假设系统的匹配结果完全正确），每个系统从不同角度进行匹配，匹配结果是相同实体列表。
这些匹配结果中往往存在交叉重复的问题，需要对所有匹配结果进行合并去重。例如系统 AAA 的匹配结果是 ["111", "222"] ，系统 BBB 的匹配结果是 ["222", "333"]，那么合并后的匹配结果是 ["111", "222", "333"]。请你按照上述逻辑，编写代码实现对匹配结果的合并去重。
输入描述

第一行输入是整数 NNN，表示有 NNN 个实体匹配系统，1<=N<=100001<=N<=100001<=N<=10000 ；

接下来 NNN 行是每个实体匹配系统的匹配结果（相同实体列表，每行实体数量不超过 100100100 ）；实体使用数字字符串表示（字符长度不超过 101010），实体之间通过空格分开。实体种类数量不超过 100000100000100000 。

输出描述
输出 MMM 行（M<=NM <= NM<=N），每行内容是合并后的匹配结果。
注意，每行的输出结果需要按照字典顺序进行排序；合并后的匹配结果列表之间，也需要按字典顺序进行排序。
样例1
输入
5
1 2 3
4 5
11 22
33 44 55 1
3 66

输出
1 2 3 33 44 55 66
11 22
4 5

说明
匹配结果 "111 222 333 "、"333333 444444 555555 111"、"333 666666"，存在重复实体 "111" 和 "333"，故可以合并，合并后按字典序为 "111 222 333 333333  444444 555555 666666"；
另外两组结果与其他组不存在重复；
合并后的匹配结果列表之间，按字典序排序后输出，即样例输出所示内容。
样例2
输入
2
1 2
2 3

输出
1 2 3

说明
有两组匹配结果，即 "111 222"和"222 333"，存在重复实体 "222"，故可以合并为 "111 222 333"。

#### TextSol

解题思路
题意要求将多个实体匹配系统输出的实体结果进行去重、合并与排序。
每个系统的输出可视为一个集合，若两个集合存在交集，则它们应被合并为一个更大的集合。
这实际上是一个并查集（Union-Find） 的典型应用场景：

每个实体可以看作一个节点；
若两个实体在同一系统结果中出现，则它们属于同一连通分量；
通过并查集合并所有出现在同一行的实体；
最后，将所有节点根据其根节点分组，输出每个连通分量（集合）内的实体。

实现步骤

读取输入的系统数 N；

对每一行实体结果：

将该行所有实体放入列表；
使用并查集，将该行所有实体合并到同一集合中；

最终遍历所有实体，按根节点进行归类；

对每个集合内的实体进行字典序排序；

对所有集合按字典序整体排序；

输出结果。

复杂度分析

时间复杂度：
每次合并操作近似为常数时间（路径压缩优化），总复杂度约为 O(T * α(N))，其中 T 为所有实体出现次数（≤100000），α(N) 为阿克曼函数，几乎可视为常数。
排序部分复杂度为 O(K log K)，K 为最终集合内的元素数。
综合复杂度为 O(N log N)。

空间复杂度：
存储并查集及映射关系，约为 O(N)，符合题目要求。

代码实现
Python 实现
# 并查集实现类
class UnionFind:
def __init__(self):
self.parent = {}

def find(self, x):
if self.parent[x] != x:
self.parent[x] = self.find(self.parent[x])
return self.parent[x]

def union(self, x, y):
px, py = self.find(x), self.find(y)
if px != py:
self.parent[py] = px

def merge_entities(n, systems):
uf = UnionFind()
# 初始化所有实体
for line in systems:
for entity in line:
if entity not in uf.parent:
uf.parent[entity] = entity

# 按每行进行合并
for line in systems:
base = line[0]
for entity in line[1:]:
uf.union(base, entity)

# 收集每个集合
groups = {}
for entity in uf.parent:
root = uf.find(entity)
groups.setdefault(root, set()).add(entity)

# 按题意要求排序
result = []
for group in groups.values():
sorted_group = sorted(group)
result.append(sorted_group)
result.sort()

return result

if __name__ == "__main__":
n = int(input())
systems = []
for _ in range(n):
line = input().strip().split()
if line:
systems.append(line)

merged = merge_entities(n, systems)
for group in merged:
print(" ".join(group))

Java 实现
import java.util.*;

public class Main {
// 并查集：用于把同一行出现的实体合并到同一个集合
static class UnionFind {
Map<String, String> parent = new HashMap<>();

// 查找（带路径压缩）
String find(String x) {
if (!parent.get(x).equals(x)) {
parent.put(x, find(parent.get(x)));
}
return parent.get(x);
}

// 合并
void union(String a, String b) {
String pa = find(a), pb = find(b);
if (!pa.equals(pb)) parent.put(pb, pa);
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取系统数量
int n = Integer.parseInt(sc.nextLine());
UnionFind uf = new UnionFind();
List<List<String>> systems = new ArrayList<>();

// 读取每行系统输出（实体用空格分隔）
for (int i = 0; i < n; i++) {
if (!sc.hasNextLine()) break;
String line = sc.nextLine().trim();
if (line.isEmpty()) continue;  // 跳过空行
// 使用 \\s+ 以容忍多空格
String[] parts = line.split("\\s+");
List<String> list = Arrays.asList(parts);
systems.add(list);
// 初始化并查集中的节点
for (String s : list) uf.parent.putIfAbsent(s, s);
}

// 每行内的实体合并为同一集合
for (List<String> list : systems) {
if (list.isEmpty()) continue;
String base = list.get(0);
for (int j = 1; j < list.size(); j++) {
uf.union(base, list.get(j));
}
}

// 按根结点分组
Map<String, List<String>> groups = new HashMap<>();
for (String s : uf.parent.keySet()) {
String root = uf.find(s);
groups.computeIfAbsent(root, k -> new ArrayList<>()).add(s);
}

// ===== 关键改动：按“字典序（字符串比较）”排序 =====
// 1) 组内：Collections.sort -> 字符串自然顺序（字典序）
List<List<String>> res = new ArrayList<>();
for (List<String> g : groups.values()) {
Collections.sort(g);   // 组内字典序
res.add(g);
}

// 2) 组间：逐元素字符串比较的字典序
res.sort((a, b) -> {
int len = Math.min(a.size(), b.size());
for (int i = 0; i < len; i++) {
int cmp = a.get(i).compareTo(b.get(i)); // 字典序逐元素比较
if (cmp != 0) return cmp;
}
return Integer.compare(a.size(), b.size()); // 前缀相同则短的在前
});

// 输出
for (List<String> list : res) {
System.out.println(String.join(" ", list));
}

sc.close();
}
}

C++ 实现
#include <bits/stdc++.h>
using namespace std;

// 并查集结构体
struct UnionFind {
unordered_map<string, string> parent;

// 查找根节点（带路径压缩）
string find(const string &x) {
if (parent[x] != x)
parent[x] = find(parent[x]);
return parent[x];
}

// 合并两个节点
void unite(const string &a, const string &b) {
string pa = find(a), pb = find(b);
if (pa != pb) parent[pb] = pa;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
cin.ignore(); // 忽略换行符

UnionFind uf;
vector<vector<string>> systems; // 存储每个系统的匹配结果

// 读取输入
for (int i = 0; i < n; i++) {
string line;
getline(cin, line);
if (line.empty()) continue;
stringstream ss(line);
string x;
vector<string> temp;

// 分割实体
while (ss >> x) {
temp.push_back(x);
if (!uf.parent.count(x))
uf.parent[x] = x; // 初始化父节点
}
systems.push_back(temp);
}

// 合并每一行中的实体集合
for (auto &v : systems) {
for (size_t j = 1; j < v.size(); j++)
uf.unite(v[0], v[j]);
}

// 根据根节点分组
map<string, set<string>> groups;
for (auto &p : uf.parent) {
string root = uf.find(p.first);
groups[root].insert(p.first);
}

// 转换为 vector 并排序输出
vector<vector<string>> res;
for (auto &it : groups) {
vector<string> tmp(it.second.begin(), it.second.end());
sort(tmp.begin(), tmp.end());
res.push_back(tmp);
}

// 按字典序排序所有集合
sort(res.begin(), res.end());

// 输出结果
for (auto &v : res) {
for (size_t i = 0; i < v.size(); i++) {
if (i) cout << " ";
cout << v[i];
}
cout << "\n";
}

return 0;
}

---

### 第2题-新能源汽车最高总续航里程（P4346）
- 链接：https://codefun2000.com/p/P4346

> 页面标题：#P4346. 第2题-新能源汽车最高总续航里程

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有从 111 到 nnn 按序编号的 nnn 辆纯电的新能源汽车，给定一个总的电池容量 kkk ，请根据每辆新能源汽车的电油容量和续航里程情况，选取出对应的新能源汽车的组合，满足所选择的组合内的新能源汽车的电油容量总和不大于 kkk ，总续航里程最高。
输入描述
第一行输入为整数 nnn ，表示新能源汽车数量，范围为 111 ~ 505050 ;
第二行输入为整数 kkk ，表示给定的总的电池容量，范围为 111 ~ 100010001000 ;
接下来的 nnn 行输入，按照 111 到 nnn 按序编号顺序，逐行表示对应编号的新能源汽车的电池容量和续航里程，以空格分隔;
电池容量范围为 111 ~ 100100100，续航里程范围为 111 ~ 100010001000 。
输出描述
按照编码从小到大输出所选组合中的新能源汽车编号，编号间以空格隔开。
注意:
111、如果没有满足要求的组合，输出 −1-1−1 。
222、如果存在多个满足条件的组合均达到最高里程，则取总电量最少的组合输出。
在上述前提下，若存在多个组合均满足最少总电量，则取汽车数量最少的组合输出。
在上述前提下，题目可保证仅有一组组合。
样例1
输入
1
80
100
300

输出
-1

说明
该用例中不存在电量不大于 808080 的组合，因此返回 −1-1−1
样例2
输入
5
80
30 45 15 15 80
400 470 200 200 870

输出
1 2

说明
一共 555 辆车，电油容量分别为 30、45、15、15、8030、45、15、15、8030、45、15、15、80 ，续航里程分别为 400、470、200、200、870400、470、200、200、870400、470、200、200、870 ，总电量要求不大于 808080 。
对应如下表
总电量不大于 808080 的车辆组合可以是：$(1)、(2)、(3)、(4)、(5)、(1,2)、(1,3)、(1,4)、(1,3,4)、(2,3)、(2,4)、(2,3,4)、(3,4)$
对应的总电量依次为:
30、45、15、15、80、75、45、45、60、60、60、75、3030、45、15、15、80、75、45、45、60、60、60、75、3030、45、15、15、80、75、45、45、60、60、60、75、30
对应的总续航里程依次为:
$400、470、200、200、870、870、600、600、800，670、670、870、400$
由上可知，满足条件的最高续航里程为 870870870 ，分别为组合 (5)、(1,2)、(2,3,4)(5)、(1,2)、(2,3,4)(5)、(1,2)、(2,3,4)
在续航里程相同的情况下，取电量最小的组合，分别为 (1,2)、(2,3,4)(1,2)、(2,3,4)(1,2)、(2,3,4)
在电量相同的情况下，取汽车数量最小的组合，为 (1,2)(1,2)(1,2)
因此最终输出为
111 222
样例3
输入
4
80
30 45 50 60
400 470 450 600

输出
1 2

说明
一共 444 辆车，电池容量分别为 30、45、50、6030、45、50、6030、45、50、60，续航里程分别为 400、470、450、600400、470、450、600400、470、450、600，总电量要求不大于 808080 。
总电量不大于 808080 的车辆组合可以是 111 (总电量 303030 )、111 和 222 (总电量 757575 )、111 和 333 (总电量 808080 )、222 (总电量 454545 )、333(总电量 505050 )、444 (总电量 606060 )，总续航里程分别为 400,870,850,470,450,600400,870,850,470,450,600400,870,850,470,450,600 .
因此最长续航里程为 870870870 ，对应的组合为 111 和 222 。
最终输出
111 222

#### TextSol

解题思路
给出 n 辆车，每辆车有电池容量 cap[i] 与续航里程 rng[i]，总容量上限为 K。要求在总容量不超过 K 的前提下：

总续航里程最大；
若有并列，取总容量更小；
若仍并列，取车辆数量更少；
并输出所选车辆的编号（升序）。若无法选择任何车辆则输出 -1。

这是标准的 0/1 背包 问题的变体。设 dp[i][w] 表示只考虑前 i 辆车、容量上限为 w 时的最优解三元组 (总续航, 总容量, 车辆数)，转移：

不选第 i 辆：dp[i-1][w]
选第 i 辆（若 w>=cap[i]）：dp[i-1][w-cap[i]] 再加上第 i 辆的属性

三元组比较规则（自定义“更优”）：

总续航更大优先；
若续航相同，总容量更小优先；
若仍相同，车辆数更少优先。

用 take[i][w] 记录是否选择第 i 辆，最终从 dp[n][K] 反推路径并输出编号升序。

输入格式按样例：第一行 n，第二行 K，第三行 n 个容量，第四行 n 个续航。

复杂度分析

时间复杂度：O(n*K)，其中 n ≤ 50，K ≤ 1000，可行。
空间复杂度：O(n*K)，存储三个整型表与选择表，同样可行。

代码实现
Python
# 题面功能函数：求解并返回选择的车辆编号（升序），若无则返回空列表
def choose_cars(cap, rng, K):
n = len(cap)
# dp 三个维度：总续航、总容量、车辆数
val = [[0]*(K+1) for _ in range(n+1)]
wt  = [[0]*(K+1) for _ in range(n+1)]
cnt = [[0]*(K+1) for _ in range(n+1)]
take = [[False]*(K+1) for _ in range(n+1)]

# 比较 (v1,w1,c1) 是否比 (v2,w2,c2) 更优
def better(v1, w1, c1, v2, w2, c2):
if v1 != v2: return v1 > v2
if w1 != w2: return w1 < w2
return c1 < c2

for i in range(1, n+1):
ci, vi = cap[i-1], rng[i-1]
for w in range(0, K+1):
# 不选
v0, w0, c0 = val[i-1][w], wt[i-1][w], cnt[i-1][w]
best_v, best_w, best_c = v0, w0, c0
# 选
if w >= ci:
v2 = val[i-1][w-ci] + vi
w2 = wt[i-1][w-ci] + ci
c2 = cnt[i-1][w-ci] + 1
if better(v2, w2, c2, best_v, best_w, best_c):
best_v, best_w, best_c = v2, w2, c2
take[i][w] = True
else:
take[i][w] = False
else:
take[i][w] = False
val[i][w], wt[i][w], cnt[i][w] = best_v, best_w, best_c

# 若未选中任何车辆，则输出 -1
if cnt[n][K] == 0:
return []

# 反推路径
ans = []
w = K
for i in range(n, 0, -1):
if take[i][w]:
ans.append(i)     # 车辆编号从 1 开始
w -= cap[i-1]
ans.reverse()
return ans

# 主函数：读入、调用、输出
if __name__ == "__main__":
import sys
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
exit(0)
n, K = data[0], data[1]
cap = data[2:2+n]
rng = data[2+n:2+2*n]
res = choose_cars(cap, rng, K)
if not res:
print(-1)
else:
print(" ".join(map(str, res)))

Java
import java.util.*;

// ACM 风格，类名为 Main
public class Main {

// 题面功能函数：返回选择的车辆编号（升序），若无则返回空数组
public static List<Integer> chooseCars(int[] cap, int[] rng, int K) {
int n = cap.length;
int[][] val = new int[n + 1][K + 1]; // 总续航
int[][] wt  = new int[n + 1][K + 1]; // 总容量
int[][] cnt = new int[n + 1][K + 1]; // 车辆数
boolean[][] take = new boolean[n + 1][K + 1];

// 比较 (v1,w1,c1) 是否优于 (v2,w2,c2)
java.util.function.Predicate<int[]> dummy = x -> true; // 仅为避免警告
for (int i = 1; i <= n; i++) {
int ci = cap[i - 1], vi = rng[i - 1];
for (int w = 0; w <= K; w++) {
// 不选
int bv = val[i - 1][w], bw = wt[i - 1][w], bc = cnt[i - 1][w];
boolean tk = false;
// 选
if (w >= ci) {
int v2 = val[i - 1][w - ci] + vi;
int w2 = wt[i - 1][w - ci] + ci;
int c2 = cnt[i - 1][w - ci] + 1;
if (better(v2, w2, c2, bv, bw, bc)) {
bv = v2; bw = w2; bc = c2; tk = true;
}
}
val[i][w] = bv; wt[i][w] = bw; cnt[i][w] = bc; take[i][w] = tk;
}
}

if (cnt[n][K] == 0) return new ArrayList<>(); // 无可选车辆

// 反推路径
List<Integer> ans = new ArrayList<>();
int w = K;
for (int i = n; i >= 1; i--) {
if (take[i][w]) {
ans.add(i); // 编号从 1 开始
w -= cap[i - 1];
}
}
Collections.reverse(ans);
return ans;
}

// 自定义比较：续航大优先；续航相同容量小优先；再者车辆数少优先
private static boolean better(int v1, int w1, int c1, int v2, int w2, int c2) {
if (v1 != v2) return v1 > v2;
if (w1 != w2) return w1 < w2;
return c1 < c2;
}

// 主函数：读入、调用、输出
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNextInt()) return;
int n = sc.nextInt();
int K = sc.nextInt();
int[] cap = new int[n];
int[] rng = new int[n];
for (int i = 0; i < n; i++) cap[i] = sc.nextInt(); // 第三行：容量
for (int i = 0; i < n; i++) rng[i] = sc.nextInt(); // 第四行：续航
List<Integer> res = chooseCars(cap, rng, K);
if (res.isEmpty()) {
System.out.println(-1);
} else {
for (int i = 0; i < res.size(); i++) {
if (i > 0) System.out.print(" ");
System.out.print(res.get(i));
}
System.out.println();
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 题面功能函数：返回选择的车辆编号（升序），若无则返回空向量
vector<int> choose_cars(const vector<int>& cap, const vector<int>& rng, int K) {
int n = cap.size();
// 三个 DP 表：总续航、总容量、车辆数
vector<vector<int>> val(n + 1, vector<int>(K + 1, 0));
vector<vector<int>> wt (n + 1, vector<int>(K + 1, 0));
vector<vector<int>> cnt(n + 1, vector<int>(K + 1, 0));
vector<vector<char>> take(n + 1, vector<char>(K + 1, 0));

auto better = [](int v1, int w1, int c1, int v2, int w2, int c2)->bool{
if (v1 != v2) return v1 > v2;
if (w1 != w2) return w1 < w2;
return c1 < c2;
};

for (int i = 1; i <= n; ++i) {
int ci = cap[i - 1], vi = rng[i - 1];
for (int w = 0; w <= K; ++w) {
// 不选
int bv = val[i - 1][w], bw = wt[i - 1][w], bc = cnt[i - 1][w];
char tk = 0;
// 选
if (w >= ci) {
int v2 = val[i - 1][w - ci] + vi;
int w2 = wt[i - 1][w - ci] + ci;
int c2 = cnt[i - 1][w - ci] + 1;
if (better(v2, w2, c2, bv, bw, bc)) {
bv = v2; bw = w2; bc = c2; tk = 1;
}
}
val[i][w] = bv; wt[i][w] = bw; cnt[i][w] = bc; take[i][w] = tk;
}
}

if (cnt[n][K] == 0) return {}; // 无可选车辆

// 反推路径
vector<int> ans;
int w = K;
for (int i = n; i >= 1; --i) {
if (take[i][w]) {
ans.push_back(i); // 编号从 1 开始
w -= cap[i - 1];
}
}
reverse(ans.begin(), ans.end());
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, K;
if (!(cin >> n)) return 0;
cin >> K;
vector<int> cap(n), rng(n);
for (int i = 0; i < n; ++i) cin >> cap[i]; // 第三行：容量
for (int i = 0; i < n; ++i) cin >> rng[i]; // 第四行：续航
vector<int> res = choose_cars(cap, rng, K);
if (res.empty()) {
cout << -1 << "\n";
} else {
for (size_t i = 0; i < res.size(); ++i) {
if (i) cout << ' ';
cout << res[i];
}
cout << "\n";
}
return 0;
}

---

### 第2题-采苹果（P4280）
- 链接：https://codefun2000.com/p/P4280

> 页面标题：#P4280. 第2题-采苹果

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小红出门采苹果，前方 mmm 个格子代表 mmm 片苹果林，每个格子中的数字代表可采苹果的数量。
小红出门带了 nnn 个苹果，只能往前走，需要消耗掉 111 个苹果才能踏上一个格子。
小红最多进行 kkk 次苹果采摘，每个格子最多采摘一次，请问小红苹果数最多的时候有几个苹果?
注意:可以不走上格子;苹果为 000 时无法走上新的格子。
输入描述
第一行为 m、n、km、n、km、n、k ，空格隔开
第二行为 mmm 个整数，代表 mmm 个格子上的苹果数，苹果数范围 [0,20][0,20][0,20] ，空格隔开
m、n、km、n、km、n、k 都为正整数，范围 [1,20][1,20][1,20]
输出描述
最多的苹果数
样例1
**输入
5 5 1
0 0 2 1 1

输出
5

说明
小红不踏上格子，不进行采摘的情况下苹果数最多，为 555 个
样例2
输入
10 3 2
0 0 3 4 7 8 9 10 11 12

输出
8

说明
走到第 333 格时，消耗了 333 个苹果，进行第一次采摘获得 333 个苹果，剩余苹果 333 个
接下来走到第 555 个格子，又消耗了 222 个苹果，进行第二次采摘获得 777 个苹果，剩余 888 个苹果，在后面的格子进行采摘结果也一样。
故小红最多的时候有 888 个苹果。

#### TextSol

解题思路

这是一个“只能向前、每次采摘至多一次”的路径规划问题。由于走格子只会消耗苹果、采摘只会增加苹果，苹果数的峰值只可能出现在起点或某次采摘之后。

设苹果林为下标从 1 到 m 的数组 A[i]。从起点到第 i 格需消耗 i 个苹果；从已采摘的第 j 格走到更靠前的第 i 格需消耗 i-j 个苹果。到达时苹果可以为 0（但此时不能继续前进一步，正好在该格采摘）。

动态规划：

定义 dp[t][i]：恰好进行了 t 次采摘且第 t 次在第 i 格后，采摘完成时手上的最大苹果数；不可达则为负无穷。
初始转移（从起点直接到第 i 格并采摘一次）：若 n >= i，则 dp[1][i] = n - i + A[i]。
一般转移（从已在 j 格完成第 t-1 次采摘的状态到 i 格进行第 t 次采摘）：
若 dp[t-1][j] >= i-j，则
dp[t][i] = max(dp[t][i], dp[t-1][j] - (i-j) + A[i])。

答案为 max(n, max_{1<=t<=k, 1<=i<=m} dp[t][i])，即起点不动与所有可达采摘后的峰值二者取最大。

算法：二维动态规划（区间/有序选择 + 可达性约束）。

复杂度分析

状态数 O(k*m)，每个状态枚举前一个采摘格 j，转移 O(m)，总时间复杂度 O(k * m^2)；在约束 m,k ≤ 20 下足够快。
额外空间复杂度 O(k * m)。

代码实现
Python
# 题目功能放在函数里，主函数只做输入输出（ACM风格）
import sys

INF_NEG = -10**9

def solve(m, n, k, arr):
# 将数组改为1-based，便于计算步数
A = [0] + arr
# dp[t][i]：恰好t次采摘，最后一次在i格，采摘后手中最多苹果
dp = [[INF_NEG]*(m+1) for _ in range(k+1)]
ans = n  # 起点不动也可能是最大值

# 第一次采摘：从起点直接走到i
for i in range(1, m+1):
if n >= i:
dp[1][i] = n - i + A[i]
if dp[1][i] > ans:
ans = dp[1][i]

# 后续采摘
for t in range(2, k+1):
for i in range(1, m+1):
best = INF_NEG
for j in range(1, i):
if dp[t-1][j] >= i - j:  # 有能力走到i
cand = dp[t-1][j] - (i - j) + A[i]
if cand > best:
best = cand
dp[t][i] = best
if best > ans:
ans = best

return ans

def main():
data = sys.stdin.read().strip().split()
m, n, k = map(int, data[:3])
arr = list(map(int, data[3:3+m]))
print(solve(m, n, k, arr))

if __name__ == "__main__":
main()

Java
// ACM风格：主类Main，主函数读写，核心逻辑在外部静态函数
import java.util.*;

public class Main {
static final int INF_NEG = -1000000000;

// 解决函数：返回最多时刻的苹果数
static int solve(int m, int n, int k, int[] arr0) {
int[] A = new int[m + 1]; // 1-based
for (int i = 1; i <= m; i++) A[i] = arr0[i - 1];

int[][] dp = new int[k + 1][m + 1];
for (int t = 0; t <= k; t++) Arrays.fill(dp[t], INF_NEG);

int ans = n; // 起点不动

// 第一次采摘：从起点到i
for (int i = 1; i <= m; i++) {
if (n >= i) {
dp[1][i] = n - i + A[i];
if (dp[1][i] > ans) ans = dp[1][i];
}
}

// 后续采摘
for (int t = 2; t <= k; t++) {
for (int i = 1; i <= m; i++) {
int best = INF_NEG;
for (int j = 1; j < i; j++) {
if (dp[t - 1][j] >= i - j) {
int cand = dp[t - 1][j] - (i - j) + A[i];
if (cand > best) best = cand;
}
}
dp[t][i] = best;
if (best > ans) ans = best;
}
}

return ans;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int m = sc.nextInt(), n = sc.nextInt(), k = sc.nextInt();
int[] arr = new int[m];
for (int i = 0; i < m; i++) arr[i] = sc.nextInt();
System.out.println(solve(m, n, k, arr));
sc.close();
}
}

C++
// ACM风格：主函数读写，核心逻辑放在独立函数
#include <bits/stdc++.h>
using namespace std;

const int INF_NEG = -1000000000;

// 解决函数：返回最多时刻的苹果数
int solve(int m, int n, int k, const vector<int>& arr0) {
vector<int> A(m + 1, 0); // 1-based
for (int i = 1; i <= m; ++i) A[i] = arr0[i - 1];

vector<vector<int>> dp(k + 1, vector<int>(m + 1, INF_NEG));
int ans = n; // 起点不动

// 第一次采摘：从起点到i
for (int i = 1; i <= m; ++i) {
if (n >= i) {
dp[1][i] = n - i + A[i];
ans = max(ans, dp[1][i]);
}
}

// 后续采摘
for (int t = 2; t <= k; ++t) {
for (int i = 1; i <= m; ++i) {
int best = INF_NEG;
for (int j = 1; j < i; ++j) {
if (dp[t - 1][j] >= i - j) {
int cand = dp[t - 1][j] - (i - j) + A[i];
best = max(best, cand);
}
}
dp[t][i] = best;
ans = max(ans, best);
}
}

return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int m, n, k;
if (!(cin >> m >> n >> k)) return 0;
vector<int> arr(m);
for (int i = 0; i < m; ++i) cin >> arr[i];
cout << solve(m, n, k, arr) << "\n";
return 0;
}

---

### 第3题-商品购买预测（P4344）
- 链接：https://codefun2000.com/p/P4344

> 页面标题：#P4344. 第3题-商品购买预测

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

实现一个二分类逻辑回归模型，用于预测用户是否会购买某商品（111 表示购买，000 表示不购买）。已知用户特征包括年龄（岁）、月收入（千元）和浏览时长（分钟），需通过这些特征建立预测模型。
我们构建一个逻辑回归模型来预测购买：ypred=sigmoid(wx+b)y_{pred} = sigmoid(wx + b)ypred​=sigmoid(wx+b)，
www 和 bbb 分别为特征权重和偏置。
要求：

基于训练数据，使用梯度下降法训练逻辑回归模型参数。要求采用的具体函数方法为：损失函数为预测结果与标签值的交叉熵

$L = \frac{1}{n} \sum_{i=1}^{n} CrossEntropy(y_i^{pred}, y_i^{label})$，使用 L2L2L2 正则约束权重 L2(w)=∣∣w∣∣2L_2(w) = ||w||_2L2​(w)=∣∣w∣∣2​，激活函数为 SigmoidSigmoidSigmoid 。
训练终止条件：迭代次数达到最大次数（max_itermax\_itermax_iter）或损失函数变化量小于阈值（toltoltol）。
对测试数据进行预测，输出预测结果（概率 ≥0.5≥0.5≥0.5 预测为 111，否则为 000），和对应的概率值，四舍五入保留四位小数。
输入描述
第一行：555 个数字，分别为训练样本数 nnn 、最大迭代次数 max_itermax\_itermax_iter、学习率 ααα（浮点型）、正则化系数 λλλ（浮点型）、损失阈值 toltoltol（浮点型）。
接下来 nnn 行：每行 444 个数值，前 333 个为特征（年龄、月收入、浏览时长），第 444 个为标签（000 或 111）。
第 n+2n+2n+2 行：整数 mmm（测试样本数）。
接下来 mmm 行：每行 333 个数值，为测试特征。
输出描述
mmm 行，每行 111 个整数（ 000 或 111），表示预测结果；接着是一个空格；紧接着输出对应的商品购买小数概率值（保留四位小数）
样例1
输入
10 1000 0.01 0.1 0.0001
25 8 5 0
30 15 15 1
35 20 10 0
40 25 20 1
45 30 25 1
50 35 18 1
55 40 12 0
60 45 8 0
65 50 5 0
70 55 30 1
3
32 18 12
48 33 22
62 48 10

输出
1 0.7539
1 0.9966
0 0.0004

说明
对于第一个样例，年龄（323232 岁）、月收入（181818 千元）和浏览时长（121212 分钟），输出结果 111 表示该用户会购买该商品，0.75390.75390.7539 表示用户购买该商品的概率是 75.3975.3975.39%。
样例2
输入
10 1000 0.01 0.1 0.0001
25 8 5 0
30 15 15 1
35 20 10 0
40 25 20 1
45 30 25 1
50 35 18 1
55 40 12 0
60 45 8 0
65 50 5 0
70 55 30 1
1
48 30 10

输出
0 0.0081

说明
对于第一个样例，年龄（484848 岁）、月收入（303030 千元）和浏览时长（101010 分钟），输出结果 000 表示该用户不会购买该商品，0.00810.00810.0081 表示该用户购买该商品的概率是 0.810.810.81%。

#### TextSol

解题思路
本题要求用二分类逻辑回归（Logistic Regression）对“是否购买”进行预测。模型形式为
y^=σ(z)=σ(w⊤x+b)\hat y = \sigma(z)=\sigma(w^\top x + b)y^​=σ(z)=σ(w⊤x+b)，其中 σ(t)=11+e−t\sigma(t)=\frac{1}{1+e^{-t}}σ(t)=1+e−t1​ 为 Sigmoid。
优化目标（带 L2 正则的交叉熵）：
对 nnn 个样本，特征维度为 d=3d=3d=3（年龄、月收入、浏览时长），标签 y∈{0,1}y\in\{0,1\}y∈{0,1}。
损失函数取平均交叉熵并加入 L2 正则（采用更常见的平方范数形式）：
$$J(w,b)=\frac{1}{n}\sum_{i=1}^n\Big[-y_i\log \hat y_i-(1-y_i)\log(1-\hat y_i)\Big]+\frac{\lambda}{2n}\|w\|_2^2$$其中 y^i=σ(w⊤xi+b)\hat y_i=\sigma(w^\top x_i+b)y^​i​=σ(w⊤xi​+b)。
梯度推导： 记 pi=y^ip_i=\hat y_ipi​=y^​i​，则
$$\frac{\partial J}{\partial w}=\frac{1}{n}\sum_{i=1}^n (p_i-y_i)\,x_i+\frac{\lambda}{n}w,\qquad
\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{i=1}^n (p_i-y_i).$$训练（批量梯度下降）：

初始化 w=0,b=0w=\mathbf{0}, b=0w=0,b=0；
迭代更新
w←w−α ∂J/∂ww \leftarrow w-\alpha\,\partial J/\partial ww←w−α∂J/∂w，
b←b−α ∂J/∂bb \leftarrow b-\alpha\,\partial J/\partial bb←b−α∂J/∂b；
终止条件：达到最大迭代次数 max_iter或 先更新参数，再计算一次新损失，用相邻两次损失之差判断是否 < tol；
数值稳定性：交叉熵内的 log⁡\loglog 对概率做 ε\varepsilonε 截断（如 1e−151e{-15}1e−15），Sigmoid 采用分段公式避免上溢/下溢。

预测：

概率 p=σ(w⊤x+b)p=\sigma(w^\top x+b)p=σ(w⊤x+b)；
阈值 0.5：p≥0.5p\ge 0.5p≥0.5 判为 1，否则 0；
输出格式为“预测结果 概率（四位小数）”。

复杂度分析

时间复杂度：每次迭代需扫一遍数据并做 ddd 次累计，故为 O(max_iter×n×d)O(\text{max\_iter}\times n \times d)O(max_iter×n×d)。本题 d=3d=3d=3，复杂度适宜。
空间复杂度：存储数据与参数，O(n×d)+O(d)O(n\times d)+O(d)O(n×d)+O(d)。参数仅 O(d)O(d)O(d)；数据为输入必须项。

代码实现
Python
import sys
import math

# Sigmoid 函数，数值稳定写法
def sigmoid(z):
if z >= 0:
ez = math.exp(-z)
return 1.0 / (1.0 + ez)
else:
ez = math.exp(z)
return ez / (1.0 + ez)

# 计算带 L2 正则（平方范数）的平均交叉熵损失及其梯度
def compute_loss_and_grad(X, y, w, b, lam):
n = len(X)
d = len(w)
eps = 1e-15

loss = 0.0
grad_w = [0.0] * d
grad_b = 0.0

# 累加交叉熵与梯度
for i in range(n):
z = b
for j in range(d):
z += w[j] * X[i][j]
p = sigmoid(z)
yi = y[i]
# 交叉熵
loss += -(yi * math.log(max(p, eps)) + (1 - yi) * math.log(max(1 - p, eps)))
# 梯度累加
diff = p - yi
for j in range(d):
grad_w[j] += diff * X[i][j]
grad_b += diff

# 取平均
loss /= n
for j in range(d):
grad_w[j] /= n
grad_b /= n

# L2 正则项：lambda/(2n)*||w||^2，并相应修正梯度
l2 = 0.0
for j in range(d):
l2 += w[j] * w[j]
grad_w[j] += (lam / n) * w[j]
loss += (lam / (2 * n)) * l2

return loss, grad_w, grad_b

# 训练逻辑回归（批量梯度下降）
def train_logreg(X, y, max_iter, alpha, lam, tol):
d = len(X[0])
w = [0.0] * d
b = 0.0

# 先算一次初始损失
loss, _, _ = compute_loss_and_grad(X, y, w, b, lam)

for _ in range(max_iter):
# 基于当前参数计算梯度并更新
_, grad_w, grad_b = compute_loss_and_grad(X, y, w, b, lam)
for j in range(d):
w[j] -= alpha * grad_w[j]
b -= alpha * grad_b

# 更新后再计算一次新损失，用于提前停止判断
new_loss, _, _ = compute_loss_and_grad(X, y, w, b, lam)
if abs(loss - new_loss) < tol:
break
loss = new_loss

return w, b

# 单样本预测
def predict_one(x, w, b):
z = b
for j in range(len(w)):
z += w[j] * x[j]
p = sigmoid(z)
label = 1 if p >= 0.5 else 0
return label, p

def main():
data = sys.stdin.read().strip().split()
it = iter(data)

# 读取第一行
n = int(next(it))
max_iter = int(next(it))
alpha = float(next(it))
lam = float(next(it))
tol = float(next(it))

# 训练数据
X = []
y = []
for _ in range(n):
a = float(next(it))
inc = float(next(it))
dur = float(next(it))
lab = int(next(it))
X.append([a, inc, dur])
y.append(lab)

# 测试数据
m = int(next(it))
test = []
for _ in range(m):
a = float(next(it)); inc = float(next(it)); dur = float(next(it))
test.append([a, inc, dur])

# 训练
w, b = train_logreg(X, y, max_iter, alpha, lam, tol)

# 预测与输出
for x in test:
lab, p = predict_one(x, w, b)
print(f"{lab} {p:.4f}")

if __name__ == "__main__":
main()

Java
import java.util.*;

/**
* 逻辑回归（批量梯度下降，Sigmoid，交叉熵，L2 正则）
* 输入输出均在主函数中完成，核心训练与预测在外部静态函数中
*/
public class Main {

// Sigmoid，分段实现避免溢出
static double sigmoid(double z) {
if (z >= 0) {
double ez = Math.exp(-z);
return 1.0 / (1.0 + ez);
} else {
double ez = Math.exp(z);
return ez / (1.0 + ez);
}
}

// 计算损失与梯度（带 L2 正则的平方范数）
static double[] computeLossAndGrad(double[][] X, int[] y, double[] w, double b, double lam) {
int n = X.length;
int d = w.length;
double eps = 1e-15;

double loss = 0.0;
double[] gradW = new double[d];
double gradB = 0.0;

for (int i = 0; i < n; i++) {
double z = b;
for (int j = 0; j < d; j++) z += w[j] * X[i][j];
double p = sigmoid(z);
int yi = y[i];

// 交叉熵
double pp = Math.max(p, eps);
double qq = Math.max(1.0 - p, eps);
loss += -(yi * Math.log(pp) + (1 - yi) * Math.log(qq));

// 梯度
double diff = p - yi;
for (int j = 0; j < d; j++) gradW[j] += diff * X[i][j];
gradB += diff;
}

// 平均
loss /= n;
for (int j = 0; j < d; j++) gradW[j] /= n;
gradB /= n;

// L2 正则
double l2 = 0.0;
for (int j = 0; j < d; j++) {
l2 += w[j] * w[j];
gradW[j] += (lam / n) * w[j];
}
loss += (lam / (2.0 * n)) * l2;

// 返回一个数组： [loss, gradB, gradW...]
double[] res = new double[2 + d];
res[0] = loss;
res[1] = gradB;
for (int j = 0; j < d; j++) res[2 + j] = gradW[j];
return res;
}

// 训练
static double[] train(double[][] X, int[] y, int maxIter, double alpha, double lam, double tol) {
int d = X[0].length;
double[] w = new double[d];
double b = 0.0;

// 初始损失
double[] pack0 = computeLossAndGrad(X, y, w, b, lam);
double loss = pack0[0];

for (int it = 0; it < maxIter; it++) {
double[] pack = computeLossAndGrad(X, y, w, b, lam);
double gradB = pack[1];
for (int j = 0; j < d; j++) {
double gradWj = pack[2 + j];
w[j] -= alpha * gradWj;
}
b -= alpha * gradB;

double[] packNew = computeLossAndGrad(X, y, w, b, lam);
double newLoss = packNew[0];
if (Math.abs(loss - newLoss) < tol) break;
loss = newLoss;
}

double[] params = new double[d + 1];
params[0] = b;
for (int j = 0; j < d; j++) params[1 + j] = w[j];
return params;
}

// 单样本预测
static double predictProb(double[] x, double[] w, double b) {
double z = b;
for (int j = 0; j < w.length; j++) z += w[j] * x[j];
return sigmoid(z);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

int n = sc.nextInt();
int maxIter = sc.nextInt();
double alpha = sc.nextDouble();
double lam = sc.nextDouble();
double tol = sc.nextDouble();

double[][] X = new double[n][3];
int[] y = new int[n];

// 读训练数据
for (int i = 0; i < n; i++) {
X[i][0] = sc.nextDouble(); // 年龄
X[i][1] = sc.nextDouble(); // 月收入(千元)
X[i][2] = sc.nextDouble(); // 浏览时长(分钟)
y[i] = sc.nextInt();       // 标签
}

int m = sc.nextInt();
double[][] T = new double[m][3];
for (int i = 0; i < m; i++) {
T[i][0] = sc.nextDouble();
T[i][1] = sc.nextDouble();
T[i][2] = sc.nextDouble();
}
sc.close();

// 训练
double[] params = train(X, y, maxIter, alpha, lam, tol);
double b = params[0];
double[] w = new double[params.length - 1];
for (int j = 0; j < w.length; j++) w[j] = params[1 + j];

// 预测与输出
for (int i = 0; i < m; i++) {
double p = predictProb(T[i], w, b);
int lab = (p >= 0.5) ? 1 : 0;
System.out.printf("%d %.4f%n", lab, p);
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// Sigmoid，分段实现避免溢出
double sigmoid(double z) {
if (z >= 0) {
double ez = exp(-z);
return 1.0 / (1.0 + ez);
} else {
double ez = exp(z);
return ez / (1.0 + ez);
}
}

// 计算损失与梯度（带 L2 正则的平方范数）
// 返回 pair<loss, pair<grad_b, grad_w>>
pair<double, pair<double, vector<double>>> computeLossAndGrad(
const vector<array<double,3>>& X,
const vector<int>& y,
const vector<double>& w,
double b,
double lam
){
int n = (int)X.size();
int d = (int)w.size();
double eps = 1e-15;

double loss = 0.0;
vector<double> grad_w(d, 0.0);
double grad_b = 0.0;

for (int i = 0; i < n; ++i) {
double z = b;
for (int j = 0; j < d; ++j) z += w[j] * X[i][j];
double p = sigmoid(z);
int yi = y[i];

// 交叉熵
double pp = max(p, eps);
double qq = max(1.0 - p, eps);
loss += -(yi * log(pp) + (1 - yi) * log(qq));

// 梯度
double diff = p - yi;
for (int j = 0; j < d; ++j) grad_w[j] += diff * X[i][j];
grad_b += diff;
}

// 平均
loss /= n;
for (int j = 0; j < d; ++j) grad_w[j] /= n;
grad_b /= n;

// L2 正则
double l2 = 0.0;
for (int j = 0; j < d; ++j) {
l2 += w[j] * w[j];
grad_w[j] += (lam / n) * w[j];
}
loss += (lam / (2.0 * n)) * l2;

return {loss, {grad_b, grad_w}};
}

// 训练逻辑回归（批量梯度下降）
pair<vector<double>, double> train(
const vector<array<double,3>>& X,
const vector<int>& y,
int max_iter, double alpha, double lam, double tol
){
int d = 3;
vector<double> w(d, 0.0);
double b = 0.0;

// 初始损失
auto initPack = computeLossAndGrad(X, y, w, b, lam);
double loss = initPack.first;

for (int it = 0; it < max_iter; ++it) {
auto res = computeLossAndGrad(X, y, w, b, lam);
double grad_b = res.second.first;
const vector<double>& grad_w = res.second.second;

for (int j = 0; j < d; ++j) w[j] -= alpha * grad_w[j];
b -= alpha * grad_b;

auto resNew = computeLossAndGrad(X, y, w, b, lam);
double new_loss = resNew.first;
if (fabs(loss - new_loss) < tol) break;
loss = new_loss;
}
return {w, b};
}

// 单样本预测
pair<int,double> predict_one(const array<double,3>& x, const vector<double>& w, double b) {
double z = b;
for (int j = 0; j < (int)w.size(); ++j) z += w[j] * x[j];
double p = sigmoid(z);
int lab = (p >= 0.5) ? 1 : 0;
return {lab, p};
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, max_iter;
double alpha, lam, tol;
if (!(cin >> n >> max_iter >> alpha >> lam >> tol)) return 0;

vector<array<double,3>> X(n);
vector<int> y(n);

for (int i = 0; i < n; ++i) {
double a, inc, dur; int lab;
cin >> a >> inc >> dur >> lab;
X[i] = {a, inc, dur};
y[i] = lab;
}

int m; cin >> m;
vector<array<double,3>> T(m);
for (int i = 0; i < m; ++i) {
double a, inc, dur;
cin >> a >> inc >> dur;
T[i] = {a, inc, dur};
}

// 训练
auto model = train(X, y, max_iter, alpha, lam, tol);
vector<double> w = model.first;
double b = model.second;

cout.setf(std::ios::fixed);
cout << setprecision(4);

// 预测与输出
for (int i = 0; i < m; ++i) {
auto pr = predict_one(T[i], w, b);
cout << pr.first << " " << pr.second << "\n";
}
return 0;
}

---

### 第3题-最短的环（P4347）
- 链接：https://codefun2000.com/p/P4347

> 页面标题：#P4347. 第3题-最短的环

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

考虑一个有 nnn 个节点的图，每个节点对应一个整数，其有 nnn 个整数
a1,a2,a3,…,ana_1,a_2,a_3,…,a_na1​,a2​,a3​,…,an​ ，当且仅当 aia_iai​ & aj≠0a_j≠0aj​=0 时表示节点 iii 和节点 j(i≠j)j(i≠j)j(i=j) 之间有一条边，其中 & 表示按位与操作。
例如:
333 & 6:36:36:3 的二进制表示是 0110 1 1011 ，666 的二进制表示是 110110110，333 ＆ 6=26=26=2 (二进制 010010010 )不为 000 ，表示 333 和 666 之间有一条边。
333 & 28:328:328:3 的二进制表示是 000110001100011，282828 的二进制表示是 111001110011100 ，333 ＆ 28=028=028=0 ，表示 333 和 282828 之间没有边。
请找出该图中最短的环的长度(环的最小长度是 333 )，如果图中没有环输出 −1-1−1 。
输入描述
第一行输入一个整数 n(1≤n≤106)n(1≤n≤10^6)n(1≤n≤106) ，表示数字的个数。
第二行输入 nnn 个整数 a1,a2,…,an(0≤ai≤1018)a_1,a_2,…,a_n(0≤a_i≤10^{18})a1​,a2​,…,an​(0≤ai​≤1018)，表示数字序列。(输入的数字有可能重复)
输出描述
如果图中没有环，输出 −1-1−1 。
否则输出最短环的长度。
样例1
输入
10
448 0 112 0 0 0 28 260 3 0

输出
4

说明
448448448 112112112 282828 260260260 333 的二进制表示为:
448:111000000448:111000000448:111000000
112:001110000112:001110000112:001110000
28:00001110028:00001110028:000011100
260:100000100260:100000100260:100000100
3:0000000113:0000000113:000000011
448448448 −112-112−112 −28-28−28 −260-260−260 构成环，长度为 444 。
样例2
输入
1
1000000000000000000

输出
-1

说明
一个节点无法构成环
样例3
输入
4
1 2 4 8

输出
-1

说明
111 222 444 888 的二进制表示为:
1:00011:00011:0001
2:00102:00102:0010
4:01004:01004:0100
8:10008:10008:1000
节点之间两两没有连接，无法构成环。
样例4
输入
4
3 6 28 5

输出
3

说明
333 666 282828 555 的二进制表示为:
3:000113:000113:00011
6:001106:001106:00110
28:1110028:1110028:11100
5:001015:001015:00101
333 和 666 相连，666 和 282828 相连，555 和 333 相连，3−6−53-6-53−6−5 构成了一个环，长度为 333
样例5
输入
4
3 6 28 9

输出
4

说明
333 666 282828 999 的二进制表示为:
3:000113:000113:00011
6:001106:001106:00110
28:1110028:1110028:11100
9:010019:010019:01001
333 和 666 相连，666 和 282828 相连，282828 和 999 相连，999 和 333 相连，3−6−28−93-6-28-93−6−28−9 构成了一个环，长度为 444

#### TextSol

解题思路

将每个数看作一个点，若 ai & aj != 0 则两点间连一条无向边，求图的最短环长度（环的最小长度为 3）。

关键剪枝：若某一位的置位数量 ≥ 3，则这三个点两两都有该位相连，答案必为 3。又因为最高只需考虑 0~60 位（ai ≤ 1e18），若非零数的个数 m > 120，按抽屉原理必有某位出现 ≥3 次，直接输出 3。

否则每一位最多出现 2 次，非零点数 m ≤ 120。此时可以把这些点显式建图：

对所有两两点判断一次按位与是否为正，若是则加边。
用 BFS 从每个起点求最短环：BFS 过程中若遇到已访问且不是父亲的点 v，就发现了一个环，长度更新为 dist[u] + dist[v] + 1。

若最终没有发现环，输出 -1。

相关算法：位运算+抽屉原理剪枝，BFS 求无向图最短环。
复杂度分析

统计每一位出现次数：O(n * 60)。
若 m ≤ 120，建图 O(m^2)，从每个点 BFS：O(m * (m + E))，最坏 m ≤ 120 时约为 O(m^3)，上界也就百万级操作，完全可行。
额外空间：图与 BFS 队列 O(m^2)（最坏完全图）。

代码实现
Python
# -*- coding: utf-8 -*-
import sys
from collections import deque

# 外部函数：返回最短环长度
def shortest_cycle(nums):
# 过滤零（与任何数都不连边）
b = [x for x in nums if x != 0]
m = len(b)
if m == 0:
return -1

# 统计每一位出现次数，若有 >=3 直接返回 3
cnt = [0] * 61
for x in b:
for k in range(61):
if (x >> k) & 1:
cnt[k] += 1
if any(c >= 3 for c in cnt):
return 3

# 若非零数超过120，必有答案为3（抽屉原理）
if m > 120:
return 3

# 显式建无向图
g = [[] for _ in range(m)]
for i in range(m):
for j in range(i + 1, m):
if (b[i] & b[j]) != 0:
g[i].append(j)
g[j].append(i)

INF = 10 ** 9
ans = INF

# 从每个点 BFS，寻找最短环
for s in range(m):
dist = [INF] * m
fa = [-1] * m
q = deque([s])
dist[s] = 0
while q:
u = q.popleft()
for v in g[u]:
if dist[v] == INF:
dist[v] = dist[u] + 1
fa[v] = u
q.append(v)
elif fa[u] != v:  # 遇到非父边，形成环
ans = min(ans, dist[u] + dist[v] + 1)
if ans == 3:  # 已经是最优
break

return -1 if ans == INF else ans

def main():
data = list(map(int, sys.stdin.buffer.read().split()))
if not data:
return
n = data[0]
nums = data[1:1 + n]
print(shortest_cycle(nums))

if __name__ == "__main__":
main()

Java
// 注意：ACM 风格，类名为 Main
import java.io.*;
import java.util.*;

// 自定义快读以应对 n 可到 1e6
public class Main {
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is){ in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
long nextLong() throws IOException {
int c; do { c = read(); } while (c <= ' '); // 跳过空白
int sign = 1;
if (c == '-') { sign = -1; c = read(); }
long val = 0;
while (c > ' ') {
val = val * 10 + (c - '0');
c = read();
}
return val * sign;
}
}

// 外部函数：返回最短环长度
static int shortestCycle(long[] nums) {
ArrayList<Long> b = new ArrayList<>();
for (long x : nums) if (x != 0) b.add(x);
int m = b.size();
if (m == 0) return -1;

// 统计每一位出现次数
int[] cnt = new int[61];
for (long x : b) {
for (int k = 0; k <= 60; k++) {
if (((x >> k) & 1L) == 1L) cnt[k]++;
}
}
for (int c : cnt) if (c >= 3) return 3;
if (m > 120) return 3;

// 建图
ArrayList<Integer>[] g = new ArrayList[m];
for (int i = 0; i < m; i++) g[i] = new ArrayList<>();
for (int i = 0; i < m; i++) {
for (int j = i + 1; j < m; j++) {
if ( (b.get(i) & b.get(j)) != 0 ) {
g[i].add(j);
g[j].add(i);
}
}
}

final int INF = 1 << 29;
int ans = INF;

// 多源 BFS（逐点作为起点）
for (int s = 0; s < m; s++) {
int[] dist = new int[m];
int[] fa = new int[m];
Arrays.fill(dist, INF);
Arrays.fill(fa, -1);
ArrayDeque<Integer> q = new ArrayDeque<>();
dist[s] = 0; q.add(s);
while (!q.isEmpty()) {
int u = q.poll();
for (int v : g[u]) {
if (dist[v] == INF) {
dist[v] = dist[u] + 1;
fa[v] = u;
q.add(v);
} else if (fa[u] != v) {
ans = Math.min(ans, dist[u] + dist[v] + 1);
}
}
}
if (ans == 3) break;
}
return ans == INF ? -1 : ans;
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);
int n = (int) fs.nextLong();
long[] a = new long[n];
for (int i = 0; i < n; i++) a[i] = fs.nextLong();
System.out.println(shortestCycle(a));
}
}

C++
// ACM 风格：读入、输出在主函数，核心逻辑在外部函数
#include <bits/stdc++.h>
using namespace std;

// 外部函数：返回最短环长度
int shortest_cycle(const vector<long long>& nums) {
vector<long long> b;
for (auto x : nums) if (x != 0) b.push_back(x);
int m = (int)b.size();
if (m == 0) return -1;

// 统计每一位出现次数，出现 >=3 直接为 3
int cnt[61] = {0};
for (auto x : b) {
for (int k = 0; k <= 60; ++k)
if ((x >> k) & 1LL) cnt[k]++;
}
for (int k = 0; k <= 60; ++k) if (cnt[k] >= 3) return 3;
if (m > 120) return 3; // 抽屉原理

// 建图（m ≤ 120）
vector<vector<int>> g(m);
for (int i = 0; i < m; ++i) {
for (int j = i + 1; j < m; ++j) {
if ( (b[i] & b[j]) != 0 ) {
g[i].push_back(j);
g[j].push_back(i);
}
}
}

const int INF = 1e9;
int ans = INF;

// 从每个点 BFS，寻找最短环
for (int s = 0; s < m; ++s) {
vector<int> dist(m, INF), fa(m, -1);
queue<int> q;
dist[s] = 0; q.push(s);
while (!q.empty()) {
int u = q.front(); q.pop();
for (int v : g[u]) {
if (dist[v] == INF) {
dist[v] = dist[u] + 1;
fa[v] = u;
q.push(v);
} else if (fa[u] != v) {
ans = min(ans, dist[u] + dist[v] + 1);
}
}
}
if (ans == 3) break;
}
return ans == INF ? -1 : ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n;
if (!(cin >> n)) return 0;
vector<long long> a(n);
for (int i = 0; i < n; ++i) cin >> a[i];
cout << shortest_cycle(a) << "\n";
return 0;
}

---

### 第3题-制定项目计划（P4281）
- 链接：https://codefun2000.com/p/P4281

> 页面标题：#P4281. 第3题-制定项目计划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

一个项目经理需要对项目进行计划制定，现有 nnn 个项目，每个项目有一个开始时间 startTime[i]startTime[i]startTime[i]、结束时间  endTime[i]endTime[i]endTime[i] 以及所需投入的人力 effort[i]effort[i]effort[i] ，完成每个项目能获得的收益为 profit[i]profit[i]profit[i] 。
项目团队可以投入的最大工作量为 maxEffortmaxEffortmaxEffort ，并且在时间上重叠的项目不能同时开展。
如果一个项目在时间 XXX 结束，可以立刻承接在时间 XXX 开始的新项目。
请编写一个函数，计算在不超过可以投入最大工作量为 maxEffortmaxEffortmaxEffort 的情况下，合理安排计划获得的最大收益。
输入描述
函数包含 555 个参数，前四个数组参数，长度相同且 ≤2000≤
2000≤2000，数值均 ≤109≤10^9≤109 ，555 个参数分 555 行输入，数组数据以 ",,," 分割，示例如下:
1、开始时间数组 startTime,0≤startTime,0≤startTime,0≤ 数组长度及数据 ≤2000≤2000≤2000 ，示例: 111 555 999 ;
2、结束时间数组 endTime，0≤endTime，0≤endTime，0≤ 数组长度及数据 ≤2000≤2000≤2000 ，示例: 333 777 111111 ;
3、所需投入的工作量 effort，0≤effort，0≤effort，0≤ 数组长度及数据 ≤2000≤2000≤2000 ，示例:202020 303030 101010 ;
4、以及获得收益数组 profitprofitprofit ，0≤0≤0≤	数组长度及数据 ≤2000≤2000≤2000 ，示例:202020 808080 303030 ;
5、可以投入最大工作量 maxEffort，0≤maxEffort≤1000maxEffort，0 ≤ maxEffort ≤1000maxEffort，0≤maxEffort≤1000 ，示例:404040
输入完整示例如下:
1,5,91,5,91,5,9
3,7,113,7,113,7,11
20,30,1020,30,1020,30,10
20,80,3020,80,3020,80,30
404040
输出描述
在不超过每日工作量上限的情况下，安排合理计划获得最大收益
样例1
输入
2 4 7
6 8 11
20 20 20
30 90 30
40

输出
90

说明
选择第二个项目，由于时间与其他项目时间重叠
无法选取其他项目，总精力为 20<=4020<=4020<=40 ,总收益为 909090
样例2
输入
1 5 9
3 7 11
20 30 10
20 80 30
40

输出
110

说明
选择第二个和第三个项目，总精力为 30+10=40<=4030+10=40<=4030+10=40<=40 ,总收益为 80+30=11080+30=11080+30=110

#### TextSol

解题思路

本题是“带容量约束的加权区间调度”问题：
既要保证所选项目在时间上两两不重叠（若一个在时间 X 结束，可接 X 开始的项目），又要满足总工作量不超过 maxEffort，并使收益最大。

做法：

将项目按结束时间从小到大排序，记排序后第 i 个项目为 (s[i], e[i], w[i], v[i])，分别是开始/结束/工作量/收益。

预处理每个项目 i 的“前驱” pre[i]：排序后在 i 之前、且 end <= s[i] 的最后一个项目下标（不存在则为 -1）。可用二分在结束时间数组上找到。

二维动态规划（DP）：
设 dp[i][E] 表示只考虑前 i 个项目、总可用工作量为 E 时的最大收益。转移：

不选第 i 个：dp[i][E] = dp[i-1][E]
选第 i 个（若 w[i] ≤ E）：
dp[i][E] = max(dp[i][E], dp[pre[i]+1][E - w[i]] + v[i])
注意这里用到的是“前驱项目集合”的最优解。

答案为 dp[n][maxEffort]。

相关算法：加权区间调度 + 0/1 背包（二维 DP + 二分预处理）。

复杂度分析

预处理排序与二分：O(n log n)
DP 转移：O(n * maxEffort)（n ≤ 2000, maxEffort ≤ 1000，可行）
空间复杂度：O(n * maxEffort)
（Python 采用紧凑存储以避免大内存消耗）

代码实现
Python
# -*- coding: utf-8 -*-
# 说明：输入为 5 行，依次为 startTime、endTime、effort、profit、maxEffort（以空格分隔）。
# 为稳妥与简洁，此处直接按空格 split 读取；题面保证数据合法。

import sys
from bisect import bisect_right
from array import array  # 紧凑整数数组，降低内存

def max_profit_with_effort(start, end, effort, profit, maxEffort):
n = len(start)
if n == 0 or maxEffort == 0:
return 0

# 1) 按结束时间排序
jobs = sorted(zip(start, end, effort, profit), key=lambda x: x[1])
s = [x[0] for x in jobs]
e = [x[1] for x in jobs]
w = [x[2] for x in jobs]
v = [x[3] for x in jobs]

# 2) 预处理前驱 pre[i]：满足 e[pre] <= s[i] 的最大下标
pre = []
for i in range(n):
j = bisect_right(e, s[i]) - 1  # 最右 <= s[i]
pre.append(j)

# 3) 二维 DP，使用一维扁平数组紧凑存储：索引 (i, E) -> i*(maxEffort+1)+E
M = maxEffort + 1
dp = array('q', [0] * ((n + 1) * M))  # 'q' 为有符号 64 位整数

for i in range(1, n + 1):
base = i * M
prev_base = (i - 1) * M

# 不选第 i 个
for E in range(M):
dp[base + E] = dp[prev_base + E]

# 选第 i 个（注意数组下标与 i-1 对应）
wi = w[i - 1]
vi = v[i - 1]
pi = pre[i - 1] + 1  # 转为 dp 的“行号”
pi_base = pi * M

if wi <= maxEffort:
for E in range(wi, M):
cand = dp[pi_base + (E - wi)] + vi
if cand > dp[base + E]:
dp[base + E] = cand

return dp[n * M + maxEffort]

def read_ints(line):
line = line.strip()
if not line:
return []
return list(map(int, line.split()))

def main():
data = sys.stdin.read().strip().splitlines()
# 兼容空行：只取前 5 条有效行
lines = []
for t in data:
if lines.__len__() < 5:
lines.append(t)

start = read_ints(lines[0]) if len(lines) > 0 else []
end = read_ints(lines[1]) if len(lines) > 1 else []
effort = read_ints(lines[2]) if len(lines) > 2 else []
profit = read_ints(lines[3]) if len(lines) > 3 else []
maxEffort = int(lines[4].strip()) if len(lines) > 4 and lines[4].strip() else 0

ans = max_profit_with_effort(start, end, effort, profit, maxEffort)
print(ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {

// 统一：解析为 long[]，再按需转 int
static long[] parseLongArray(String line) {
if (line == null) return new long[0];
line = line.trim();
if (line.isEmpty()) return new long[0];
String[] parts = line.split("\\s+");
long[] arr = new long[parts.length];
for (int i = 0; i < parts.length; i++) arr[i] = Long.parseLong(parts[i]);
return arr;
}

static long solve(long[] start, long[] end, int[] effort, long[] profit, int maxEffort) {
int n = start.length;
if (n == 0 || maxEffort == 0) return 0L;

// 1) 按结束时间排序
Integer[] idx = new Integer[n];
for (int i = 0; i < n; i++) idx[i] = i;
Arrays.sort(idx, Comparator.comparingLong(i -> end[i]));

long[] s = new long[n], e = new long[n], v = new long[n];
int[] w = new int[n];
for (int i = 0; i < n; i++) {
int id = idx[i];
s[i] = start[id]; e[i] = end[id]; w[i] = effort[id]; v[i] = profit[id];
}

// 2) 前驱
long[] ends = e.clone();
int[] pre = new int[n];
for (int i = 0; i < n; i++) {
int pos = upperBound(ends, s[i]) - 1;
pre[i] = pos;
}

// 3) 二维 DP
long[][] dp = new long[n + 1][maxEffort + 1];
for (int i = 1; i <= n; i++) {
for (int E = 0; E <= maxEffort; E++) dp[i][E] = dp[i - 1][E]; // 不选
int wi = w[i - 1];
long vi = v[i - 1];
int pi = pre[i - 1] + 1;
if (wi <= maxEffort) {
for (int E = wi; E <= maxEffort; E++) {
dp[i][E] = Math.max(dp[i][E], dp[pi][E - wi] + vi);
}
}
}
return dp[n][maxEffort];
}

static int upperBound(long[] a, long key) {
int l = 0, r = a.length;
while (l < r) {
int m = (l + r) >>> 1;
if (a[m] <= key) l = m + 1;
else r = m;
}
return l;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String l1 = br.readLine();
String l2 = br.readLine();
String l3 = br.readLine();
String l4 = br.readLine();
String l5 = br.readLine();

long[] start = parseLongArray(l1);
long[] end   = parseLongArray(l2);
long[] effortL = parseLongArray(l3);
long[] profit = parseLongArray(l4);

// 将 effort 转为 int（题面范围安全）
int[] effort = new int[effortL.length];
for (int i = 0; i < effortL.length; i++) effort[i] = (int)effortL[i];

int maxEffort = 0;
if (l5 != null && !l5.trim().isEmpty()) {
maxEffort = (int)Long.parseLong(l5.trim());
}

long ans = solve(start, end, effort, profit, maxEffort);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

/* 统一解析为 long long，再按需转成 int */
static vector<long long> parseLLLine(const string &line) {
vector<long long> a;
if (line.empty()) return a;
stringstream ss(line);
long long x;
while (ss >> x) a.push_back(x);
return a;
}

long long solve(const vector<long long>& start,
const vector<long long>& endt,
const vector<int>& effort,
const vector<long long>& profit,
int maxEffort) {
int n = (int)start.size();
if (n == 0 || maxEffort == 0) return 0LL;

// 1) 按结束时间排序
vector<int> idx(n);
iota(idx.begin(), idx.end(), 0);
sort(idx.begin(), idx.end(), [&](int a, int b){
return endt[a] < endt[b];
});

vector<long long> s(n), e(n), v(n);
vector<int> w(n);
for (int i = 0; i < n; ++i) {
int id = idx[i];
s[i] = start[id]; e[i] = endt[id]; w[i] = effort[id]; v[i] = profit[id];
}

// 2) 预处理前驱 pre[i]
vector<int> pre(n);
for (int i = 0; i < n; ++i) {
int pos = upper_bound(e.begin(), e.end(), s[i]) - e.begin() - 1; // 最右 <= s[i]
pre[i] = pos; // 可能为 -1
}

// 3) 二维 DP
vector<vector<long long>> dp(n + 1, vector<long long>(maxEffort + 1, 0));
for (int i = 1; i <= n; ++i) {
for (int E = 0; E <= maxEffort; ++E) dp[i][E] = dp[i - 1][E]; // 不选
int wi = w[i - 1];
long long vi = v[i - 1];
int pi = pre[i - 1] + 1;
if (wi <= maxEffort) {
for (int E = wi; E <= maxEffort; ++E) {
dp[i][E] = max(dp[i][E], dp[pi][E - wi] + vi);
}
}
}
return dp[n][maxEffort];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string l1, l2, l3, l4, l5;
getline(cin, l1);
getline(cin, l2);
getline(cin, l3);
getline(cin, l4);
getline(cin, l5);

vector<long long> startLL  = parseLLLine(l1);
vector<long long> endLL    = parseLLLine(l2);
vector<long long> effortLL = parseLLLine(l3);
vector<long long> profitLL = parseLLLine(l4);

// 将 effort 转为 int（题面范围安全）
vector<int> effort(effortLL.size());
for (size_t i = 0; i < effortLL.size(); ++i) effort[i] = (int)effortLL[i];

// 解析 maxEffort
int maxEffort = 0;
if (!l5.empty()) {
stringstream ss(l5);
long long tmp; ss >> tmp;
maxEffort = (int)tmp;
}

cout << solve(startLL, endLL, effort, profitLL, maxEffort) << "\n";
return 0;
}

---

## 2025年10月23日-AI方向(留学生)

### 第2题-人脸关键点对齐（P4277）
- 链接：https://codefun2000.com/p/P4277

> 页面标题：#P4277. 第2题-人脸关键点对齐

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

人脸关键点对齐是人脸识别算法过程中非常重要的一步，其方法是基于检测人脸关键点及模板人脸关键点获得变换矩阵 MMM ，使得最小二乘意义下把原图的关键点贴到模板关键点位置，其基本原理是对图像得仿射变换。现在你将实现一个图像的仿射变换函数，该函数接收一个二维图像矩阵 AAA 、一个变换矩阵 MMM 和输出图像的尺寸 000 ，返回变换后的图像。
变换公式为，其中 x,yx,yx,y 为原坐标， x′,y′x',y'x′,y′ 为变换后的坐标， a,b,c,da,b,c,da,b,c,d 是线性变换部分的系数， tx,tyt_x,t_ytx​,ty​ 是平移向量:
x′=a×x+b×y+txx'=a×x+b×y+t_xx′=a×x+b×y+tx​
y′=c×x+d×y+tyy'=c×x+d×y+t_yy′=c×x+d×y+ty​
如果变换后的坐标超出原图像范围，则不赋值(保留为 000 )。
输入描述
输入图像 AAA :一个二维列表，表示输入图像，每个元素是一个像素值。
交换矩阵 MMM :一个二维列表，格式如下:
[[a,b,tx],[c,d,ty]][[a, b, t_ x], [c,d,t_y]][[a,b,tx​],[c,d,ty​]]
输出图像的尺寸 height,widthheight, widthheight,width
输入第一行分别为 A、MA、MA、M 列表的长度 a,ma,ma,m 以及输出列表 OOO 所占用的行，接下来的 aaa 行为输入图像 AAA ，然后 mmm 行是输入变换矩阵，最后一行是输出图像的大小
输出描述
返回一个二维列表，表示变换后的图像
样例1
输入
3 2 1
10 20 30
40 50 60
70 80 90
0 1 0
-1 0 2
3 3

输出
30 60 90 20 50 80 10 40 70

说明
第一行 333 222 111 表示:
从第二行起接下来的三行是图像 AAA 的输入，然后下面两行是变换矩阵的输入，最后一行是输出图像的高度及宽度
输出图像矩阵为 [[30,60,90],[20,50,80],[10,40,70][[30,60,90],[20,50,80],[10,40,70][[30,60,90],[20,50,80],[10,40,70] ,
展开后最终的输出为 303030 606060 909090 202020 505050 808080 101010 404040 707070
样例2
输入
3 2 1
10 20 30
40 50 60
70 80 90
-1 0 2
0 1 0
3 4

输出
30 20 10 0 60 50 40 0 90 80 70 0

提示
1.如果变换矩阵的线性部分 (a,b,c,d)(a,b,c,d)(a,b,c,d) 不可逆，则返回一个全 000 的图像

#### TextSol

解题思路

算法：对给定图像做二维仿射变换。仿射模型为
x′=ax+by+tx,y′=cx+dy+tyx' = a x + b y + t_x,\quad y' = c x + d y + t_yx′=ax+by+tx​,y′=cx+dy+ty​。
为避免“空洞”，采用逆映射 + 最近邻插值：对每个输出像素 (x′,y′)(x',y')(x′,y′)，先减去平移，再乘线性部分的逆矩阵，得到源坐标 (x,y)(x,y)(x,y)。若 (x,y)(x,y)(x,y) 在原图范围内，则取最近邻像素；否则置 0。

核心实现：

从矩阵 M=[abtxcdty]M=\begin{bmatrix}a&b&t_x\\c&d&t_y\end{bmatrix}M=[ac​bd​tx​ty​​] 取出 a,b,c,d,tx,tya,b,c,d,t_x,t_ya,b,c,d,tx​,ty​。
计算线性部分的逆:

枚举输出图像尺寸 H×WH\times WH×W 的每个像素 (x′,y′)(x',y')(x′,y′)，

取 (round(x),round(y))(\text{round}(x),\text{round}(y))(round(x),round(y)) 作为最近邻位置，越界则填 0。

坐标约定：x 为列、y 为行，左上角为 (0,0)(0,0)(0,0)。

输入输出：
第一行给出行数：a m o_lines。接着 a 行是图像 A；随后 m 行是 2×3 的变换矩阵 M；最后一行是输出尺寸 H W。
输出按行优先展平成一行空格分隔的数列。

复杂度分析

时间复杂度：枚举全部输出像素，O(H×W)O(H \times W)O(H×W)。
空间复杂度：保存输出图像，O(H×W)O(H \times W)O(H×W)（除输入外）。

代码实现
Python
# 题面功能封装在函数里；主函数做输入输出（ACM 风格）

from typing import List
import sys
import math

def affine_transform(A: List[List[int]], M: List[List[float]], H: int, W: int) -> List[List[int]]:
# 解析仿射参数
a, b, tx = M[0]
c, d, ty = M[1]
# 线性部分行列式
det = a * d - b * c
hA, wA = len(A), len(A[0]) if A else 0
# 输出初始化为 0
O = [[0 for _ in range(W)] for _ in range(H)]
if abs(det) < 1e-12 or hA == 0 or wA == 0:
return O

# 预计算逆矩阵
inv00 =  d / det
inv01 = -b / det
inv10 = -c / det
inv11 =  a / det

for y2 in range(H):          # y'
for x2 in range(W):      # x'
# 去掉平移再乘逆矩阵 -> 源坐标 (x, y)
dx = x2 - tx
dy = y2 - ty
x = inv00 * dx + inv01 * dy
y = inv10 * dx + inv11 * dy
xi = int(round(x))
yi = int(round(y))
if 0 <= yi < hA and 0 <= xi < wA:
O[y2][x2] = A[yi][xi]
return O

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
a = int(next(it)); m = int(next(it)); _ = int(next(it))  # O 占 1 行
A = []
if __name__ == "__main__":
import sys

lines = sys.stdin.read().strip().splitlines()
if not lines:
sys.exit(0)
a, m, _ = map(int, lines[0].split())
idx = 1
A = [list(map(int, lines[idx+i].split())) for i in range(a)]
idx += a
M = [list(map(float, lines[idx].split())), list(map(float, lines[idx+1].split()))]
idx += m
H, W = map(int, lines[idx].split())

O = affine_transform(A, M, H, W)
# 按行优先展平输出
out = []
for r in O:
out.extend(map(str, r))
print(" ".join(out))

Java
// 类名固定为 Main；主方法处理输入输出，功能写在外部静态函数里
import java.io.*;
import java.util.*;

public class Main {

// 仿射变换，最近邻
static int[][] affineTransform(int[][] A, double[][] M, int H, int W) {
int hA = A.length;
int wA = hA > 0 ? A[0].length : 0;
int[][] O = new int[H][W];
double a = M[0][0], b = M[0][1], tx = M[0][2];
double c = M[1][0], d = M[1][1], ty = M[1][2];
double det = a * d - b * c;
if (Math.abs(det) < 1e-12 || hA == 0 || wA == 0) return O;

// 线性部分逆矩阵
double inv00 =  d / det, inv01 = -b / det;
double inv10 = -c / det, inv11 =  a / det;

for (int y2 = 0; y2 < H; y2++) {
for (int x2 = 0; x2 < W; x2++) {
double dx = x2 - tx;
double dy = y2 - ty;
double x = inv00 * dx + inv01 * dy;
double y = inv10 * dx + inv11 * dy;
int xi = (int)Math.round(x);
int yi = (int)Math.round(y);
if (0 <= yi && yi < hA && 0 <= xi && xi < wA) {
O[y2][x2] = A[yi][xi];
} // 越界保持 0
}
}
return O;
}

public static void main(String[] args) throws Exception {
// 读取整段文本后逐行解析，避免 Scanner 过慢
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
List<String> lines = new ArrayList<>();
String s;
while ((s = br.readLine()) != null && s.length() > 0) lines.add(s);
if (lines.isEmpty()) return;

String[] t0 = lines.get(0).trim().split("\\s+");
int a = Integer.parseInt(t0[0]);
int m = Integer.parseInt(t0[1]); // 题目中 m=2
// o_lines = Integer.parseInt(t0[2]); // 未用

int idx = 1;
int[][] A = new int[a][];
for (int i = 0; i < a; i++) {
String[] ts = lines.get(idx++).trim().split("\\s+");
A[i] = new int[ts.length];
for (int j = 0; j < ts.length; j++) A[i][j] = Integer.parseInt(ts[j]);
}
double[][] M = new double[2][3];
for (int i = 0; i < 2; i++) {
String[] ts = lines.get(idx++).trim().split("\\s+");
for (int j = 0; j < 3; j++) M[i][j] = Double.parseDouble(ts[j]);
}
String[] ts = lines.get(idx).trim().split("\\s+");
int H = Integer.parseInt(ts[0]);
int W = Integer.parseInt(ts[1]);

int[][] O = affineTransform(A, M, H, W);

// 展平输出
StringBuilder out = new StringBuilder();
for (int i = 0; i < H; i++) {
for (int j = 0; j < W; j++) {
if (out.length() > 0) out.append(' ');
out.append(O[i][j]);
}
}
System.out.println(out.toString());
}
}

C++
// 主函数读入，功能放在独立函数；ACM 风格
#include <bits/stdc++.h>
using namespace std;

// 仿射变换：逆映射 + 最近邻
vector<vector<int>> affine_transform(const vector<vector<int>>& A,
const array<array<double,3>,2>& M,
int H, int W) {
int hA = (int)A.size();
int wA = hA ? (int)A[0].size() : 0;
vector<vector<int>> O(H, vector<int>(W, 0));

double a = M[0][0], b = M[0][1], tx = M[0][2];
double c = M[1][0], d = M[1][1], ty = M[1][2];
double det = a * d - b * c;
if (fabs(det) < 1e-12 || hA == 0 || wA == 0) return O;

// 线性部分逆矩阵
double inv00 =  d / det, inv01 = -b / det;
double inv10 = -c / det, inv11 =  a / det;

for (int y2 = 0; y2 < H; ++y2) {
for (int x2 = 0; x2 < W; ++x2) {
double dx = x2 - tx;
double dy = y2 - ty;
double x = inv00 * dx + inv01 * dy;
double y = inv10 * dx + inv11 * dy;
int xi = (int)llround(x); // 最近邻
int yi = (int)llround(y);
if (0 <= yi && yi < hA && 0 <= xi && xi < wA) {
O[y2][x2] = A[yi][xi];
}
}
}
return O;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int a, m, o;
if (!(cin >> a >> m >> o)) return 0;

// 读入图像 A（a 行）
vector<vector<int>> A(a);
cin.clear();
cin.seekg(0, ios::beg);
// 读整段
vector<string> lines;
string s;
while (getline(cin, s)) if(!s.empty()) lines.push_back(s);
if (lines.empty()) return 0;
{
stringstream ss(lines[0]);
ss >> a >> m >> o;
}
int idx = 1;
A.clear(); A.reserve(a);
for (int i = 0; i < a; ++i) {
stringstream ss(lines[idx++]);
vector<int> row; int v;
while (ss >> v) row.push_back(v);
A.push_back(row);
}
array<array<double,3>,2> M;
for (int i = 0; i < 2; ++i) {
stringstream ss(lines[idx++]);
for (int j = 0; j < 3; ++j) ss >> M[i][j];
}
int H, W;
{
stringstream ss(lines[idx]);
ss >> H >> W;
}

auto O = affine_transform(A, M, H, W);

// 展平输出
bool first = true;
for (int i = 0; i < H; ++i) {
for (int j = 0; j < W; ++j) {
if (!first) cout << ' ';
first = false;
cout << O[i][j];
}
}
cout << '\n';
return 0;
}

---

### 第3题-卷积结构实现（P4278）
- 链接：https://codefun2000.com/p/P4278

> 页面标题：#P4278. 第3题-卷积结构实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

卷积神经网络 (CNN)(CNN)(CNN) 是计算机视觉领域的核心模型，ResNedResNedResNed 通过残差连接 (Residual(Residual(Residual Connection)Connection)Connection) 进一步解决了深层神经网络梯度消失的问题，本题要求实现 CNNCNNCNN 基础的卷积函数 $Conv2D(input, weight, bias, stride,padding, dilation)$，相关参数描述如下:
inputinputinput:输入数据;
weightweightweight:卷积核的权重;
biasbiasbias:卷积核的偏置
stridestridestride:卷积核的移动步长;
paddingpaddingpadding:输入数据边缘填充的像素数(填充 000 );
dilationdilationdilation:卷积核元素之间的间隔;
输入描述
第 111 行:输入数据的形状 c,x,yc,x,yc,x,y，以空格隔开
第 222 行:输入数据，为 c∗x∗yc*x*yc∗x∗y 个实数，按照先行后列排序。
第 333 行:卷积核的形状 out,in,k,kout,in,k,kout,in,k,k
第 444 行:卷积的权重，数量为 out∗in∗k∗kout*in*k*kout∗in∗k∗k ，按照先行后列排序
第 555 行: bias,stride,padding,dilationbias, stride, padding, dilationbias,stride,padding,dilation
第 666 行:若 biasbiasbias 为 111 ，则该行为 biasbiasbias 的具体值，长度为 outoutout ，否则该行为空
其中 0<x,y<1000,0<k<1000<x,y<1000,0<k<1000<x,y<1000,0<k<100
输出描述
卷积的计算结果，输出为一行，保留 444 位小数，不足四位小数补 000
样例1
输入
1 4 4
1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0
1 1 3 3
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
0 1 0 1

输出
54.0000 63.0000 90.0000 99.0000

说明
输入的形状为 (1.4,4)(1.4,4)(1.4,4) ，故第二行的数据 1.01.01.0 2.02.02.0 3.03.03.0 4.04.04.0 5.05.05.0 6.06.06.0 7.07.07.0 8.08.08.0 9.09.09.0 10.010.010.0 11.011.011.0 12.012.012.0 13.013.013.0 14.014.014.0 15.015.015.0 16.016.016.0 的数据排列方式为:
[[[1.0,2.0,3.0,4.0],[[[1.0, 2.0, 3.0, 4.0],[[[1.0,2.0,3.0,4.0],
[5.0.6.0,7.0,8.0],[5.0.6.0,7.0,8.0],[5.0.6.0,7.0,8.0],
[9.0,10.0,11.0,12.0][9.0,10.0,11.0,12.0][9.0,10.0,11.0,12.0]
[13.0,14.0,15.0,16.0]]][13.0,14.0,15.0,16.0]]][13.0,14.0,15.0,16.0]]]
卷积计算结果为:
[[[54.0000,63.0000],[[[54.0000, 63.0000],[[[54.0000,63.0000],
[90.0000,99.0000][90.0000,99.0000][90.0000,99.0000]
输出为:54.000054.000054.0000 63.000063.000063.0000 90.000090.000090.0000 99.000099.000099.0000
样例2
输入
1 4 4
1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0 15.0 16.0
1 1 3 3
1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
1 1 0 1
1.0

输出
55.0000 64.0000 91.0000 100.0000

#### TextSol

解题思路
本题需要手写二维卷积 Conv2D(input, weight, bias, stride, padding, dilation)，支持步幅、零填充与空洞（扩张）卷积。
设输入形状为 (C, H, W)，卷积核形状为 (Out, In, K, K)。

输出尺寸计算
令有效核尺寸 K_eff = dilation * (K - 1) + 1
H_out = floor((H + 2*padding - K_eff) / stride) + 1
W_out = floor((W + 2*padding - K_eff) / stride) + 1

卷积计算
对每个输出通道 oc、输出位置 (oh, ow)：
y[oc, oh, ow] = (bias[oc] if 有偏置 else 0)
+ Σ_{ic=0..In-1} Σ_{kh=0..K-1} Σ_{kw=0..K-1}
x[ic, ih, iw] * w[oc, ic, kh, kw]
其中：
ih = oh*stride + kh*dilation - padding
iw = ow*stride + kw*dilation - padding
超出边界的 (ih, iw) 视为 0（零填充）。

读写顺序

输入与权重均按“先行后列”展开；多维时采用 通道优先 再行、再列，即：

input 展开顺序：ic -> ih -> iw
weight 展开顺序：oc -> ic -> kh -> kw

输出打印顺序：oc -> oh -> ow，全部保留 4 位小数，以空格分隔。

复杂度分析

时间复杂度：O(Out * In * H_out * W_out * K * K)
空间复杂度：O(C*H*W + Out*In*K*K + Out*H_out*W_out)（主要为存储输入、权重与结果），额外辅助空间为 O(1)。

代码实现
Python
# -*- coding: utf-8 -*-
# 题面要求：主函数内做输入输出，功能在外部函数；ACM 风格；中文注释

import sys

def conv2d(input_arr, C, H, W, weight_arr, Out, InC, K, bias_arr, has_bias, stride, padding, dilation):
# 计算输出尺寸
K_eff = dilation * (K - 1) + 1
H_out = (H + 2 * padding - K_eff) // stride + 1
W_out = (W + 2 * padding - K_eff) // stride + 1

# 索引函数（行优先）
def idx_input(ic, ih, iw):
return ic * (H * W) + ih * W + iw

def idx_weight(oc, ic, kh, kw):
return (((oc * InC + ic) * K + kh) * K + kw)

# 结果数组（扁平存储：oc -> oh -> ow）
out_size = Out * H_out * W_out
out_arr = [0.0] * out_size

# 卷积主循环
for oc in range(Out):
b = bias_arr[oc] if has_bias else 0.0
for oh in range(H_out):
for ow in range(W_out):
s = b
base_h = oh * stride - padding
base_w = ow * stride - padding
for ic in range(InC):
for kh in range(K):
ih = base_h + kh * dilation
if ih < 0 or ih >= H:
continue
for kw in range(K):
iw = base_w + kw * dilation
if iw < 0 or iw >= W:
continue
s += input_arr[idx_input(ic, ih, iw)] * weight_arr[idx_weight(oc, ic, kh, kw)]
out_index = (oc * H_out + oh) * W_out + ow
out_arr[out_index] = s
return out_arr, H_out, W_out

def main():
data = sys.stdin.read().strip().split()
it = iter(data)

# 读取输入形状 C H W
C = int(next(it)); H = int(next(it)); W = int(next(it))
# 读取输入数据（行优先，通道优先）
input_cnt = C * H * W
input_arr = [float(next(it)) for _ in range(input_cnt)]

# 读取卷积核形状 Out In K K
Out = int(next(it)); InC = int(next(it)); K1 = int(next(it)); K2 = int(next(it))
K = K1  # 题目保证为方核

# 读取权重
weight_cnt = Out * InC * K * K
weight_arr = [float(next(it)) for _ in range(weight_cnt)]

# 读取 bias 标志、stride、padding、dilation
has_bias_flag = int(next(it))
stride = int(next(it)); padding = int(next(it)); dilation = int(next(it))

# 读取 bias
if has_bias_flag == 1:
bias_arr = [float(next(it)) for _ in range(Out)]
has_bias = True
else:
bias_arr = [0.0] * Out
has_bias = False

# 计算卷积
out_arr, H_out, W_out = conv2d(input_arr, C, H, W, weight_arr, Out, InC, K, bias_arr, has_bias, stride, padding, dilation)

# 输出一行，四位小数
res = ["{:.4f}".format(v) for v in out_arr]
print(" ".join(res))

if __name__ == "__main__":
main()

Java
// ACM 风格；类名 Main；中文注释
import java.io.*;
import java.util.*;

public class Main {
// 计算一维索引（行优先）
static int idxInput(int ic, int ih, int iw, int C, int H, int W) {
return ic * (H * W) + ih * W + iw;
}
static int idxWeight(int oc, int ic, int kh, int kw, int Out, int InC, int K) {
return (((oc * InC + ic) * K + kh) * K + kw);
}

static double[] conv2d(double[] input, int C, int H, int W,
double[] weight, int Out, int InC, int K,
double[] bias, boolean hasBias,
int stride, int padding, int dilation) {
int K_eff = dilation * (K - 1) + 1;
int H_out = (H + 2 * padding - K_eff) / stride + 1;
int W_out = (W + 2 * padding - K_eff) / stride + 1;

double[] out = new double[Out * H_out * W_out];

for (int oc = 0; oc < Out; oc++) {
double b = hasBias ? bias[oc] : 0.0;
for (int oh = 0; oh < H_out; oh++) {
for (int ow = 0; ow < W_out; ow++) {
double s = b;
int base_h = oh * stride - padding;
int base_w = ow * stride - padding;
for (int ic = 0; ic < InC; ic++) {
for (int kh = 0; kh < K; kh++) {
int ih = base_h + kh * dilation;
if (ih < 0 || ih >= H) continue;
for (int kw = 0; kw < K; kw++) {
int iw = base_w + kw * dilation;
if (iw < 0 || iw >= W) continue;
s += input[idxInput(ic, ih, iw, C, H, W)] *
weight[idxWeight(oc, ic, kh, kw, Out, InC, K)];
}
}
}
int outIdx = (oc * H_out + oh) * W_out + ow;
out[outIdx] = s;
}
}
}
return out;
}

// 简单快速读入（兼顾性能与易懂）
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
while ((c = read()) != -1 && c <= ' ') {}
if (c == -1) return null;
do {
sb.append((char)c);
c = read();
} while (c != -1 && c > ' ');
return sb.toString();
}
int nextInt() throws IOException { return Integer.parseInt(next()); }
double nextDouble() throws IOException { return Double.parseDouble(next()); }
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);

// 读取输入形状 C H W
int C = Integer.parseInt(fs.next());
int H = Integer.parseInt(fs.next());
int W = Integer.parseInt(fs.next());

// 输入数据
int inCnt = C * H * W;
double[] input = new double[inCnt];
for (int i = 0; i < inCnt; i++) input[i] = Double.parseDouble(fs.next());

// 卷积核形状 Out In K K
int Out = Integer.parseInt(fs.next());
int InC = Integer.parseInt(fs.next());
int K1 = Integer.parseInt(fs.next());
int K2 = Integer.parseInt(fs.next());
int K = K1; // 方核

// 权重
int wCnt = Out * InC * K * K;
double[] weight = new double[wCnt];
for (int i = 0; i < wCnt; i++) weight[i] = Double.parseDouble(fs.next());

// bias 标志、stride、padding、dilation
int hasBiasFlag = Integer.parseInt(fs.next());
int stride = Integer.parseInt(fs.next());
int padding = Integer.parseInt(fs.next());
int dilation = Integer.parseInt(fs.next());

// bias
double[] bias = new double[Out];
boolean hasBias = hasBiasFlag == 1;
if (hasBias) {
for (int i = 0; i < Out; i++) bias[i] = Double.parseDouble(fs.next());
}

// 计算
double[] out = conv2d(input, C, H, W, weight, Out, InC, K, bias, hasBias, stride, padding, dilation);

// 输出一行，四位小数
StringBuilder sb = new StringBuilder();
Locale.setDefault(Locale.US);
for (int i = 0; i < out.length; i++) {
if (i > 0) sb.append(' ');
sb.append(String.format(Locale.US, "%.4f", out[i]));
}
System.out.println(sb.toString());
}
}

C++
// ACM 风格；中文注释；保持语法简洁
#include <bits/stdc++.h>
using namespace std;

inline int idxInput(int ic, int ih, int iw, int C, int H, int W) {
return ic * (H * W) + ih * W + iw;
}
inline int idxWeight(int oc, int ic, int kh, int kw, int Out, int InC, int K) {
return (((oc * InC + ic) * K + kh) * K + kw);
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int C, H, W;
if (!(cin >> C >> H >> W)) return 0;

// 输入数据
int inCnt = C * H * W;
vector<double> input(inCnt);
for (int i = 0; i < inCnt; ++i) cin >> input[i];

// 卷积核形状 Out In K K
int Out, InC, K1, K2;
cin >> Out >> InC >> K1 >> K2;
int K = K1; // 方核

// 权重
int wCnt = Out * InC * K * K;
vector<double> weight(wCnt);
for (int i = 0; i < wCnt; ++i) cin >> weight[i];

// bias 标志、stride、padding、dilation
int hasBiasFlag, stride, padding, dilation;
cin >> hasBiasFlag >> stride >> padding >> dilation;

// bias
vector<double> bias(Out, 0.0);
bool hasBias = (hasBiasFlag == 1);
if (hasBias) {
for (int i = 0; i < Out; ++i) cin >> bias[i];
}

// 输出尺寸
int K_eff = dilation * (K - 1) + 1;
int H_out = (H + 2 * padding - K_eff) / stride + 1;
int W_out = (W + 2 * padding - K_eff) / stride + 1;

vector<double> out(Out * H_out * W_out, 0.0);

// 卷积
for (int oc = 0; oc < Out; ++oc) {
double b = hasBias ? bias[oc] : 0.0;
for (int oh = 0; oh < H_out; ++oh) {
for (int ow = 0; ow < W_out; ++ow) {
double s = b;
int base_h = oh * stride - padding;
int base_w = ow * stride - padding;
for (int ic = 0; ic < InC; ++ic) {
for (int kh = 0; kh < K; ++kh) {
int ih = base_h + kh * dilation;
if (ih < 0 || ih >= H) continue;
for (int kw = 0; kw < K; ++kw) {
int iw = base_w + kw * dilation;
if (iw < 0 || iw >= W) continue;
s += input[idxInput(ic, ih, iw, C, H, W)] *
weight[idxWeight(oc, ic, kh, kw, Out, InC, K)];
}
}
}
out[(oc * H_out + oh) * W_out + ow] = s;
}
}
}

// 按要求输出为一行，四位小数
cout.setf(std::ios::fixed);
cout << setprecision(4);
for (size_t i = 0; i < out.size(); ++i) {
if (i) cout << ' ';
cout << out[i];
}
cout << '\n';
return 0;
}

---

## 2025年10月22日-AI方向

### 第2题-最大能量路径（P4274）
- 链接：https://codefun2000.com/p/P4274

> 页面标题：#P4274. 第2题-最大能量路径

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在自动驾驶系统中，车道线识别是核心功能之一。车道线通常具有连续性，从图像左侧到右侧逐渐展开。
为了识别出最可能的车道线路径，我们可以在图像中找到一条路径，使得路径上所有像素的信号值与策略矩阵的乘积之和最大。
现定义每个位置的能量值为策略矩阵与该位置周边信号值的乘积和。
给定一个 H×WH×WH×W 的图像以及一个 K×KK×KK×K 的策略矩阵，用于模拟不同方向的路径选择策略。
你需要从图像的第一列任意像素出发，走到最后一列任意像素，每一步只能向右、右上、右下移动一格。
在行进的过程中，需要实时的收集能量值，请找到一条路径，使得路径上的能量值之和最大。
输入描述
第一行输入 HHH WWW KKK KKK ，分表表示给定图像及策略矩阵的维度
接下来
HHH 行输入图像矩阵
KKK 行输入策略矩阵
输出描述
输出最大能量值
样例1
输入
1 1 1 1
5
1

输出
5.0

说明
有且仅有一条路径，最大能量值为 5∗15*15∗1 为 5.05.05.0
样例2
输入
3 3 3 3
1 2 3
4 5 6
7 8 9
1 2 2
1 1 1
1 1 1

输出
119.0

说明
输入第一行是一个 3×33×33×3 的图像以及 3×33×33×3 的策略矩阵
每个位置的能量图：
[[12.21.16.][[12.21.16.][[12.21.16.]
[30.50.36.][30.50.36.][30.50.36.]
[33.50.34.]][33.50.34.]][33.50.34.]]
最大能量路径的值：119.0119.0119.0 最大能量路径：(2,0)−>(1,1)−>(1,2)(2,0)->(1,1)->(1,2)(2,0)−>(1,1)−>(1,2)
提示
1.1.1.策略矩阵为奇数，边缘处用零填充
2.2.2.输出保留一位小数

#### TextSol

思路

预处理能量： 先按上式计算整张图的能量矩阵 EEE，复杂度 O(H⋅W⋅K2)O(H\cdot W\cdot K^2)O(H⋅W⋅K2)。

动态规划建模： 用 fi,jf_{i,j}fi,j​ 表示走到位置 (i,j)(i,j)(i,j) 的最大能量和：

边界： fi,0=Ei,0f_{i,0}=E_{i,0}fi,0​=Ei,0​，对所有 i∈[0,H−1]i\in[0,H-1]i∈[0,H−1]。

转移：

答案： max⁡0≤i<Hfi,W−1\max\limits_{0\le i<H} f_{i,W-1}0≤i<Hmax​fi,W−1​。
动规部分复杂度 O(H⋅W)O(H\cdot W)O(H⋅W)，总复杂度 O(H⋅W⋅K2)O(H\cdot W\cdot K^2)O(H⋅W⋅K2)，空间 O(H⋅W)O(H\cdot W)O(H⋅W)（可滚动数组降到 O(H)O(H)O(H)）。

实现细节：

第一行输入可能是用空格或反斜杠分隔，实际读取时可将反斜杠替换为空格再解析 H,W,KH, W, KH,W,K。
输出用固定小数位格式保留 111 位小数。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读取首行，兼容空格或反斜杠分隔
string first;
// 跳过可能的空行
do {
if (!getline(cin, first)) return 0;
} while (first.find_first_not_of(" \t\r\n") == string::npos);

for (char &c : first) if (c == '\\') c = ' ';
stringstream ss(first);
int H, W, K;
ss >> H >> W >> K;

// 读取图像矩阵
vector<vector<double>> I(H, vector<double>(W));
for (int i = 0; i < H; ++i) {
for (int j = 0; j < W; ++j) {
cin >> I[i][j];
}
}
// 读取策略(卷积核)矩阵
vector<vector<double>> P(K, vector<double>(K));
for (int i = 0; i < K; ++i) {
for (int j = 0; j < K; ++j) {
cin >> P[i][j];
}
}

// 计算能量矩阵 E，按0填充的卷积（相关）方式
vector<vector<double>> E(H, vector<double>(W, 0.0));
int pad = K / 2;
for (int i = 0; i < H; ++i) {
for (int j = 0; j < W; ++j) {
double s = 0.0;
// 遍历核
for (int a = 0; a < K; ++a) {
for (int b = 0; b < K; ++b) {
int ii = i + a - pad;
int jj = j + b - pad;
if (0 <= ii && ii < H && 0 <= jj && jj < W) {
s += P[a][b] * I[ii][jj];
}
}
}
E[i][j] = s;
}
}

// 动态规划：从第0列走到第W-1列，允许右、右上、右下
vector<vector<double>> dp(H, vector<double>(W, -1e300));
for (int i = 0; i < H; ++i) dp[i][0] = E[i][0];

for (int j = 1; j < W; ++j) {
for (int i = 0; i < H; ++i) {
double best = dp[i][j-1];
if (i > 0) best = max(best, dp[i-1][j-1]);
if (i + 1 < H) best = max(best, dp[i+1][j-1]);
dp[i][j] = best + E[i][j];
}
}

double ans = -1e300;
for (int i = 0; i < H; ++i) ans = max(ans, dp[i][W-1]);

cout.setf(std::ios::fixed);
cout << setprecision(1) << ans << "\n";
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
H = int(next(it)); W = int(next(it)); K1 = int(next(it)); K2 = int(next(it))
K = K1  # 题面给了两个K，这里取第一个；通常两者相等

# 读图像矩阵
I = [[float(next(it)) for _ in range(W)] for _ in range(H)]
# 读策略矩阵
P = [[float(next(it)) for _ in range(K)] for _ in range(K)]

# 计算能量图（零填充卷积）
r = K // 2
E = [[0.0]*W for _ in range(H)]
for i in range(H):
for j in range(W):
s = 0.0
for u in range(K):
ii = i + (u - r)
if 0 <= ii < H:
rowI = I[ii]
rowP = P[u]
for v in range(K):
jj = j + (v - r)
if 0 <= jj < W:
s += rowP[v] * rowI[jj]
E[i][j] = s

# 动态规划
NEG = -1e300
prev = [NEG]*H
for i in range(H):
prev[i] = E[i][0]

for j in range(1, W):
cur = [NEG]*H
for i in range(H):
best = prev[i]
if i-1 >= 0:
best = max(best, prev[i-1])
if i+1 < H:
best = max(best, prev[i+1])
cur[i] = E[i][j] + best
prev = cur

ans = max(prev)
print(f"{ans:.1f}")

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;
import java.util.Locale;

public class Main {
public static void main(String[] args) throws Exception {
Locale.setDefault(Locale.US); // 确保小数点为 '.'
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
List<Double> tokens = new ArrayList<>();
String line;
// 读取所有数字（支持以空格或换行分隔）
while ((line = br.readLine()) != null) {
line = line.trim();
if (line.isEmpty()) continue;
String[] parts = line.split("\\s+");
for (String p : parts) tokens.add(Double.parseDouble(p));
}
int idx = 0;
int H = tokens.get(idx++).intValue();
int W = tokens.get(idx++).intValue();
int K1 = tokens.get(idx++).intValue();
int K2 = tokens.get(idx++).intValue();
int K = K1; // 题面给了两个K

double[][] I = new double[H][W];
for (int i = 0; i < H; i++)
for (int j = 0; j < W; j++)
I[i][j] = tokens.get(idx++);

double[][] P = new double[K][K];
for (int i = 0; i < K; i++)
for (int j = 0; j < K; j++)
P[i][j] = tokens.get(idx++);

// 计算能量图（零填充卷积）
int r = K / 2;
double[][] E = new double[H][W];
for (int i = 0; i < H; i++) {
for (int j = 0; j < W; j++) {
double s = 0.0;
for (int u = 0; u < K; u++) {
int ii = i + (u - r);
if (0 <= ii && ii < H) {
for (int v = 0; v < K; v++) {
int jj = j + (v - r);
if (0 <= jj && jj < W) {
s += P[u][v] * I[ii][jj];
}
}
}
}
E[i][j] = s;
}
}

// 动态规划：只能右、右上、右下
double NEG = -1e300;
double[] prev = new double[H];
double[] cur = new double[H];
Arrays.fill(prev, NEG);
for (int i = 0; i < H; i++) prev[i] = E[i][0];

for (int j = 1; j < W; j++) {
Arrays.fill(cur, NEG);
for (int i = 0; i < H; i++) {
double best = prev[i];
if (i - 1 >= 0) best = Math.max(best, prev[i - 1]);
if (i + 1 < H) best = Math.max(best, prev[i + 1]);
cur[i] = E[i][j] + best;
}
double[] tmp = prev; prev = cur; cur = tmp;
}

double ans = NEG;
for (int i = 0; i < H; i++) ans = Math.max(ans, prev[i]);

System.out.printf("%.1f%n", ans);
}
}

---

### 第2题-小红书创作（P4271）
- 链接：https://codefun2000.com/p/P4271

> 页面标题：#P4271. 第2题-小红书创作

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小朱同学看到小红书上有很多外国人涌入，于是决定给这些外国人展示他与朋友们的日常生活。
已知他有 nnn 个朋友，分享他第 iii 个朋友的故事需要花费 TiTiTi 的时间和 HiHiHi 的脑细胞来编辑文章，并在发表后能获得 AiAiAi 的点赞量。
请问:在花费总时间不超过 TTT 且总脑细胞不超过 HHH 的前提下，最多可以获得多少点赞量?
提示:1<=n<=1001<=n<=1001<=n<=100
1<=H、T、ti、hi、ai<=1001<=H、T、ti、hi、 ai<=1001<=H、T、ti、hi、ai<=100
输入描述
第一行输入一个正整数 nnn ，代表朋友的数量。
第二行输入两个正整数 TTT 和 HHH ，代表时间限制和脑细胞限制(脑细胞不会重生)。空格隔开
接下来的 nnn 行，每行输入三个正整数 ti,hi,aiti,hi,aiti,hi,ai，代表分享第 iii 个朋友的故事需要花费 tititi 的时间、hihihi 的脑细胞，然后能获得 aiaiai 的点赞量，空格隔开。
输出描述
最多可以获得的点赞量
样例1
输入
2
5 4
1 5 2
6 2 3

输出
0

说明
时间或脑细胞无法完成任何一项创作，故获得 000 点赞量
样例2
输入
3
5 4
1 2 2
2 1 3
4 1 5

输出
7

说明
在不超过限制的情况下，分享第 111 个和第 333 个朋友的故事可获得的点赞量最高，为 777

#### TextSol

解题思路

这是一个二维约束的 0/1 背包问题：每个朋友是一件物品，消耗时间 ti 与脑细胞 hi，价值为点赞数 ai；总时间不超过 T、总脑细胞不超过 H，问最大点赞数。

动态规划（二维 0/1 背包）
设 dp[t][h] 表示在时间上限为 t、脑细胞上限为 h 时能获得的最大点赞数。
对每个朋友进行一次倒序转移：
dp[t][h] = max(dp[t][h], dp[t - ti][h - hi] + ai)   (t>=ti 且 h>=hi)

倒序是为了保证每个朋友只能被选一次（0/1 背包的关键）。

答案为 dp[T][H]。

复杂度分析

时间复杂度：O(n * T * H)，其中 n ≤ 100，T,H ≤ 100，最多约 100 万次转移，完全可行。
空间复杂度：O(T * H)，一个二维数组保存状态（≈ 10^4 级别）。

代码实现
Python
# 题面功能函数：二维0/1背包，返回最大点赞数
def max_likes(n, T, H, items):
# dp[t][h]：时间不超过t、脑细胞不超过h的最大点赞
dp = [[0] * (H + 1) for _ in range(T + 1)]
for ti, hi, ai in items:
# 倒序遍历，确保每个朋友只能选一次
for t in range(T, ti - 1, -1):
for h in range(H, hi - 1, -1):
v = dp[t - ti][h - hi] + ai
if v > dp[t][h]:
dp[t][h] = v
return dp[T][H]

# 主函数：读入与输出（ACM风格）
def main():
import sys
data = sys.stdin.read().strip().split()
it = iter(data)
n = int(next(it))
T = int(next(it))
H = int(next(it))
items = []
for _ in range(n):
ti = int(next(it))
hi = int(next(it))
ai = int(next(it))
items.append((ti, hi, ai))
print(max_likes(n, T, H, items))

if __name__ == "__main__":
main()

Java
import java.util.*;

// ACM 风格：类名为 Main
public class Main {
// 题面功能函数：二维0/1背包
static int maxLikes(int n, int T, int H, int[] ti, int[] hi, int[] ai) {
int[][] dp = new int[T + 1][H + 1];
// 枚举每个朋友(物品)
for (int i = 0; i < n; i++) {
// 倒序遍历时间与脑细胞，保证每个朋友至多使用一次
for (int t = T; t >= ti[i]; t--) {
for (int h = H; h >= hi[i]; h--) {
dp[t][h] = Math.max(dp[t][h], dp[t - ti[i]][h - hi[i]] + ai[i]);
}
}
}
return dp[T][H];
}

// 主函数：输入输出
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNextInt()) { sc.close(); return; }
int n = sc.nextInt();
int T = sc.nextInt();
int H = sc.nextInt();
int[] ti = new int[n];
int[] hi = new int[n];
int[] ai = new int[n];
for (int i = 0; i < n; i++) {
ti[i] = sc.nextInt();
hi[i] = sc.nextInt();
ai[i] = sc.nextInt();
}
System.out.println(maxLikes(n, T, H, ti, hi, ai));
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 题面功能函数：二维0/1背包
int maxLikes(int n, int T, int H, const vector<int>& t, const vector<int>& h, const vector<int>& a) {
// dp[t][h]：时间不超过t、脑细胞不超过h的最大点赞
vector<vector<int>> dp(T + 1, vector<int>(H + 1, 0));
for (int i = 0; i < n; ++i) {
// 倒序遍历，确保每个朋友只能选择一次
for (int tt = T; tt >= t[i]; --tt) {
for (int hh = H; hh >= h[i]; --hh) {
dp[tt][hh] = max(dp[tt][hh], dp[tt - t[i]][hh - h[i]] + a[i]);
}
}
}
return dp[T][H];
}

// 主函数：读入与输出（ACM风格）
int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n;
if (!(cin >> n)) return 0;
int T, H;
cin >> T >> H;
vector<int> t(n), h(n), a(n);
for (int i = 0; i < n; ++i) {
cin >> t[i] >> h[i] >> a[i];
}
cout << maxLikes(n, T, H, t, h, a) << "\n";
return 0;
}

---

### 第3题-基于空间连续块的稀疏注意力机制（P4275）
- 链接：https://codefun2000.com/p/P4275

> 页面标题：#P4275. 第3题-基于空间连续块的稀疏注意力机制

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在大语言模型推理过程中，随着上下文长度增加，标准 AttentionAttentionAttention 的计算开销以 O(n2)O(n^2)O(n2) 增长，成为性能瓶颈。为提升长序列处理效率，提出一种基于空间连续块的稀疏注意力机制。
具体流程如下：

一个长度为 nnn 的历史 tokentokentoken 序列，每个 tokentokentoken 表示为 111 个 ddd 维特征向量 xj∈Rd\mathbf{x}_j \in \mathbb{R}^dxj​∈Rd
。按固定块大小bbb，将序列划分为 m=ceil(n/b)m = ceil(n/b)m=ceil(n/b)个空间连续块（最后一个块可不满）
B1,B2,...,BmB_1, B_2, ..., B_mB1​,B2​,...,Bm​，其中：Bk=[x(k−1)b,...,xmin(kn)−1]B_k = [x_{(k-1)b}, ..., x_{min(kn)-1}]Bk​=[x(k−1)b​,...,xmin(kn)−1​]

对每个块 BkB_kBk​：
(1) 计算平均池化向量：$\mathbf{h}_k = \frac{1}{B_k} \sum_{x \in B_k} \mathbf{x}$
(2) 使用一个两层多层感知机（MLPMLPMLP）进行非线性压缩（隐藏维度dl=1d_l = 1dl​=1）：$\mathbf{c}_k = W_2 \cdot \sigma(W_1 \cdot \mathbf{h}_k + b_1) + b_2$
其中：
① W1∈R1×dW_1 \in \mathbb{R}^{1 \times d}W1​∈R1×d，W2∈Rd×1W_2 \in \mathbb{R}^{d \times 1}W2​∈Rd×1，输出 ck∈Rd\mathbf{c}_k \in \mathbb{R}^dck​∈Rd
②b1=2b_1 = 2b1​=2，b2=1b_2 = 1b2​=1
③σ(x)=max(0,x)\sigma(x) = max(0, x)σ(x)=max(0,x)（即 ReLU 激活函数）

给定查询向量q∈Rd\mathbf{q} \in \mathbb{R}^dq∈Rd（题目中固定为全 111 向量：qi=1q_i = 1qi​=1），计算每个压缩块的注意力得分：
$a_k = \frac{\mathbf{q} \cdot \mathbf{c}_k}{\sqrt{d}}$
得到压缩块注意力得分序列 A=(a1,a2,...,am)A = (a_1, a_2, ..., a_m)A=(a1​,a2​,...,am​)

将序列 AAA 划分为恰好 222 个连续非空子数组，目标是最大化这两个子数组和中的最小值 SSS 。

最终输出该最大化的最小值 SSS 的整数化得分，该子数组对应的 tokentokentoken 块将跳过细粒度 attentionattentionattention 计算，实现稀疏推理。
其中，整数化得分即 S SS  乘以 100100100 后四舍五入得到的整数，以实现保留两位小数精度的整数化表示：
round(100⋅S)round(100 \cdot S)round(100⋅S)

输入描述
第 111 行：nnn ddd bbb，以空格分隔，分别为序列长度、tokentokentoken 向量维度、块大小
接下来 nnn 行：每行 ddd  个数，以空格分隔，表示 xix_ixi​
倒数第 222 行：ddd 个数，以空格分隔，表示 W1W_1W1​
最后 111 行：ddd 个数，以空格分隔，表示 W2W_2W2​
约束条件：
1≤n≤10001 \leq n\leq 10001≤n≤1000
1≤b≤n1 \leq b\leq n1≤b≤n
1≤d≤1001 \leq d \leq 1001≤d≤100
所有向量非零
输出描述
返回一个整数，即上述步骤 555 的整数化得分
样例1
输入
3 1 1
2.0
4.0
6.0
1.0
2.0

输出
1700

说明
①分块：B1=[2.0]B_1 = [2.0]B1​=[2.0]，B2=[4.0]B_2 = [4.0]B2​=[4.0]，B3=[6.0]B_3 = [6.0]B3​=[6.0]
②平均池化：h1=[2.0]h_1 = [2.0]h1​=[2.0]，h2=[4.0]h_2 = [4.0]h2​=[4.0]，h3=[6.0]h_3 = [6.0]h3​=[6.0]
③MLPMLPMLP 压缩：c1=[9.0]c_1 = [9.0]c1​=[9.0]，c2=[13.0]c_2 = [13.0]c2​=[13.0]，c3=[17.0]c_3 = [17.0]c3​=[17.0]
④注意力得分：A=[9,13,17]A=[9,13,17]A=[9,13,17]
⑤划分为 222 个连续非空子数组，最大化min(sum)min(sum)min(sum)：
[9]∣[13,17][9]|[13,17][9]∣[13,17] →→→ 和：9,30→min=99, 30 → min = 99,30→min=9
[9,13]∣[17][9,13]|[17][9,13]∣[17] →→→ 和：22,17→min=17→S=1722, 17 → min = 17→ S=1722,17→min=17→S=17，输出 1700
样例2
输入
3 2 1
2.0 1.0
3.0 2.0
4.0 3.0
1.0 0.5
2.0 1.0

输出
1732

说明
①分块：B1=[2.0,1.0]B_1 = [2.0, 1.0]B1​=[2.0,1.0]，B2=[3.0,2.0]B_2 = [3.0, 2.0]B2​=[3.0,2.0]，B3=[4.0,3.0]B_3 = [4.0, 3.0]B3​=[4.0,3.0]
②平均池化：h1=[2.0,1.0]h_1 = [2.0, 1.0]h1​=[2.0,1.0]，h2=[3.0,2.0]h_2 = [3.0, 2.0]h2​=[3.0,2.0]，h3=[4.0,3.0]h_3 = [4.0, 3.0]h3​=[4.0,3.0]
③MLPMLPMLP 压缩：c1=[10.0,5.5]c_1 = [10.0, 5.5]c1​=[10.0,5.5]，c2=[13.0,7.0]c_2 = [13.0, 7.0]c2​=[13.0,7.0]，c3=[16.0,8.5]c_3 = [16.0, 8.5]c3​=[16.0,8.5]
④注意力得分：$A = [\frac{15.5}{\sqrt{2}}, \frac{20.0}{\sqrt{2}}, \frac{24.5}{\sqrt{2}}]$
⑤划分为 222 个连续非空子数组，最大化(min(sum))：
$[\frac{15.5}{\sqrt{2}}] ， [\frac{20.0}{\sqrt{2}}, \frac{24.5}{\sqrt{2}}] →$和：15.52\frac{15.5}{\sqrt{2}}2​15.5​，44.52\frac{44.5}{\sqrt{2}}2​44.5​ →min=→ min =→min= 15.52\frac{15.5}{\sqrt{2}}2​15.5​
$[\frac{15.5}{\sqrt{2}}, \frac{20.0}{\sqrt{2}}] ， [\frac{24.5}{\sqrt{2}}] →$ 和：35.52\frac{35.5}{\sqrt{2}}2​35.5​，24.52\frac{24.5}{\sqrt{2}}2​24.5​ $→ min = \frac{24.5}{\sqrt{2}}→ S = \frac{24.5}{\sqrt{2}}$，输出 1732

#### TextSol

解题思路
长序列下，将历史 token 划分为固定大小的空间连续块，每块做均值池化后经一个两层 MLP 压缩成向量，再用固定查询向量 q=1q=\mathbf{1}q=1 与压缩结果做打分。得到的压缩分数序列 A=(a1,…,am)A=(a_1,\dots,a_m)A=(a1​,…,am​) 之后，需要将其划分为恰好两个连续非空子数组，使两段和的最小值最大。整体可分为两部分：

数值构造：分块 + 池化 + MLP + 打分

设序列长度为 nnn、维度为 ddd、块大小为 bbb，块数 m=⌈n/b⌉m=\lceil n/b\rceilm=⌈n/b⌉。

第 kkk 个块的均值池化
$$h_k=\frac{1}{|B_k|}\sum_{x\in B_k} x\in\mathbb{R}^d$$

两层 MLP（隐藏维度为 1）：
$$t_k=W_1\cdot h_k+b_1,\quad r_k=\sigma(t_k)=\max(0,t_k)$$ck=W2⋅rk+b2    ∈Rdc_k=W_2\cdot r_k + b_2\;\;\in\mathbb{R}^d
ck​=W2​⋅rk​+b2​∈Rd
其中 $W_1\in\mathbb{R}^{1\times d},\, W_2\in\mathbb{R}^{d\times 1},\, b_1=2,\, b_2=1$（标量，按维度广播）。

因为 q=1q=\mathbf{1}q=1，注意力得分
$$a_k=\frac{q\cdot c_k}{\sqrt d}=\frac{\sum_{i=1}^{d} c_k^{(i)}}{\sqrt d}$$顺序得到 AAA。

最优划分：前缀和 + 贪心

目标是 $\max_{1\le s\le m-1} \min\Big(\sum_{i=1}^{s}a_i,\sum_{i=s+1}^{m}a_i\Big)$。
记总和 T=∑i=1maiT=\sum_{i=1}^{m}a_iT=∑i=1m​ai​，前缀和 Ps=∑i=1saiP_s=\sum_{i=1}^{s}a_iPs​=∑i=1s​ai​。显然最优 sss 使得两段尽量“均衡”，即 PsP_sPs​ 最接近 T/2T/2T/2。
实现上只需一次线性扫描：维护前缀和，逐个计算 min⁡(Ps,T−Ps)\min(P_s,T-P_s)min(Ps​,T−Ps​) 的最大值即可。
这是典型的前缀和 + 单遍扫描贪心，时间 O(m)O(m)O(m)，优于通用的“二分答案 + 可行性判断”。

最终答案为 S=max⁡smin⁡(⋅)S=\max_s \min(\cdot)S=maxs​min(⋅)，题目要求输出 round(100⋅S)\text{round}(100\cdot S)round(100⋅S) 的整数（四舍五入，保留两位小数的整数化）。
复杂度分析

时间复杂度：

计算所有块均值与 MLP：遍历每个 token 各维度，O(n⋅d)O(n\cdot d)O(n⋅d)。
计算打分并寻找最优切分点：O(m)O(m)O(m)，其中 m=⌈n/b⌉≤nm=\lceil n/b\rceil\le nm=⌈n/b⌉≤n。
总计 O(n⋅d)O(n\cdot d)O(n⋅d)。

空间复杂度：

保存一块的中间向量与常量参数，外加得分序列（或仅累计总和与前缀），为 O(d+m)O(d+m)O(d+m)，可降到 O(d)O(d)O(d)（边算边累计，不必存整列）。

代码实现
Python
import sys
import math
import numpy as np

# 核心功能：根据题意计算最终整数化得分
def solve(n: int, d: int, b: int, X: np.ndarray, W1: np.ndarray, W2: np.ndarray) -> int:
m = (n + b - 1) // b  # 块数
A = []  # 压缩注意力得分序列

sqrt_d = math.sqrt(d)

# 逐块计算 a_k
for k in range(m):
start = k * b
end = min((k + 1) * b, n)
block = X[start:end]  # 该块的所有 token，形状 (len, d)

# 平均池化 h_k
h_k = block.mean(axis=0)

# 两层 MLP：t = W1·h + b1，r = ReLU(t)，c = W2*r + b2(逐维加1)
t = float(W1.dot(h_k)) + 2.0
r = max(0.0, t)
c = W2 * r + 1.0  # 广播加 1
a_k = float(c.sum()) / sqrt_d
A.append(a_k)

# 线性扫描寻找最优切分点，使 min(左和, 右和) 最大
T = sum(A)
best = -1e100
pref = 0.0
for s in range(1, m):  # 必须切成两个非空段
pref += A[s - 1]
best = max(best, min(pref, T - pref))

S = best
return int(round(S * 100.0))

def main():
data = sys.stdin.read().strip().split()
it = iter(data)

# 读入 n d b
n = int(next(it)); d = int(next(it)); b = int(next(it))

# 读入 n 行，每行 d 个浮点
xs = [ [float(next(it)) for _ in range(d)] for _ in range(n) ]
X = np.array(xs, dtype=float)

# 读入 W1, W2（各 d 个数）
W1 = np.array([float(next(it)) for _ in range(d)], dtype=float)
W2 = np.array([float(next(it)) for _ in range(d)], dtype=float)

ans = solve(n, d, b, X, W1, W2)
print(ans)

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
static long roundHalfToEven(double x) {
final double EPS = 1e-12;
double r = Math.floor(x);      // 向下取整
double frac = x - r;           // [0,1) 的小数部分
if (frac < 0.5 - EPS) return (long) r;
if (frac > 0.5 + EPS) return (long) (r + 1.0);
// frac 约等于 0.5：五取偶
long ri = (long) r;            // floor(x)
return (ri % 2 == 0) ? ri : (ri + 1);
}

// 核心功能：计算最终整数化得分
static long solve(int n, int d, int b, double[][] X, double[] W1, double[] W2) {
int m = (n + b - 1) / b;
double[] A = new double[m];
double sqrt_d = Math.sqrt(d);

// 逐块计算 a_k
for (int k = 0; k < m; k++) {
int start = k * b;
int end = Math.min((k + 1) * b, n);
int len = end - start;

// 平均池化 h_k
double[] hk = new double[d];
Arrays.fill(hk, 0.0);
for (int i = start; i < end; i++) {
for (int j = 0; j < d; j++) {
hk[j] += X[i][j];
}
}
for (int j = 0; j < d; j++) hk[j] /= len;

// 两层 MLP
double t = 0.0;
for (int j = 0; j < d; j++) t += W1[j] * hk[j];
t += 2.0;
double r = Math.max(0.0, t);

double sumc = 0.0;
for (int j = 0; j < d; j++) sumc += (W2[j] * r + 1.0);

double ak = sumc / sqrt_d;
A[k] = ak;
}

// 单遍扫描找最优切分
double T = 0.0;
for (double v : A) T += v;

double best = -1e100;
double pref = 0.0;
for (int s = 1; s <= m - 1; s++) {
pref += A[s - 1];
double cur = Math.min(pref, T - pref);
if (cur > best) best = cur;
}

double S = best;
return roundHalfToEven(S * 100.0);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读入 n d b
int n = sc.nextInt();
int d = sc.nextInt();
int b = sc.nextInt();

// 读入 X
double[][] X = new double[n][d];
for (int i = 0; i < n; i++) {
for (int j = 0; j < d; j++) {
X[i][j] = sc.nextDouble();
}
}

// 读入 W1, W2
double[] W1 = new double[d];
double[] W2 = new double[d];
for (int j = 0; j < d; j++) W1[j] = sc.nextDouble();
for (int j = 0; j < d; j++) W2[j] = sc.nextDouble();

long ans = solve(n, d, b, X, W1, W2);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

long long round_half_to_even(double x) {
const double EPS = 1e-12;
double r = floor(x);           // 向下取整
double frac = x - r;           // [0,1) 的小数部分
if (frac < 0.5 - EPS) return (long long)r;
if (frac > 0.5 + EPS) return (long long)(r + 1.0);
// frac 约等于 0.5：五取偶
long long ri = (long long)r;   // floor(x) 的整数部分
return (ri % 2 == 0) ? ri : (ri + 1);
}

// 核心功能：计算最终整数化得分
long long solve(int n, int d, int b,
const vector<vector<double>>& X,
const vector<double>& W1,
const vector<double>& W2) {
int m = (n + b - 1) / b;
vector<double> A(m, 0.0);
double sqrt_d = sqrt((double)d);

// 逐块计算 a_k
for (int k = 0; k < m; ++k) {
int start = k * b;
int end = min((k + 1) * b, n);
int len = end - start;

// 平均池化 h_k
vector<double> hk(d, 0.0);
for (int i = start; i < end; ++i) {
for (int j = 0; j < d; ++j) {
hk[j] += X[i][j];
}
}
for (int j = 0; j < d; ++j) hk[j] /= (double)len;

// 两层 MLP：t = W1·h + 2，r = ReLU(t)，c = W2*r + 1
double t = 0.0;
for (int j = 0; j < d; ++j) t += W1[j] * hk[j];
t += 2.0;
double r = max(0.0, t);

double sumc = 0.0;
for (int j = 0; j < d; ++j) sumc += (W2[j] * r + 1.0);

double ak = sumc / sqrt_d;
A[k] = ak;
}

// 单遍扫描找到最优切分
double T = 0.0;
for (double v : A) T += v;

double best = -1e100;
double pref = 0.0;
for (int s = 1; s <= m - 1; ++s) {
pref += A[s - 1];
double cur = min(pref, T - pref);
if (cur > best) best = cur;
}

double S = best;
return round_half_to_even(S * 100.0);
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, d, b;
if (!(cin >> n >> d >> b)) return 0;

vector<vector<double>> X(n, vector<double>(d));
for (int i = 0; i < n; ++i) {
for (int j = 0; j < d; ++j) {
cin >> X[i][j];
}
}

vector<double> W1(d), W2(d);
for (int j = 0; j < d; ++j) cin >> W1[j];
for (int j = 0; j < d; ++j) cin >> W2[j];

long long ans = solve(n, d, b, X, W1, W2);
cout << ans << "\n";
return 0;
}

---

### 第3题-求菱形的数量（P4272）
- 链接：https://codefun2000.com/p/P4272

> 页面标题：#P4272. 第3题-求菱形的数量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明来到一个新的城市，当他看到城市里四个不同的地点 a、b、ca、b、ca、b、c 和 ddd 时，如果存在两条从 aaa 到 ccc 的路径————一条通过 bbb ，另一条通过 ddd，他就称这个四个地点组合为“菱形”。
菱形的定义:
a、b、c、da、b、c、da、b、c、d 四个不同的地点，满足以下条件:
(a,b)、(b,c)、(a,d)、(d,c)(a,b)、(b,c)、(a,d)、(d,c)(a,b)、(b,c)、(a,d)、(d,c) 这些道路是直接连接的。
也就是说，aaa 到 ccc 有两条不同的路径:一条通过 bbb ，另一条通过 ddd .(画出来有可能是凹四面形)

给定一个城市的地点和道路的信息，小明想计算出有多少个“菱形"。
备注:
道路信息是单向的，如 111 222 表示从 111 到 222 的单向路径，222 111 表示从 222 到 111 的单向路径
输入描述
第一行包含两个整数 nnn 和 mmm (nnn 和 mmm 使用空格隔开)，其中 nnn 表示地点的数量，mmm 表示道路的数量，n,m(1≤n≤1000，0≤m≤10000)n,m(1≤n≤1000，0≤m≤ 10000)n,m(1≤n≤1000，0≤m≤10000) 。
接下来 mmm 行每行包含一对整数 a,ba,ba,b 表示有一条从地点 aaa 到地点 bbb 的单向道路。
输出描述
输出城市中所有“菱形”的数量。
样例1
输入
4 12
1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3

输出
12

说明
存在 121212 个菱形:
1−>2−>3,1−>4−>31->2->3,1->4->31−>2−>3,1−>4−>3
1−>2−>4,1−>3−>41->2->4,1->3->41−>2−>4,1−>3−>4
2−>3−>1,2−>4−>12->3->1,2->4->12−>3−>1,2−>4−>1
4−>2−>1,4−>3−>14->2->1,4->3->14−>2−>1,4−>3−>1
4−>1−>2,4−>3−>24->1->2,4->3->24−>1−>2,4−>3−>2
4−>1−>3,4−>2−>34->1->3,4->2->34−>1−>3,4−>2−>3
样例2
输入
5 4
1 2
2 3
1 4
4 3

输出
1

说明
存在 111 个菱形：
1−>2−>3,1−>4−>2−>31->2->3,1->4->2->31−>2−>3,1−>4−>2−>3

#### TextSol

解题思路

定义回顾：四个不同点 a,b,c,d 构成“菱形”当且仅当存在有向边 a→b, b→c, a→d, d→c。
等价转化：固定一对有序端点 (a,c)，设能把 a 接到 c 的不同中间点（即 a→x 且 x→c 的点）个数为 k，则可由它们两两配对形成 C(k,2) 个菱形。
实现：对每个源点 a，遍历所有两步路径 a→b→c，用数组 cnt[c] 统计到该 c 的不同中间点数；只记录出现过的 c（列表 touched），最后对每个被访问的 c 把 C(cnt[c],2) 加入答案。遍历时排除 c==a 和 c==b，同时忽略自环 u==v，以确保四点互异。

复杂度分析

总时间复杂度：
对每条边 a→b 再枚举 b 的出边，共为 O(∑_v in[v]·out[v])；由于只遍历出现过的 c，没有额外的 O(n^2)。
空间复杂度：O(n + m)（邻接表 + 计数数组）。

代码实现
Python
# -*- coding: utf-8 -*-
import sys

def count_diamonds(n, edges):
"""统计菱形数量：对每对(a,c)按中间点两两配对"""
# 建立出边邻接表
out = [[] for _ in range(n + 1)]
for u, v in edges:
if u != v:           # 忽略自环
out[u].append(v)

ans = 0
# 枚举源点 a
for a in range(1, n + 1):
cnt = [0] * (n + 1)  # cnt[c]: a 到 c 的不同中间点数量
touched = []         # 只记录被访问到的 c，避免 O(n) 扫描
for b in out[a]:
if b == a:
continue
for c in out[b]:
# 确保四点互异：c 不能等于 a 或 b
if c != a and c != b:
if cnt[c] == 0:
touched.append(c)  # 第一次访问该 c
cnt[c] += 1
# 只遍历出现过的 c，累加组合数 C(k,2)
for c in touched:
k = cnt[c]
if k >= 2:
ans += k * (k - 1) // 2
return ans

def main():
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
return
n, m = data[0], data[1]
edges = []
idx = 2
for _ in range(m):
u, v = data[idx], data[idx + 1]
edges.append((u, v))
idx += 2
print(count_diamonds(n, edges))

if __name__ == "__main__":
main()

Java
// -*- coding: utf-8 -*-
import java.io.*;
import java.util.*;

/**
* ACM 风格，类名统一为 Main
* 思路：对每个 a 统计所有两步路径 a->b->c 的终点 c 的不同中间点数量，
*      仅遍历出现过的 c，累加 C(k,2)。
*/
public class Main {

// 功能函数：计算菱形数量
static long countDiamonds(int n, List<int[]> edges) {
// 建立出边邻接表
ArrayList<Integer>[] out = new ArrayList[n + 1];
for (int i = 0; i <= n; i++) out[i] = new ArrayList<>();
for (int[] e : edges) {
int u = e[0], v = e[1];
if (u != v) out[u].add(v); // 忽略自环
}

long ans = 0L;
// 枚举源点 a
for (int a = 1; a <= n; a++) {
int[] cnt = new int[n + 1];            // cnt[c]
ArrayList<Integer> touched = new ArrayList<>(); // 只记录出现过的 c
for (int b : out[a]) {
if (b == a) continue;
for (int c : out[b]) {
if (c != a && c != b) {
if (cnt[c] == 0) touched.add(c); // 第一次访问 c
cnt[c]++;
}
}
}
// 累加组合数 C(k,2)
for (int c : touched) {
long k = cnt[c];
if (k >= 2) ans += k * (k - 1) / 2;
}
}
return ans;
}

public static void main(String[] args) throws Exception {
// 输入：第一行 n m，接着 m 行 u v
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String first = br.readLine();
if (first == null || first.trim().isEmpty()) return;
StringTokenizer st = new StringTokenizer(first);
int n = Integer.parseInt(st.nextToken());
int m = Integer.parseInt(st.nextToken());
List<int[]> edges = new ArrayList<>();
for (int i = 0; i < m; i++) {
st = new StringTokenizer(br.readLine());
int u = Integer.parseInt(st.nextToken());
int v = Integer.parseInt(st.nextToken());
edges.add(new int[]{u, v});
}
System.out.println(countDiamonds(n, edges));
}
}

C++
// -*- coding: utf-8 -*-
#include <bits/stdc++.h>
using namespace std;

/*
功能函数：计算菱形数量
方法：对每个 a 统计两步路径 a->b->c 的终点 c 的不同中间点数，
只遍历出现过的 c，答案累加 C(cnt[c], 2)。
*/
long long count_diamonds(int n, const vector<pair<int,int>>& edges) {
// 建立出边邻接表
vector<vector<int>> out(n + 1);
for (auto e : edges) {
int u = e.first, v = e.second;
if (u != v) out[u].push_back(v); // 忽略自环
}

long long ans = 0;
for (int a = 1; a <= n; ++a) {
vector<int> cnt(n + 1, 0); // cnt[c]
vector<int> touched;       // 仅记录出现过的 c
for (int b : out[a]) {
if (b == a) continue;
for (int c : out[b]) {
if (c != a && c != b) {
if (cnt[c] == 0) touched.push_back(c); // 第一次访问 c
cnt[c]++; // a->b->c 的中间点数加一
}
}
}
// 累加组合数
for (int c : touched) {
long long k = cnt[c];
if (k >= 2) ans += k * (k - 1) / 2;
}
}
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, m;
if (!(cin >> n >> m)) return 0;
vector<pair<int,int>> edges;
edges.reserve(m);
for (int i = 0; i < m; ++i) {
int u, v; cin >> u >> v;
edges.emplace_back(u, v);
}
cout << count_diamonds(n, edges) << "\n";
return 0;
}

---

## 2025年10月17日-AI方向

### 第2题-利用大规模预训练模型实现智能告警聚类与故障诊断（P4238）
- 链接：https://codefun2000.com/p/P4238

> 页面标题：#P4238. 第2题-利用大规模预训练模型实现智能告警聚类与故障诊断

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

【背景信息】在现代运维体系中，大量告警可能指向同一故障根源（如 “服务器 CPU 利用率过高” 和 “应用响应超时” 可能由同一硬件资源不足导致）。若能将语义相似的告警归为一类，不仅可以减少重复信息的干扰，还能帮助运维人员快速定位故障核心，缩短故障修复时间。
行业内普遍采用自然语言处理（NLP）技术对告警文本进行语义理解，采用基于预训练语言模型（如 BERT、sBERT 等）的语义向量（embedding）转化技术：通过模型处理，每条告警文本被转化为一个高维数值向量，向量的数学特征能够准确反映告警的语义信息，使得两条描述相同故障的告警（即使措辞略有差异），其对应的向量在空间中的距离会非常近；而语义无关的告警，向量距离则较远。
【任务目标】通过语义向量（embedding）对给定的告警信息进行聚类：每条告警包含唯一的 ID 和对应的向量 embedding，要求将余弦相似度≥0.95 的告警归为同一个聚类，并返回数量最大的聚类的告警数量
【规则要求】
聚类判定标准：
1）相似度阈值：当两条告警的余弦相似度 ≥ 0.95 时，判定为语义相似。
2）弱传递聚类（连通图聚类）规则：初始状态：每条告警单独构成一个类别。归入规则：若告警 X 与某类别 C 中的任意一条告警 的余弦相似度 ≥ 0.95，则将 X 归入类别 C。
合并规则：若告警 X 同时满足归入多个类别的条件（即与多个类别中的告警均相似），则这些类别需合并为一个新类别，X 归入该新类别。
传递性保证：聚类过程需确保所有满足相似条件的告警最终被合并到同一类别中。例如：若 A 与 B 相似（余弦相似度 ≥ 0.95），且 B 与 C 相似（余弦相似度 ≥ 0.95），则 A、B、C 必须属于同一类别（即使 A 与 C 的相似度可能 < 0.95）。
输入描述
每一行为一个告警信息，其中第一个字段是告警 ID，后面的字段是告警的嵌入向量。告警信息的总行数不会超过 1000 条。（请注意，测试集中可能包含如样例 2 所示的那种异常情况）
输出描述
找到包含告警数量最多的聚类，输出该聚类的告警数量。若所有告警均无法聚类（即每个类别仅包含 1 条告警），则返回 1；若输入为空列表（无任何告警），或者输入告警信息的向量维度不一致（即不同告警的 embedding 长度不同），则返回 0。
样例1
输入
1 1.0 0.0 0.0
2 0.99 0.01 0.0
3 0.0 1.0 0.0
4 0.0 1.0 0.01
5 0.1 0.0 0.0

输出
3

说明
每一行输入的第一个字段是告警 id，后面的字段是告警的嵌入向量，根据余弦相似度≥0.95 的规则，我们得到以下聚类关系：

告警 1、2、5 构成一个聚类；

告警 3、4 构成一个聚类；
所有聚类的大小分别为 3、2。其中数量最大的为 3，因此输出为 3。

样例2
输入
1 1.0 0.0 0.0
2 0.99 0.01 0.0 0.98
3 0.0 1.0 0.0

输出
0

说明
第 2 个告警的嵌入向量维度与其他告警不一致，属于异常情况，返回 0
样例3
输入
1 0.878434 -0.068245 -0.46237 0.099552
2 0.33961 -0.083281 -0.348141 0.869786
3 0.326485 -0.071012 -0.353166 0.873865
4 0.330106 -0.085155 -0.338106 0.87719
5 0.340185 -0.066865 -0.339054 0.874554
6 0.482266 -0.483077 0.539977 -0.492423
7 0.491966 -0.485237 0.526674 -0.495104
8 0.48426 -0.477249 0.531019 -0.505711
9 -0.669925 -0.330461 0.409454 -0.523778
10 -0.668543 -0.331692 0.403806 -0.529123

输出
4

说明
每一行输入的第一个字段是告警 id，后面的字段是告警的嵌入向量，根据余弦相似度≥0.95 的规则，我们得到以下聚类关系：

告警 2、3、4、5 构成一个聚类；

告警 6、7、8 构成一个聚类；

告警 9、10 构成一个聚类；

告警 1 独立成一个聚类；
综上所述，所有聚类的大小分别为 4、3、2、1。其中数量最大的为 4，因此输出为 4。

▶️

#### TextSol

video solution

解题思路
本题要求对告警信息进行语义聚类，核心是基于余弦相似度的连通分量问题。题目的关键在于理解弱传递聚类规则：如果告警A与B相似，B与C相似，即使A与C不相似，它们也应属于同一聚类。这实际上是一个典型的并查集问题。
首先需要处理输入数据的合法性验证。输入为空或向量维度不一致时直接返回0。对于合法输入，我们需要计算所有告警对之间的余弦相似度。余弦相似度的计算公式为：
cos(A,B) = (A·B) / (|A| × |B|)
其中A·B表示向量点积，|A|和|B|表示向量的欧几里得范数。当余弦相似度大于等于0.95时，认为两条告警语义相似，需要将它们归入同一聚类。
为了高效地处理聚类合并操作，我们采用并查集数据结构。并查集支持两个核心操作：查找元素所属集合的根节点，以及合并两个集合。通过路径压缩优化，可以使查找操作接近常数时间复杂度。
算法流程如下：首先初始化并查集，每个告警独立成一个集合。然后遍历所有告警对，计算它们的余弦相似度，如果相似度达到阈值则合并两个集合。最后统计每个集合的大小，返回最大的集合大小即为答案。
复杂度分析
时间复杂度：O(n²·d + n²·α(n))，其中n是告警数量，d是向量维度，α是反阿克曼函数（可视为常数）。计算所有告警对的余弦相似度需要O(n²·d)时间，每次相似度计算涉及向量点积和范数计算均为O(d)。并查集的查找和合并操作经过路径压缩优化后均摊时间复杂度为O(α(n))，总共需要O(n²)次操作。
空间复杂度：O(n)，主要用于存储并查集的父节点数组以及统计聚类大小的哈希表。输入数据的存储空间为O(n·d)，但这是必须的输入开销。
代码实现
Python
import sys
import math
from collections import Counter

def solve(alerts):
# 处理空输入
if not alerts:
return 0

n = len(alerts)
if n == 0:
return 0

# 检查向量维度一致性
dim = len(alerts[0][1])
for i in range(n):
if len(alerts[i][1]) != dim:
return 0

# 初始化并查集
parent = list(range(n))

def find(x):
# 路径压缩
if parent[x] != x:
parent[x] = find(parent[x])
return parent[x]

def union(x, y):
# 合并两个集合
px, py = find(x), find(y)
if px != py:
parent[px] = py

def cosine_similarity(v1, v2):
# 计算余弦相似度
dot_product = sum(a * b for a, b in zip(v1, v2))
norm1 = math.sqrt(sum(a * a for a in v1))
norm2 = math.sqrt(sum(b * b for b in v2))
if norm1 == 0 or norm2 == 0:
return 0
return dot_product / (norm1 * norm2)

# 遍历所有告警对，合并相似告警
for i in range(n):
for j in range(i + 1, n):
sim = cosine_similarity(alerts[i][1], alerts[j][1])
if sim >= 0.95:
union(i, j)

# 统计每个聚类的大小
clusters = Counter(find(i) for i in range(n))

# 返回最大聚类大小
return max(clusters.values())

def main():
alerts = []
for line in sys.stdin:
line = line.strip()
if not line:
continue
parts = line.split()
alert_id = parts[0]
embedding = [float(x) for x in parts[1:]]
alerts.append((alert_id, embedding))

result = solve(alerts)
print(result)

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
static class UnionFind {
int[] parent;

UnionFind(int n) {
parent = new int[n];
for (int i = 0; i < n; i++) {
parent[i] = i;
}
}

int find(int x) {
// 路径压缩
if (parent[x] != x) {
parent[x] = find(parent[x]);
}
return parent[x];
}

void union(int x, int y) {
// 合并两个集合
int px = find(x);
int py = find(y);
if (px != py) {
parent[px] = py;
}
}
}

static double cosineSimilarity(double[] v1, double[] v2) {
// 计算余弦相似度
double dotProduct = 0;
double norm1 = 0;
double norm2 = 0;

for (int i = 0; i < v1.length; i++) {
dotProduct += v1[i] * v2[i];
norm1 += v1[i] * v1[i];
norm2 += v2[i] * v2[i];
}

norm1 = Math.sqrt(norm1);
norm2 = Math.sqrt(norm2);

if (norm1 == 0 || norm2 == 0) {
return 0;
}

return dotProduct / (norm1 * norm2);
}

static int solve(List<double[]> embeddings) {
int n = embeddings.size();

if (n == 0) {
return 0;
}

// 检查向量维度一致性
int dim = embeddings.get(0).length;
for (int i = 1; i < n; i++) {
if (embeddings.get(i).length != dim) {
return 0;
}
}

UnionFind uf = new UnionFind(n);

// 遍历所有告警对，合并相似告警
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
double sim = cosineSimilarity(embeddings.get(i), embeddings.get(j));
if (sim >= 0.95) {
uf.union(i, j);
}
}
}

// 统计每个聚类的大小
Map<Integer, Integer> clusterSize = new HashMap<>();
for (int i = 0; i < n; i++) {
int root = uf.find(i);
clusterSize.put(root, clusterSize.getOrDefault(root, 0) + 1);
}

// 返回最大聚类大小
int maxSize = 0;
for (int size : clusterSize.values()) {
maxSize = Math.max(maxSize, size);
}

return maxSize;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
List<double[]> embeddings = new ArrayList<>();

while (sc.hasNextLine()) {
String line = sc.nextLine().trim();
if (line.isEmpty()) {
continue;
}

String[] parts = line.split("\\s+");
double[] embedding = new double[parts.length - 1];

for (int i = 1; i < parts.length; i++) {
embedding[i - 1] = Double.parseDouble(parts[i]);
}

embeddings.add(embedding);
}

int result = solve(embeddings);
System.out.println(result);

sc.close();
}
}

C++
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cmath>
#include <map>
#include <algorithm>
using namespace std;

class UnionFind {
public:
vector<int> parent;

UnionFind(int n) {
parent.resize(n);
for (int i = 0; i < n; i++) {
parent[i] = i;
}
}

int find(int x) {
// 路径压缩
if (parent[x] != x) {
parent[x] = find(parent[x]);
}
return parent[x];
}

void unionSet(int x, int y) {
// 合并两个集合
int px = find(x);
int py = find(y);
if (px != py) {
parent[px] = py;
}
}
};

double cosineSimilarity(const vector<double>& v1, const vector<double>& v2) {
// 计算余弦相似度
double dotProduct = 0;
double norm1 = 0;
double norm2 = 0;

for (size_t i = 0; i < v1.size(); i++) {
dotProduct += v1[i] * v2[i];
norm1 += v1[i] * v1[i];
norm2 += v2[i] * v2[i];
}

norm1 = sqrt(norm1);
norm2 = sqrt(norm2);

if (norm1 == 0 || norm2 == 0) {
return 0;
}

return dotProduct / (norm1 * norm2);
}

int solve(vector<vector<double>>& embeddings) {
int n = embeddings.size();

if (n == 0) {
return 0;
}

// 检查向量维度一致性
int dim = embeddings[0].size();
for (int i = 1; i < n; i++) {
if ((int)embeddings[i].size() != dim) {
return 0;
}
}

UnionFind uf(n);

// 遍历所有告警对，合并相似告警
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
double sim = cosineSimilarity(embeddings[i], embeddings[j]);
if (sim >= 0.95) {
uf.unionSet(i, j);
}
}
}

// 统计每个聚类的大小
map<int, int> clusterSize;
for (int i = 0; i < n; i++) {
int root = uf.find(i);
clusterSize[root]++;
}

// 返回最大聚类大小
int maxSize = 0;
for (auto& p : clusterSize) {
maxSize = max(maxSize, p.second);
}

return maxSize;
}

int main() {
vector<vector<double>> embeddings;
string line;

while (getline(cin, line)) {
if (line.empty()) {
continue;
}

stringstream ss(line);
string alertId;
ss >> alertId;

vector<double> embedding;
double val;
while (ss >> val) {
embedding.push_back(val);
}

embeddings.push_back(embedding);
}

int result = solve(embeddings);
cout << result << endl;

return 0;
}

---

### 第2题-手机CPU负载均衡（P4235）
- 链接：https://codefun2000.com/p/P4235

> 页面标题：#P4235. 第2题-手机CPU负载均衡

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在手机系统中，多核 CPUCPUCPU 普遍应用于每个核心上运行的多个进程。
假设现在有两个 CPUCPUCPU 核心，每个核心上运行了 nnn 个进程，每个进程都有其各自的负载，记录在整数数组 cpu1[]cpu1[]cpu1[] 和 cpu2[]cpu2[]cpu2[] 中。
为了实现两个核心之间的负载平衡，需要将一些进程进行多次迁核交换，将运行在 cpu1cpu1cpu1 上的进程与 cpu2cpu2cpu2 上的进程进行交换，直到两个核心达到负载平衡，每次交换会消耗一定的功耗，功耗的具体计算是两个交换任务的负载的较小值。
这里负载平衡的定义是，两个核心上运行的进程按负载排序后，序列相同，即排序后，两个核心相同下标的负载相同请返回达到负载平衡所需的最小功耗值。如果无法达到负载平衡，请返回 −1-1−1 。
输入描述
输入为两行，每一行都是个整数序列 cpu1[]cpu1[]cpu1[] 和 cpu2[]cpu2[]cpu2[] ，分别代表 cpu1cpu1cpu1 和 cpu2cpu2cpu2 上的进程负载参数范围:
1.进程个数 n:1<=n<=105n:1<=n<=10^5n:1<=n<=105
2.负载范围:1<=cpu1[i]<=108,1<=cpu2[i]<=1081<=cpu1[i]<=10^8,1<=cpu2[i]<=10^81<=cpu1[i]<=108,1<=cpu2[i]<=108
输出描述
输出一个整数，代表达到负载平衡所需的最小功耗值，−1-1−1 代表无法完成负载均衡
样例1
输入
4,2,2,4
2,1,1,2

输出
1

说明
cpu1cpu1cpu1 的下标 000 的元素 444 和 cpu2cpu2cpu2 下标 111 的元素 111 交换,产生功耗为 111 ，此时 cpu1=[1,2,2,4],cpu2=[2,4,1,2]cpu1=[1,2,2,4],cpu2=[2,4,1,2]cpu1=[1,2,2,4],cpu2=[2,4,1,2] 排序后字列相同
样例2
输入
4,2,2
1,2,1

输出
-1

说明
无法完成负载均衡

▶️

#### TextSol

video solution

解题思路

把两个核心上的进程负载分别记为数组 cpu1[]、cpu2[]。若将两数组排序后完全相同，则称达到“负载平衡”。

交换一次的功耗为两被交换任务负载的较小值。

关键观察与算法：

计数判定：将两数组所有数值做频次统计，若某个负载在两数组合并后的出现次数为奇数，则无法分成两半，返回 -1。

构造需要互换的多重集合：对每个负载 v，目标是让两个数组中 v 的个数都为 total[v]/2。
多出的放入 Aextra（来自 cpu1），缺的放入 Bextra（来自 cpu2，用等价的“多出”表示）。两个集合大小相等。

贪心配对 + 中转优化：

将 Aextra 升序，Bextra 降序，一一配对交换，可使直接交换代价为 min(x, y) 的和最小。
允许通过全局最小值 g = min(all elements) 作为“中转”来降低代价（两次交换），该方案代价为 2*g。
因此每一对的最小代价为 min( min(x, y), 2*g )。

将上述代价累加即为答案；若本就已平衡则答案为 0。

复杂度分析

设进程数为 n。
频次统计与构造集合：O(n)；排序与配对：O(k log k)（k 为需要交换的对数，k ≤ n）。
总时间复杂度 O(n log n)，空间复杂度 O(n)，满足数据范围。

代码实现
Python
# 题面功能在外部函数里，主函数只负责读写
import sys
from collections import Counter
from ast import literal_eval

def parse_line(s: str):
"""优先用 literal_eval；失败则按常见分隔符处理"""
s = s.strip()
if not s:
return []
try:
arr = literal_eval(s)
if isinstance(arr, (list, tuple)):
return list(map(int, arr))
except Exception:
pass
for ch in "[],;":
s = s.replace(ch, " ")
return [int(x) for x in s.split()]

def min_energy(a, b) -> int:
"""返回最小功耗；若无法平衡返回 -1"""
cntA = Counter(a)
cntB = Counter(b)
total = cntA + cntB

# 若某负载总数为奇数，则无法平衡
for v, c in total.items():
if c % 2 == 1:
return -1

half = {v: c // 2 for v, c in total.items()}
Aextra, Bextra = [], []
for v in total:
diff = cntA.get(v, 0) - half[v]
if diff > 0:
Aextra.extend([v] * diff)
elif diff < 0:
Bextra.extend([v] * (-diff))

if not Aextra:  # 已经平衡
return 0

Aextra.sort()             # 升序
Bextra.sort(reverse=True) # 降序
g = min(min(a), min(b))   # 全局最小值

ans = 0
for x, y in zip(Aextra, Bextra):
ans += min(min(x, y), 2 * g)
return ans

def main():
lines = [ln for ln in sys.stdin.read().strip().splitlines() if ln.strip()]
if len(lines) < 2:
print(0)
return
a = parse_line(lines[0])
b = parse_line(lines[1])
print(min_energy(a, b))

if __name__ == "__main__":
main()

Java
// 类名必须为 Main，ACM 风格：主函数处理输入输出，算法写在静态函数里
import java.io.*;
import java.util.*;

public class Main {

// 计算最小功耗；无法平衡返回 -1
static long minEnergy(int[] a, int[] b) {
Map<Integer, Integer> cntA = new HashMap<>();
Map<Integer, Integer> cntB = new HashMap<>();
for (int x : a) cntA.put(x, cntA.getOrDefault(x, 0) + 1);
for (int x : b) cntB.put(x, cntB.getOrDefault(x, 0) + 1);

Map<Integer, Integer> total = new HashMap<>();
for (Map.Entry<Integer, Integer> e : cntA.entrySet())
total.put(e.getKey(), total.getOrDefault(e.getKey(), 0) + e.getValue());
for (Map.Entry<Integer, Integer> e : cntB.entrySet())
total.put(e.getKey(), total.getOrDefault(e.getKey(), 0) + e.getValue());

// 奇数频次则无解
for (int v : total.keySet()) {
if ((total.get(v) & 1) == 1) return -1L;
}

Map<Integer, Integer> half = new HashMap<>();
for (Map.Entry<Integer, Integer> e : total.entrySet())
half.put(e.getKey(), e.getValue() / 2);

List<Integer> Aextra = new ArrayList<>();
List<Integer> Bextra = new ArrayList<>();
for (int v : total.keySet()) {
int diff = cntA.getOrDefault(v, 0) - half.get(v);
if (diff > 0) {
for (int i = 0; i < diff; i++) Aextra.add(v);
} else if (diff < 0) {
for (int i = 0; i < -diff; i++) Bextra.add(v);
}
}

if (Aextra.isEmpty()) return 0L;

Collections.sort(Aextra);                    // 升序
Bextra.sort(Collections.reverseOrder());     // 降序

int g = Integer.MAX_VALUE;
for (int x : a) g = Math.min(g, x);
for (int x : b) g = Math.min(g, x);

long ans = 0L;
for (int i = 0; i < Aextra.size(); i++) {
int x = Aextra.get(i), y = Bextra.get(i);
ans += Math.min(Math.min(x, y), 2L * g);
}
return ans;
}

// 将一行如 "[4,2,2,4]" 或 "4 2 2 4" 转成 int[]
static int[] parseLine(String s) {
s = s.trim();
s = s.replace('[', ' ').replace(']', ' ')
.replace(',', ' ').replace(';', ' ');
if (s.isEmpty()) return new int[0];
String[] parts = s.split("\\s+");
int[] arr = new int[parts.length];
for (int i = 0; i < parts.length; i++) arr[i] = Integer.parseInt(parts[i]);
return arr;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String l1 = br.readLine();
String l2 = br.readLine();
int[] a = parseLine(l1 == null ? "" : l1);
int[] b = parseLine(l2 == null ? "" : l2);
System.out.println(minEnergy(a, b));
}
}

C++
// ACM 风格：主函数读写，核心逻辑在独立函数中
#include <bits/stdc++.h>
using namespace std;

// 计算最小功耗；无法平衡返回 -1
long long minEnergy(const vector<long long>& a, const vector<long long>& b) {
unordered_map<long long, long long> cntA, cntB, total;
for (auto x : a) cntA[x]++, total[x]++;
for (auto x : b) cntB[x]++, total[x]++;

// 奇数频次则无解
for (auto &kv : total) if (kv.second % 2 == 1) return -1;

unordered_map<long long, long long> half;
for (auto &kv : total) half[kv.first] = kv.second / 2;

vector<long long> Aextra, Bextra;
for (auto &kv : total) {
long long v = kv.first;
long long diff = (long long)cntA[v] - half[v];
if (diff > 0) Aextra.insert(Aextra.end(), diff, v);
else if (diff < 0) Bextra.insert(Bextra.end(), -diff, v);
}

if (Aextra.empty()) return 0;

sort(Aextra.begin(), Aextra.end());                // 升序
sort(Bextra.begin(), Bextra.end(), greater<>());   // 降序

long long g = LLONG_MAX;
for (auto x : a) g = min(g, x);
for (auto x : b) g = min(g, x);

long long ans = 0;
for (size_t i = 0; i < Aextra.size(); ++i) {
long long x = Aextra[i], y = Bextra[i];
ans += min(min(x, y), 2 * g); // 直接交换或经全局最小值中转
}
return ans;
}

// 将一行如 "[4,2,2,4]" 或 "4 2 2 4" 转为数组
vector<long long> parseLine(string s) {
for (char &c : s) {
if (c == '[' || c == ']' || c == ',' || c == ';') c = ' ';
}
stringstream ss(s);
vector<long long> v; long long x;
while (ss >> x) v.push_back(x);
return v;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string l1, l2;
if (!getline(cin, l1)) { cout << 0 << "\n"; return 0; }
getline(cin, l2);
vector<long long> a = parseLine(l1);
vector<long long> b = parseLine(l2);

cout << minEnergy(a, b) << "\n";
return 0;
}

---

### 第3题-反向传播实现（P4239）
- 链接：https://codefun2000.com/p/P4239

> 页面标题：#P4239. 第3题-反向传播实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定K层前馈网络模型的权重矩阵M[i]M[i]M[i]、偏移向量b[i]b[i]b[i]，以及一批输入数据XXX和对应的真实分类标签Y_true_labelsY\_true\_labelsY_true_labels，请计算出总损失LLL对每一个权重矩阵M[i]M[i]M[i]和每一个偏移向量b[i]b[i]b[i]的梯度。
模型架构
模型有K个权重矩阵，第i个矩阵是M[i]。还有K个偏移向量，第i个向量是b[i]。
网络的计算过程（前向传播）如下：

输入是一个 N×wN \times wN×w 的矩阵 xxx，其中 NNN 是 batch size （本次输入数据的个数），www 是初始特征的数量。
网络的计算分为K层。我们用 A[i]A[i]A[i] 代表第 iii 层的输出（激活值）。初始输入 A[0]=XA[0] = XA[0]=X。
对于第 iii 层（从 i=1i = 1i=1 到 K−1K - 1K−1 ）：

线性计算：Z[i]=A[i−1]⋅M[i]+b[i]Z[i] = A[i - 1] \cdot M[i] + b[i]Z[i]=A[i−1]⋅M[i]+b[i]
激活函数：A[i]=ReLU(Z[i])A[i] = ReLU(Z[i])A[i]=ReLU(Z[i])

对于最后一层（第 KKK 层），使用 Softmax 激活函数来输出每个类别的概率：

线性计算：Z[K]=A[K−1]⋅M[K]+b[K]Z[K] = A[K - 1] \cdot M[K] + b[K]Z[K]=A[K−1]⋅M[K]+b[K]
激活函数：A[K]=Softmax(Z[K])A[K] = Softmax(Z[K])A[K]=Softmax(Z[K])

最终的输出为 A[K]A[K]A[K]，我们称之为 output_probabilities。这是一个 N×10N \times 10N×10 的矩阵。

为了衡量模型预测的好坏，使用了交叉熵损失（Cross-Entropy Loss），具体计算公式参见提示部分。
输入描述

第一行是一个整数KKK，代表网络的层数。

第二行是KKK个整数，依次代表每层的维度h[0],h[1],h[2],…,h[K−1]h[0], h[1], h[2], \ldots, h[K-1]h[0],h[1],h[2],…,h[K−1]。
最后一层的输出维度固定为10，代表10个类别。其中h[0]=W,h[K]=10h[0] = W, h[K] = 10h[0]=W,h[K]=10。

M[i]M[i]M[i]的形状是h[i−1]×h[i]h[i-1] \times h[i]h[i−1]×h[i]（其中hhh即为www），1≤i≤K1 \le i \le K1≤i≤K。

b[i]b[i]b[i]的形状是1×h[i]1 \times h[i]1×h[i]。

接下来是 KKK 个权重矩阵 M[1],…,M[K]M[1], \ldots, M[K]M[1],…,M[K] 的数据。第 iii 矩阵的数字分为 h[i−1]h[i - 1]h[i−1] 行、每行 h[i]h[i]h[i] 个浮点数、第 iii 行j列表示 M[i]M[i]M[i] 矩阵的第 iii 行j列 1≤i≤K1 \leq i \leq K1≤i≤K）。

接下来是KKK个偏移向量b[1],…,b[K]b[1], \ldots, b[K]b[1],…,b[K]的数据。
分为KKK行，第iii行有h[i]h[i]h[i]个数字，表示b[i]b[i]b[i]的权重（1≤i≤K1 \le i \le K1≤i≤K）。

之后是一个整数NNN，代表batch size。

接下来是NNN行，每行www个浮点数，代表输入矩阵XXX。

最后是NNN行，每行一个整数y∈{0,1,…,9}y \in \{0,1,\ldots,9\}y∈{0,1,…,9}，代表真实的类别标签。

输入保证输入的所有浮点数绝对值不超过100，且小数点后最多2位数字。
即任意输入浮点数fff，有∣f∣≤100|f| \le 100∣f∣≤100，且100⋅f100 \cdot f100⋅f是整数。
输出描述

依次输出KKK个权重矩阵的梯度和KKK个偏移向量的梯度。

对于第iii层（从1到KKK）：

首先，输出梯度矩阵∂L∂M[i]\dfrac{\partial L}{\partial M[i]}∂M[i]∂L​，分为h[i−1]h[i-1]h[i−1]行输出，每行h[i]h[i]h[i]个实数，用一个空格分隔，行末不能有空格。
然后，输出平均梯度向量∂L∂b[i]\dfrac{\partial L}{\partial b[i]}∂b[i]∂L​，一行有h[i]h[i]h[i]个数字，用一个空格分隔，行末不能有空格。

所有浮点数保留4位小数。

输入保证计算出来的输出梯度不会有NAN，且可以被双精度浮点数表示（即不会炸梯度，不会出现NAN/INF）。
样例1
输入
2
4 5
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
1.0 1.0 1.0 1.0 1.0
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1
0.1 0.1 0.1 0.1 0.1
0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0
2
0.5 0.5 0.5 0.5
0.5 0.5 0.5 0.5
2
8

输出
0.0000 0.0000 0.0000 0.0000 0.0000
0.0000 0.0000 0.0000 0.0000 0.0000
0.0000 0.0000 0.0000 0.0000 0.0000
0.0000 0.0000 0.0000 0.0000 0.0000
0.0000 0.0000 0.0000 0.0000 0.0000
0.2100 0.2100 -0.8400 0.2100 0.2100 0.2100 0.2100 0.2100 -0.8400 0.2100
0.2100 0.2100 -0.8400 0.2100 0.2100 0.2100 0.2100 0.2100 -0.8400 0.2100
0.2100 0.2100 -0.8400 0.2100 0.2100 0.2100 0.2100 0.2100 -0.8400 0.2100
0.2100 0.2100 -0.8400 0.2100 0.2100 0.2100 0.2100 0.2100 -0.8400 0.2100
0.2100 0.2100 -0.8400 0.2100 0.2100 0.2100 0.2100 0.2100 -0.8400 0.2100
0.1000 0.1000 -0.4000 0.1000 0.1000 0.1000 0.1000 0.1000 -0.4000 0.1000

说明
输入样例是2个样本，特征相同，但是标签不同。
样例2
输入
1
2
1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 10.0
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.1
1
50.0 60.0
4

输出
0.0000 0.0000 0.0000 0.0000 -50.0000 0.0000 0.0000 0.0000 0.0000 50.0000
0.0000 0.0000 0.0000 0.0000 -60.0000 0.0000 0.0000 0.0000 0.0000 60.0000
0.0000 0.0000 0.0000 0.0000 -1.0000 0.0000 0.0000 0.0000 0.0000 1.0000

说明
一层网络，一个样本。
Z[1] = [56.01 112.02 168.03 224.04 280.05 336.06 392.07 448.08 504.09 560.1]
A[1] = [1.1925994847839173e-219, 2.519582300056682e-195, 5.323073712302622e-171,
1.1245956818306658e-146, 2.3759119560363354e-122, 5.019544102861018e-98,
1.060469557238993e-73, 2.240433909505195e-49, 4.733322204863164e-25, 1.0]
Ground Truth是[0,0,0,0,1,0,0,0,0,0]
提示
Loss计算公式
对于一批（batch）大小为N的输入，每个输入都有一个真实的类别标签
yj∈{0,1,…,9}y_j \in \{0,1,\ldots,9\}yj​∈{0,1,…,9}
首先，我们将真实标签yjy_jyj​转换为one-hot向量(Ytrue)j(Y_{true})_j(Ytrue​)j​。例如，如果真实标签为2，其one-hot向量为
[0,0,1,0,0,0,0,0,0,0][0,0,1,0,0,0,0,0,0,0][0,0,1,0,0,0,0,0,0,0]。
总损失LLL的计算方式是批次中所有样本损失的平均值：
$$L = -\frac{1}{N} \sum_{j=1}^{N} \sum_{l=0}^{9} (Y_{true})_{jl} \log(output\_probabilities_{jl})$$其中(output_probabilities)jl(output\_probabilities)_{jl}(output_probabilities)jl​是第jjj个样本的预测输出向量（经过Softmax后）的第lll个元素。
数据范围
1≤K≤51 \le K \le 51≤K≤5
1≤w,h[i]≤1001 \le w, h[i] \le 1001≤w,h[i]≤100
1≤N≤1001 \le N \le 1001≤N≤100
所有输入浮点数的绝对值不超过100，且浮点数小数点后最多两位小数。
提示
提示

提示1：

$\frac{\partial L}{\partial b[i]_j} = \frac{\partial Z[i]_j}{\partial b[i]_j} \cdot \frac{\partial L}{\partial Z[i]_j} = \frac{\partial L}{\partial Z[i]_j}$

提示2：

$\frac{\partial L}{\partial M[i]_{kj}} = \frac{\partial Z[i]_j}{\partial M[i]_{kj}} \cdot \frac{\partial L}{\partial Z[i]_j} = A[i-1][k] \cdot \frac{\partial L}{\partial Z[i]_j}$

提示3：

根据链式法则，dM[i]=A[i−1]T×dZ[i]dM[i] = A[i-1]^T \times dZ[i]dM[i]=A[i−1]T×dZ[i]（T表示转置）

#### TextSol

解题思路
这道题要求实现一个多层前馈神经网络的反向传播算法，计算损失函数对每层权重矩阵和偏置向量的梯度。
核心算法是反向传播（Backpropagation），其基本思想是利用链式法则从输出层向输入层逐层计算梯度。具体实现包括以下步骤：
第一步是前向传播。从输入层开始，逐层计算每一层的线性组合结果Z和激活值A。前K-1层使用ReLU激活函数，最后一层使用Softmax激活函数得到类别概率分布。在前向传播过程中，需要保存所有的Z和A值，供反向传播使用。
第二步是计算输出层的梯度。对于交叉熵损失函数配合Softmax激活函数的组合，其对Z[K]的梯度有简化形式：dZ[K] = (output_probabilities - Y_true) / N，其中Y_true是真实标签的one-hot编码。
第三步是反向传播计算各层梯度。从输出层向输入层反向遍历，对于每一层，根据链式法则计算梯度。对于使用ReLU激活的层，需要根据前向传播时的Z值判断ReLU的导数（大于0为1，否则为0）。每层的权重梯度等于上一层激活值的转置与该层Z梯度的矩阵乘积，偏置梯度等于该层Z梯度在样本维度上的求和。
第四步是将计算得到的梯度按指定格式输出。需要注意梯度矩阵的形状必须与对应的权重矩阵形状一致。
实现过程中需要特别注意的是Softmax函数的数值稳定性问题，应该采用减去最大值的技巧避免指数运算溢出。
复杂度分析
时间复杂度为O(N × sum(h[i] × h[i+1]))，其中N是批次大小，h[i]是每层的维度。前向传播和反向传播都需要遍历所有层，每层的矩阵乘法运算复杂度为O(N × h[i] × h[i+1])。
空间复杂度为O(K × N × max(h[i]))，需要存储K层的所有中间激活值和梯度值，每层最多需要存储N × h[i]大小的矩阵。
代码实现
Python
import sys
import numpy as np

# 打印矩阵，保留 4 位小数
def print_formatted_matrix(matrix):
for row in matrix:
print(" ".join(f"{x:.4f}" for x in row))

# 打印向量，保留 4 位小数
def print_formatted_vector(vector):
print(" ".join(f"{x:.4f}" for x in vector))

# 数值稳定的 Softmax 实现
def stable_softmax(z):
# 减去每行的最大值，防止指数溢出
z_shifted = z - np.max(z, axis=1, keepdims=True)
exps = np.exp(z_shifted)
return exps / np.sum(exps, axis=1, keepdims=True)

# 反向传播函数
def backprop(dZK, K, A, M, Z):
"""
dZK: 最后一层 softmax+交叉熵 的梯度
K: 网络层数
A: 每层激活输出（包含输入 A[0]）
M: 每层权重矩阵
Z: 每层线性变换结果
"""
grad_M = [None] * (K + 1)  # 存放每层对 M 的梯度
grad_b = [None] * (K + 1)  # 存放每层对 b 的梯度

# 最后一层梯度计算
grad_M[K] = A[K - 1].T @ dZK           # dL/dM[K] = A[K-1]^T * dZ[K]
grad_b[K] = np.sum(dZK, axis=0)        # dL/db[K] = sum(dZ[K])
dA_prev = dZK @ M[K].T                 # 传播到前一层

# 逐层反向传播（从 K-1 到 1）
for i in range(K - 1, 0, -1):
# ReLU 的导数：Z>0 时为 1，否则为 0
dZi = dA_prev * (Z[i] > 0).astype(float)
grad_M[i] = A[i - 1].T @ dZi       # dL/dM[i]
grad_b[i] = np.sum(dZi, axis=0)    # dL/db[i]
dA_prev = dZi @ M[i].T             # 向前传播梯度

return grad_M, grad_b

def solve():
try:
# 读取层数 K
K_str = sys.stdin.readline()
if not K_str.strip():
return
K = int(K_str)

# 读取每层维度（例如：4 5）
h_str = sys.stdin.readline()
h = list(map(int, h_str.split()))
dims = h + [10]  # 最后一层固定输出维度为 10 类

# 初始化权重矩阵和偏置向量
M = [None] * (K + 1)
b = [None] * (K + 1)

# 读取每层权重矩阵 M[i]
for i in range(1, K + 1):
rows, cols = dims[i-1], dims[i]
M[i] = np.array(
[list(map(float, sys.stdin.readline().split())) for _ in range(rows)],
dtype=float
).reshape(rows, cols)

# 读取每层偏置向量 b[i]
for i in range(1, K + 1):
b[i] = np.array(
list(map(float, sys.stdin.readline().split())),
dtype=float
).reshape(1, dims[i])

# 读取 batch size N
N = int(sys.stdin.readline())
# 读取输入样本矩阵 x
x = np.array([list(map(float, sys.stdin.readline().split())) for _ in range(N)], dtype=float)
# 读取真实标签（整数形式）
Y_labels = [int(sys.stdin.readline()) for _ in range(N)]

# 转换为 one-hot 编码
Y_true_onehot = np.zeros((N, 10), dtype=float)
Y_true_onehot[np.arange(N), Y_labels] = 1.0

# 前向传播
A = [None] * (K + 1)
Z = [None] * (K + 1)
A[0] = x

# 前 K-1 层使用 ReLU
for i in range(1, K):
Z[i] = A[i - 1] @ M[i] + b[i]
A[i] = np.maximum(0.0, Z[i])

# 最后一层使用 Softmax
Z[K] = A[K - 1] @ M[K] + b[K]
A[K] = stable_softmax(Z[K])
output_probabilities = A[K]

# Softmax + CrossEntropy 的梯度
dZK = (output_probabilities - Y_true_onehot) / N

# 反向传播计算梯度
grad_M, grad_b = backprop(dZK, K, A, M, Z)

# 输出每层梯度矩阵和偏置向量
for i in range(1, K + 1):
print_formatted_matrix(grad_M[i])
print_formatted_vector(grad_b[i])

except (IOError, ValueError, IndexError):
# 捕获输入或计算错误，防止程序崩溃
return

# 程序入口
if __name__ == "__main__":
solve()

Java
import java.util.*;
import java.io.*;

public class Main {
// 数值稳定的softmax实现
static double[][] stableSoftmax(double[][] z) {
int n = z.length;
int m = z[0].length;
double[][] result = new double[n][m];

for (int i = 0; i < n; i++) {
double maxVal = z[i][0];
for (int j = 1; j < m; j++) {
maxVal = Math.max(maxVal, z[i][j]);
}

double sum = 0;
for (int j = 0; j < m; j++) {
result[i][j] = Math.exp(z[i][j] - maxVal);
sum += result[i][j];
}

for (int j = 0; j < m; j++) {
result[i][j] /= sum;
}
}
return result;
}

// 矩阵乘法
static double[][] matmul(double[][] a, double[][] b) {
int n = a.length;
int m = b[0].length;
int k = a[0].length;
double[][] result = new double[n][m];

for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
for (int p = 0; p < k; p++) {
result[i][j] += a[i][p] * b[p][j];
}
}
}
return result;
}

// 矩阵转置
static double[][] transpose(double[][] a) {
int n = a.length;
int m = a[0].length;
double[][] result = new double[m][n];

for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
result[j][i] = a[i][j];
}
}
return result;
}

// 反向传播计算梯度
static void backprop(double[][] dZK, int K, double[][][] A, double[][][] M, double[][][] Z,
double[][][] gradM, double[][] gradB) {
double[][] dZ = dZK;

for (int i = K; i >= 1; i--) {
// 计算权重梯度
gradM[i] = matmul(transpose(A[i - 1]), dZ);

// 计算偏置梯度
int cols = dZ[0].length;
gradB[i] = new double[cols];
for (int j = 0; j < dZ.length; j++) {
for (int k = 0; k < cols; k++) {
gradB[i][k] += dZ[j][k];
}
}

if (i > 1) {
// 计算对前一层的梯度
double[][] dA = matmul(dZ, transpose(M[i]));
// 应用ReLU导数
dZ = new double[dA.length][dA[0].length];
for (int j = 0; j < dA.length; j++) {
for (int k = 0; k < dA[0].length; k++) {
dZ[j][k] = Z[i - 1][j][k] > 0 ? dA[j][k] : 0;
}
}
}
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取网络层数
int K = sc.nextInt();
// 读取每层维度
int[] dims = new int[K + 1];
for (int i = 0; i < K; i++) {
dims[i] = sc.nextInt();
}
dims[K] = 10;

// 读取权重矩阵
double[][][] M = new double[K + 1][][];
for (int i = 1; i <= K; i++) {
M[i] = new double[dims[i - 1]][dims[i]];
for (int j = 0; j < dims[i - 1]; j++) {
for (int k = 0; k < dims[i]; k++) {
M[i][j][k] = sc.nextDouble();
}
}
}

// 读取偏置向量
double[][] b = new double[K + 1][];
for (int i = 1; i <= K; i++) {
b[i] = new double[dims[i]];
for (int j = 0; j < dims[i]; j++) {
b[i][j] = sc.nextDouble();
}
}

// 读取batch size
int N = sc.nextInt();
// 读取输入数据
double[][] X = new double[N][dims[0]];
for (int i = 0; i < N; i++) {
for (int j = 0; j < dims[0]; j++) {
X[i][j] = sc.nextDouble();
}
}

// 读取真实标签
double[][] yTrue = new double[N][10];
for (int i = 0; i < N; i++) {
int label = sc.nextInt();
yTrue[i][label] = 1;
}

// 前向传播
double[][][] A = new double[K + 1][][];
double[][][] Z = new double[K + 1][][];
A[0] = X;

for (int i = 1; i <= K; i++) {
// 线性变换
Z[i] = matmul(A[i - 1], M[i]);
for (int j = 0; j < N; j++) {
for (int k = 0; k < dims[i]; k++) {
Z[i][j][k] += b[i][k];
}
}

if (i < K) {
// ReLU激活
A[i] = new double[N][dims[i]];
for (int j = 0; j < N; j++) {
for (int k = 0; k < dims[i]; k++) {
A[i][j][k] = Math.max(0, Z[i][j][k]);
}
}
} else {
// Softmax激活
A[i] = stableSoftmax(Z[i]);
}
}

// 计算输出层梯度
double[][] dZK = new double[N][10];
for (int i = 0; i < N; i++) {
for (int j = 0; j < 10; j++) {
dZK[i][j] = (A[K][i][j] - yTrue[i][j]) / N;
}
}

// 反向传播
double[][][] gradM = new double[K + 1][][];
double[][] gradB = new double[K + 1][];
backprop(dZK, K, A, M, Z, gradM, gradB);

// 输出梯度
for (int i = 1; i <= K; i++) {
for (int j = 0; j < gradM[i].length; j++) {
for (int k = 0; k < gradM[i][j].length; k++) {
if (k > 0) System.out.print(" ");
System.out.printf("%.4f", gradM[i][j][k]);
}
System.out.println();
}
for (int j = 0; j < gradB[i].length; j++) {
if (j > 0) System.out.print(" ");
System.out.printf("%.4f", gradB[i][j]);
}
System.out.println();
}
}
}

C++
#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
#include <algorithm>
using namespace std;

// 数值稳定的softmax实现
vector<vector<double>> stableSoftmax(const vector<vector<double>>& z) {
int n = z.size();
int m = z[0].size();
vector<vector<double>> result(n, vector<double>(m));

for (int i = 0; i < n; i++) {
double maxVal = *max_element(z[i].begin(), z[i].end());
double sum = 0;

for (int j = 0; j < m; j++) {
result[i][j] = exp(z[i][j] - maxVal);
sum += result[i][j];
}

for (int j = 0; j < m; j++) {
result[i][j] /= sum;
}
}
return result;
}

// 矩阵乘法
vector<vector<double>> matmul(const vector<vector<double>>& a,
const vector<vector<double>>& b) {
int n = a.size();
int m = b[0].size();
int k = a[0].size();
vector<vector<double>> result(n, vector<double>(m, 0));

for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
for (int p = 0; p < k; p++) {
result[i][j] += a[i][p] * b[p][j];
}
}
}
return result;
}

// 矩阵转置
vector<vector<double>> transpose(const vector<vector<double>>& a) {
int n = a.size();
int m = a[0].size();
vector<vector<double>> result(m, vector<double>(n));

for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
result[j][i] = a[i][j];
}
}
return result;
}

// 反向传播计算梯度
void backprop(vector<vector<double>> dZK, int K,
vector<vector<vector<double>>>& A,
vector<vector<vector<double>>>& M,
vector<vector<vector<double>>>& Z,
vector<vector<vector<double>>>& gradM,
vector<vector<double>>& gradB) {
vector<vector<double>> dZ = dZK;

for (int i = K; i >= 1; i--) {
// 计算权重梯度
gradM[i] = matmul(transpose(A[i - 1]), dZ);

// 计算偏置梯度
int cols = dZ[0].size();
gradB[i].resize(cols, 0);
for (int j = 0; j < dZ.size(); j++) {
for (int k = 0; k < cols; k++) {
gradB[i][k] += dZ[j][k];
}
}

if (i > 1) {
// 计算对前一层的梯度
vector<vector<double>> dA = matmul(dZ, transpose(M[i]));
// 应用ReLU导数
dZ = vector<vector<double>>(dA.size(), vector<double>(dA[0].size()));
for (int j = 0; j < dA.size(); j++) {
for (int k = 0; k < dA[0].size(); k++) {
dZ[j][k] = Z[i - 1][j][k] > 0 ? dA[j][k] : 0;
}
}
}
}
}

int main() {
// 读取网络层数
int K;
cin >> K;

// 读取每层维度
vector<int> dims(K + 1);
for (int i = 0; i < K; i++) {
cin >> dims[i];
}
dims[K] = 10;

// 读取权重矩阵
vector<vector<vector<double>>> M(K + 1);
for (int i = 1; i <= K; i++) {
M[i].resize(dims[i - 1], vector<double>(dims[i]));
for (int j = 0; j < dims[i - 1]; j++) {
for (int k = 0; k < dims[i]; k++) {
cin >> M[i][j][k];
}
}
}

// 读取偏置向量
vector<vector<double>> b(K + 1);
for (int i = 1; i <= K; i++) {
b[i].resize(dims[i]);
for (int j = 0; j < dims[i]; j++) {
cin >> b[i][j];
}
}

// 读取batch size
int N;
cin >> N;

// 读取输入数据
vector<vector<double>> X(N, vector<double>(dims[0]));
for (int i = 0; i < N; i++) {
for (int j = 0; j < dims[0]; j++) {
cin >> X[i][j];
}
}

// 读取真实标签
vector<vector<double>> yTrue(N, vector<double>(10, 0));
for (int i = 0; i < N; i++) {
int label;
cin >> label;
yTrue[i][label] = 1;
}

// 前向传播
vector<vector<vector<double>>> A(K + 1);
vector<vector<vector<double>>> Z(K + 1);
A[0] = X;

for (int i = 1; i <= K; i++) {
// 线性变换
Z[i] = matmul(A[i - 1], M[i]);
for (int j = 0; j < N; j++) {
for (int k = 0; k < dims[i]; k++) {
Z[i][j][k] += b[i][k];
}
}

if (i < K) {
// ReLU激活
A[i] = Z[i];
for (int j = 0; j < N; j++) {
for (int k = 0; k < dims[i]; k++) {
A[i][j][k] = max(0.0, Z[i][j][k]);
}
}
} else {
// Softmax激活
A[i] = stableSoftmax(Z[i]);
}
}

// 计算输出层梯度
vector<vector<double>> dZK(N, vector<double>(10));
for (int i = 0; i < N; i++) {
for (int j = 0; j < 10; j++) {
dZK[i][j] = (A[K][i][j] - yTrue[i][j]) / N;
}
}

// 反向传播
vector<vector<vector<double>>> gradM(K + 1);
vector<vector<double>> gradB(K + 1);
backprop(dZK, K, A, M, Z, gradM, gradB);

// 输出梯度
cout << fixed << setprecision(4);
for (int i = 1; i <= K; i++) {
for (int j = 0; j < gradM[i].size(); j++) {
for (int k = 0; k < gradM[i][j].size(); k++) {
if (k > 0) cout << " ";
cout << gradM[i][j][k];
}
cout << "\n";
}
for (int j = 0; j < gradB[i].size(); j++) {
if (j > 0) cout << " ";
cout << gradB[i][j];
}
cout << "\n";
}

return 0;
}

---

### 第3题-货物的最大价值（P4236）
- 链接：https://codefun2000.com/p/P4236

> 页面标题：#P4236. 第3题-货物的最大价值

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小张拥有多箱货物，每箱具有不同的重量和价值。现有一收购商提出，将以最低一箱货物的价值作为整体收购价格，且允许小张最多出售 mmm 箱货物。请协助小张计算，在此条件下，他能够获得的最大总价值是多少。数值可能较大，最终结果与 100000000710000000071000000007 取余后输出.
总价值的计算方法:mmm 箱货物的总重量乘上 mmm 箱货物中价值最小值
输入描述
输入为 444 行
第一行为一个整数 nnn ，代表货物的箱子总数，0<=n<=1050<=n<=10^50<=n<=105
第二行为一个整数序列，长度为 nnn ，分别代表货物每箱的重量，重量范围: 0<=weight<=1050<= weight<= 10^50<=weight<=105
第三行为一个整数序列，长度为 nnn ，分别代表货物每箱的价格,价格范围: 0<=value<=1070<= value<= 10^70<=value<=107
第四行为一个整数 mmm，代表最多卖出的货物箱数 0<=m<=n0<=m<=n0<=m<=n
输出描述
输出小张能获得最大价值，与 100000000710000000071000000007 取余后输出
样例1
输入
6
2,11,3,6,5,8
5,9,3,9,7,5
3

输出
154

说明
分别选择重量和价格为 [11,9],[6,9],[5,7][11,9],[6,9],[5,7][11,9],[6,9],[5,7] 三个箱子价值最大，总重量为 11+6+5=2211+6+5=2211+6+5=22 ，总价值 22∗7=15422*7=15422∗7=154
样例2
输入
3
5,7,3
2,9,3
2

输出
63

说明
分别选择重量和价格为 [7,9][7,9][7,9] 的箱子价值最大，价值 7∗9=637*9=637∗9=63

#### TextSol

解题思路

将每个箱子看作一对 (weight, value)。允许选择不超过 m 个箱子，目标是最大化：
sum(weights_of_chosen) * min(value_of_chosen)。
核心做法:

按 value 从大到小排序，把当前箱子的 value 视作被选集合的最小价值阈值。
依次加入其 weight 到一个小根堆（只保留不超过 m 个最大的重量），同时维护堆中重量和 sumW。
在每一步，以当前 value 作为最小价值，候选答案为 sumW * value。
这样自然覆盖了选择 1…m 个箱子的所有情况（当堆里元素少于 m 时，即为“少于 m 个”）。

为什么正确：排序后，当前 value 作为最小值时，能搭配的只能是“价值 ≥ 当前 value”的物品；为了最大化乘积，需要在这些物品里取重量和最大的至多 m 个，堆正好完成这一点。

复杂度分析

排序 O(n log n)，每个元素最多入堆出堆一次，堆操作 O(log m)，总体 O(n log n + n log m)，在 m ≤ n 时可写成 O(n log n)。
额外空间为堆与已排序数组，O(n)；堆本身 O(m)。

代码实现
Python
# -*- coding: utf-8 -*-
# 题意：给定 n 个箱子，每个有 weight 和 value，最多选 m 个，使
# sum(weight) * min(value) 最大，输出对 1e9+7 取模

import sys
import heapq
from ast import literal_eval

MOD = 1000000007

def max_total_value(weights, values, m):
# 将 (value, weight) 按 value 降序
pairs = sorted(zip(values, weights), reverse=True)
min_heap = []  # 小根堆，存放当前选中的权重
sumW = 0
best = 0
for v, w in pairs:
# 加入一个重量
heapq.heappush(min_heap, w)
sumW += w
# 若超过 m 个，只保留最大的 m 个重量
if len(min_heap) > m:
sumW -= heapq.heappop(min_heap)
# 以当前 v 为最小价值，计算候选答案（当堆里元素 < m 时代表少选）
best = max(best, sumW * v)
return best % MOD

def read_int_list(line):
line = line.strip()
# 优先用 literal_eval 解析 1,2,3 / [1,2,3] 等格式
try:
arr = literal_eval(line)
if isinstance(arr, int):
return [arr]
return list(arr)
except Exception:
# 退化为空格分割
return list(map(int, line.replace(',', ' ').split()))

def main():
data = sys.stdin.read().strip().splitlines()
if not data:
return
n = int(data[0].strip())
weights = read_int_list(data[1])
values = read_int_list(data[2])
m = int(data[3].strip())
print(max_total_value(weights, values, m))

if __name__ == "__main__":
main()

Java
// 题意：最多选 m 个箱子，使 sum(weights) * min(value) 最大，输出 mod
// 做法：按 value 降序，维护一个小根堆保存至多 m 个最大的 weight 与其和
import java.io.*;
import java.util.*;

public class Main {
static final long MOD = 1000000007L;

// 核心函数：返回答案（已取模）
static long maxTotalValue(int[] weights, int[] values, int m) {
int n = weights.length;
int[][] a = new int[n][2];
for (int i = 0; i < n; i++) {
a[i][0] = values[i];
a[i][1] = weights[i];
}
// 按 value 降序
Arrays.sort(a, (x, y) -> Integer.compare(y[0], x[0]));

PriorityQueue<Integer> minHeap = new PriorityQueue<>(); // 小根堆
long sumW = 0;
long best = 0;

for (int i = 0; i < n; i++) {
int v = a[i][0];
int w = a[i][1];
minHeap.offer(w);
sumW += w;
// 只保留 m 个最大的重量
if (minHeap.size() > m) {
sumW -= minHeap.poll();
}
long cand = sumW * (long) v;
if (cand > best) best = cand;
}
return best % MOD;
}

// 把逗号替换为空格后分割
static int[] readIntArray(String line, int n) {
line = line.trim().replace(",", " ");
String[] sp = line.split("\\s+");
int[] a = new int[n];
for (int i = 0; i < n; i++) a[i] = Integer.parseInt(sp[i]);
return a;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s1 = br.readLine();
if (s1 == null || s1.trim().isEmpty()) return;
int n = Integer.parseInt(s1.trim());

String wLine = br.readLine();
String vLine = br.readLine();
String mLine = br.readLine();

int[] weights = readIntArray(wLine, n);
int[] values = readIntArray(vLine, n);
int m = Integer.parseInt(mLine.trim());

long ans = maxTotalValue(weights, values, m);
System.out.println(ans);
}
}

C++
// 题意：最多选 m 个箱子，使 sum(weights) * min(value) 最大
// 思路：按 value 降序遍历；用小根堆维护到目前为止价值>=当前value的重量中最大的至多 m 个
#include <bits/stdc++.h>
using namespace std;
const long long MOD = 1000000007LL;

long long maxTotalValue(const vector<long long>& weights,
const vector<long long>& values, int m) {
int n = (int)weights.size();
vector<pair<long long,long long>> a(n);
for (int i = 0; i < n; ++i) a[i] = {values[i], weights[i]};
sort(a.begin(), a.end(), [](const auto& x, const auto& y){
return x.first > y.first; // value 降序
});

priority_queue<long long, vector<long long>, greater<long long>> minh; // 小根堆
long long sumW = 0, best = 0;
for (int i = 0; i < n; ++i) {
long long v = a[i].first, w = a[i].second;
minh.push(w);
sumW += w;
if ((int)minh.size() > m) {
sumW -= minh.top(); minh.pop();
}
long long cand = sumW * v;
if (cand > best) best = cand;
}
return best % MOD;
}

// 将逗号替换为空格后用 stringstream 读取
vector<long long> readArrayLine(string line, int n) {
for (char& c : line) if (c == ',') c = ' ';
stringstream ss(line);
vector<long long> a(n);
for (int i = 0; i < n; ++i) ss >> a[i];
return a;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
string line;
if (!getline(cin, line)) return 0;
int n = stoi(line);
string wLine, vLine, mLine;
getline(cin, wLine);
getline(cin, vLine);
getline(cin, mLine);

vector<long long> weights = readArrayLine(wLine, n);
vector<long long> values  = readArrayLine(vLine, n);
int m = stoi(mLine);

cout << maxTotalValue(weights, values, m) << "\n";
return 0;
}

---

## 2025年10月15日-AI方向

### 第2题-动态注意力掩码调度问题（P4227）
- 链接：https://codefun2000.com/p/P4227

> 页面标题：#P4227. 第2题-动态注意力掩码调度问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你正在设计一种跨模态知的大模型精准度机制，给定一个长度为 nnn 的输入 tokentokentoken 序列，每个位置 jjj 拥有一个 dd d维特征向量 Xj∈RdX_j \in \mathbb{R}^dXj​∈Rd和一个正整数计算容量 cjc_jcj​，表示该位置最多可接收来自前 jjj 位置的信息连接数。
系统需完成以下步骤：

RMSNormRMSNormRMSNorm 归一化：对所有特征向量进行 RMSNormRMSNormRMSNorm 归一化本题取(γ=1,ϵ=0)(\gamma = 1, \epsilon = 0)(γ=1,ϵ=0)：
每个特征向量记为xi∈Rdx_i \in \mathbb{R}^dxi​∈Rd，其第 k kk 个分量为 xi[k]x_i[k]xi​[k]。RMSNormRMSNormRMSNorm 定义为：
$\hat{X_i}  = \frac{ x_i}{\sqrt{\frac{1}{d}\sum_{k=1}^{d}x_i[k]^2 + \epsilon}}\cdot\gamma$

注意力得分计算：计算每对位置 i<ji<ji<j 的注意力得分，使用标准缩放点积公式（基于 RMSNormRMSNormRMSNorm 归一化向量）：
$A_{ij} = \frac{\hat{x_i}  \cdot \hat{x_j}}{\sqrt{d}}$

掩码矩阵构造：构造下三角注意力掩码矩阵M∈{0,1}n×nM \in \{0,1\}^{n \times n}M∈{0,1}n×n，满足入度约束：
$\forall j \in [0, n), \sum_{i=0}^{j-1} M_{ij} \leq c_j$

目标函数最大化：最大化全局注意力信息总量，全局注意力信息总量定义为所有激活连接的平方注意力得分之和：
$S = \sum_{j=0}^{n-1} \sum_{i=0}^{j-1} M_{ij} \cdot A_{ij}^2$

输出整数化得分：最终返回将最大化 SSS 乘以 100100100 后四舍五入得到的整数，以实现保留两位小数精度的整数化表示：
round(100⋅S)\text{round}(100 \cdot S)round(100⋅S)

输入描述

第 111 行: nnn ddd，以空格分隔，分别表示 tokentokentoken 序列长度和向量维度。
接下来 nnn 行：每行 ddd 个浮点数，以空格分隔，表示 xjx_jxj​。
最后 111 行: nn n 个正整数，以空格分隔，表示 cjc_jcj​。

约束条件

1≤n≤10001 \leq n \leq 10001≤n≤1000
1≤d≤1001 \leq d \leq 1001≤d≤100
所有向量非零

输出描述
返回一个整数，即上述步骤 555 的整数化得分
样例1
输入
4 2
2.0 2.0
3.0 0.0
0.0 4.0
1.0 1.0
1 2 1 3

输出
600

说明
位置 000：RMSNormRMSNormRMSNorm 归一化为 [1,1][1, 1][1,1]；无前置位置→→→对信息总量贡献 000
位置 111：RMSNormRMSNormRMSNorm 归一化为 [2,0][\sqrt{2}, 0][2​,0]；前置位置 j=0j=0j=0，A012=1；c1=2A_{01}^2 = 1；c_1 = 2A012​=1；c1​=2，选择接收来自 j=0j=0j=0 的信息→→→对信息总量贡献 111
位置 2：RMSNorm2：RMSNorm2：RMSNorm 归一化为 [0,2][0, \sqrt{2}][0,2​]；前置位置 j=0j=0j=0 和 j=1j=1j=1，计算 A022=1A_{02}^2=1A022​=1,A122=0A_{12}^2 = 0A122​=0；c2=1c_2 = 1c2​=1，选择接收来自 j=0j=0j=0 的信息→→→对信息总量贡献 111
位置 3：RMSNorm3：RMSNorm3：RMSNorm 归一化为 [1,1][1, 1][1,1]；前置位置 j=0j=0j=0 和 j=1j=1j=1 和 j=2j=2j=2，计算 A032=2A_{03}^2 = 2A032​=2，A132=1A_{13}^2 = 1A132​=1，A232=1A_{23}^2 = 1A232​=1；c2=3c_2 = 3c2​=3，选择接收来自 j=0j=0j=0 和 j=1j=1j=1 和 j=2j=2j=2 的信息→→→对信息总量贡献 444
最大化 S=6S=6S=6，输出整数化得分 600600600
样例2
输入
3 2
1.0 0.0
0.0 1.0
1.0 1.0
1 1 2

输出
200

说明
位置 0：RMSNorm0：RMSNorm0：RMSNorm 归一化为 [2,0][\sqrt{2}, 0][2​,0]；无前置位置→→→对信息总量贡献 000
位置 1：RMSNorm1：RMSNorm1：RMSNorm 归一化为 [0,2][0, \sqrt{2}][0,2​]；前置位置 j=0j=0j=0，A012=0A_{01}^2 = 0A012​=0；c1=1c_1 = 1c1​=1，选择接收来自 i=0i=0i=0 的信息→→→对信息总量贡献 000
位置 2：RMSNorm2：RMSNorm2：RMSNorm 归一化为 [1,1][1, 1][1,1]；前置位置 j=0j=0j=0 和 j=1j=1j=1，计算 A022=1A_{02}^2 = 1A022​=1，A122=1A_{12}^2 = 1A122​=1；c2=2c_2 = 2c2​=2，选择接收来自 j=0j=0j=0 和 j=1j=1j=1 的信息→→→对信息总量贡献 222
最大化 S=2S=2S=2，输出整数化得分 200200200

▶️

#### TextSol

video solution

解题思路
本题的核心是在资源约束下最大化注意力信息总量。问题可以分解为以下几个步骤进行求解：
首先需要对所有特征向量进行RMSNorm归一化处理。对于每个d维特征向量，计算其均方根值，然后将向量的每个分量除以该均方根值。这一步保证了后续注意力得分计算的标准化基础。
接着计算所有位置对之间的注意力得分。对于任意两个位置i和j（其中i<j），使用归一化后的向量进行缩放点积运算，得到注意力得分AijA_{ij}Aij​，并计算其平方值Aij2A_{ij}^2Aij2​。由于最终目标函数中使用的是平方值，因此可以直接存储平方值以便后续使用。
问题的关键在于构造路径矩阵M。对于每个位置j，需要从前面的所有位置中选择最多cjc_jcj​个位置建立连接。为了最大化目标函数S，应当采用贪心策略：对于每个位置j，将所有前置位置按照Aij2A_{ij}^2Aij2​的值从大到小排序，然后选择前cjc_jcj​个最大的值。这样可以保证每个位置获得的注意力信息量最大。
贪心策略的正确性在于：目标函数S是所有激活连接的Aij2A_{ij}^2Aij2​之和，每个位置的选择是相互独立的，因此局部最优解（每个位置选择最大的cjc_jcj​个值）必然能导致全局最优解。
最后将计算得到的S乘以100并四舍五入得到整数输出。
代码实现
Python
import numpy as np

def solve(n, d, vectors, capacities):
# 步骤1：对所有特征向量进行RMSNorm归一化
normalized = []
for vec in vectors:
# 计算均方根值
rms = np.sqrt(np.mean(np.array(vec) ** 2))
# 归一化
normalized.append(np.array(vec) / rms)

# 步骤2：计算注意力得分的平方
A_squared = [[0.0] * n for _ in range(n)]
for i in range(n):
for j in range(i + 1, n):
# 计算点积
dot_product = np.dot(normalized[i], normalized[j])
# 缩放并计算平方
A_ij = dot_product / np.sqrt(d)
A_squared[i][j] = A_ij ** 2

# 步骤3：贪心选择，最大化全局注意力信息总量S
S = 0.0
for j in range(1, n):
# 收集位置j的所有前置位置的注意力得分平方
scores = []
for i in range(j):
scores.append(A_squared[i][j])

# 降序排序，选择最大的c_j个
scores.sort(reverse=True)
S += sum(scores[:capacities[j]])

# 步骤4：输出整数化得分
return round(100 * S)

if __name__ == "__main__":
# 读取n和d
n, d = map(int, input().split())

# 读取特征向量
vectors = []
for _ in range(n):
vec = list(map(float, input().split()))
vectors.append(vec)

# 读取计算容量
capacities = list(map(int, input().split()))

# 计算并输出结果
result = solve(n, d, vectors, capacities)
print(result)

Java
import java.util.*;

public class Main {
public static int solve(int n, int d, double[][] vectors, int[] capacities) {
// 步骤1：对所有特征向量进行RMSNorm归一化
double[][] normalized = new double[n][d];
for (int i = 0; i < n; i++) {
// 计算均方根值
double sumSquare = 0.0;
for (int k = 0; k < d; k++) {
sumSquare += vectors[i][k] * vectors[i][k];
}
double rms = Math.sqrt(sumSquare / d);
// 归一化
for (int k = 0; k < d; k++) {
normalized[i][k] = vectors[i][k] / rms;
}
}

// 步骤2：计算注意力得分的平方
double[][] ASquared = new double[n][n];
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
// 计算点积
double dotProduct = 0.0;
for (int k = 0; k < d; k++) {
dotProduct += normalized[i][k] * normalized[j][k];
}
// 缩放并计算平方
double Aij = dotProduct / Math.sqrt(d);
ASquared[i][j] = Aij * Aij;
}
}

// 步骤3：贪心选择，最大化全局注意力信息总量S
double S = 0.0;
for (int j = 1; j < n; j++) {
// 收集位置j的所有前置位置的注意力得分平方
List<Double> scores = new ArrayList<>();
for (int i = 0; i < j; i++) {
scores.add(ASquared[i][j]);
}

// 降序排序，选择最大的c_j个
Collections.sort(scores, Collections.reverseOrder());
for (int i = 0; i < Math.min(capacities[j], scores.size()); i++) {
S += scores.get(i);
}
}

// 步骤4：输出整数化得分
return (int) Math.round(100 * S);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取n和d
int n = sc.nextInt();
int d = sc.nextInt();

// 读取特征向量
double[][] vectors = new double[n][d];
for (int i = 0; i < n; i++) {
for (int j = 0; j < d; j++) {
vectors[i][j] = sc.nextDouble();
}
}

// 读取计算容量
int[] capacities = new int[n];
for (int i = 0; i < n; i++) {
capacities[i] = sc.nextInt();
}

// 计算并输出结果
int result = solve(n, d, vectors, capacities);
System.out.println(result);

sc.close();
}
}

C++
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;

int solve(int n, int d, vector<vector<double>>& vectors, vector<int>& capacities) {
// 步骤1：对所有特征向量进行RMSNorm归一化
vector<vector<double>> normalized(n, vector<double>(d));
for (int i = 0; i < n; i++) {
// 计算均方根值
double sumSquare = 0.0;
for (int k = 0; k < d; k++) {
sumSquare += vectors[i][k] * vectors[i][k];
}
double rms = sqrt(sumSquare / d);
// 归一化
for (int k = 0; k < d; k++) {
normalized[i][k] = vectors[i][k] / rms;
}
}

// 步骤2：计算注意力得分的平方
vector<vector<double>> ASquared(n, vector<double>(n, 0.0));
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
// 计算点积
double dotProduct = 0.0;
for (int k = 0; k < d; k++) {
dotProduct += normalized[i][k] * normalized[j][k];
}
// 缩放并计算平方
double Aij = dotProduct / sqrt(d);
ASquared[i][j] = Aij * Aij;
}
}

// 步骤3：贪心选择，最大化全局注意力信息总量S
double S = 0.0;
for (int j = 1; j < n; j++) {
// 收集位置j的所有前置位置的注意力得分平方
vector<double> scores;
for (int i = 0; i < j; i++) {
scores.push_back(ASquared[i][j]);
}

// 降序排序，选择最大的c_j个
sort(scores.begin(), scores.end(), greater<double>());
int limit = min(capacities[j], (int)scores.size());
for (int i = 0; i < limit; i++) {
S += scores[i];
}
}

// 步骤4：输出整数化得分
return (int)round(100 * S);
}

int main() {
// 读取n和d
int n, d;
cin >> n >> d;

// 读取特征向量
vector<vector<double>> vectors(n, vector<double>(d));
for (int i = 0; i < n; i++) {
for (int j = 0; j < d; j++) {
cin >> vectors[i][j];
}
}

// 读取计算容量
vector<int> capacities(n);
for (int i = 0; i < n; i++) {
cin >> capacities[i];
}

// 计算并输出结果
int result = solve(n, d, vectors, capacities);
cout << result << endl;

return 0;
}

---

### 第2题-转发下一跳问题（P4224）
- 链接：https://codefun2000.com/p/P4224

> 页面标题：#P4224. 第2题-转发下一跳问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

网络中有 nnn 台路由器 R1,R2,...,RnR1,R2,...,RnR1,R2,...,Rn，两台路由器之间最多只有一条链路双向连通，每条链路有对应的转发成 本 Lij(Lij>0,Lij=Lji)Lij(Lij>0,Lij=Lji)Lij(Lij>0,Lij=Lji) 。以 RiRiRi 为源节点进行转发时，会以 RiRiRi 为根基于链路转发成本计算一棵最短路径树，RiRiRi 到其它 RjRjRj 的报文会沿着最短路径树进行转发。以下图拓扑为例，R1R1R1 到 R2R2R2 的最短路径为 R1−>R2R1->R2R1−>R2 ，最小转发代价为 555 (所有路径成本之和).
转发的下一跳定义如下: 源节点 SSS 到目的节点 DDD 的最短路径上 SSS 的直连的邻居节点，用来指导报文从哪条链路转发。以下图为例，R1R1R1 到 R2R2R2 的转发下一跳为 R2R2R2 。
需要注意的是，最短路径树中最短路径可能不止一条，对应转发的下一跳可能存在多个。以下图为例，R1R1R1 到 R3R3R3 的最短路径有两条,分别为: R1−>R2−>R3;R1−>R4−>R3R1->R2->R3;R1->R4->R3R1−>R2−>R3;R1−>R4−>R3,R1R1R1 到 R3R3R3 的转发下一跳为 R2、R4R2、R4R2、R4 。

任务:给定路由器数量和路由器之间的连通关系及转发成本，并指定两个路由器 Ri、RjRi、RjRi、Rj ，计算以 RjRjRj 为目的时， RiRiRi 到 RjRjRj 的最小转发代价，以及 RiRiRi 的转发下一跳的集合。
输入描述
第 111 行包含两个整数，分别表示路由器个数 nnn 、连通关系个数 k,1<=n<=1000,1<=k<=n∗(n−1)/2k,1<=n<=1000,1<=k<=n*(n-1)/2k,1<=n<=1000,1<=k<=n∗(n−1)/2
第 222 行开始的 kkk 行代表链路信息,每行 333 个正整数:路由器 RiRiRi 、路由器 RjRjRj 、链路转发成本 LijLijLij ，1<=Lij<=1001<=Lij<=1001<=Lij<=100，Ri、RjRi、RjRi、Rj 在 [1,n][1,n][1,n] 范围内
最后一行包含 222 个正整数，为源路由器 RiRiRi ，以及目的路由器 RjRjRj 。
输出描述
输出包括两行:
第一行为 RiRiRi 到 RjRjRj 之间的最小转发代价
第二行为一个正整数序列，以单个空格间隔,表示以 RjRjRj 为目的时，RiRiRi 的转发下一跳集合，要求升序排列。
注：
1.若两个路由器之间未连通，则最小转发代价为 111 ，转发下一跳集合为 −1-1−1
2.若源节点和目的节点为同一个点，最小转发代价为 000 ，转发下一跳集合为 −1-1−1
样例1
输入
4 3
1 2 5
1 3 5
2 3 5
1 4

输出
-1
-1

说明
111 作为源路由器，444 作为目的路由，1−>41->41−>4 路径不可达，最小转发代价为 −1-1−1 ，转发下一跳集合为空
样例2
输入
4 4
1 2 5
2 3 5
3 4 5
1 4 5
1 3

输出
10
2 4

说明
111 作为源路由器，333 作为目的路由器，1−>31->31−>3 的最短路径为 1−>2−>31->2->31−>2−>3 和 1−>4−>31->4->31−>4−>3 ，最小转发代价为101010 ，转发下一跳集合为 242424
样例3
输入
4 4
1 2 5
2 3 5
3 4 5
1 4 10
1 3

输出
10
2

说明
111 作为源路由器，333 作为目的路由器，1−>31->31−>3 的最短路径为 1−>2−>31->2->31−>2−>3 , 最小转发代价为 101010 。转发下一跳仅
有 222

#### TextSol

解题思路

问题抽象为：给定一个无向、正权图（路由器为点，链路代价为边权），求源路由器 s 到目的路由器 t 的最短路代价；同时给出当目的为 t 时，源路由器 s 的“下一跳集合”（即所有能出现在某条最短路径第一条边的相邻路由器）。

相关算法：Dijkstra 最短路算法（边权为正，适用）。

核心做法：

用邻接表存图，边为双向，权为 Lij。
分别从 s 与 t 各跑一次 Dijkstra，得到 distS[x] = s→x 的最短距离、distT[x] = x→t 的最短距离。
若 distS[t] 为无穷大（不可达），输出代价 -1 和下一跳 -1。
特判 s == t：代价 0，下一跳 -1。
否则，遍历 s 的所有邻居 v，若满足
w(s,v) + distT[v] == distS[t]
则 v 是某条最短路的第一跳，加入集合。最后按升序输出该集合（若集合为空，按题意输出 -1）。

上述判定的正确性：一条从 s 到 t 的最短路若以 s→v 开始，则整条路径长度等于首边权 w(s,v) 加上 v→t 的最短路长度 distT[v]，与全长 distS[t] 相等且最小。因此判定条件充要。

复杂度分析

设路由器数 n、链路数 k。一次 Dijkstra 复杂度为 O((n + k) log n)（优先队列 + 邻接表），两次仍为 O((n + k) log n)。
空间复杂度 O(n + k)（存图与两个距离数组）。

代码实现
Python
# -*- coding: utf-8 -*-
# 题意：无向正权图，求 s 到 t 的最短路代价与从 s 出发的下一跳集合
# 思路：两次 Dijkstra（从 s 和从 t），用 distS、distT 判定下一跳

import sys
import heapq

INF = 10 ** 18

def dijkstra(n, graph, start):
"""从 start 出发的 Dijkstra，返回最短距离数组"""
dist = [INF] * (n + 1)
dist[start] = 0
pq = [(0, start)]  # (距离, 节点)
while pq:
d, u = heapq.heappop(pq)
if d != dist[u]:
continue
for v, w in graph[u]:
nd = d + w
if nd < dist[v]:
dist[v] = nd
heapq.heappush(pq, (nd, v))
return dist

def solve():
data = list(map(int, sys.stdin.read().split()))
it = iter(data)
n = next(it); k = next(it)

# 邻接表
g = [[] for _ in range(n + 1)]
# 记录 s 的邻居需要权重，可直接从 g[s] 中取
for _ in range(k):
u = next(it); v = next(it); w = next(it)
g[u].append((v, w))
g[v].append((u, w))
s = next(it); t = next(it)

if s == t:
print(0)
print(-1)
return

distS = dijkstra(n, g, s)
distT = dijkstra(n, g, t)

if distS[t] >= INF:
print(-1)
print(-1)
return

# 判定下一跳：所有满足 w(s,v) + distT[v] == distS[t] 的邻居 v
hops = []
for v, w in g[s]:
if w + distT[v] == distS[t]:
hops.append(v)
hops = sorted(set(hops))  # 去重并升序

print(distS[t])
if hops:
print(" ".join(map(str, hops)))
else:
print(-1)

if __name__ == "__main__":
solve()

Java
// 题意：无向正权图，求 s->t 最短路代价与 s 的下一跳集合
// 思路：从 s、t 分别跑 Dijkstra；根据 w(s,v)+distT[v]==distS[t] 判定下一跳
import java.io.*;
import java.util.*;

public class Main {
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
int nextInt() throws IOException {
int c, sgn = 1, x = 0;
do { c = read(); } while (c <= 32);
if (c == '-') { sgn = -1; c = read(); }
while (c > 32) {
x = x * 10 + (c - '0');
c = read();
}
return x * sgn;
}
}

static class Edge {
int to, w;
Edge(int t, int w) { this.to = t; this.w = w; }
}

static long[] dijkstra(int n, List<Edge>[] g, int s) {
long INF = Long.MAX_VALUE / 4;
long[] dist = new long[n + 1];
Arrays.fill(dist, INF);
dist[s] = 0;
PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));
pq.add(new long[]{0, s});
while (!pq.isEmpty()) {
long[] cur = pq.poll();
long d = cur[0];
int u = (int) cur[1];
if (d != dist[u]) continue;
for (Edge e : g[u]) {
int v = e.to;
long nd = d + e.w;
if (nd < dist[v]) {
dist[v] = nd;
pq.add(new long[]{nd, v});
}
}
}
return dist;
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);

int n = fs.nextInt();
int k = fs.nextInt();

@SuppressWarnings("unchecked")
List<Edge>[] g = new ArrayList[n + 1];
for (int i = 0; i <= n; i++) g[i] = new ArrayList<>();

for (int i = 0; i < k; i++) {
int u = fs.nextInt();
int v = fs.nextInt();
int w = fs.nextInt();
g[u].add(new Edge(v, w));
g[v].add(new Edge(u, w));
}
int s = fs.nextInt();
int t = fs.nextInt();

if (s == t) {
System.out.println(0);
System.out.println(-1);
return;
}

long[] distS = dijkstra(n, g, s);
long[] distT = dijkstra(n, g, t);
long INF = Long.MAX_VALUE / 4;

if (distS[t] >= INF) {
System.out.println(-1);
System.out.println(-1);
return;
}

// 检查 s 的所有邻居
TreeSet<Integer> hops = new TreeSet<>();
for (Edge e : g[s]) {
int v = e.to;
if (e.w + distT[v] == distS[t]) {
hops.add(v);
}
}

System.out.println(distS[t]);
if (hops.isEmpty()) {
System.out.println(-1);
} else {
StringBuilder sb = new StringBuilder();
boolean first = true;
for (int v : hops) {
if (!first) sb.append(' ');
first = false;
sb.append(v);
}
System.out.println(sb.toString());
}
}
}

C++
// 题意：无向正权图，求 s->t 最短路代价与 s 的下一跳集合
// 思路：两次 Dijkstra；判定条件 w(s,v)+distT[v]==distS[t]
#include <bits/stdc++.h>
using namespace std;

const long long INF = (1LL<<62);

struct Edge {
int to, w;
};
vector<vector<Edge>> g;

vector<long long> dijkstra(int n, int s) {
vector<long long> dist(n + 1, INF);
dist[s] = 0;
priority_queue<pair<long long,int>, vector<pair<long long,int>>, greater<pair<long long,int>>> pq;
pq.push({0, s});
while (!pq.empty()) {
auto [d, u] = pq.top(); pq.pop();
if (d != dist[u]) continue;
for (auto &e : g[u]) {
int v = e.to;
long long nd = d + e.w;
if (nd < dist[v]) {
dist[v] = nd;
pq.push({nd, v});
}
}
}
return dist;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, k;
if (!(cin >> n >> k)) return 0;

g.assign(n + 1, {});
for (int i = 0; i < k; ++i) {
int u, v, w;
cin >> u >> v >> w;
g[u].push_back({v, w});
g[v].push_back({u, w});
}
int s, t;
cin >> s >> t;

if (s == t) {
cout << 0 << "\n" << -1 << "\n";
return 0;
}

auto distS = dijkstra(n, s);
auto distT = dijkstra(n, t);

if (distS[t] >= INF/2) {
cout << -1 << "\n" << -1 << "\n";
return 0;
}

// 判定 s 的下一跳
set<int> hops; // 用 set 保证升序且去重
for (auto &e : g[s]) {
int v = e.to;
if ((long long)e.w + distT[v] == distS[t]) {
hops.insert(v);
}
}

cout << distS[t] << "\n";
if (hops.empty()) {
cout << -1 << "\n";
} else {
bool first = true;
for (int v : hops) {
if (!first) cout << ' ';
first = false;
cout << v;
}
cout << "\n";
}
return 0;
}

---

### 第3题-基于二分Kmeans算法的子网分割问题（P4228）
- 链接：https://codefun2000.com/p/P4228

> 页面标题：#P4228. 第3题-基于二分Kmeans算法的子网分割问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

背景：在网络规划中，经常涉及子网分割问题，子网分割的目的是将距离相近的网络站点划分为一个子网，从而便于管理。
问题：聚类算法可以很好的解决子网分割问题，但是，聚类问题容易陷入局部最优。因此，本题期望采用优化版的聚类算法二分 KmeansKmeansKmeans 算法（Bi−KmeansBi-KmeansBi−Kmeans）进行子网分割。
方案概述：Bi−KmeansBi-KmeansBi−Kmeans 算法首先将全网按照常规的 KmeansKmeansKmeans 算法聚类成两个子网（也就是 K=2K=2K=2，两簇），然后，Bi−KmeansBi-KmeansBi−Kmeans 算法会基于 SSESSESSE（SumSumSum ofofof SquaredSquaredSquared ErrorErrorError）最小化原理，每次迭代只选择一个子网进一步划分，选择子网的原则是对该子网的进一步划分能够最大程度的降低全局 SSESSESSE，划分方法依旧是常规的 KmeansKmeansKmeans 算法（K=2K=2K=2），直到子网个数达到预期数量时，停止 Bi−KmeansBi-KmeansBi−Kmeans 算法的迭代（算法实现细节参见下述备注 1/2/31/2/31/2/3）。
备注 111-初始值选取：在进行常规 KmeansKmeansKmeans 聚类（K=2K=2K=2）二分子网时，选取子网中 xxx 坐标最小和最大的两个站点作为初始簇心进行划分（网络站点拥有不同的 xxx 坐标，本题中 xxx 坐标的最小值和最大值唯一）。
备注 222-算法迭代：在进行常规 KmeansKmeansKmeans 聚类（K=2K=2K=2）二分子网时，以簇中全部站点的平均坐标作为更新簇心；如果相邻的两次迭代聚类结果相同（各簇心迭代前后之间的距离小于 1e−61e^{-6}1e−6 则视为结果相同），则停止迭代，或者当迭代次数达到 100010001000 次时停止迭代。
备注 3−SSE3-SSE3−SSE 计算：以子网中全部站点的平均坐标为簇心，SSESSESSE 的计算方式是簇内所有站点到簇心距离的平方之和。
输入描述
输入包括三部分信息：
1）第一行数据表示期望分割的子网数量，用 NNN 表示，也就是聚类结果中簇的数量；NNN 是整数，范围 1<=N<=1001<=N<=1001<=N<=100 。
2）第二行数据表示全网站点总数，用 MMM 表示；MMM 是整数，范围 1<=M<=10001<=M<=10001<=M<=1000 。
3）从第三行开始的数据表示网络站点坐标，每一行代表一个站点的二维坐标，用空格分隔 xxx 轴坐标和 yyy 轴坐标； xxx 轴坐标和 yyy 轴坐标均为整数，0<=x0<=x0<=x 轴坐标 <=1000<=1000<=1000，0<=y0<=y0<=y 轴坐标 <=1000< =1000<=1000 。
输出描述
输出用二维数组记录划分的最终结果和划分过程，其中，第 kkk 行记录第 kkk 次划分后的结果，结果包含第 kkk 次划分后每个子网的站点数量，用空格分隔，并按照降序排列。
样例1
输入
3
3
0 0
2 2
5 5

输出
2 1
1 1 1

说明
输入表示我们期望将坐标分别为 (0,0)、(2,2)、(5,5)(0,0)、(2,2)、(5,5)(0,0)、(2,2)、(5,5) 的 333 个网络站点划分为 333 个子网。
按照题目要求，需要经过两次划分，第一次划分的结果为：
簇 111 1=[(0,0),(2,2)]1=[(0,0),(2,2)]1=[(0,0),(2,2)]
簇 111 2=[(5,5)]2=[(5,5)] 2=[(5,5)]
因此，期望输出的第一行是 222 111，其中，222 表示划分结果簇 111 111 有 222 个站点，111 表示划分结果簇 111 222 有 111 个站点，降序排列。
第二次划分的结果为：
簇 222 1=[(0,0)]1=[(0,0)]1=[(0,0)]
簇 222 2=[(2,2)]2=[(2,2)]2=[(2,2)]
簇 222 3=[(5,5)]3=[(5,5)]3=[(5,5)]
因此，期望输出的第二行是 111 111 111，其中，第一个 111 表示划分结果簇 222 111 有 111 个站点，第二个 111 表示划分结果簇 222 222 有 111 个站点，第三个 111 表示划分结果簇 222 333 有 111 个站点，降序排列。
样例2
输入
2
3
0 0
2 2
5 5

输出
2 1

说明
输入表示我们期望将坐标分别为 (0,0)、(2,2)、(5,5)(0,0)、(2,2)、(5,5)(0,0)、(2,2)、(5,5) 的 333 个网络站点划分为 222 个子网。
按照题目要求，需要经过一次划分，划分的结果为：
簇 1=[(0,0),(2,2)]1=[(0,0),(2,2)]1=[(0,0),(2,2)]
簇 2=[(5,5)]2=[(5,5)]2=[(5,5)]
因此，期望输出是 222 111，其中，222 表示划分结果簇 111 有 222 个站点，111 表示划分结果簇 222 有 111 个站点，降序排列。

▶️

#### TextSol

video solution

解题思路
本题要求实现二分 K-means (Bi-Kmeans) 算法来解决网络子网分割问题。该算法是对传统 K-means 算法的优化，能够有效避免陷入局部最优解。
算法的核心思想是采用自顶向下的分裂策略，每次选择一个簇进行二分，直到达到目标簇数量。具体流程如下：
首先，将所有网络站点作为一个整体，使用标准 K-means 算法（K=2）将其分割成两个子网。在进行 K-means 聚类时，选取子网中 x 坐标最小和最大的两个站点作为初始簇心，然后迭代更新簇心（使用簇内所有站点的平均坐标），直到簇心变化小于阈值或达到最大迭代次数。
接下来，算法进入主循环，每次迭代都需要从现有的所有簇中选择一个进行进一步划分。选择的标准是基于 SSE（误差平方和）最小化原则：计算每个簇被划分前后的 SSE 差值，选择能够最大程度降低全局 SSE 的簇进行划分。SSE 的计算方式是以簇的平均坐标为簇心，计算簇内所有站点到簇心的欧氏距离平方和。
每次划分后，都需要输出当前所有簇的站点数量，并按降序排列。重复这个过程，直到簇的数量达到预期值 N。
需要注意的边界情况包括：只有一个站点的簇无法继续划分；簇的分配需要基于站点到簇心的最小欧氏距离；迭代过程中需要处理空簇的情况。
代码实现
Python
import numpy as np

def calculate_sse(points):
# 计算簇的SSE（误差平方和）
if len(points) == 0:
return 0
center = np.mean(points, axis=0)
return np.sum((points - center) ** 2)

def kmeans_split(points):
# 使用K-means算法将点集分成两个簇
if len(points) <= 1:
return [points]

# 选择x坐标最小和最大的点作为初始簇心
min_idx = np.argmin(points[:, 0])
max_idx = np.argmax(points[:, 0])
centers = np.array([points[min_idx], points[max_idx]])

# 迭代更新簇心
for _ in range(1000):
# 计算每个点到两个簇心的距离
distances = np.sum((points[:, np.newaxis] - centers) ** 2, axis=2)
labels = np.argmin(distances, axis=1)

# 更新簇心
new_centers = np.array([
np.mean(points[labels == 0], axis=0) if np.any(labels == 0) else centers[0],
np.mean(points[labels == 1], axis=0) if np.any(labels == 1) else centers[1]
])

# 检查是否收敛
if np.sum((centers - new_centers) ** 2) < 1e-12:
break

centers = new_centers

# 最终分配
distances = np.sum((points[:, np.newaxis] - centers) ** 2, axis=2)
labels = np.argmin(distances, axis=1)

return [points[labels == 0], points[labels == 1]]

def bi_kmeans(points, n):
# 二分K-means算法主函数
clusters = [points]
results = []

# 第一次划分
clusters = kmeans_split(clusters[0])
sizes = sorted([len(c) for c in clusters], reverse=True)
results.append(sizes)

# 继续划分直到达到目标簇数量
while len(clusters) < n:
max_sse_reduction = -1
best_idx = -1

# 选择划分后SSE减少最多的簇
for i in range(len(clusters)):
if len(clusters[i]) <= 1:
continue

current_sse = calculate_sse(clusters[i])
new_clusters = kmeans_split(clusters[i])
new_sse = sum(calculate_sse(c) for c in new_clusters)
sse_reduction = current_sse - new_sse

if sse_reduction > max_sse_reduction:
max_sse_reduction = sse_reduction
best_idx = i

# 划分选中的簇
new_clusters = kmeans_split(clusters[best_idx])
clusters = clusters[:best_idx] + new_clusters + clusters[best_idx + 1:]

sizes = sorted([len(c) for c in clusters], reverse=True)
results.append(sizes)

return results

# 主函数
n = int(input())
m = int(input())
points = np.array([list(map(int, input().split())) for _ in range(m)], dtype=float)

results = bi_kmeans(points, n)
for result in results:
print(' '.join(map(str, result)))

Java
import java.util.*;

public class Main {
static class Point {
double x, y;

Point(double x, double y) {
this.x = x;
this.y = y;
}
}

// 计算两点之间的欧氏距离平方
static double calculateDistanceSquared(Point p1, Point p2) {
return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
}

// 计算点集的平均坐标（簇心）
static Point calculateCenter(List<Point> points) {
double xSum = 0, ySum = 0;
for (Point p : points) {
xSum += p.x;
ySum += p.y;
}
return new Point(xSum / points.size(), ySum / points.size());
}

// 计算簇的SSE（误差平方和）
static double calculateSSE(List<Point> points) {
if (points.isEmpty()) return 0;
Point center = calculateCenter(points);
double sse = 0;
for (Point p : points) {
sse += calculateDistanceSquared(p, center);
}
return sse;
}

// 使用K-means算法将点集分成两个簇
static List<List<Point>> kmeansSplit(List<Point> points) {
if (points.size() <= 1) {
List<List<Point>> result = new ArrayList<>();
result.add(new ArrayList<>(points));
return result;
}

// 选择x坐标最小和最大的点作为初始簇心
Point minXPoint = points.get(0);
Point maxXPoint = points.get(0);
for (Point p : points) {
if (p.x < minXPoint.x) minXPoint = p;
if (p.x > maxXPoint.x) maxXPoint = p;
}

Point[] centers = {new Point(minXPoint.x, minXPoint.y),
new Point(maxXPoint.x, maxXPoint.y)};

// 迭代更新簇心
for (int iter = 0; iter < 1000; iter++) {
// 将每个点分配到最近的簇心
List<List<Point>> clusters = new ArrayList<>();
clusters.add(new ArrayList<>());
clusters.add(new ArrayList<>());

for (Point p : points) {
double dist0 = calculateDistanceSquared(p, centers[0]);
double dist1 = calculateDistanceSquared(p, centers[1]);
if (dist0 <= dist1) {
clusters.get(0).add(p);
} else {
clusters.get(1).add(p);
}
}

// 更新簇心
Point[] newCenters = new Point[2];
for (int i = 0; i < 2; i++) {
if (!clusters.get(i).isEmpty()) {
newCenters[i] = calculateCenter(clusters.get(i));
} else {
newCenters[i] = centers[i];
}
}

// 检查是否收敛
if (calculateDistanceSquared(centers[0], newCenters[0]) < 1e-12 &&
calculateDistanceSquared(centers[1], newCenters[1]) < 1e-12) {
break;
}

centers = newCenters;
}

// 最终分配
List<List<Point>> clusters = new ArrayList<>();
clusters.add(new ArrayList<>());
clusters.add(new ArrayList<>());
for (Point p : points) {
double dist0 = calculateDistanceSquared(p, centers[0]);
double dist1 = calculateDistanceSquared(p, centers[1]);
if (dist0 <= dist1) {
clusters.get(0).add(p);
} else {
clusters.get(1).add(p);
}
}

return clusters;
}

// 二分K-means算法主函数
static List<List<Integer>> biKmeans(List<Point> points, int n) {
List<List<Point>> clusters = new ArrayList<>();
clusters.add(new ArrayList<>(points));
List<List<Integer>> results = new ArrayList<>();

// 第一次划分
List<List<Point>> newClusters = kmeansSplit(clusters.get(0));
clusters = newClusters;

List<Integer> sizes = new ArrayList<>();
for (List<Point> cluster : clusters) {
sizes.add(cluster.size());
}
Collections.sort(sizes, Collections.reverseOrder());
results.add(sizes);

// 继续划分直到达到目标簇数量
while (clusters.size() < n) {
double maxSSEReduction = -1;
int bestIdx = -1;

// 选择划分后SSE减少最多的簇
for (int i = 0; i < clusters.size(); i++) {
if (clusters.get(i).size() <= 1) continue;

double currentSSE = calculateSSE(clusters.get(i));
List<List<Point>> splitClusters = kmeansSplit(clusters.get(i));
double newSSE = 0;
for (List<Point> c : splitClusters) {
newSSE += calculateSSE(c);
}
double sseReduction = currentSSE - newSSE;

if (sseReduction > maxSSEReduction) {
maxSSEReduction = sseReduction;
bestIdx = i;
}
}

// 划分选中的簇
List<List<Point>> splitClusters = kmeansSplit(clusters.get(bestIdx));
List<List<Point>> newClustersList = new ArrayList<>();
for (int i = 0; i < clusters.size(); i++) {
if (i == bestIdx) {
newClustersList.addAll(splitClusters);
} else {
newClustersList.add(clusters.get(i));
}
}
clusters = newClustersList;

sizes = new ArrayList<>();
for (List<Point> cluster : clusters) {
sizes.add(cluster.size());
}
Collections.sort(sizes, Collections.reverseOrder());
results.add(sizes);
}

return results;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int m = sc.nextInt();

List<Point> points = new ArrayList<>();
for (int i = 0; i < m; i++) {
double x = sc.nextDouble();
double y = sc.nextDouble();
points.add(new Point(x, y));
}

List<List<Integer>> results = biKmeans(points, n);
for (List<Integer> result : results) {
for (int i = 0; i < result.size(); i++) {
if (i > 0) System.out.print(" ");
System.out.print(result.get(i));
}
System.out.println();
}
}
}

C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>
using namespace std;

struct Point {
double x, y;
Point(double x = 0, double y = 0) : x(x), y(y) {}
};

// 计算两点之间的欧氏距离平方
double calculateDistanceSquared(const Point& p1, const Point& p2) {
return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
}

// 计算点集的平均坐标（簇心）
Point calculateCenter(const vector<Point>& points) {
double xSum = 0, ySum = 0;
for (const Point& p : points) {
xSum += p.x;
ySum += p.y;
}
return Point(xSum / points.size(), ySum / points.size());
}

// 计算簇的SSE（误差平方和）
double calculateSSE(const vector<Point>& points) {
if (points.empty()) return 0;
Point center = calculateCenter(points);
double sse = 0;
for (const Point& p : points) {
sse += calculateDistanceSquared(p, center);
}
return sse;
}

// 使用K-means算法将点集分成两个簇
vector<vector<Point>> kmeansSplit(const vector<Point>& points) {
if (points.size() <= 1) {
return {points};
}

// 选择x坐标最小和最大的点作为初始簇心
Point minXPoint = points[0];
Point maxXPoint = points[0];
for (const Point& p : points) {
if (p.x < minXPoint.x) minXPoint = p;
if (p.x > maxXPoint.x) maxXPoint = p;
}

vector<Point> centers = {minXPoint, maxXPoint};

// 迭代更新簇心
for (int iter = 0; iter < 1000; iter++) {
// 将每个点分配到最近的簇心
vector<vector<Point>> clusters(2);
for (const Point& p : points) {
double dist0 = calculateDistanceSquared(p, centers[0]);
double dist1 = calculateDistanceSquared(p, centers[1]);
if (dist0 <= dist1) {
clusters[0].push_back(p);
} else {
clusters[1].push_back(p);
}
}

// 更新簇心
vector<Point> newCenters(2);
for (int i = 0; i < 2; i++) {
if (!clusters[i].empty()) {
newCenters[i] = calculateCenter(clusters[i]);
} else {
newCenters[i] = centers[i];
}
}

// 检查是否收敛
if (calculateDistanceSquared(centers[0], newCenters[0]) < 1e-12 &&
calculateDistanceSquared(centers[1], newCenters[1]) < 1e-12) {
break;
}

centers = newCenters;
}

// 最终分配
vector<vector<Point>> clusters(2);
for (const Point& p : points) {
double dist0 = calculateDistanceSquared(p, centers[0]);
double dist1 = calculateDistanceSquared(p, centers[1]);
if (dist0 <= dist1) {
clusters[0].push_back(p);
} else {
clusters[1].push_back(p);
}
}

return clusters;
}

// 二分K-means算法主函数
vector<vector<int>> biKmeans(const vector<Point>& points, int n) {
vector<vector<Point>> clusters = {points};
vector<vector<int>> results;

// 第一次划分
vector<vector<Point>> newClusters = kmeansSplit(clusters[0]);
clusters = newClusters;

vector<int> sizes;
for (const auto& cluster : clusters) {
sizes.push_back(cluster.size());
}
sort(sizes.begin(), sizes.end(), greater<int>());
results.push_back(sizes);

// 继续划分直到达到目标簇数量
while ((int)clusters.size() < n) {
double maxSSEReduction = -1;
int bestIdx = -1;

// 选择划分后SSE减少最多的簇
for (int i = 0; i < (int)clusters.size(); i++) {
if (clusters[i].size() <= 1) continue;

double currentSSE = calculateSSE(clusters[i]);
vector<vector<Point>> splitClusters = kmeansSplit(clusters[i]);
double newSSE = 0;
for (const auto& c : splitClusters) {
newSSE += calculateSSE(c);
}
double sseReduction = currentSSE - newSSE;

if (sseReduction > maxSSEReduction) {
maxSSEReduction = sseReduction;
bestIdx = i;
}
}

// 划分选中的簇
vector<vector<Point>> splitClusters = kmeansSplit(clusters[bestIdx]);
vector<vector<Point>> newClustersList;
for (int i = 0; i < (int)clusters.size(); i++) {
if (i == bestIdx) {
for (const auto& c : splitClusters) {
newClustersList.push_back(c);
}
} else {
newClustersList.push_back(clusters[i]);
}
}
clusters = newClustersList;

sizes.clear();
for (const auto& cluster : clusters) {
sizes.push_back(cluster.size());
}
sort(sizes.begin(), sizes.end(), greater<int>());
results.push_back(sizes);
}

return results;
}

int main() {
int n, m;
cin >> n >> m;

vector<Point> points(m);
for (int i = 0; i < m; i++) {
cin >> points[i].x >> points[i].y;
}

vector<vector<int>> results = biKmeans(points, n);
for (const auto& result : results) {
for (int i = 0; i < (int)result.size(); i++) {
if (i > 0) cout << " ";
cout << result[i];
}
cout << endl;
}

return 0;
}

---

### 第3题-最亮二叉树（P4225）
- 链接：https://codefun2000.com/p/P4225

> 页面标题：#P4225. 第3题-最亮二叉树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个普通二叉树 bulbs , 我们在二叉树的节点上安装灯泡，每个灯泡都有自己的亮度值和开关，如果选择打开一个灯泡，则它相邻的父节点和子节点上的灯泡都不能被打开，计算能够获得的最大亮度总和。
输入描述
假设 bulbs[bulbs[bulbs[ ]]] 是使用层序遍历存储的二叉树，其元素数值代表该对应树节点上灯泡的亮度值。
第一行输入为一个整数 nnn ，代表 bulbs[bulbs[bulbs[ ]]] 的数组大小;
第二行输入为 nnn 个整数，代表 bulbs[bulbs[bulbs[ ]]] 的元素值。
关于层序遍历的说明：
简单来说就是从根节点开始，一层一层从上到下、从左到右逐层遍历二叉树的节点，并按顺序将遍历结果保存在一维数组中。这样，我们可以得到一个包含二叉树所有节点灯泡亮度值的一维数组，顺序就是层序遍历的顺序。如果某个位置没有节点，用 000 来占位，代表该处没有节点，亮度是 000 。
参数取值范围：

1<=bulbs.length<=1061 <= bulbs.length<=10^61<=bulbs.length<=106

0<=bulbs[i]<=1000 <= bulbs[i]<= 1000<=bulbs[i]<=100

输出描述
一个整数，能够获得的最大亮度总和。
样例1
输入
5
1 2 3 0 4

输出
7

说明

1.
[1,2,3,0,4][1, 2, 3,0,4][1,2,3,0,4] 代表输入的二叉树为:

2.
1

3.
/           \

4.
2              3

5.
\

6.
4

7.
打开根节点的右子节点和最下方的节点的灯泡,可以获得满足要求的最大亮度值 3+4=73+4=73+4=7，则返回 777

样例2
输入
5
1 2 0 0 4

输出
5

说明

1.
[1,2,0,0,4][1, 2, 0,0,4][1,2,0,0,4] 代表输入的二叉树为:

2.
1

3.
/

4.
2

5.
\

6.
4

7.
打开根节点和最下方的节点的灯泡，可以获得满足要求的最大亮度值 1+4=51+4=51+4=5，则返回 555

▶️

#### TextSol

video solution

解题思路
核心思路采用深度优先搜索（DFS）结合动态规划求解。对于树上的每个节点，定义两种状态：选择该节点或不选择该节点。通过递归计算子树的状态，自底向上得到最优解。
具体实现方法如下。对每个节点维护两个值：不选该节点时的最大亮度和选该节点时的最大亮度。状态转移关系为：若选择当前节点，则其左右子节点都不能选，亮度为当前值加上左右子树不选状态的亮度；若不选当前节点，则左右子节点可选可不选，取其最大值之和。最终答案为根节点两种状态的最大值。
由于输入采用层序遍历数组表示二叉树，可以直接在数组上进行DFSDFSDFS，利用索引关系访问父子节点。对于索引为i的节点，其左子节点索引为2i+12i+12i+1，右子节点索引为2i+22i+22i+2。当索引超出范围或节点值为000时，表示该位置无节点。
复杂度分析
时间复杂度为O(n)O(n)O(n)，其中nnn为节点数量。每个节点只会被访问一次，在访问过程中进行常数时间的状态转移计算。
空间复杂度为O(h)O(h)O(h)，其中hhh为树的高度。递归调用栈的深度取决于树的高度，最坏情况下为O(n)O(n)O(n)（退化为链表），平均情况下为O(logn)O(log n)O(logn)（平衡二叉树）。
代码实现
Python
def maxBrightness(bulbs):
# DFS返回[不选当前节点的最大值, 选当前节点的最大值]
def dfs(idx):
# 越界或值为0表示无节点
if idx>=n or bulbs[idx]==0:
return [0,0]
# 递归计算左右子树
left=dfs(2*idx+1)
right=dfs(2*idx+2)
# 不选当前节点:子节点可选可不选
not_select=max(left)+max(right)
# 选当前节点:子节点都不能选
select=bulbs[idx]+left[0]+right[0]
return [not_select,select]
n=len(bulbs)
result=dfs(0)
return max(result)

n=int(input())
bulbs=list(map(int,input().split()))
print(maxBrightness(bulbs))

Java
import java.util.*;

public class Main{
static int[] dfs(int idx,int[] bulbs,int n){
// 越界或值为0表示无节点
if(idx>=n||bulbs[idx]==0){
return new int[]{0,0};
}
// 递归计算左右子树
int[] left=dfs(2*idx+1,bulbs,n);
int[] right=dfs(2*idx+2,bulbs,n);
// 不选当前节点:子节点可选可不选
int notSelect=Math.max(left[0],left[1])+Math.max(right[0],right[1]);
// 选当前节点:子节点都不能选
int select=bulbs[idx]+left[0]+right[0];
return new int[]{notSelect,select};
}

static int maxBrightness(int[] bulbs){
int[] result=dfs(0,bulbs,bulbs.length);
return Math.max(result[0],result[1]);
}

public static void main(String[] args){
Scanner sc=new Scanner(System.in);
int n=sc.nextInt();
int[] bulbs=new int[n];
for(int i=0;i<n;i++){
bulbs[i]=sc.nextInt();
}
System.out.println(maxBrightness(bulbs));
}
}

C++
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

// DFS返回pair<不选当前节点的最大值,选当前节点的最大值>
pair<int,int> dfs(int idx,vector<int>& bulbs,int n){
// 越界或值为0表示无节点
if(idx>=n||bulbs[idx]==0){
return {0,0};
}
// 递归计算左右子树
auto left=dfs(2*idx+1,bulbs,n);
auto right=dfs(2*idx+2,bulbs,n);
// 不选当前节点:子节点可选可不选
int notSelect=max(left.first,left.second)+max(right.first,right.second);
// 选当前节点:子节点都不能选
int select=bulbs[idx]+left.first+right.first;
return {notSelect,select};
}

int maxBrightness(vector<int>& bulbs){
auto result=dfs(0,bulbs,bulbs.size());
return max(result.first,result.second);
}

int main(){
int n;
cin>>n;
vector<int> bulbs(n);
for(int i=0;i<n;i++){
cin>>bulbs[i];
}
cout<<maxBrightness(bulbs)<<endl;
return 0;
}

---

## 2025年10月10日-AI方向

### 第2题-数据聚类及噪声点识别（P3874）
- 链接：https://codefun2000.com/p/P3874

> 页面标题：#P3874. 第2题-数据聚类及噪声点识别

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

DBSCANDBSCANDBSCAN（Density−BasedDensity-BasedDensity−Based SpatialSpatialSpatial ClusteringClusteringClustering ofofof ApplicationsApplicationsApplications withwithwith NoiseNoiseNoise）是一种基于密度的聚类算法。它能够识别出噪声点，发现任意形状的簇，其核心概念包括：

eps-邻域：样本点 PPP 与 点 QQQ 的距离小于 epsepseps 的所有样本点的集合，即点 PPP 周围以 epsepseps 为半径内所有样本点的集合。

核心点：若点 PPP 的 epsepseps 邻域内的样本点数量大于 min_samplesmin\_samplesmin_samples 的阈值，则称点 PPP 为核心点。

直接密度可达：若点 PPP 是核心点，且点 QQQ 处于点 PPP 的 epsepseps 邻域内，则称点 QQQ 由点 PPP 直接密度可达。

密度可达：若有一串点 P1,P2,...,PnP_1, P_2, ..., P_nP1​,P2​,...,Pn​，对于任意 iii，Pi+1P_{i+1}Pi+1​ 可由 PiP_iPi​ 直接密度可达，则称点 PnP_nPn​ 可由点 P1P_1P1​ 密度可达。

密度相连：若存在点 OOO ，使得点 PPP 和点 QQQ 都可由 OOO 密度可达，则称点 PPP 和点 QQQ 是密度相连的。

簇：对于任意的点 PPP 和点 QQQ ，若点 PPP 属于某个簇，且点 QQQ 由点 PPP 密度可达，则点 QQQ 也属于这个簇。同理，由点 QQQ 密度可达的点也属于这个簇。即同一簇内的点，是密度相连的。

噪声点：不属于样本集内任何簇的样本点。

请你根据以上要求实现 DBSCANDBSCANDBSCAN 算法，要求根据给定的数据集、epsepseps 和 min_samplesmin\_samplesmin_samples 值，输出簇的个数和噪声点的个数。
输入描述
第一行输入 333 个数 epsepseps, min_samplesmin\_samplesmin_samples, xxx，以空格隔开，分别表示：

epsepseps：计算 epsepseps-邻域的半径值，可为小数
min_samplesmin\_samplesmin_samples：核心点的 epsepseps-邻域内样本点数量阈值，整数
xxx：数据集行数，即样本数量，整数

第二行开始为输入的样本数据，数值之间用空格隔开，共输入 xxx 行，每行输入数值数量为 yyy，2≤y≤32 \leq y \leq 32≤y≤3
输出描述
输出两个值，用空格隔开，第一个值表示得到的簇的个数，第二个值表示识别到的噪声点的个数
样例1
输入
2 2 10
0 0
3 3
6 6
9 9
12 12
2 6
6 2
9 5
5 9
10 2

输出
0 10

说明
epsepseps 设为 222，min_samplesmin\_samplesmin_samples 为 222，但给出的数据集中任意两个点之间的距离都大于222，因此即使 min_samplemin\_samplemin_sample 设置为 222，也没有形成任何簇，即所有的点都是噪声，如下图：

样例2
输入
1 5 20
5.05 1.36
-8.19 -6.47
4.5 2.5
5.01 2.06
4.30 2.28
4.22 1.82
4.58 1.82
4.81 2.46
4.81 1.09
4.80 1.78
5.16 2.44
-6.92 -6.38
-6.84 -7.03
-6.70 -7.20
-6.83 -7.87
-6.47 -6.20
-6.70 -6.11
-6.90 -6.10
-6.99 -6.70
5 5

输出
2 2

说明
样例数据集中共 202020 个点，给定 epsepseps 为 111 ， min_samplesmin\_samplesmin_samples 为 555 ，聚类后得到两个簇： 一个在坐标系第一象限，一个在第三象限，且存在两个噪声点 (5,5)(5, 5) (5,5) 和 (−8.19,−6.47)(-8.19, -6.47) (−8.19,−6.47)不属于任何簇，如下图：

▶️

#### TextSol

video solution

解题思路
DBSCAN 基于“密度”成簇：对每个点找 eps 邻域（欧氏距离 ≤ eps 的点集合），若邻域样本数 ≥ min_samples，该点为核心点；从未访问的核心点出发，用 BFS/DFS 扩展，将其邻域内的点并入当前簇；若被并入的点本身也是核心点，则继续把它的邻域加入队列，直到不再扩展。最终没有被任何簇吸纳的点即为噪声点。
实现细节：

计算并缓存所有点的邻居列表（两两距离判断，含自身）；维度不写死，自动支持二维或三维输入。
core[i] = (len(neighbors[i]) >= min_samples) 判定核心点。
逐点扫描：若是未访问的核心点，创建新簇并用队列扩展；扩展时把邻居标成当前簇，遇到核心点则把它的邻居继续入队。
统计得到的簇个数与仍为 -1 的样本数（噪声点）。

复杂度分析

设样本数为 n，维度 d∈{2,3}。
预计算邻居：O(n^2 * d)；扩展遍历整体 O(n^2)。
总时间复杂度 O(n^2 * d)；空间复杂度（邻接表）O(n^2)，标记与标签 O(n)。在题目给定规模下可接受。

代码实现
Python
import sys
from collections import deque
from ast import literal_eval

def dist2(a, b):
# 欧氏距离平方，维度自适应（2D/3D均可）
return sum((ai - bi) ** 2 for ai, bi in zip(a, b))

def dbscan(points, eps, min_samples):
n = len(points)
if n == 0:
return 0, 0
eps2 = eps * eps

# 预计算邻居（含自身），阈值用 <=
neighbors = [[] for _ in range(n)]
for i in range(n):
for j in range(n):
if dist2(points[i], points[j]) <= eps2:
neighbors[i].append(j)

core = [len(neighbors[i]) >= min_samples for i in range(n)]
labels = [-1] * n
visited = [False] * n
cluster_id = 0

for i in range(n):
if visited[i]:
continue
visited[i] = True
if not core[i]:
continue

labels[i] = cluster_id
q = deque(neighbors[i])  # 从核心点的邻居开始扩展
in_q = [False] * n
for nb in neighbors[i]:
in_q[nb] = True

while q:
j = q.popleft()
if labels[j] == -1:
labels[j] = cluster_id
if not visited[j]:
visited[j] = True
if core[j]:
for nb in neighbors[j]:
if not in_q[nb]:
q.append(nb)
in_q[nb] = True
cluster_id += 1

noise = sum(1 for v in labels if v == -1)
return cluster_id, noise

def main():
data = sys.stdin.read().strip().splitlines()
if not data:
return
a, b, c = data[0].split()
eps = float(a)
min_samples = int(b)
x = int(c)

points = [list(map(float,data[i].split())) for i in range(1, 1 + x)]
clusters, noise = dbscan(points, eps, min_samples)
print(f"{clusters} {noise}")

if __name__ == "__main__":
main()

Java
import java.io.BufferedInputStream;
import java.util.*;

public class Main {
static double dist2(double[] a, double[] b) {
double s = 0.0;
for (int i = 0; i < a.length; i++) {
double d = a[i] - b[i];
s += d * d;
}
return s;
}

static int[] dbscan(List<double[]> points, double eps, int minSamples) {
int n = points.size();
if (n == 0) return new int[]{0, 0};
double eps2 = eps * eps;

// 邻居列表（含自身）
List<List<Integer>> neighbors = new ArrayList<>();
for (int i = 0; i < n; i++) neighbors.add(new ArrayList<>());
for (int i = 0; i < n; i++) {
double[] pi = points.get(i);
for (int j = 0; j < n; j++) {
if (dist2(pi, points.get(j)) <= eps2) {
neighbors.get(i).add(j);
}
}
}

boolean[] core = new boolean[n];
for (int i = 0; i < n; i++) core[i] = neighbors.get(i).size() >= minSamples;

int[] labels = new int[n];
Arrays.fill(labels, -1);
boolean[] visited = new boolean[n];
int clusterId = 0;

for (int i = 0; i < n; i++) {
if (visited[i]) continue;
visited[i] = true;
if (!core[i]) continue;

labels[i] = clusterId;
ArrayDeque<Integer> q = new ArrayDeque<>();
boolean[] inQ = new boolean[n];
for (int nb : neighbors.get(i)) {
q.add(nb); inQ[nb] = true;
}
while (!q.isEmpty()) {
int j = q.poll();
if (labels[j] == -1) labels[j] = clusterId;
if (!visited[j]) {
visited[j] = true;
if (core[j]) {
for (int nb : neighbors.get(j)) {
if (!inQ[nb]) { q.add(nb); inQ[nb] = true; }
}
}
}
}
clusterId++;
}

int noise = 0;
for (int v : labels) if (v == -1) noise++;
return new int[]{clusterId, noise};
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(new BufferedInputStream(System.in), "UTF-8");
if (!sc.hasNext()) { sc.close(); return; }
double eps = sc.nextDouble();
int minSamples = sc.nextInt();
int x = sc.nextInt();
sc.nextLine();

List<double[]> points = new ArrayList<>();
for (int i = 0; i < x; i++) {
String line = sc.nextLine().trim();
if (line.isEmpty()) { i--; continue; }
String[] sp = line.split("\\s+"); // 空格分隔，2D/3D皆可
double[] row = new double[sp.length];
for (int k = 0; k < sp.length; k++) row[k] = Double.parseDouble(sp[k]);
points.add(row);
}
sc.close();

int[] ans = dbscan(points, eps, minSamples);
System.out.println(ans[0] + " " + ans[1]);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

double dist2(const vector<double>& a, const vector<double>& b) {
double s = 0.0;
for (size_t i = 0; i < a.size(); ++i) {
double d = a[i] - b[i];
s += d * d;
}
return s;
}

pair<int,int> dbscan(const vector<vector<double>>& points, double eps, int min_samples) {
int n = (int)points.size();
if (n == 0) return {0, 0};
double eps2 = eps * eps;

vector<vector<int>> neighbors(n);
for (int i = 0; i < n; ++i) {
for (int j = 0; j < n; ++j) {
if (dist2(points[i], points[j]) <= eps2) {
neighbors[i].push_back(j);
}
}
}

vector<char> core(n, false);
for (int i = 0; i < n; ++i) {
if ((int)neighbors[i].size() >= min_samples) core[i] = true;
}

vector<int> labels(n, -1);
vector<char> visited(n, false);
int cluster_id = 0;

for (int i = 0; i < n; ++i) {
if (visited[i]) continue;
visited[i] = true;
if (!core[i]) continue;

labels[i] = cluster_id;
deque<int> q;
vector<char> in_q(n, false);
for (int nb : neighbors[i]) { q.push_back(nb); in_q[nb] = true; }

while (!q.empty()) {
int j = q.front(); q.pop_front();
if (labels[j] == -1) labels[j] = cluster_id;
if (!visited[j]) {
visited[j] = true;
if (core[j]) {
for (int nb : neighbors[j]) {
if (!in_q[nb]) { q.push_back(nb); in_q[nb] = true; }
}
}
}
}
++cluster_id;
}

int noise = 0;
for (int v : labels) if (v == -1) ++noise;
return {cluster_id, noise};
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

double eps; int min_samples, x;
if (!(cin >> eps >> min_samples >> x)) return 0;
string dummy; getline(cin, dummy);

vector<vector<double>> points;
points.reserve(x);
for (int i = 0; i < x; ++i) {
string line; getline(cin, line);
if (line.empty()) { --i; continue; }
stringstream ss(line);
vector<double> row; double v;
while (ss >> v) row.push_back(v); // 2D/3D兼容
points.push_back(row);
}

auto res = dbscan(points, eps, min_samples);
cout << res.first << " " << res.second << "\n";
return 0;
}

---

### 第2题-坐火车IV（P3877）
- 链接：https://codefun2000.com/p/P3877

> 页面标题：#P3877. 第2题-坐火车IV

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某旅行线路上有一辆有 MMM 节车厢的列车，所有车厢中都没人，现有 NNN 个旅行团需要搭乘该线路，其 IDIDID 为 ：[0,N)[0,N)[0,N) 。请给出具体的乘坐方案，满足使得各车厢间的乘客数量差异最小。(说明：乘客最多的车厢中的人数记作 XXX ，乘客最少的车厢中的人数记作 YYY ，需要满足 X−YX-YX−Y 最小) 旅行团乘坐列车需要满足如下要求：
1.对于任意 0<i<j<M0<i<j<M0<i<j<M ，车厢i中的任意旅行团的 IDIDID 小于车厢 jjj 中任意旅行团的 IDIDID 。
2.同个车厢内的旅行团，他们的 IDIDID 是连续的。
3.同个旅行团的成员必须在一个车厢内。
注：当只有一个车厢时，该车厢的乘客数既是最大乘客数，也是最小乘客数
输入描述
第 111 行：NNN MMM，其中

NNN 是旅行团个数，范围是 [1,1000][1,1000][1,1000]

MMM 是车厢个数，范围是 [1,N][1,N][1,N]

第 222 行：P1P_1P1​ P2P_2P2​ ... PNP_NPN​ ，每个数字代表一个旅行团的成员个数，成员个数范围是 [1,100000][1,100000][1,100000]
输出描述
输出乘客最多的车厢中的人数 XXX
样例1
输入
3 3
1 6 4

输出
6

说明
333 333 ：有 333 个旅行团，列车有 333 节车厢
111 666 444 ：这 333 个旅行团的成员个数分别是 111 666 444
每个车厢都有旅行团时车厢人数差异才可能最小，考虑以下 111 种乘坐方案

[1][6][4][1] [6] [4][1][6][4]

可知乘客最多的车厢中的人数是 666
样例2
输入
5 2
7 2 5 10 8

输出
18

说明
555 222 ：有 555 个旅行团，列车有 222 节车厢
777 222 555 101010 888 ：这 555 个旅行团的成员个数分别是 777 222 555 101010 888
每个车厢都有旅行团时车厢人数差异才可能小，因此只考虑以下 444 种乘坐方案

[7][2[7][2[7][2 555 101010 8]8]8] ：777 和 252525 ，人数差异 181818

[7[7[7 2][52][52][5 101010 8]8]8] ：999 和 232323 ，人数差异 141414

[7[7[7 222 5][105][105][10 8]8]8] ：141414 和 181818 ，人数差异 444

[7[7[7 222 555 10][8]10][8]10][8] ：242424 和 888 ，人数差异 161616

可知最好的方式是 [7[7[7 222 5][105][105][10 8]8]8] ，其中乘客最多的车厢中的人数是 181818

▶️

#### TextSol

video solution

解题思路
题意：将按 ID 递增排列的 N 个旅行团（人数为数组 P[1..N]）切分成 M 个连续段（每段对应一节车厢），每个旅行团整体必须在同一车厢。目标是让各车厢人数的最大值记为 X、最小值记为 Y，使 X - Y 最小，要求输出对应方案中的 X。
关键结论（直观且常用于竞赛）：
要让差异 X - Y 尽量小，首先必须把最大车厢人数 X 压到尽可能小。
一旦存在某个划分的最大值高于可实现的“最小可能最大段和”，我们就能找到一个最大值更小的划分，从而不会使差异变得更好。因此，最终输出的 X 等于把数组切成 M 段时的最小可能最大段和。这正是经典问题 “分割数组的最大值最小化（Split Array Largest Sum）”。
实现方法（算法组合：二分答案 + 贪心检查）：

设搜索上下界：

下界 L = max(P)（任一车厢都要容纳某个旅行团）。
上界 R = sum(P)（全部放一节车厢）。

二分中间值 mid，用贪心模拟在“单节车厢人数不超过 mid”的限制下，需要多少节车厢：

从左到右累加，当加入下一个旅行团会超过 mid 时，就开新车厢。
统计得到的车厢数 cnt。

若 cnt > M，说明 mid 太小（车厢不够），上调下界；否则可行，收缩上界。

迭代至收敛，得到的 L 即为最小可行的最大车厢人数 X。

说明：题目只要求输出 X，不必输出具体分段；而该 X 与题意中“最小化差异”的最优方案一致。

复杂度分析

时间复杂度：O(N log S)，其中 S = sum(P)。每次二分用一次线性贪心计数。
空间复杂度：O(1)（只用常量额外空间）。

代码实现
Python
# 题目：最小化车厢人数差异（输出最大车厢人数 X）
# 思路：二分答案 + 贪心计数
# 说明：ACM 风格，主函数中完成输入输出，核心逻辑写在外部函数中

import sys

def need_cars(limit, arr, M):
"""
给定每节车厢人数上限 limit，计算贪心最少需要多少节车厢。
若某个旅行团人数本身 > limit，则必不可行（但二分下界已保证不会发生）。
"""
count = 1      # 至少一节车厢
cur = 0
for x in arr:
if cur + x <= limit:
cur += x
else:
count += 1
cur = x
return count

def solve(N, M, arr):
left = max(arr)      # 下界：至少容纳最大旅行团
right = sum(arr)     # 上界：全部放一节
while left < right:
mid = (left + right) // 2
cnt = need_cars(mid, arr, M)
if cnt > M:
# 需要的车厢太多，说明上限太小
left = mid + 1
else:
# 可以在不超过 M 节车厢的情况下装下，尝试压缩上限
right = mid
return left

def main():
data = sys.stdin.read().strip().split()
N, M = map(int, data[:2])
P = list(map(int, data[2:2+N]))
ans = solve(N, M, P)
print(ans)

if __name__ == "__main__":
main()

Java
// 题目：最小化车厢人数差异（输出最大车厢人数 X）
// 思路：二分答案 + 贪心计数
// 说明：ACM 风格，类名 Main，输入输出在 main 中完成，核心逻辑在外部静态方法中

import java.io.*;
import java.util.*;

public class Main {

// 贪心计算在单节车厢上限为 limit 时需要的车厢数量
static int needCars(long limit, int[] arr) {
int cnt = 1;          // 至少一节车厢
long cur = 0;
for (int x : arr) {
if (cur + x <= limit) {
cur += x;
} else {
cnt++;
cur = x;
}
}
return cnt;
}

static long solve(int N, int M, int[] arr) {
long left = 0, right = 0;
for (int x : arr) {
left = Math.max(left, x);   // 下界：最大旅行团人数
right += x;                 // 上界：总人数
}
while (left < right) {
long mid = (left + right) / 2;
int cnt = needCars(mid, arr);
if (cnt > M) {
// 需要车厢数过多，说明上限偏小
left = mid + 1;
} else {
// 可行，尝试减小上限
right = mid;
}
}
return left;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] p1 = br.readLine().trim().split("\\s+");
int N = Integer.parseInt(p1[0]);
int M = Integer.parseInt(p1[1]);
String[] p2 = br.readLine().trim().split("\\s+");
int[] arr = new int[N];
for (int i = 0; i < N; i++) arr[i] = Integer.parseInt(p2[i]);

long ans = solve(N, M, arr);
System.out.println(ans);
}
}

C++
// 题目：最小化车厢人数差异（输出最大车厢人数 X）
// 思路：二分答案 + 贪心计数
// 说明：ACM 风格，主函数中读写，核心逻辑单独函数

#include <bits/stdc++.h>
using namespace std;

// 贪心计算在单节车厢上限为 limit 时需要的车厢数量
static int need_cars(long long limit, const vector<int>& a) {
int cnt = 1;                 // 至少一节车厢
long long cur = 0;
for (int x : a) {
if (cur + x <= limit) cur += x;
else { ++cnt; cur = x; }
}
return cnt;
}

static long long solve(int N, int M, const vector<int>& a) {
long long left = 0, right = 0;
for (int x : a) {
left = max<long long>(left, x);   // 下界：最大旅行团人数
right += x;                        // 上界：总人数
}
while (left < right) {
long long mid = (left + right) / 2;
int cnt = need_cars(mid, a);
if (cnt > M) {
// 需要车厢数过多，上限偏小
left = mid + 1;
} else {
// 可行，尝试压缩上限
right = mid;
}
}
return left;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int N, M;
if (!(cin >> N >> M)) return 0;
vector<int> a(N);
for (int i = 0; i < N; ++i) cin >> a[i];
cout << solve(N, M, a) << "\n";
return 0;
}

---

### 第2题-服务器的编号（P3868）
- 链接：https://codefun2000.com/p/P3868

> 页面标题：#P3868. 第2题-服务器的编号

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

数据中心有 MMM 个服务器(编号 1−M1-M1−M )，现在 NNN 个(编号 1−N1-N1−N )需要执行，当一个任务开始执行时，会独占编号最小的空闲服务器，执行完后会立即释放该服多器。任务按照启动时间的先后顺序执行(所有任务的启动时间都不相同)。请返回编号为 KKK 的任务执行时占用的服务器编号。
输入描述
第一行是用空格分隔的三个整数：M，N，KM，N，KM，N，K 分别代表服务器个数，任务数，需要查询的任务编号， 1<=K<=N<=M<=1041<=K<=N <= M <= 10^41<=K<=N<=M<=104
接下来 NNN 行是编号 1−N1-N1−N 的任务信息，每行是用空格分隔的两个整数，分别代表任务的启动时间，执行需要的时间。1<=1<=1<= 启动时间，执行时间 <=105<=10^5<=105
输出描述
编号为 KKK 的任务执行时占用的服务器编号
样例1
输入
4 3 2
1 2
4 6
3 3

输出
2

说明
编号为 111 的任务(启动时间为 111 )占用 111 号服务器
编号为 333 的任务(启动时间为 333 )执行时，编号为 111 的任务已经执行完，111 号服务器空闲，所以占用 111 号服务器
编号为 222 的任务(启动时间为 444 )执行时，编号为 333 的任务还没有执行完，所以占用 222 号服务器
样例2
输入
2 1 1
1 5

输出
1

说明
只有 111 个任务，占用 111 号服务器

#### TextSol

解题思路
我们有 M 台服务器（编号 1..M），N 个任务（编号 1..N）。第 i 个任务给出启动时间 s_i 与执行时间 t_i，不同任务的启动时间两两不同。任务按启动时间发生：
当某任务到来时，所有在该时刻之前或恰好完成的任务会释放其服务器；若有空闲服务器，则该任务立刻占用编号最小的空闲服务器并执行。要求输出编号为 K 的任务在执行时占用的服务器编号。
核心算法：事件模拟 + 两个小根堆（优先队列）

将任务按启动时间 s_i 升序排序，同时保留任务原编号 i。

维护两个堆：

avail：空闲服务器编号的小根堆（初始放入 1..M）。
busy：正在运行任务的小根堆，元素为 (结束时间, 服务器编号)。

依次处理每个任务 (s_i, t_i, i)：

先把 busy 中所有 结束时间 <= s_i 的元素弹出，并把对应服务器放回 avail；
从 avail 弹出最小编号的服务器 id，记录 ans[i] = id；
将 (s_i + t_i, id) 压入 busy。

最后输出 ans[K]。

复杂度分析

排序：O(N log N)
每个任务最多一次入堆/出堆，两类堆的操作均为 O(log M)，合计 O(N log M)
总时间复杂度：O(N log N + N log M)
空间复杂度：O(M + N)（两个堆与答案数组）

代码实现
Python
import sys
import heapq

def server_of_k(M, tasks, K):
# tasks: 列表 [(s, t, idx)]
tasks.sort(key=lambda x: x[0])  # 按启动时间排序

# 空闲服务器小根堆（编号最小优先）
avail = list(range(1, M + 1))
heapq.heapify(avail)

# 正在运行的任务：(结束时间, 服务器编号)
busy = []

# 记录每个原编号任务的分配服务器
ans = [0] * (len(tasks) + 1)

for s, t, idx in tasks:
# 释放所有在 s 之前或恰好 s 时刻完成的任务
while busy and busy[0][0] <= s:
end_time, sid = heapq.heappop(busy)
heapq.heappush(avail, sid)

# 取出最小编号的空闲服务器
sid = heapq.heappop(avail)
ans[idx] = sid

# 压入该任务的结束事件
heapq.heappush(busy, (s + t, sid))

return ans[K]

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
M = int(next(it)); N = int(next(it)); K = int(next(it))
tasks = []
for i in range(1, N + 1):
s = int(next(it)); t = int(next(it))
tasks.append((s, t, i))
print(server_of_k(M, tasks, K))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {

static int serverOfK(int M, int[][] tasks, int K) {
// 按启动时间升序
Arrays.sort(tasks, Comparator.comparingInt(a -> a[0]));

// 空闲服务器：小根堆（编号最小优先）
PriorityQueue<Integer> avail = new PriorityQueue<>();
for (int i = 1; i <= M; i++) avail.offer(i);

// 正在运行：小根堆（结束时间最小优先）
// 元素为 int[]{endTime, serverId}
PriorityQueue<int[]> busy = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));

int n = tasks.length;
int[] ans = new int[n + 1]; // 以任务原编号为下标

for (int[] x : tasks) {
int s = x[0], t = x[1], idx = x[2];

// 释放完成的任务（结束时间 <= 当前启动时间）
while (!busy.isEmpty() && busy.peek()[0] <= s) {
int[] cur = busy.poll();
avail.offer(cur[1]);
}

// 分配最小编号服务器
int sid = avail.poll();
ans[idx] = sid;

// 加入结束事件
busy.offer(new int[]{s + t, sid});
}

return ans[K];
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

int M = sc.nextInt();
int N = sc.nextInt();
int K = sc.nextInt();

// tasks[i] = {start, duration, originalIndex}
int[][] tasks = new int[N][3];
for (int i = 0; i < N; i++) {
int s = sc.nextInt();
int t = sc.nextInt();
tasks[i][0] = s;
tasks[i][1] = t;
tasks[i][2] = i + 1; // 原编号
}

System.out.println(serverOfK(M, tasks, K));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int server_of_k(int M, vector<tuple<int,int,int>>& tasks, int K) {
// 按启动时间排序
sort(tasks.begin(), tasks.end());

// 空闲服务器：最小编号优先
priority_queue<int, vector<int>, greater<int>> avail;
for (int i = 1; i <= M; ++i) avail.push(i);

// 正在运行任务：结束时间最小优先，元素 (end, serverId)
using PII = pair<int,int>;
priority_queue<PII, vector<PII>, greater<PII>> busy;

int n = (int)tasks.size();
vector<int> ans(n + 1, 0); // 原编号 -> 服务器编号

for (auto &tp : tasks) {
int s = get<0>(tp), t = get<1>(tp), idx = get<2>(tp);

// 释放到当前时刻已完成的任务
while (!busy.empty() && busy.top().first <= s) {
int sid = busy.top().second;
busy.pop();
avail.push(sid);
}

// 分配最小编号的空闲服务器
int sid = avail.top(); avail.pop();
ans[idx] = sid;

// 加入结束事件
busy.push({s + t, sid});
}
return ans[K];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int M, N, K;
if (!(cin >> M >> N >> K)) return 0;

vector<tuple<int,int,int>> tasks;
tasks.reserve(N);
for (int i = 0; i < N; ++i) {
int s, t;
cin >> s >> t;
tasks.emplace_back(s, t, i + 1); // 保存原编号
}

cout << server_of_k(M, tasks, K) << "\n";
return 0;
}

---

### 第3题-经典LSTM模型结构实现（P3875）
- 链接：https://codefun2000.com/p/P3875

> 页面标题：#P3875. 第3题-经典LSTM模型结构实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

【问题说明】长短期记忆网络（LongLongLong Short−TermShort-TermShort−Term MemoryMemoryMemory, LSTMLSTMLSTM）是一种特殊的循环神经网络（RNNRNNRNN），旨在解决传统 RNNRNNRNN 中存在的梯度消失和梯度爆炸问题，使其能够有效地学习长期依赖关系。
一个 LSTMLSTMLSTM 单元（CellCellCell）的核心由三个关键的门和一个细胞状态（CellCellCell StateStateState）组成：
细胞状态 (CellCellCell StateStateState):这是 LSTMLSTMLSTM 的“记忆高速公路"，信息沿着这条路径从一个时间步传递到下一个。它的更新是一个简单的线性操作(加法和乘法)，这使得梯度可以更直接地流动，从而避免了梯度消失。
遗忘门 (ForgetForgetForget GateGateGate):遗忘门决定从上一时间步的细胞状态中丢弃哪些信息。它通过一个 SigmoidSigmoidSigmoid 激活函数，对上一个隐藏状态和当前输入进行处理，输出一个介于 000 和 111 之间的向量。000 表示完全遗忘，111 表示完全保留。
输入门（InputGateInput GateInputGate）：输入门控制新信息写入到细胞状态中。它包含两个部分：

一个 SigmoidSigmoidSigmoid 层，用于决定哪些值需要更新。
一个 TanhTanhTanh 层，用于创建新的候选细胞状态（CCC ~ ttt）。

输出门（OutputOutputOutput GateGateGate）：输出门决定当前时刻的隐藏状态（HiddenHiddenHidden StateStateState）将输出哪些信息。它首先通过一个 SigmoidSigmoidSigmoid 层来决定细胞状态的哪些部分会被输出，然后对当前的细胞状态应用 TanhTanhTanh 函数，最后两者相乘得到新的隐藏状态。
【任务要求】请根据下图的 LSTMLSTMLSTM 结构示意图，实现一个 LSTMLSTMLSTM 模型的关键函数，并按下列要求输出计算结果。

该 LSTMLSTMLSTM 模型包含了 555 个 LSTMLSTMLSTM CellCellCell（上图中 AAA 单元），每个 LSTMLSTMLSTM CellCellCell 中的权重的定义如下图所示，分别为 wf,wi,wg,wowf, wi, wg, wowf,wi,wg,wo, 对应的偏置为 bf,bi,bg,bobf, bi, bg, bobf,bi,bg,bo。已在 pythonpythonpython 代码模板中提供了 555 个 LSTMLSTMLSTM CellCellCell 的权重和偏置的数据。如果使用非 PythonPythonPython 语言, 需沿用 Python3Python3Python3 代码模板中的参数设置。

该 LSTMLSTMLSTM 模型会循环地作用于输入序列中的每一个时间步（从 t=1t=1t=1 到 t=sequence_lengtht=sequence\_lengtht=sequence_length），每个时间步的计算都会产生一个 555 维的隐藏状态。请针对不同输入矩阵运行 LSTMLSTMLSTM 模型，计算对应每个时间步隐藏层状态 hhh 的首元素。其中输入 XXX 矩阵的形状为 [4,7][4, 7][4,7] ，即输入数据序列时间步长 sequence_lengthsequence\_lengthsequence_length 为 444 ，输入数据维度 X_dimX\_dimX_dim 为 777 。
输入描述
一共一行数据，用于描述输入矩阵。
其中前两个为整型数据，分别为 sequence_lengthsequence\_lengthsequence_length 行数和 x_dimx\_dimx_dim 列数，后面数据为输入矩阵的参数，均为浮点数，按行平铺 flattenflattenflatten 形式展开为一维序列，数据间以一个空格间隔。
输出描述
一共一行数据，输出每个时间步隐藏状态的首元素，按时间步顺序组成，数据之间以一个空格间隔。
数据精度要求:且均四舍五入精确到小数点后 333 位，同时若尾部存在 000 结尾需进行舍弃如 0.2000.2000.200 0.3100.310 0.310 0.8910.8910.891 0.0070.0070.007 需要舍弃尾部，变为 0.20.20.2 0.310.310.31 0.8910.8910.891 0.0070.0070.007 。特殊情况：000 或 0.0000.0000.000 或 0.000.000.00 或 0.00.00.0 需输出为 0.00.00.0 。
样例1
输入
4 7 -1.153285 -0.081943 0.464549 3.411137 0.594197 1.21088 -0.234899 -0.272196 0.279498 -0.289765 -0.826989 -0.224368 0.711969 -0.067545 0.80226 0.574793 2.458116 0.733628 0.698731 -0.816701 0.533741 -1.756603 -0.123113 -0.550757 0.273727 0.249046 -1.165406 -0.31581

输出
0.001 -0.002 0.012 -0.006

样例2
输入
4 7 -1.609352 -0.165708 -0.494005 1.980481 0.316188 -0.005439 -1.108964 0.576463 -0.048573 -0.384642 -1.112576 0.351411 0.698983 0.607453 0.364154 -0.220041 0.345962 -0.274185 -0.784176 -1.740389 1.118046 0.794949 2.249595 -0.038455 0.037336 -0.652332 1.491228 -0.248807

输出
-0.006 -0.012 -0.013 0.014

说明
样例的输入输出均为一行数据，具体格式及输出规范参考上述输入输出描述。经典LSTM模型结构实现

#### TextSol

思路与公式

记忆单元数量（隐藏维度）为 m=5m=5m=5，输入维度为 x_dim=7x\_dim=7x_dim=7，因此每个门的权重矩阵形状均为 (m,  x_dim+m)=(5,12)(m,\; x\_dim+m)=(5,12)(m,x_dim+m)=(5,12)。在每个时间步 ttt，把当前输入 xt∈R7x_t\in\mathbb{R}^{7}xt​∈R7 与上一步隐藏向量 ht−1∈R5h_{t-1}\in\mathbb{R}^{5}ht−1​∈R5 级联成 xc=[xt;ht−1]∈R12\mathrm{xc}=[x_t;h_{t-1}]\in\mathbb{R}^{12}xc=[xt​;ht−1​]∈R12。

经典 LSTM 的前向计算如下（与题面描述一致）：
$$\begin{aligned}
g_t &= \tanh(W_g \, \mathrm{xc} + b_g),\\
i_t &= \sigma(W_i \, \mathrm{xc} + b_i),\\
f_t &= \sigma(W_f \, \mathrm{xc} + b_f),\\
o_t &= \sigma(W_o \, \mathrm{xc} + b_o),\\
s_t &= g_t \odot i_t + s_{t-1} \odot f_t,\\
h_t &= \tanh(s_t) \odot o_t,
\end{aligned}$$其中 σ(⋅)\sigma(\cdot)σ(⋅) 为 Sigmoid，tanh⁡(⋅)\tanh(\cdot)tanh(⋅) 为双曲正切，⊙\odot⊙ 为按元素乘法；初始 s0=0, h0=0s_0=\mathbf{0},\,h_0=\mathbf{0}s0​=0,h0​=0。

输出：对每个时间步的 hth_tht​ 取首元素 ht[0]h_t[0]ht​[0]，四舍五入到 3 位小数并去除尾随 0；仅当数值为 0 时输出 0.0。

代码
import numpy as np

def sigmoid(x):
return 1 / (1 + np.exp(-x))

class LetterParam:
def __init__(self, mem_cell_ct, x_dim):
self.mem_cell_ct = mem_cell_ct
self.x_dim = x_dim
# Weight Matrices Shape(mem_cell_ct, x_dim + mem_cell_ct)
self.wg = np.array([
[0.009763, 0.043038, 0.020553, 0.008977, -0.015209, 0.000179, -0.012636, 0.017535, -0.022032, 0.06664, 0.06077, 0.02607],
[0.013609, 0.095119, -0.085793, -0.095274, -0.099966, 0.086524, 0.056641, 0.074002, 0.06774, -0.00704, 0.00686, -0.01013],
[-0.076345, 0.027984, -0.071329, 0.088934, 0.00437, -0.017065, -0.047089, 0.046647, -0.06871, 0.00387, -0.00661, -0.01133],
[0.022419, 0.023837, 0.08375, 0.036964, -0.028098, -0.012594, 0.039626, -0.03785, 0.03383, 0.00188, -0.00723, -0.06378],
[-0.036914, -0.027258, 0.014093, -0.01228, 0.007675, -0.078691, -0.058225, -0.05922, -0.04942, -0.06378, -0.01133, 0.00689]
], dtype=float)

self.wi = np.array([
[-0.012801, -0.094815, 0.009932, -0.012938, -0.015208, -0.03393, -0.06907, 0.02384, -0.04069, -0.04695, 0.04227, 0.00689],
[-0.073084, 0.002716, -0.063112, 0.057087, 0.017075, -0.001143, 0.06291, -0.06470, 0.00196, -0.06943, -0.04476, -0.00694],
[-0.074568, 0.019349, -0.054798, -0.076611, -0.053938, -0.030035, -0.00644, -0.06951, 0.02981, -0.03384, 0.00647, -0.02581],
[0.058727, 0.016001, -0.06754, 0.04015, 0.09291, 2e-06, 0.077904, -0.031577, 0.01303, -0.01410, -0.01398, 0.05501],
[0.007121, 0.090749, 0.005842, -0.053581, -0.025732, 0.07017, -0.018745, -0.09456, -0.05945, -0.06571, 0.06871, 0.00411]
], dtype=float)

self.wf = np.array([
[-0.084738, 0.055984, -0.012318, 0.044693, 0.065598, 0.007089, 0.000224, -0.06559, -0.04612, -7.3e-05, 0.03686, 0.06116],
[-0.023812, -0.086313, -0.042371, 0.081919, -0.057323, -0.009575, 0.086241, -0.05902, 0.03011, 0.00626, -0.05909, 0.00688],
[0.081826, -0.073366, 0.004863, 0.050082, 0.033803, -0.005449, -0.05630, -0.00347, -0.02532, -0.0456, -0.02682, 0.03758],
[0.05373, -0.037201, 0.014525, -0.04479, -0.009431, -0.029404, 0.03148, -0.02329, -0.03618, 0.03586, -0.01707, 0.01834],
[-0.06391, 0.048224, -0.015252, -0.014709, 0.028876, 0.004581, -0.017023, -0.09715, -0.03168, 0.04157, 0.04680, 0.05221]
], dtype=float)

self.wo = np.array([
[0.022434, -0.066186, -0.012788, 0.053852, -0.040935, -0.070167, -0.05504, -0.01525, -0.05224, -0.05249, 0.03916, -0.05965],
[-0.083761, 0.03392, 0.024249, -0.045149, -0.006756, -0.076326, -0.085208, 0.08015, 0.05878, 0.06814, 0.05341, 0.06931],
[0.015455, 0.062753, -0.015736, -0.09451, -0.009173, -0.079835, 0.063444, 0.039546, 0.03367, -0.05155, 0.09695, 0.07272],
[0.023083, -0.002993, -0.015995, 0.04557, -0.035437, -0.019891, -0.039207, 0.08944, 0.08376, 0.06708, -0.09135, 0.06871],
[0.090088, 0.061318, -0.003744, 0.093352, -0.016804, -0.036232, -0.096711, -0.05294, -0.06852, -0.01468, -0.03823, -0.06719]
], dtype=float)

# bias terms
self.bg = np.array([-0.017119, -0.010762, -0.01027, -0.075269, -0.065529], dtype=float)
self.bi = np.array([0.075116, 0.059407, 0.049271, -0.074094, 0.054991], dtype=float)
self.bf = np.array([0.018351, -0.01307, -0.014564, 0.009966, 0.066618], dtype=float)
self.bo = np.array([-0.054807, -0.077083, -0.014593, 0.047107, 0.007309], dtype=float)

class LstmState:
def __init__(self, mem_cell_ct, x_dim):
self.g = np.zeros(mem_cell_ct, dtype=float)
self.i = np.zeros(mem_cell_ct, dtype=float)
self.f = np.zeros(mem_cell_ct, dtype=float)
self.o = np.zeros(mem_cell_ct, dtype=float)
self.s = np.zeros(mem_cell_ct, dtype=float)
self.h = np.zeros(mem_cell_ct, dtype=float)

class LstmNode:
def __init__(self, lstm_param, lstm_state):
# store reference to parameters and to activations
self.state = lstm_state
self.param = lstm_param
# non-recurrent input concatenated with recurrent input
self.xc = None

class LstmNetwork():
def __init__(self, lstm_param):
self.lstm_param = lstm_param
self.lstm_node_list = []
# input sequence
self.x_list = []

def x_list_clear(self):
self.x_list = []

def x_list_add(self, x):
self.x_list.append(x)

def forward(self):
mem_cell_ct = self.lstm_param.mem_cell_ct
h_prev = np.zeros(mem_cell_ct, dtype=float)
s_prev = np.zeros(mem_cell_ct, dtype=float)
h_list = []

for t in range(len(self.x_list)):
x = self.x_list[t]
xc = np.hstack((x, h_prev))

g = np.tanh(np.dot(self.lstm_param.wg, xc) + self.lstm_param.bg)
i = sigmoid(np.dot(self.lstm_param.wi, xc) + self.lstm_param.bi)
f = sigmoid(np.dot(self.lstm_param.wf, xc) + self.lstm_param.bf)
o = sigmoid(np.dot(self.lstm_param.wo, xc) + self.lstm_param.bo)

s = f * s_prev + i * g
h = o * np.tanh(s)

h_list.append(h.copy())
h_prev = h
s_prev = s

return h_list

def format_float(x):
s = f"{x:.3f}"
if '.' in s:
s = s.rstrip('0').rstrip('.')
if s == '' or s == '-0':
return '0.0'
if '.' not in s:
s += '.0'
return s

def func():
data = list(map(float, input().split()))
seq_len = int(data[0])
x_dim = int(data[1])
vals = data[2:]
x_list = np.array(vals, dtype=float).reshape(seq_len, x_dim)

mem_cell_ct = 5
lstm_param = LetterParam(mem_cell_ct, x_dim)
lstm_net = LstmNetwork(lstm_param)

for i in range(seq_len):
lstm_net.x_list_add(x_list[i])

h_list = lstm_net.forward()
first_elems = [h[0] for h in h_list]
formatted = [format_float(x) for x in first_elems]
print(' '.join(formatted))

if __name__ == "__main__":
func()

---

### 第3题-无线网络频段最优利用率评估（P3878）
- 链接：https://codefun2000.com/p/P3878

> 页面标题：#P3878. 第3题-无线网络频段最优利用率评估

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在 5G5G5G 网络规划中，运营商需要评估不同频段组合的资源利用率。每个频段有一个特定的带宽质量评分(数值越大表示质量越好)。当多个连续频段被组合使用时，它们的整体利用率由「组合质量系数」决定，该系数等于组合中最差频段的质量评分乘以组合的频段数量。
作为网络优化工程师，你需要计算所有可能的连续频段组合的利用率，找出其中最大的「组合质量系数」，从而确定最优的频段分配方案。
问题定义
给定一个整数数组 numsnumsnums ，表示一系列连续频段的质量评分。计算所有可能的连续非空频段组合的「组合质量系数」，并返回其中的最大值。
连续非空频段组合：指一组连续的频段，例如频段质量序列 [1,2,3][1,2,3][1,2,3] 的组合包括：
[1]、[2]、[3][1]、[2]、[3][1]、[2]、[3]
[1,2]、[2,3][1,2]、[2,3][1,2]、[2,3]
[1,2,3][1,2,3][1,2,3]
组合质量系数：该组合中最低质量评分乘以频段数量。
输入描述
第 111 行：整数 nnn ，表示频段数量 (1≤n≤10000)(1≤n≤10000)(1≤n≤10000) 。
第 222 ~ n+1n+1n+1 行：nnn 个整数，表示每个频段的质量评分 (1≤nums[i]≤10000)(1≤nums[i]≤10000)(1≤nums[i]≤10000) 。
输出描述
一个整数，表示所有组合中最大的「组合质量系数」。
样例1
输入
2
1
2

输出
2

说明
组合 [1]→[1] →[1]→ 系数 =1×1=1=1×1=1=1×1=1
组合 [2]→[2]→[2]→ 系数 =2×1=2=2×1=2=2×1=2
组合 [1,2]→[1,2]→[1,2]→ 最低质量 =1=1=1 ，频段数 =2→=2→=2→ 系数 =1×2=2=1×2=2=1×2=2
最大系数为 222 ，来自 [2][2][2] 或 [1,2][1,2][1,2] 。
样例2
输入
3
5
3
4

输出
9

说明
组合 [5]→[5]→[5]→ 最低质量 =5=5=5 ，频段数 =1→=1→=1→ 系数 =5×1=5=5×1=5=5×1=5
组合 [5,3]→[5,3]→[5,3]→ 最低质量 =3=3=3 ，频段数 =2→=2→=2→ 系数 =3×2=6=3×2=6=3×2=6
组合 [5,3,4]→[5,3,4]→[5,3,4]→ 最低质量 =3=3=3 ，频段数 =3→=3→=3→ 系数 =3×3=9=3×3=9=3×3=9
组合 [3]→[3]→[3]→ 最低质量 =3=3=3 ，频段数 =1→=1→=1→ 系数 =3×1=3=3×1=3=3×1=3
组合 [3,4]→[3,4]→[3,4]→ 最低质量 =3=3=3 ，频段数 =2→=2→=2→ 系数 =3×2=6=3×2=6=3×2=6
组合 [4]→[4]→[4]→ 最低质量 =4=4=4 ，频段数 =1→=1→=1→ 系数 =4×1=4=4×1=4=4×1=4
最大系数为 999 ，来自组合 [5,3,4][5,3,4][5,3,4] 。

#### TextSol

解题思路
给定长度为 n 的正整数数组 nums，表示各连续频段的质量评分。
对任意一个连续非空子数组（组合），其「组合质量系数」定义为：
该组合内的最小质量评分 × 组合长度。
目标是求所有组合中该值的最大值。
这是经典问题：对每个元素把它当作组合中的最小值，尽量向左、向右扩展，直到遇到更小的元素为止。
这样该元素可主导的最大组合长度 = right[i] - left[i] - 1，其中：

left[i]：i 左侧最近的 严格小于 nums[i] 的位置（没有则为 -1）
right[i]：i 右侧最近的 小于等于 nums[i] 的位置（没有则为 n）

上述边界可用**单调栈（递增栈）**在 O(n) 时间内求出：

从左到右维护“严格递增”栈，得到 left[i]
从右到左维护“非严格递增”（> 弹栈）得到 right[i]

随后枚举每个 i，计算面积（质量系数）：
area = nums[i] * (right[i] - left[i] - 1)，取最大即可。
这与“柱状图中最大的矩形面积”是同一思路。
复杂度分析

时间复杂度：O(n)，每个元素最多进栈出栈一次。
空间复杂度：O(n)，需要 left、right 数组与单调栈。

代码实现
Python
# 题面功能放在外部函数，主函数只负责输入输出

from typing import List

def max_quality(nums: List[int]) -> int:
n = len(nums)
left = [-1] * n   # 左边最近的严格更小元素位置
right = [n] * n   # 右边最近的小于等于元素位置

# 单调递增栈（存下标），用于求 left（严格小于）
stack = []
for i in range(n):
# 保证栈顶元素对应值 < nums[i]
while stack and nums[stack[-1]] >= nums[i]:
stack.pop()
left[i] = stack[-1] if stack else -1
stack.append(i)

# 清空栈，反向求 right（小于等于）
stack.clear()
for i in range(n - 1, -1, -1):
# 使得下一个不满足 > 的位置为 right（即 <=）
while stack and nums[stack[-1]] > nums[i]:
stack.pop()
right[i] = stack[-1] if stack else n
stack.append(i)

ans = 0
for i in range(n):
width = right[i] - left[i] - 1
area = nums[i] * width
if area > ans:
ans = area
return ans

if __name__ == "__main__":
# ACM 风格输入：第一行 n，接着 n 行为各评分
import sys
data = sys.stdin.read().strip().split()
n = int(data[0])
nums = list(map(int, data[1:1+n]))
print(max_quality(nums))

Java
// 类名必须为 Main，ACM 风格从标准输入读取
import java.util.*;

public class Main {

// 外部函数：计算最大组合质量系数
public static int maxQuality(int[] nums) {
int n = nums.length;
int[] left = new int[n];   // 左侧最近严格更小的位置
int[] right = new int[n];  // 右侧最近小于等于的位置
Arrays.fill(left, -1);
Arrays.fill(right, n);

// 单调递增栈（存下标），用于求 left（严格小于）
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
// 保证栈内对应值严格递增
while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {
stack.pop();
}
left[i] = stack.isEmpty() ? -1 : stack.peek();
stack.push(i);
}

// 清栈，反向求 right（小于等于）
stack.clear();
for (int i = n - 1; i >= 0; i--) {
// 弹出所有 > nums[i] 的元素，保留 <= 的第一个作为边界
while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {
stack.pop();
}
right[i] = stack.isEmpty() ? n : stack.peek();
stack.push(i);
}

int ans = 0;
for (int i = 0; i < n; i++) {
int width = right[i] - left[i] - 1;
int area = nums[i] * width; // 质量系数
if (area > ans) ans = area;
}
return ans;
}

public static void main(String[] args) {
// 数据范围不大，直接使用 Scanner
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[] nums = new int[n];
for (int i = 0; i < n; i++) nums[i] = sc.nextInt();
System.out.println(maxQuality(nums));
}
}

C++
// ACM 风格：标准输入输出，函数外实现核心逻辑
#include <bits/stdc++.h>
using namespace std;

// 计算最大组合质量系数
int max_quality(const vector<int>& nums) {
int n = (int)nums.size();
vector<int> left(n, -1);  // 左侧最近严格更小
vector<int> right(n, n);  // 右侧最近小于等于
vector<int> st;

// 求 left：维护单调递增栈（值严格递增）
for (int i = 0; i < n; ++i) {
while (!st.empty() && nums[st.back()] >= nums[i]) st.pop_back();
left[i] = st.empty() ? -1 : st.back();
st.push_back(i);
}

// 清空栈，反向求 right：找到第一个 <= 的位置
st.clear();
for (int i = n - 1; i >= 0; --i) {
while (!st.empty() && nums[st.back()] > nums[i]) st.pop_back();
right[i] = st.empty() ? n : st.back();
st.push_back(i);
}

long long ans = 0;
for (int i = 0; i < n; ++i) {
long long width = right[i] - left[i] - 1;
long long area = 1LL * nums[i] * width; // 质量系数
if (area > ans) ans = area;
}
return (int)ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n;
if (!(cin >> n)) return 0;
vector<int> nums(n);
for (int i = 0; i < n; ++i) cin >> nums[i];
cout << max_quality(nums) << "\n";
return 0;
}

---

### 第3题-最大客户数（P3869）
- 链接：https://codefun2000.com/p/P3869

> 页面标题：#P3869. 第3题-最大客户数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

业务背景：
假设你是一家云服务提供商的工程师，负责优化云资源的分配。公司有多个数据中心，每个数据中心有不同数量的服务器。现在有一些新的客户需要分配服务器资源。每个客户对服务器的需求量不同，而每个数据中心的服务器数量有限。你的任务是尽可能满足更多客户的需求，要求：同一个数据中心的服务器可以分配给多个客户使用，一个客户的需求只能分配到其中一个数据中心。
问题:
给定一个列表 datadatadata_centerscenterscenters，表示每个数据中心的服务器数量，和一个列表 customercustomercustomer _requestsrequestsrequests，表示每个客户的服务器需求量。你需要设计一个算法，将客户分配到不同的数据中心，使得满足客户需求的数量最大。
输入描述
输入四行：
第一行是一个整数，表示数据中心大小
第二行为一个数组，表示每个数据中心的服务器数量，用空格分割
第三行是一个整数，表示客户总数
第四行为一个数组，表示每个客户的服务器需求量，用空格分割
输入范围：
1<=len(data1<= len(data1<=len(data_centers)<=1000centers) <= 1000centers)<=1000
1<=len(customer1<= len(customer1<=len(customer_requests)<=1000requests)<=1000requests)<=1000
1<=data1<=data1<=data_centers[i]<=10000centers[i]<= 10000centers[i]<=10000
1<=customer1<= customer1<=customer_requests[i]<=10000requests[i]<= 10000requests[i]<=10000
输出描述
一个整数，表示最多可以满足的客户数量。
如果所有客户都不满足需求，则返回客户数为 000 。
样例1
输入
3
1 2 3
3
100 2 300

输出
1

说明
在这个样例中，每个数据中心的服务器数量都非常少，分别为 1、21、21、2 和 333 台而每个客户的需求量，分别为 100、2100、2100、2 和 300300300 台服务器
只能能够满足一个客户的需求，输出为 111
样例2
输入
3
10 20 30
4
5 10 15 25

输出
4

说明
可以将需求为 555 的客户分配到第二个数据中心
将需求为 101010 的客户分配到第一个数据中心
将需求为 151515 的客户分配到第二个数据中心
将需求为 252525 的客户分配到第三个数据中心

#### TextSol

本题是NP-hard问题，无法在线性时间得到最优解。由于数据范围较大，题解给出近似解法First-Fit Decreasing。

解题思路
给定多个数据中心的服务器容量 data_centers[i]，以及多个客户的服务器需求 customer_requests[j]。一个客户必须完全放到同一个数据中心中，数据中心可以服务多个客户，只要总占用不超过其容量。目标是最大化能被完全服务的客户数量。
核心思路：
将客户按照需求从小到大排序，优先满足小需求；同时用一个“有序可更新的容器”保存当前各数据中心的“剩余容量”。对每个客户需求 r，在容器中找到最小的且≥r 的剩余容量（best-fit）。若找到：

把该容量取出，分配 r 后若仍有剩余 rest = cap - r，再把 rest 放回容器；
计数加一。
若找不到，跳过该客户。

相关算法与数据结构：

贪心（按需求升序 + 最小可行仓位分配，Best-Fit）
有序容器：C++ 用 multiset，Java 用 TreeMap（作为“有序多重集合”），Python 用排序列表 + bisect 二分插入/查找。

代码实现
Python
from bisect import bisect_left, insort

def max_customers(data_centers, customer_requests):
# 剩余容量有序表
remains = sorted(data_centers)
# 客户需求升序
reqs = sorted(customer_requests)
count = 0

for r in reqs:
# 找到第一个 >= r 的剩余容量位置（best-fit）
pos = bisect_left(remains, r)
if pos == len(remains):
# 没有数据中心能容纳该客户，跳过
continue
cap = remains.pop(pos)       # 取出该容量
rest = cap - r               # 分配后的剩余
if rest > 0:
insort(remains, rest)    # 仍有剩余则放回有序表
count += 1
return count

def main():
# 读取输入（四行）
n = int(input().strip())
data_centers = list(map(int, input().strip().split()))
m = int(input().strip())
customer_requests = list(map(int, input().strip().split()))
# 计算并输出
print(max_customers(data_centers, customer_requests))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {

static int maxCustomers(int[] dataCenters, int[] customerRequests) {
// TreeMap 作为“有序多重集合”：key = 剩余容量，value = 该容量出现次数
TreeMap<Integer, Integer> map = new TreeMap<>();
for (int cap : dataCenters) {
map.put(cap, map.getOrDefault(cap, 0) + 1);
}

Arrays.sort(customerRequests); // 客户需求升序
int count = 0;

for (int r : customerRequests) {
// 找到最小的 >= r 的容量
Integer key = map.ceilingKey(r);
if (key == null) {
// 无法满足该客户
continue;
}
// 使用该容量一次
int c = map.get(key);
if (c == 1) map.remove(key);
else map.put(key, c - 1);

int rest = key - r; // 分配后的剩余
if (rest > 0) {
map.put(rest, map.getOrDefault(rest, 0) + 1);
}
count++;
}
return count;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取输入（四行）
int n = Integer.parseInt(sc.nextLine().trim());
String[] a = sc.nextLine().trim().split("\\s+");
int[] dataCenters = new int[n];
for (int i = 0; i < n; i++) dataCenters[i] = Integer.parseInt(a[i]);

int m = Integer.parseInt(sc.nextLine().trim());
String[] b = sc.nextLine().trim().split("\\s+");
int[] customerRequests = new int[m];
for (int i = 0; i < m; i++) customerRequests[i] = Integer.parseInt(b[i]);

// 计算并输出
System.out.println(maxCustomers(dataCenters, customerRequests));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int max_customers(const vector<int>& data_centers, const vector<int>& customer_requests) {
multiset<int> ms;                    // 有序多重集合保存剩余容量
for (int x : data_centers) ms.insert(x);

vector<int> reqs = customer_requests;
sort(reqs.begin(), reqs.end());      // 客户需求升序

int cnt = 0;
for (int r : reqs) {
// 找到第一个 >= r 的容量（best-fit）
auto it = ms.lower_bound(r);
if (it == ms.end()) {
// 没有数据中心可以容纳该客户
continue;
}
int cap = *it;
ms.erase(it);                    // 取出该容量
int rest = cap - r;              // 分配后的剩余
if (rest > 0) ms.insert(rest);   // 仍有剩余则放回
cnt++;
}
return cnt;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读取输入（四行）
int n;
cin >> n;
vector<int> data_centers(n);
for (int i = 0; i < n; ++i) cin >> data_centers[i];

int m;
cin >> m;
vector<int> customer_requests(m);
for (int i = 0; i < m; ++i) cin >> customer_requests[i];

// 计算并输出
cout << max_customers(data_centers, customer_requests) << "\n";
return 0;
}

---

## 2025年10月10日(留学生)-AI岗

### 第2题-磁盘故障检测的特征工程（P3871）
- 链接：https://codefun2000.com/p/P3871

> 页面标题：#P3871. 第2题-磁盘故障检测的特征工程

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

输入是磁盘检测中使用的典型的 "SMARTSMARTSMART" 数据集的部分信息，请根据下面的特征工程，提取相关特征。
特征工程的处理过程如下：

读取输入数据：

从标准输入读取一行数据，将其拆分成一个浮点数列表。

计算统计特征指标：

对个数据特征，计算以下统计指标：

均值 (MeanMeanMean)：计算每列数据的平均值。

最大值 (MaxMaxMax)：找出每列中的最大值。

最小值 (MinMinMin)：找出每列中的最小值。

极差 (PtpPtpPtp)：计算每列的最大值与最小值之差。

标准差 (StdStdStd)：计算每列数据的标准差，反映数据的高程度。

方差 (VarVarVar)：计算每列数据的方差，反映数据的离散程度。

偏度 (SkewSkewSkew)：计算数据的偏度，反映数据分布的不对称性。

峰度 (KurtKurtKurt)：计算数据的峰度，反映数据分布的程度。
统计指标计算公式：
1.均值 (MeanMeanMean)：计算列据的平均值。
公式：means(summeans(summeans(sum ofofof allallall values)/numbervalues)/numbervalues)/number ofofof valuesvaluesvalues
2.最大值 (MaxMaxMax)：找出每列中的最大值。
3.最小值 (MinMinMin)：找出每列中的最小值。
4.极差 (PtpPtpPtp)：计算每列的最大值与最小值之差。
公式：ptp=max−minptp=max-minptp=max−min
5.标准差 (StdStdStd) ：计算每列数据的标准差，反映数据的离散程度。
公式：std=sqrt(variance)std=sqrt(variance)std=sqrt(variance)
6.方差 (VarVarVar)：计算每列数据的方差，反映数据的离散程度。
公式：variance=meanvariance = meanvariance=mean ofofof squaredsquaredsquared difierencesdifierencesdifierences fromfromfrom thethethe MeanMeanMean
7.偏度 (SkewSkewSkew)：计算数据的偏度，反映数据分布的不对称性。
公式：skewness=(sum((x−mean)3)/n)/std3skewness =(sum((x-mean)^3)/n) /std^3skewness=(sum((x−mean)3)/n)/std3
8.峰度 (KurtKurtKurt)：计算数据的峰度，反映数据分布的陡峭程度。
公式：kurtosis=(sum((x−mean)4)/n)/std4−3kurtosis=(sum((x-mean)^4)/n)/std^{4}-3kurtosis=(sum((x−mean)4)/n)/std4−3

输出结果：

将所有统计指标按顺序排列

输入描述
输入数据为一行，包含多个样本信息，其中米格样本是 191919 个浮点数，代表不同的存储设备指标。
每个样本的数据描述如下：
数据含义 说明
时间戳 UnixUnixUnix 时间戳(秒级或毫秒级)
容量 存储设备的总容量(字节)
已用容量 存储设备的已用容量(字节)
空闲容量 存储设备的空闲容量(字节)
读取操作计数 单位时间内完成的读取操作次数
写入操作计数 单位时间内完成的写入操作次数
读取吞吐量 读取数据的吞吐量(字节/秒)
写入吞吐量 写入数据的吞吐量(字节/秒)
读取延迟 读取操作的平均延迟(毫秒)
写入延迟 写入操作的平均延迟(毫秒)
读取错误计数 单位时间内发生的读取错误次数
写入错误计数 单位时间内发生的写入错误次数
硬盘温度 硬盘的当前温度(摄氏度)
转速 硬盘的转速 (RPM)(RPM)(RPM)
读取带宽 读取操作的带宽 (MB/s)(MB/s)(MB/s)
写入带宽 写入操作的带宽 (MB/s)(MB/s)(MB/s)
读取队列深度 读取操作的队列深度
写入队列深度 写入操作的队列
深度硬盘健康状态 硬盘的健康状态
输出描述
输出结果格式：
1、统计结果以一行输出，包含所有统计指标，按以下题序列，便用空格作为分隔符：
mean_0 max_0 min_0 ptp_0 std_0 var_0 skew_0 kurt 0 mean_1 max_1 min_1 ptp_1 std_1 var_1 skew_1 kurt_1... mean_18 max_18 min_18 ptp_18 std_18 var_18 skew_18 kurt_18
2、每个统计指标保留 222 位小数，便于阅读和理解。
样例1
输入
1623456000 1000000.0 800000.0 200000.0 100.0 200.0 500.0 1000.0 10.0 20.0 0.0 0.0 40.0 7200.0 50.0 100.0 5.0 10.0 0.0 1623456001 1000000.0 800000.0 200000.0 100.0 200.0 500.0 1000.0 10.0 20.0 0.0 0.0 40.0 7200.0 50.0 100.0 5.0 10.0 0.0 1623456002 1000000.0 800000.0 200000.0 100.0 200.0 500.0 1000.0 10.0 20.0 0.0 0.0 40.0 7200.0 50.0 100.0 5.0 10.0 0.0 1623456003 1000000.0 800000.0 200000.0 100.0 200.0 500.0 1000.0 10.0 20.0 0.0 0.0 40.0 7200.0 50.0 100.0 5.0 10.0 0.0 1623456004 1000000.0 800000.0 200000.0 100.0 200.0 500.0 1000.0 10.0 20.0 0.0 0.0 40.0 7200.0 50.0 100.0 5.0 10.0 0.0

输出
1623456002.00 1623456004.00 1623456000.00 4.00 1.41 2.00 0.00 -1.30 1000000.00 1000000.00 1000000.00 0.00 0.00 0.00 0.00 0.00 800000.00 800000.00 800000.00 0.00 0.00 0.00 0.00 0.00 200000.00 200000.00 200000.00 0.00 0.00 0.00 0.00 0.00 100.00 100.00 100.00 0.00 0.00 0.00 0.00 0.00 200.00 200.00 200.00 0.00 0.00 0.00 0.00 0.00 500.00 500.00 500.00 0.00 0.00 0.00 0.00 0.00 1000.00 1000.00 1000.00 0.00 0.00 0.00 0.00 0.00 10.00 10.00 10.00 0.00 0.00 0.00 0.00 0.00 20.00 20.00 20.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 40.00 40.00 40.00 0.00 0.00 0.00 0.00 0.00 7200.00 7200.00 7200.00 0.00 0.00 0.00 0.00 0.00 50.00 50.00 50.00 0.00 0.00 0.00 0.00 0.00 100.00 100.00 100.00 0.00 0.00 0.00 0.00 0.00 5.00 5.00 5.00 0.00 0.00 0.00 0.00 0.00 10.00 10.00 10.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00

说明
输入样本是 101010 个，每个样本的内容是 191919 列特征：样本 1−1-1− 特征 000 样本 2−2-2− 特征 222 ... 样本 111 特征 181818 样本 2−2-2− 特征 000 ... 样本 2−2-2− 特征 181818 ... 样本 10−10-10− 特征 000 样本 10−10-10− 特征 181818
输出是每个特征的度量值：特征 0−0-0− 均值 特征 0−0-0− 最大值 ... 特征 0−0-0− 峰度 特征 1−1-1− 均值 特征 1−1-1− 最大值 … 特征 1−1-1− 峰度 ... 特征 18−18-18− 均值 特征 18−18-18− 最大值 … 特征 18−18-18− 峰度
提示
输入样本解释：
1、实际用例中，输入无注释，仅数值
2、实际用例中，多个样本拼接成一行输入，用户需要自己隔离样本( 191919 个特征为一个样本)
输出结果解释：
1、实际输出中，仅需保留数值，(参考样例的输出解释)
2、结果显示小数点后 222 位

#### TextSol

解题思路

输入解析：从标准输入读取一整行（或多行拼接）数字序列。每 19 个数字为一个样本，共有 NNN 个样本。将数据按列重排，得到 19 列，每列长度为 NNN。

Python：优先尝试 literal_eval 解析为列表，失败则按空白分割；同时兼容逗号分隔。
C++/Java：读取整段文本，替换换行/逗号为空格后用输入流解析为 double。

统计指标（逐列计算，采用总体定义，即分母为 nnn）：

均值：μ=1n∑xi\mu=\frac{1}{n}\sum x_iμ=n1​∑xi​
最大值 / 最小值
极差：ptp=max⁡−min⁡\mathrm{ptp}=\max-\minptp=max−min
方差：σ2=1n∑(xi−μ)2\sigma^2=\frac{1}{n}\sum (x_i-\mu)^2σ2=n1​∑(xi​−μ)2
标准差：σ=σ2\sigma=\sqrt{\sigma^2}σ=σ2​
偏度（总体三阶标准化矩）：

峰度（Fisher过度峰度，均匀分布为负）

当 σ=0\sigma=0σ=0（整列常数）时，规定 skew=0、kurt=0。
输出：按列从 0 到 18，依次输出
mean_i max_i min_i ptp_i std_i var_i skew_i kurt_i，保留两位小数并以空格分隔。

复杂度分析

设样本数为 NNN，特征列数固定为 F=19F=19F=19。
时间复杂度：两趟扫描/列（先均值，再高阶矩）为 O(NF)O(NF)O(NF)，其中 FFF 常数，可视为 O(N)O(N)O(N)。
空间复杂度：除读入数据外，仅用常数级临时变量，O(1)O(1)O(1)（若按列临时拷贝，仍为 O(N)O(N)O(N) 以内）。

代码实现
Python
# -*- coding: utf-8 -*-
# 题意：从 stdin 读入若干浮点数，每 19 个为一条样本，按列计算 8 项总体统计量并输出两位小数。
import sys, math
from ast import literal_eval

COLS = 19

def compute_col_stats(col):
"""对单列数据计算 mean, max, min, ptp, std, var, skew, kurt（总体 & Fisher 过度峰度）"""
n = len(col)
# 基本量
s = sum(col)
mu = s / n
cmax = max(col)
cmin = min(col)
ptp = cmax - cmin
# 二/三/四阶中心矩
m2 = 0.0
m3 = 0.0
m4 = 0.0
for x in col:
d = x - mu
d2 = d * d
m2 += d2
m3 += d2 * d
m4 += d2 * d2
var = m2 / n
std = math.sqrt(var)
if std == 0.0:
skew = 0.0
kurt = 0.0
else:
skew = (m3 / n) / (std ** 3)
kurt = (m4 / n) / (std ** 4) - 3.0
return (mu, cmax, cmin, ptp, std, var, skew, kurt)

def main():
text = sys.stdin.read().strip()
nums = []
if not text:
print("")  # 无输入时输出空行
return
# 优先尝试 literal_eval（如输入为 Python 列表/嵌套列表）
parsed = None
try:
parsed = literal_eval(text)
except Exception:
parsed = None

if isinstance(parsed, (list, tuple)):
# 可能是嵌套列表，做扁平化
def flat(it):
for v in it:
if isinstance(v, (list, tuple)):
for u in flat(v):
yield float(u)
else:
yield float(v)
nums = list(flat(parsed))
else:
# 兼容逗号/换行/多空格
text = text.replace(',', ' ')
for tok in text.split():
nums.append(float(tok))

# 计算样本数
if len(nums) % COLS != 0:
# 默认输入合法；这里宽容处理，截断到最近的整样本
total = (len(nums) // COLS) * COLS
nums = nums[:total]
n = len(nums) // COLS

# 按列计算
out = []
for j in range(COLS):
col = [nums[j + i * COLS] for i in range(n)]
out.extend(compute_col_stats(col))

# 按要求格式化输出（两位小数，空格分隔）
print(' '.join(f"{x:.2f}" for x in out))

if __name__ == "__main__":
main()

Java
// 题意：读取一行/多行数值，每19个为一条样本；逐列计算总体统计量并输出两位小数（ACM风格）。
import java.io.*;
import java.util.*;
import java.math.*;

public class Main {

// 计算单列统计（总体定义 & Fisher过度峰度）
static double[] stats(double[] col) {
int n = col.length;
double sum = 0.0, cmax = -Double.MAX_VALUE, cmin = Double.MAX_VALUE;
for (double v : col) {
sum += v;
if (v > cmax) cmax = v;
if (v < cmin) cmin = v;
}
double mu = sum / n;
double m2 = 0.0, m3 = 0.0, m4 = 0.0;
for (double v : col) {
double d = v - mu;
double d2 = d * d;
m2 += d2;
m3 += d2 * d;
m4 += d2 * d2;
}
double var = m2 / n;
double std = Math.sqrt(var);
double skew, kurt;
if (std == 0.0) {
skew = 0.0; kurt = 0.0;
} else {
skew = (m3 / n) / Math.pow(std, 3);
kurt = (m4 / n) / Math.pow(std, 4) - 3.0;
}
double ptp = cmax - cmin;
return new double[]{mu, cmax, cmin, ptp, std, var, skew, kurt};
}

public static void main(String[] args) throws Exception {
final int COLS = 19;
// 读入所有文本，替换逗号/换行为空格，再用流解析为 double
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringBuilder sbAll = new StringBuilder();
String line;
while ((line = br.readLine()) != null) {
sbAll.append(line).append(' ');
}
String raw = sbAll.toString().replace(',', ' ');
StringTokenizer st = new StringTokenizer(raw);
ArrayList<Double> list = new ArrayList<>();
while (st.hasMoreTokens()) {
list.add(Double.parseDouble(st.nextToken()));
}
int total = (list.size() / COLS) * COLS; // 宽容截断
double[] a = new double[total];
for (int i = 0; i < total; i++) a[i] = list.get(i);

int n = total / COLS;
StringBuilder out = new StringBuilder();
Locale.setDefault(Locale.US); // 确保小数点为'.'
for (int j = 0; j < COLS; j++) {
double[] col = new double[n];
for (int i = 0; i < n; i++) {
col[i] = a[i * COLS + j];
}
double[] r = stats(col);
for (int k = 0; k < r.length; k++) {
if (out.length() > 0) out.append(' ');
out.append(String.format(Locale.US, "%.2f", r[k]));
}
}
System.out.print(out.toString());
}
}

C++
// 题意：读取若干浮点数，每19个为一条样本；逐列计算总体统计量（skew 用总体三阶矩，kurt 为Fisher过度峰度）。
#include <bits/stdc++.h>
using namespace std;

static inline double normZero(double x) {
// 避免打印 -0.00
return (fabs(x) < 1e-12) ? 0.0 : x;
}

array<double,8> stats(const vector<double>& col) {
int n = (int)col.size();
double sum = 0.0, cmax = -1e308, cmin = 1e308;
for (double v : col) {
sum += v;
if (v > cmax) cmax = v;
if (v < cmin) cmin = v;
}
double mu = sum / n;
double m2 = 0.0, m3 = 0.0, m4 = 0.0;
for (double v : col) {
double d = v - mu;
double d2 = d * d;
m2 += d2;
m3 += d2 * d;
m4 += d2 * d2;
}
double var = m2 / n;
double stdv = sqrt(var);
double skew = 0.0, kurt = 0.0;
if (stdv != 0.0) {
skew = (m3 / n) / (stdv * stdv * stdv);
kurt = (m4 / n) / (stdv * stdv * stdv * stdv) - 3.0;
}
double ptp = cmax - cmin;
return {mu, cmax, cmin, ptp, stdv, var, skew, kurt};
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
const int COLS = 19;

// 读取所有内容，替换逗号/换行为空格，再二次解析
string all((istreambuf_iterator<char>(cin)), istreambuf_iterator<char>());
for (char& ch : all) {
if (ch == '\n' || ch == '\r' || ch == ',') ch = ' ';
}
istringstream iss(all);
vector<double> nums;
double x;
while (iss >> x) nums.push_back(x);

int total = (int)(nums.size() / COLS) * COLS; // 宽容截断至整样本
nums.resize(total);
int n = (total == 0) ? 0 : total / COLS;

vector<double> out; out.reserve(19 * 8);
cout.setf(std::ios::fixed);
cout << setprecision(2);

for (int j = 0; j < COLS; ++j) {
vector<double> col;
col.reserve(n);
for (int i = 0; i < n; ++i) col.push_back(nums[i * COLS + j]);
auto r = stats(col);
for (double v : r) {
if (!out.empty()) cout << ' ';
cout << fixed << setprecision(2) << normZero(v);
out.push_back(v); // 仅用于控制空格输出
}
}
return 0;
}

---

### 第3题-基于逻辑回归的意图分类器（P3872）
- 链接：https://codefun2000.com/p/P3872

> 页面标题：#P3872. 第3题-基于逻辑回归的意图分类器

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

意图分类是一种常见的 NLPNLPNLP 任多，现在需要实现一个基于逻辑回归的意图分类系统(二分类)。本系统的输入是一个已处理的特征序列，输出是意图标签 ( 000 或 111 )。请根据以下步骤实现该分类器：
1、数据预处理：对输入(特征序列，即仅包含大写字母 ABCDEFGABCDEFGABCDEFG 的序列)进行 one−hotone-hotone−hot 编码，编码时的特征顺序是 ABCDEFGABCDEFGABCDEFG；某个特征存在取 111 ，不存在取 000 ;
2、模型初始化：构造一个单层的训练网络，初始化权重 www 和偏置 bbb 初始化的值全部设为 000 ;
3、模型训练：使用 SigmoidSigmoidSigmoid 函数计算预测值，使用交叉熵损失函数训练，使用梯度下降算法更新参数；训练过程中使用训练数据进行训练，相关超参数为：学习率 0.10.10.1，训练轮数 202020 ，batchbatchbatch 大小为 111 ;
（1）SigmoidSigmoidSigmoid 函数公式:
σ(z)=11+e−zσ(z)=\frac{1}{1+e^{-z}}σ(z)=1+e−z1​ ，其中 z=w⋅x+bz=w·x+bz=w⋅x+b （ xxx 为输入特征向量）。
4.模型预测：对测试数据进行预测，首先使用 sigmoidsigmoidsigmoid 函数计算预测值，然后做二值化处理(大于 0.50.50.5 认为是类别 111 ，否则是类别 000 )
输入描述
第一行输入 NNN 和 M，N(10<=N<=100)M，N(10<=N<=100)M，N(10<=N<=100) 表示训练数据条数，M(2<=M<=10)M(2<=M<=10)M(2<=M<=10) 表示测试数据条数；
接下来 NNN 行是训练数据，每行包含两部分内容(空格隔开)，即代表输入的特征序列(由大写字母 ABCDEFGABCDEFGABCDEFG 构成的字符串，长度范围是 [3,7][3,7][3,7] )和该条数据的意图标签(使用数字 000 或 111 表示)；
在接下来 MMM 行是测试数据的特征序列。
输出描述
输出有 MMM 行，每行是测试输出，即用数字 000 或 111 表示的意图标签。
样例1
输入
10 2
CBG 0
AFE 0
FGD 1
BFG 0
BBA 0
BDD 0
BEG 1
EGE 0
CAF 0
DGD 1
DBA
DAD

输出
0
0

说明
该样例有 101010 条训练数据，222 条测试数据，222 个测试输出均 000
样例2
输入
10 3
GDEE 0
BDFEA 1
BDFE 0
GECD 0
DDCEE 1
ADA 0
EECBC 0
BACBC 1
DDD 1
FEEEE 0
AADC
BBAE
ECEC

输出
1
0
0

说明
该样例有 101010 条训练数据，333 条测试数据，测试输出分别为 1、0、01、0、01、0、0 。

#### TextSol

解题思路

将每条样本的“特征序列”看成由大写字母 A~G 组成的集合。按固定顺序 A B C D E F G 做 one-hot 编码：只要某个字母在序列中出现（次数不计），对应位置记为 1，否则为 0，得到长度为 7 的特征向量。
训练一个单层逻辑回归（Logistic Regression） 分类器：
预测值 p = sigmoid(w·x + b)；损失函数采用交叉熵；用**梯度下降（SGD，batch=1）**更新参数。题面给定超参：学习率 0.1，训练轮数 20，初始 w、b 全为 0。
预测阶段：对测试数据计算 p，阈值 0.5 二值化，p>0.5 输出 1，否则输出 0。
读入格式：第一行 N M；接着 N 行为训练样本（“字符串 标签”）；之后 M 行为仅含字符串的测试样本；输出 M 行预测标签。

复杂度分析

设训练样本数为 N、特征维度为 d=7、轮数为 E=20。

时间复杂度：O(E * N * d)，题目范围下极小。
空间复杂度：O(d)，仅存放权重与一个样本向量。

代码实现
Python
# -*- coding: utf-8 -*-
# 逻辑回归 + one-hot(A~G) 的ACM风格实现
import sys, math

# 将字母串编码为长度7的one-hot（出现即1，不计次数）
def encode(seq):
x = [0.0] * 7
seen = set(seq.strip())
for ch in seen:
idx = ord(ch) - ord('A')
if 0 <= idx < 7:
x[idx] = 1.0
return x

# 训练：SGD，交叉熵损失，学习率0.1，轮数20
def train(X, y, lr=0.1, epochs=20):
w = [0.0] * 7
b = 0.0
for _ in range(epochs):
for xi, yi in zip(X, y):
z = sum(w[j] * xi[j] for j in range(7)) + b
p = 1.0 / (1.0 + math.exp(-z))
dz = p - yi  # 交叉熵对z的导数
# 参数更新（batch=1）
for j in range(7):
w[j] -= lr * dz * xi[j]
b -= lr * dz
return w, b

# 预测：p>0.5 -> 1，否则0
def predict(w, b, xi):
z = sum(w[j] * xi[j] for j in range(7)) + b
p = 1.0 / (1.0 + math.exp(-z))
return 1 if p > 0.5 else 0

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
N = int(next(it)); M = int(next(it))

X, y = [], []
# 读取N条训练数据
for _ in range(N):
seq = next(it)
label = int(next(it))
X.append(encode(seq))
y.append(label)

# 训练
w, b = train(X, y, lr=0.1, epochs=20)

# 读取并预测M条测试数据
outs = []
for _ in range(M):
seq = next(it)
xi = encode(seq)
outs.append(str(predict(w, b, xi)))

print("\n".join(outs))

if __name__ == "__main__":
main()

Java
// 逻辑回归 + one-hot(A~G) 的ACM风格实现
import java.util.*;

public class Main {

// 全局参数
static double[] w = new double[7]; // 权重
static double b = 0.0;             // 偏置

// 将字母串编码为长度7的one-hot（出现即1，不计次数）
static double[] encode(String s) {
double[] x = new double[7];
boolean[] seen = new boolean[7];
for (int i = 0; i < s.length(); i++) {
char c = s.charAt(i);
int idx = c - 'A';
if (0 <= idx && idx < 7) seen[idx] = true;
}
for (int i = 0; i < 7; i++) x[i] = seen[i] ? 1.0 : 0.0;
return x;
}

// 训练：SGD，交叉熵损失，学习率0.1，轮数20
static void train(ArrayList<double[]> X, ArrayList<Integer> Y) {
double lr = 0.1;
int epochs = 20;
Arrays.fill(w, 0.0);
b = 0.0;
for (int ep = 0; ep < epochs; ep++) {
for (int i = 0; i < X.size(); i++) {
double[] xi = X.get(i);
int yi = Y.get(i);
double z = b;
for (int j = 0; j < 7; j++) z += w[j] * xi[j];
double p = 1.0 / (1.0 + Math.exp(-z));
double dz = p - yi; // 交叉熵对z的导数
for (int j = 0; j < 7; j++) {
w[j] -= lr * dz * xi[j];
}
b -= lr * dz;
}
}
}

// 预测：p>0.5 -> 1，否则0
static int predict(double[] xi) {
double z = b;
for (int j = 0; j < 7; j++) z += w[j] * xi[j];
double p = 1.0 / (1.0 + Math.exp(-z));
return p > 0.5 ? 1 : 0;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNext()) return;
int N = sc.nextInt();
int M = sc.nextInt();

ArrayList<double[]> X = new ArrayList<>();
ArrayList<Integer> Y = new ArrayList<>();

// 读取N条训练数据
for (int i = 0; i < N; i++) {
String seq = sc.next();
int label = sc.nextInt();
X.add(encode(seq));
Y.add(label);
}

// 训练
train(X, Y);

// 读取并预测M条测试数据
StringBuilder sb = new StringBuilder();
for (int i = 0; i < M; i++) {
String seq = sc.next();
int pred = predict(encode(seq));
sb.append(pred).append('\n');
}
System.out.print(sb.toString());
sc.close();
}
}

C++
// 逻辑回归 + one-hot(A~G) 的ACM风格实现
#include <bits/stdc++.h>
using namespace std;

vector<double> wgt(7, 0.0); // 权重
double bias = 0.0;          // 偏置

// 将字母串编码为长度7的one-hot（出现即1，不计次数）
vector<double> encode(const string& s) {
vector<double> x(7, 0.0);
vector<int> seen(7, 0);
for (char c : s) {
int idx = c - 'A';
if (0 <= idx && idx < 7) seen[idx] = 1;
}
for (int i = 0; i < 7; ++i) x[i] = seen[i] ? 1.0 : 0.0;
return x;
}

// 训练：SGD，交叉熵损失，学习率0.1，轮数20
void train(const vector<vector<double>>& X, const vector<int>& y) {
double lr = 0.1;
int epochs = 20;
fill(wgt.begin(), wgt.end(), 0.0);
bias = 0.0;
for (int ep = 0; ep < epochs; ++ep) {
for (int i = 0; i < (int)X.size(); ++i) {
const vector<double>& xi = X[i];
int yi = y[i];
double z = bias;
for (int j = 0; j < 7; ++j) z += wgt[j] * xi[j];
double p = 1.0 / (1.0 + exp(-z));
double dz = p - yi; // 交叉熵对z的导数
for (int j = 0; j < 7; ++j) wgt[j] -= lr * dz * xi[j];
bias -= lr * dz;
}
}
}

// 预测：p>0.5 -> 1，否则0
int predict(const vector<double>& xi) {
double z = bias;
for (int j = 0; j < 7; ++j) z += wgt[j] * xi[j];
double p = 1.0 / (1.0 + exp(-z));
return (p > 0.5) ? 1 : 0;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, M;
if (!(cin >> N >> M)) return 0;

vector<vector<double>> X;
vector<int> Y;

// 读取N条训练数据
for (int i = 0; i < N; ++i) {
string seq; int label;
cin >> seq >> label;
X.push_back(encode(seq));
Y.push_back(label);
}

// 训练
train(X, Y);

// 读取并预测M条测试数据
for (int i = 0; i < M; ++i) {
string seq; cin >> seq;
cout << predict(encode(seq)) << "\n";
}
return 0;
}

---

## 2025年9月28日-AI方向

### 第2题-Yolo检测器中的anchor聚类（P3842）
- 链接：https://codefun2000.com/p/P3842

> 页面标题：#P3842. 第2题-Yolo检测器中的anchor聚类

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

【背景信息】YOLO (You Only Look Once) 系列算法在目标检测领域采用了基于Anchor的机制。Anchor是预定义在图像上的一组固定尺寸和比例的参考框，在特征图的每个位置上预设多个Anchor框作为物体位置和尺寸预测的基准。通过模型预测Anchor与真实框的偏移量(Δx,Δy,Δw,Δh)(\Delta x, \Delta y, \Delta w, \Delta h)(Δx,Δy,Δw,Δh)，而非直接输出坐标，避免了直接回归绝对坐标的困难。
【任务目标】
基于k-means聚类算法生成YOLO目标检测中的Anchor框：给定NNN个检测框的宽和高，聚类得到KKK个Anchor尺寸，并按照面积从大到小的顺序输出Anchor尺寸。
【任务目标】
基于k-means聚类算法生成YOLO目标检测中的Anchor框：给定NNN个检测框的宽和高，聚类得到KKK个Anchor尺寸，并按照面积从大到小的顺序输出Anchor尺寸。
聚类的流程如下：
初始化：为保证聚类结果的稳定性，采用稳定初始化策略，直接取前KKK个框作为初始中心。
分配阶段：计算每个框到所有聚类中心的距离，分配到最近的中心。
更新阶段：计算每个簇中所有框的宽高均值作为新的聚类中心（在每次迭代计算聚类中心时，均进行向下取整）。
迭代终止条件：当达到设定迭代次数T或新旧聚类中心之间的ddd值之和小于1e-4时停止迭代。
注：聚类使用 d=1−IOUd = 1 - IOUd=1−IOU 作为距离度量，ddd和IOUIOUIOU的计算均使用浮点数。
其中IOUIOUIOU的核心公式为交并面积比，即
IOU=交集面积并集面积IOU = \frac{\text{交集面积}}{\text{并集面积}}
IOU=并集面积交集面积​
对于检测框B1(w1,h1)B1(w_1,h_1)B1(w1​,h1​) 和 B2(w2,h2)B2(w_2,h_2)B2(w2​,h2​)，交集面积计算为：
$$intersection = \min(w_1, w_2) \times \min(h_1, h_2)$$并集面积则为两框总面积减去交集：
$$union = w_1 \times h_1 + w_2 \times h_2 - intersection$$最终：IOU = intersection/(union + 1e-16) (加极小值避免除零)
输入描述
第一行：N,K,TN, K, TN,K,T，以空格分开。
其中：

NNN 为训练集中检测框的个数，10≤N≤8010 \leq N \leq 8010≤N≤80

KKK 为聚类中心个数，3≤K≤93 \leq K \leq 93≤K≤9

TTT 为聚类迭代次数，2≤T≤302 \leq T \leq 302≤T≤30

接下来 NNN 行：每行为检测框的宽与高，用空格分开。
输出描述
按照聚类中心的面积从大到小的顺序，输出聚类后的中心。
（聚类中心的面积 = 聚类中心的宽 ×\times× 聚类中心的高）
样例1
输入
12 4 20
12 23
34 21
43 23
199 23
34 23
108 12
200 107
12 78
123 110
34 23
56 48
78 66

输出
133 94
121 27
36 22
12 50

说明

输入第一行为 12  4  2012 \; 4 \; 2012420，代表12个检测框，要聚成4类，最大迭代次数为20，接下来的12行是检测框的宽与高。

取前4个框 [12,23],[34,21],[43,23],[199,23][12, 23], [34, 21], [43, 23], [199, 23][12,23],[34,21],[43,23],[199,23] 作为初始聚类中心。

迭代更新计算聚类中心，注意每次迭代时聚类中心都做向下取整。

按照聚类中心的面积（宽 × 高）从大到小排序，输出4个Anchor聚类中心。

样例2
输入
12 3 10
12 23
34 21
43 23
199 23
34 23
108 12
200 107
12 78
123 110
34 23
56 48
78 66

输出
150 76
51 25
12 50

说明

输入第一行为 12  3  1012 \; 3 \; 1012310，代表12个检测框，要聚成3类，最大迭代次数为10，接下来的12行是检测框的宽与高。

取前3个框 [12,23],[34,21],[43,23][12, 23], [34, 21], [43, 23][12,23],[34,21],[43,23] 作为初始聚类中心。

迭代更新计算聚类中心，注意每次迭代时聚类中心都做向下取整。

按照聚类中心的面积（宽 × 高）从大到小排序，输出3个Anchor聚类中心。

提示
注：每次迭代的距离度量 ddd 和交并比 IOUIOUIOU 都是用浮点数计算，但每次迭代和最终输出的聚类中心都要做向下取整。

▶️

#### TextSol

video solution

解题思路
本题要求用 K-means 在宽高空间对检测框进行聚类，以获得 YOLO 的 Anchor 尺寸。与欧氏距离不同，这里采用 d = 1 − IOU 作为距离度量，能更贴近目标检测中对宽高匹配的要求。
算法选择与要点

初始化（稳定初始化）：直接取前 K 个框作为初始聚类中心（宽、高）。

分配阶段：对每个样本框 (w,h)(w, h)(w,h) 计算到所有中心 (Wk,Hk)(W_k, H_k)(Wk​,Hk​) 的距离
d=1−IOU((w,h),(Wk,Hk))d = 1 - \text{IOU}((w,h),(W_k,H_k))
d=1−IOU((w,h),(Wk​,Hk​))
其中
$$\text{IOU}=\frac{\min(w,W_k)\cdot \min(h,H_k)}{w\cdot h + W_k\cdot H_k - \min(w,W_k)\cdot \min(h,H_k) + 1e-16}$$将样本分配给距离最小的簇。

更新阶段：对每个簇计算所有成员在宽、高上的均值并向下取整（floor），作为新的中心。如果某簇为空，则保留原中心不变。

终止条件：最多迭代 T 次；或当新旧中心配对的 d 值之和
$$\sum_{k=1}^{K} \left(1-\text{IOU}\big((W_k^{old},H_k^{old}),(W_k^{new},H_k^{new})\big)\right) < 1e-4$$时提前停止。

输出：将最终 K 个中心按面积（宽×高）从大到小排序输出。
注意：迭代中每次更新的中心与最终输出都要向下取整，但 IOU 与 d 的计算始终用浮点数（避免精度问题，分母加 1e−161e{-16}1e−16）。

该流程等价于在“宽高-IOU”空间上的 K-means 变体，常用于 Anchor 聚类以提升先验框与真实框的匹配度。
代码实现
Python
import sys
import math

# 计算两个宽高框的 IOU（基于宽高，无位置信息）
def iou_wh(w1, h1, w2, h2):
inter = min(w1, w2) * min(h1, h2)
union = w1 * h1 + w2 * h2 - inter
return inter / (union + 1e-16)

# 使用 d = 1 - IOU 的 K-means 聚类，返回最终中心（整数）
def kmeans_anchors(boxes, K, T):
# 初始化：取前 K 个框为初始中心（转为浮点便于计算）
centers = [(float(boxes[i][0]), float(boxes[i][1])) for i in range(K)]
n = len(boxes)

for _ in range(T):
# 分配阶段：为每个样本选择最近中心
assign = [0] * n
for i, (w, h) in enumerate(boxes):
best_k = 0
best_d = 1.0 - iou_wh(w, h, centers[0][0], centers[0][1])
for k in range(1, K):
d = 1.0 - iou_wh(w, h, centers[k][0], centers[k][1])
if d < best_d:
best_d = d
best_k = k
assign[i] = best_k

# 更新阶段：计算新中心（对均值向下取整）
sums = [[0.0, 0.0] for _ in range(K)]
cnts = [0] * K
for (w, h), k in zip(boxes, assign):
sums[k][0] += w
sums[k][1] += h
cnts[k] += 1

new_centers = []
for k in range(K):
if cnts[k] == 0:
# 空簇：保留原中心
new_centers.append((centers[k][0], centers[k][1]))
else:
W = math.floor(sums[k][0] / cnts[k])
H = math.floor(sums[k][1] / cnts[k])
new_centers.append((float(W), float(H)))

# 终止条件：新旧中心 d 值之和
change = 0.0
for k in range(K):
change += (1.0 - iou_wh(centers[k][0], centers[k][1], new_centers[k][0], new_centers[k][1]))
centers = new_centers
if change < 1e-4:
break

# 最终结果向下取整并按面积从大到小排序
final_centers = [(int(math.floor(w)), int(math.floor(h))) for (w, h) in centers]
final_centers.sort(key=lambda x: x[0] * x[1], reverse=True)
return final_centers

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
N = int(next(it)); K = int(next(it)); T = int(next(it))
boxes = []
for _ in range(N):
w = float(next(it)); h = float(next(it))
boxes.append((w, h))

centers = kmeans_anchors(boxes, K, T)
out = []
for w, h in centers:
out.append(f"{w} {h}")
print("\n".join(out))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

/* ACM 风格，读取输入，输出结果；核心逻辑放在静态函数里 */
public class Main {

// 计算宽高框的 IOU
static double iouWH(double w1, double h1, double w2, double h2) {
double inter = Math.min(w1, w2) * Math.min(h1, h2);
double union = w1 * h1 + w2 * h2 - inter;
return inter / (union + 1e-16);
}

// d = 1 - IOU 的 K-means 聚类
static int[][] kmeansAnchors(double[][] boxes, int K, int T) {
int N = boxes.length;
// 初始化：前 K 个样本
double[][] centers = new double[K][2];
for (int k = 0; k < K; k++) {
centers[k][0] = boxes[k][0];
centers[k][1] = boxes[k][1];
}

for (int t = 0; t < T; t++) {
int[] assign = new int[N];
// 分配阶段
for (int i = 0; i < N; i++) {
double w = boxes[i][0], h = boxes[i][1];
int bestK = 0;
double bestD = 1.0 - iouWH(w, h, centers[0][0], centers[0][1]);
for (int k = 1; k < K; k++) {
double d = 1.0 - iouWH(w, h, centers[k][0], centers[k][1]);
if (d < bestD) {
bestD = d;
bestK = k;
}
}
assign[i] = bestK;
}

// 更新阶段
double[] sumW = new double[K];
double[] sumH = new double[K];
int[] cnt = new int[K];
for (int i = 0; i < N; i++) {
int k = assign[i];
sumW[k] += boxes[i][0];
sumH[k] += boxes[i][1];
cnt[k]++;
}

double[][] newCenters = new double[K][2];
for (int k = 0; k < K; k++) {
if (cnt[k] == 0) {
// 空簇，保持不变
newCenters[k][0] = centers[k][0];
newCenters[k][1] = centers[k][1];
} else {
// 向下取整
double W = Math.floor(sumW[k] / cnt[k]);
double H = Math.floor(sumH[k] / cnt[k]);
newCenters[k][0] = W;
newCenters[k][1] = H;
}
}

// 终止条件：新旧中心 d 值之和
double change = 0.0;
for (int k = 0; k < K; k++) {
change += (1.0 - iouWH(centers[k][0], centers[k][1], newCenters[k][0], newCenters[k][1]));
}
centers = newCenters;
if (change < 1e-4) break;
}

// 最终向下取整并按面积降序
int[][] ans = new int[K][2];
for (int k = 0; k < K; k++) {
ans[k][0] = (int)Math.floor(centers[k][0]);
ans[k][1] = (int)Math.floor(centers[k][1]);
}

Integer[] idx = new Integer[K];
for (int i = 0; i < K; i++) idx[i] = i;
Arrays.sort(idx, new Comparator<Integer>() {
public int compare(Integer a, Integer b) {
long areaB = 1L * ans[b][0] * ans[b][1];
long areaA = 1L * ans[a][0] * ans[a][1];
return Long.compare(areaB, areaA); // 面积降序
}
});

int[][] sorted = new int[K][2];
for (int i = 0; i < K; i++) {
sorted[i][0] = ans[idx[i]][0];
sorted[i][1] = ans[idx[i]][1];
}
return sorted;
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
if (!sc.hasNext()) return;
int N = sc.nextInt();
int K = sc.nextInt();
int T = sc.nextInt();
double[][] boxes = new double[N][2];
for (int i = 0; i < N; i++) {
boxes[i][0] = sc.nextDouble();
boxes[i][1] = sc.nextDouble();
}
int[][] res = kmeansAnchors(boxes, K, T);
StringBuilder sb = new StringBuilder();
for (int i = 0; i < res.length; i++) {
sb.append(res[i][0]).append(" ").append(res[i][1]);
if (i + 1 < res.length) sb.append("\n");
}
System.out.print(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算两个宽高框的 IOU
double iouWH(double w1, double h1, double w2, double h2) {
double inter = min(w1, w2) * min(h1, h2);
double uni = w1 * h1 + w2 * h2 - inter;
return inter / (uni + 1e-16);
}

// d = 1 - IOU 的 K-means 聚类
vector<pair<int,int>> kmeansAnchors(const vector<pair<double,double>>& boxes, int K, int T) {
int N = (int)boxes.size();
// 初始化：前 K 个样本
vector<pair<double,double>> centers(K);
for (int k = 0; k < K; ++k) centers[k] = boxes[k];

for (int t = 0; t < T; ++t) {
// 分配阶段
vector<int> assign(N, 0);
for (int i = 0; i < N; ++i) {
double w = boxes[i].first, h = boxes[i].second;
int bestK = 0;
double bestD = 1.0 - iouWH(w, h, centers[0].first, centers[0].second);
for (int k = 1; k < K; ++k) {
double d = 1.0 - iouWH(w, h, centers[k].first, centers[k].second);
if (d < bestD) {
bestD = d;
bestK = k;
}
}
assign[i] = bestK;
}

// 更新阶段
vector<double> sumW(K, 0.0), sumH(K, 0.0);
vector<int> cnt(K, 0);
for (int i = 0; i < N; ++i) {
int k = assign[i];
sumW[k] += boxes[i].first;
sumH[k] += boxes[i].second;
cnt[k] += 1;
}
vector<pair<double,double>> newCenters(K);
for (int k = 0; k < K; ++k) {
if (cnt[k] == 0) {
// 空簇，保持不变
newCenters[k] = centers[k];
} else {
double W = floor(sumW[k] / cnt[k]);
double H = floor(sumH[k] / cnt[k]);
newCenters[k] = {W, H};
}
}

// 终止条件
double change = 0.0;
for (int k = 0; k < K; ++k) {
change += (1.0 - iouWH(centers[k].first, centers[k].second,
newCenters[k].first, newCenters[k].second));
}
centers.swap(newCenters);
if (change < 1e-4) break;
}

// 最终向下取整并按面积从大到小排序
vector<pair<int,int>> ans;
ans.reserve(K);
for (int k = 0; k < K; ++k) {
int W = (int)floor(centers[k].first);
int H = (int)floor(centers[k].second);
ans.emplace_back(W, H);
}
sort(ans.begin(), ans.end(), [](const pair<int,int>& a, const pair<int,int>& b){
long long A = 1LL * a.first * a.second;
long long B = 1LL * b.first * b.second;
if (A != B) return A > B;               // 面积降序
if (a.first != b.first) return a.first > b.first; // 次级规则（可选）
return a.second > b.second;
});
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, K, T;
if (!(cin >> N >> K >> T)) return 0;
vector<pair<double,double>> boxes(N);
for (int i = 0; i < N; ++i) {
cin >> boxes[i].first >> boxes[i].second;
}
auto centers = kmeansAnchors(boxes, K, T);
for (int i = 0; i < (int)centers.size(); ++i) {
cout << centers[i].first << " " << centers[i].second;
if (i + 1 < (int)centers.size()) cout << "\n";
}
return 0;
}

---

### 第2题-奖项设置（P3845）
- 链接：https://codefun2000.com/p/P3845

> 页面标题：#P3845. 第2题-奖项设置

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

部门准备了一批奖品用于举办抽奖活动，奖品的价值为给定的正整数数组 valuesvaluesvalues，其中 values[i]values[i]values[i] 表示第 iii 个奖品的价值。
每位获奖者可以选择不限个数最大价值 limitlimitlimit 的奖品组合，获奖者选择奖品的策略为在 limitlimitlimit 限制内优先选择单价最高的奖品，请计算最少可以设置多少个奖项；
输入描述
第一行：正整数 lenlenlen ，表述奖品价值数组 valuesvaluesvalues 的长度，1<=len<=1041<=len<=10^41<=len<=104 ；
第二行：正整数数组 valuesvaluesvalues，长度为 lenlenlen，其中 values[i]values[i]values[i] 表示第 iii 个奖品的价值，1<=values[i]<=1041<=values[i]<=10^41<=values[i]<=104 ；
第三行：正整数 limitlimitlimit ，表示每个获奖者可以获得的最大奖品价值，1<=limit<=1041<=limit<=10^41<=limit<=104 。
输出描述
整数，代表本次抽奖活动可以设置最少的奖项数量；
样例1
输入
2
1 2
3

输出
1

说明
获奖者选择价值为 111 和 222 的两个奖品，最少可以设置 111 个奖项
样例2
输入
7
13 4 4 3 3 5 5
12

输出
3

说明
获奖者 111 选取价值为 (5,5)(5,5)(5,5) 的奖品组合，获奖者 222 选取价值为 (4,4,3)、3(4,4,3)、3(4,4,3)、3 的奖品组合，因此：最少可以设置 333 个奖项才能满足所有获奖者的领取诉求

▶️

#### TextSol

video solution

解题思路

将每个“奖项”看成一个容量为 limit 的“箱子”，每个奖品是一件物品，价值即体积。

题目给定的获奖者策略是：在不超过 limit 的前提下优先选择价值最高的奖品并持续选择，直到无法再选。
这与我们按同样的规则把物品装进箱子完全一致，因此问题等价为：用“在剩余容量内每次放入当前能放的最大物品”的贪心规则进行装箱，所需箱子（奖项）的最少个数。

实现方法：

先对所有价值做计数并保持有序（如 multiset/TreeMap 或“排序 + 计数”）。
每开启一个奖项（箱子），设剩余容量 rem = limit；
反复在有序容器中查找 <= rem 的最大值（upper_bound/floorKey），取出一件、减少 rem，直到找不到可放的奖品；
计数 +1，继续下一奖项；
直到所有奖品被取完。

相关算法：贪心 + 有序多重集合（上/下界查找）。该策略与题目给定的选择规则一致，且总取件数为 n，每次查找/删除为 O(log U)（U 为不同价值的种类数），整体高效。

复杂度分析

排序/建表：O(n log n) 或 O(n + U log U)（使用计数+有序键）。
每件物品至多被查找并删除一次：O(n log U)。
总时间复杂度：O(n log n)（上界）。
空间复杂度：O(U)（存放不同价值的计数）。

代码实现
Python
# -*- coding: utf-8 -*-
# 题意功能放在外部函数里；主函数只负责输入输出（ACM 风格）
import sys
from bisect import bisect_right
from collections import Counter
import ast

def min_awards(values, limit):
"""
在每个奖项容量为 limit 的前提下，
每次在剩余容量内优先选择价值最高的奖品，问最少需要多少个奖项
"""
# 题面默认数据合法；若有大于 limit 的物品则无法放入，这里直接忽略/也可假定不存在
values = [v for v in values if v <= limit]
if not values:
return 0

cnt = Counter(values)                 # 统计每个价值出现次数
uniq = sorted(cnt.keys())             # 升序唯一值，配合 bisect 查找 <= rem 的最大值
total = len(values)
ans = 0

while total > 0:
rem = limit
while True:
# 找到 <= rem 的最大价值的下标
idx = bisect_right(uniq, rem) - 1
# 跳过计数为 0 的键
while idx >= 0 and cnt[uniq[idx]] == 0:
idx -= 1
if idx < 0:                   # 本奖项放不下更多
break
val = uniq[idx]
cnt[val] -= 1                 # 取出一件
total -= 1
rem -= val                    # 更新剩余容量
ans += 1                           # 开启下一个奖项

return ans

def main():
data = sys.stdin.read().strip().splitlines()
if not data:
return
n = int(data[0].strip())

# 第二行既可能是空格分隔的数字，也可能是 Python 列表；优先尝试 literal_eval
vals_line = data[1].strip()
values = None
try:
parsed = ast.literal_eval(vals_line)
# 若 literal_eval 得到的是单个数字或列表，统一转成列表
if isinstance(parsed, (list, tuple)):
values = [int(x) for x in parsed]
else:
values = [int(parsed)]
except Exception:
values = list(map(int, vals_line.split()))
# 只取前 n 个（若输入多给了）
values = values[:n]

limit = int(data[2].strip())
print(min_awards(values, limit))

if __name__ == "__main__":
main()

Java
// ACM 风格：类名 Main，主函数负责 IO，核心逻辑在外部静态函数中
import java.util.*;

public class Main {

// 在剩余容量内优先选择最大价值的贪心装箱
public static int solve(int[] a, int limit) {
// 使用 TreeMap 作为有序多重集合：key=价值, value=计数
TreeMap<Integer, Integer> map = new TreeMap<>();
int total = 0;
for (int v : a) {
if (v <= limit) { // 默认输入合法，若存在>limit，这里忽略
map.put(v, map.getOrDefault(v, 0) + 1);
total++;
}
}
if (total == 0) return 0;

int ans = 0;
while (total > 0) {
int rem = limit;
while (true) {
// floorKey(rem): 找到 <= rem 的最大键
Integer key = map.floorKey(rem);
if (key == null) break; // 本奖项装不进更多
// 取出一件
int c = map.get(key);
if (c == 1) map.remove(key);
else map.put(key, c - 1);
total--;
rem -= key;
}
ans++; // 开启下一个奖项
}
return ans;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 数据范围较小，默认不用快读
if (!sc.hasNextInt()) return;
int n = sc.nextInt();
int[] a = new int[n];
for (int i = 0; i < n; i++) a[i] = sc.nextInt();
int limit = sc.nextInt();
System.out.println(solve(a, limit));
sc.close();
}
}

C++
// ACM 风格：主函数读写，求解函数在外部
#include <bits/stdc++.h>
using namespace std;

// 使用 multiset 作为有序多重集合：每次取 <= rem 的最大值
int solve(vector<int>& a, int limit) {
multiset<int> ms;
for (int v : a) {
if (v <= limit) ms.insert(v); // 默认输入合法；若有 >limit 的奖品则忽略
}
if (ms.empty()) return 0;

int ans = 0;
while (!ms.empty()) {
int rem = limit;
while (true) {
// upper_bound(rem) 返回第一个 > rem 的迭代器，往前一步即 <= rem 的最大值
auto it = ms.upper_bound(rem);
if (it == ms.begin()) break; // 没有可放的
--it;                        // 取 <= rem 的最大值
rem -= *it;                  // 更新剩余容量
ms.erase(it);                // 删除该元素一份
}
ans++; // 一个奖项装满（或无法继续装）
}
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
if (!(cin >> n)) return 0;
vector<int> a(n);
for (int i = 0; i < n; ++i) cin >> a[i];
int limit;
cin >> limit;

cout << solve(a, limit) << "\n";
return 0;
}

---

### 第2题-关灯方案（P3794）
- 链接：https://codefun2000.com/p/P3794

> 页面标题：#P3794. 第2题-关灯方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

老旧小区需要关闭一排灯，由于接线混乱，按某个灯的开关时可能会同步影响多个灯的状态，被影响的灯的状态会发生反转，即：原先亮着的灯会关闭，而关的灯会打开。
已知第 iii 个开关除了改变 iii 号灯的状态之外，还会额外影响多个灯的状态；
请问是否存在方案使得所有的灯都关闭，如果无解则输出 −1-1−1 ，有解时则输出选择按开关数量最小的方案，如果按开关数量相同再比较输出字典序最小的方案。
输入描述
第 111 行两个整数 nnn 和 m(1<=n<=20，0<=m<=n∗(n−1))m(1<=n<=20，0<=m<=n*(n-1))m(1<=n<=20，0<=m<=n∗(n−1)) ,表示 nnn 个灯(每个灯一个开关)， mmm 个额外的影响关系。
第 222 行 nnn 个整数 a[i]a[i]a[i] 表示灯的初始开关情况，000 表示关闭，111 表示开启 (0<=a[i]<=1,1<=i<=n(0<=a[i]<= 1,1 <=i<=n(0<=a[i]<=1,1<=i<=n ，表示灯的索引序号)。
第 333 行到第 m+2m+2m+2 行，每行两个整数 xxx 和 yyy ，表示对灯 xxx 进行开关时会额外影响灯 yyy  ，题目保证输入影响关系不重复。
输出描述
如果无解，输出 −1-1−1 ;
如果有解，输出一行从小到大排序后的整数序列，用空格隔开;
如果有多个可行解，则输出按开关数量最小的方案，数量相同时输出字典序最小的方案。这里字典序最小的比较遵循按相同开关数的方案从小到大排序后，依次从第一个数开始比较，比较到第一个不同的位置时，更小的数所在序列更小。
样例1
输入
2 2
0 1
1 2
2 1

输出
-1

说明
有两盏灯，灯 111 为关闭状态，灯 222 为打开状态;两盏灯的状态是相互影响的，当关闭灯 222 时，灯 111 会从关闭状态变为打开状态;当再次关闭灯 111 时灯 222 状态又会被打开;
所以不存在方案把两盖灯都关闭，因此输出为 −1-1−1 ;
样例2
输入
3 4
1 0 0
2 1
2 3
3 1
3 2

输出
1

说明
方案一:按下开关 111 后，只有灯 111 自身关闭，此时为 000 000 000 ，满足条件。
方案二:选择 111 222 333 的方案也可以使得最终值所有灯关闭，也满足条件，但是该方案选取的个数更多，所级输出第一种方案。
样例3
输入
3 3
0 0 1
1 2
1 3
3 2

输出
2 3

说明
当选择开关 222 和 333 之后
按下开关 222 后，没有其他影响的开关，只有灯 222 自身，此时亮灯情况为 000 111 111 。
按下开关 333 后，格外影响灯 222 、则 222 和 333 分别切换开灯状态，此时为 000 000 000 所有灯关闭。
提示
(1)如果存在两种方案均满足，其中解法一输出为 111 222 ，解法二输出为 111 333 ，根据题目的字典序最小输出要求，最终输出为解法一的答案 111 222 ;
(2)初始状态下，至少有一盏灯是打开状态;

▶️

#### TextSol

video solution

解题思路
老小区有 n 盏灯、每盏灯各有一个开关；按下第 i 个开关会翻转第 i 盏灯，同时还会额外翻转若干盏灯（给出影响关系）。已知初始状态 a[i]∈{0,1}（0 关、1 开），问是否存在一组开关使所有灯都为 0；若存在，输出按下的开关编号（升序），并在多解中选择

开关数量最少；2) 数量相同则字典序（从小到大序列的字典序）最小。

算法选择：位运算状态压缩 + 子集枚举

将每个开关的作用用一个 n 位的位掩码表示：effect[i] 的第 j 位为 1 表示按下 i 会翻转第 j 盏灯。注意第 i 位始终为 1（会翻转自身）。
将初始状态也表示为 n 位掩码 S（第 i 位为 1 表示第 i 盏灯初始为开）。
对所有开关集合的子集 mask (0..2^n-1) 枚举，表示要按下的开关集合。
该方案的最终状态为：S XOR effect[i] 对 mask 中的每个 i 叠加一次。若结果为 0，即为可行方案。
在可行方案之间，先比较 popcount(mask)（开关数量），更小者优先；若相同，进行字典序比较：从开关 1 到 n 依次比较两方案在该位置是否选择（位是否为 1），在第一个不同的位置，取 1 的那个方案更小（因为它包含了更小的编号）。

备注：本题也可用线性代数的思想建模为 A*x=a (mod 2)，用模 2 高斯消元得到一组解并在零空间中找最优解。但由于 n ≤ 20，直接枚举 2^n 个子集即可稳妥通过，代码也更简洁。

复杂度分析

时间复杂度：O(n * 2^n)（对每个子集处理至多 n 个开关或用位运算按最低位迭代）。在 n ≤ 20 时约千万级操作，可接受。
空间复杂度：O(n)（只需存储每个开关的作用掩码与常数额外变量）。

代码实现
Python
# -*- coding: utf-8 -*-
# 题意实现放在外部函数中；主函数负责输入输出（ACM 风格）

import sys

def lex_smaller(mask_a, mask_b, n):
"""在相同开关数量下，比较两方案的字典序（升序序列）。
从1到n依次看位，第一处不同时，位为1的方案更小。"""
if mask_b is None:
return True
for i in range(n):
a_bit = (mask_a >> i) & 1
b_bit = (mask_b >> i) & 1
if a_bit != b_bit:
return a_bit == 1
return False  # 完全相同

def solve(n, m, a_list, edges):
# 每个开关的作用掩码，包含自身
effect = [0] * n
for i in range(n):
effect[i] |= (1 << i)
for x, y in edges:
# 输入为1-based，转成0-based
effect[x - 1] |= (1 << (y - 1))

# 初始状态掩码
S = 0
for i, v in enumerate(a_list):
if v == 1:
S |= (1 << i)

best_mask = None
best_cnt = 1 << 30

# 枚举所有按键的子集
total = 1 << n
for mask in range(total):
cur = S
t = mask
# 逐个最低位处理能更快
while t:
lsb = t & -t
idx = (lsb.bit_length() - 1)  # 第 idx 个开关被按
cur ^= effect[idx]
t -= lsb
if cur == 0:
cnt = mask.bit_count()
if cnt < best_cnt or (cnt == best_cnt and lex_smaller(mask, best_mask, n)):
best_cnt = cnt
best_mask = mask

if best_mask is None:
return None
# 输出升序编号
ans = []
for i in range(n):
if (best_mask >> i) & 1:
ans.append(i + 1)
return ans

def main():
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
return
it = iter(data)
n = next(it)
m = next(it)
a_list = [next(it) for _ in range(n)]
edges = [(next(it), next(it)) for _ in range(m)]
res = solve(n, m, a_list, edges)
if res is None:
print(-1)
else:
print(" ".join(map(str, res)))

if __name__ == "__main__":
main()

Java
// ACM 风格：主类名统一为 Main，主函数读写；核心逻辑放外部静态函数
import java.util.*;

public class Main {

// 在相同开关数量下比较字典序：从小到大编号，第一处不同时，位为1的更小
static boolean lexSmaller(long a, long b, int n) {
if (b == -1L) return true;
for (int i = 0; i < n; i++) {
long ab = (a >> i) & 1L;
long bb = (b >> i) & 1L;
if (ab != bb) return ab == 1L;
}
return false;
}

// 返回方案（升序编号），无解返回空列表
static List<Integer> solve(int n, int m, int[] a, int[][] edges) {
long[] effect = new long[n];
for (int i = 0; i < n; i++) effect[i] |= (1L << i);
for (int i = 0; i < m; i++) {
int x = edges[i][0];
int y = edges[i][1];
effect[x - 1] |= (1L << (y - 1));
}

long S = 0;
for (int i = 0; i < n; i++) if (a[i] == 1) S |= (1L << i);

long bestMask = -1L;
int bestCnt = Integer.MAX_VALUE;

long total = 1L << n;
for (long mask = 0; mask < total; mask++) {
long cur = S;
long t = mask;
// 逐个最低位处理以加速
while (t != 0) {
int idx = Long.numberOfTrailingZeros(t);
cur ^= effect[idx];
t &= (t - 1);
}
if (cur == 0) {
int cnt = Long.bitCount(mask);
if (cnt < bestCnt || (cnt == bestCnt && lexSmaller(mask, bestMask, n))) {
bestCnt = cnt;
bestMask = mask;
}
}
}

if (bestMask == -1L) return Collections.emptyList();
List<Integer> ans = new ArrayList<>();
for (int i = 0; i < n; i++) if (((bestMask >> i) & 1L) == 1L) ans.add(i + 1);
return ans;
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
if (!in.hasNextInt()) return;
int n = in.nextInt();
int m = in.nextInt();
int[] a = new int[n];
for (int i = 0; i < n; i++) a[i] = in.nextInt();
int[][] edges = new int[m][2];
for (int i = 0; i < m; i++) {
edges[i][0] = in.nextInt();
edges[i][1] = in.nextInt();
}
List<Integer> res = solve(n, m, a, edges);
if (res.isEmpty()) {
System.out.println(-1);
} else {
StringBuilder sb = new StringBuilder();
for (int i = 0; i < res.size(); i++) {
if (i > 0) sb.append(' ');
sb.append(res.get(i));
}
System.out.println(sb.toString());
}
in.close();
}
}

C++
// ACM 风格：主函数读写，核心逻辑放外部函数
#include <bits/stdc++.h>
using namespace std;

// 在相同开关数量下比较字典序（升序编号序列）：从1到n找第一处不同，位为1的方案更小
bool lexSmaller(unsigned int a, unsigned int b, int n) {
if (b == UINT_MAX) return true; // 用作“未赋值”的标记
for (int i = 0; i < n; ++i) {
bool ab = (a >> i) & 1u;
bool bb = (b >> i) & 1u;
if (ab != bb) return ab; // ab==1 代表包含更小的编号
}
return false;
}

// 返回方案（升序编号），无解返回空vector
vector<int> solve(int n, int m, const vector<int>& a, const vector<pair<int,int>>& edges) {
vector<unsigned int> effect(n, 0);
for (int i = 0; i < n; ++i) effect[i] |= (1u << i);
for (auto &e : edges) {
int x = e.first, y = e.second;
effect[x - 1] |= (1u << (y - 1));
}
unsigned int S = 0;
for (int i = 0; i < n; ++i) if (a[i] == 1) S |= (1u << i);

unsigned int bestMask = UINT_MAX;
int bestCnt = INT_MAX;

unsigned int total = 1u << n;
for (unsigned int mask = 0; mask < total; ++mask) {
unsigned int cur = S, t = mask;
while (t) {                    // 逐个最低位处理
unsigned int lsb = t & -t; // 取最低位
int idx = __builtin_ctz(t);
cur ^= effect[idx];
t -= lsb;
}
if (cur == 0u) {
int cnt = __builtin_popcount(mask);
if (cnt < bestCnt || (cnt == bestCnt && lexSmaller(mask, bestMask, n))) {
bestCnt = cnt;
bestMask = mask;
}
}
}

if (bestMask == UINT_MAX) return {};
vector<int> ans;
for (int i = 0; i < n; ++i)
if ((bestMask >> i) & 1u) ans.push_back(i + 1);
return ans;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, m;
if (!(cin >> n >> m)) return 0;
vector<int> a(n);
for (int i = 0; i < n; ++i) cin >> a[i];
vector<pair<int,int>> edges(m);
for (int i = 0; i < m; ++i) {
int x, y; cin >> x >> y;
edges[i] = {x, y};
}
vector<int> res = solve(n, m, a, edges);
if (res.empty()) {
cout << -1 << "\n";
} else {
for (int i = 0; i < (int)res.size(); ++i) {
if (i) cout << ' ';
cout << res[i];
}
cout << "\n";
}
return 0;
}

---

### 第3题-Masked Multi-Head Self-Attention 实现（P3843）
- 链接：https://codefun2000.com/p/P3843

> 页面标题：#P3843. 第3题-Masked Multi-Head Self-Attention 实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在Transformer模型中，Multi-Head Self-Attention是核心组件，用于捕捉序列中的依赖关系。你需要从头实现一个Masked Multi-Head Self-Attention函数，支持自注意力（即queries、keys和values来自同一输入序列），并处理编码（mask）以防止未来位置的信息泄露（常见于Decoder中）。
具体要求：

支持多头注意力：将注意力机制并行分成多个"头"，每个头学习不同的注意力模式，增强模型对多维度特征的捕捉能力。
计算过程：

生成Q、K、V矩阵
对输入序列X（维度：[batch_size, seq_len, d_model]）通过3个线性层分别生成查询（Query, Q）、键（Key, K）、值（Value, V）矩阵：（Q=X⋅WQQ = X \cdot W_QQ=X⋅WQ​，K=X⋅WKK = X \cdot W_KK=X⋅WK​，V=X⋅WVV = X \cdot W_VV=X⋅WV​），其中 $W_Q, W_K, W_V \in \mathbb{R}^{d_{model} \times d_{model}}$。
将Q、K、V拆分为多个头
将Q、K、V分割为num_heads个并行的子矩阵（每个头的维度为d_k = d_model / num_heads）。
分割后维度为[batch_size, num_heads, seq_len, d_k]。
对于每个头，计算注意力分数：attention_scores = (  Q⋅KTQ \cdot K^TQ⋅KT ) / sqrt(d_k)。
提供mask（一个(batch_size, seq_len, seq_len)的布尔数组，其中True表示需要掩码的位置），则将masked位置的注意力分数设置为负无穷（-inf），以确保softmax后为0。掩码后的分数为masked_scores。
对掩码后的分数应用softmax得到注意力权重。
softmax_scores=softmax(masked_scores)。
计算注意力输出：attention=softmax_scores  ·  V。
拼接多头输出，并通过一个线性投影得到最终结果。
$output =
concat(attention_1, ..., attention_{num_heads}) · W_O$
，其中 WO∈Rdmodel×dmodel W_O \in \mathbb{R}^{d_{model} \times d_{model}} WO​∈Rdmodel​×dmodel​ 是可学习参数，输出维度为
[batch_size, seq_len, d_model].

注意：
1、需处理批次（batch_size > 1）和变长序列。
2、输入参数以分号分隔。第一个参数为多头数量num_heads；
第二个参数为Q矩阵；第三个参数为K矩阵；第四个参数为V矩阵；第五个参数为 WO W_O WO​。
3、输出为List，需要将np.ndarray转为List
输入描述
以";"分隔，分别为 num_heads, X, Q、K、V，WOW_OWO​
输出描述
输出为最终结果 outputoutputoutput，输出保留两位有效小数，并且为 List。
样例1
输入
2;[[[ 1.92, 1.48], [0.67, -1.23], [0.35, -0.68]], [[-1.11, 0.09], [-0.3, -0.39], [-0.59, -0.06]]];[[1.0, 2.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]]

输出
[[[14.64, 14.64], [-5.36, -5.36], [-4.44, -4.44]], [[-2.79, -2.79], [-3.04, -3.04], [-2.79, -2.79]]]

样例2
输入
2;[[[ 1.92, 1.48], [0.67, -1.23], [0.35, -0.68]], [[-1.11, 0.09], [-0.3, -0.39], [-0.59, -0.06]]];[[1.0,1.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]];[[1.0, 1.0], [2.0, 2.0]]

输出
[[[14.64, 14.64], [-5.37, -5.37], [-4.62, -4.62]], [[-2.79, -2.79], [-3.03, -3.03], [-2.77, -2.77]]]

提示

手动实现softmax：exp_scores = np.exp(scores - np.max(scores, axis=-1, keepdims=True))；softmax = exp_scores / np.sum(exp_scores, axis=-1, keepdims=True)。确保数值稳定性，减去每行最大值
使用np.around(np.ndarray, 2)将输出保留2位小数
通过下三角矩阵实现序列掩码mask，确保每个位置只能关注自身及之前的位置。下三角为1，上三角为0。
处理-inf：可以使用np.where(mask == 0, -np.inf, attention_scores)

#### TextSol

解题思路
本题要求手写「带因果掩码」的多头自注意力（Decoder常用），输入为：

num_heads
X：形状 [batch_size, seq_len, d_model]
Q, K, V, W_O：均为形状 [d_model, d_model] 的线性投影矩阵（对应 $W_Q, W_K, W_V, W_O$）

整体流程（Scaled Dot-Product Attention + 多头并行）：

线性映射生成 Q/K/V
Q=XWQ,K=XWK,V=XWVQ = X W_Q,\quad K = X W_K,\quad V = X W_V
Q=XWQ​,K=XWK​,V=XWV​
维度：[B, S, d_model]。

分头
将最后一维 d_model 均分为 num_heads 个头，每头维度 d_k = d_model / num_heads，并重排为
Q_h, K_h, V_h ∈ [B, H, S, d_k]。

每头计算注意力分数
$$\text{scores} = \frac{Q_h K_h^\top}{\sqrt{d_k}}\quad\in [B,H,S,S]$$

因果掩码（防未来信息泄露）
构造 下三角 Mask（[S,S]，下三角为1，上三角为0），广播到 [B,H,S,S]。
将上三角（不允许关注的）位置置为 −∞-\infty−∞：
$$\text{masked\_scores} = \text{where}(mask=0,\; -\infty,\; \text{scores})$$

Softmax 得注意力权重（按最后一维 S 做归一化，数值稳定：减去行最大值）
α=softmax(masked_scores)\alpha = \text{softmax}(\text{masked\_scores})
α=softmax(masked_scores)

聚合得到每头输出
head=αVh∈[B,H,S,dk]\text{head} = \alpha V_h \quad\in [B,H,S,d_k]
head=αVh​∈[B,H,S,dk​]

拼接各头并做输出投影
先将各头在 d_k 维拼接回 d_model：[B,S,H\cdot d_k] = [B,S,d_model]，
再乘以 W_O：
$$\text{output} = \text{concat(heads)}\; W_O \quad\in [B,S,d_{model}]$$

输出格式
题目要求保留两位小数，并以 List 形式输出（即常见的嵌套列表），需要把 ndarray/数组转换为列表。

变长序列：常见做法是先对批次内对齐（padding），然后结合 因果掩码 与 padding mask（本题未给出padding mask输入），本实现提供标准因果掩码；若有padding，可在同维度位置再叠加一个padding掩码（将padding位置设为 −∞-\infty−∞）。
复杂度分析
设批次 B、序列长度 S、模型维度 D=d_model、头数 H、每头维度 d_k=D/H。

时间复杂度

线性映射：X * W_Q/W_K/W_V 各为 O(B*S*D^2)（若使用分块/并行可等价为 O(B*S*D*D)）。
注意力 QK^T：每头 O(S^2*d_k)，总计 O(B*H*S^2*d_k) = O(B*S^2*D)。
乘 V 聚合：同阶 O(B*S^2*D)。
输出投影 * W_O：O(B*S*D^2)。
综合为 O(B*S*D^2 + B*S^2*D)，与标准Transformer一致。

空间复杂度
主要存储 Q/K/V、注意力分数与权重：O(B*S*D + B*H*S*S)，即 O(B*S*D + B*S^2*H)。

代码实现
Python
# 题意：读入 "num_heads;X;Q;K;V;W_O"（用分号分隔），实现因果掩码多头自注意力
# 要求：输出为 List（嵌套列表），保留两位小数

import sys
import numpy as np
from ast import literal_eval

def to_str(arr):
"""递归把嵌套 list 转成字符串，数值固定两位小数且无引号；把 -0.00 规整为 0.00"""
if isinstance(arr, list):
return "[" + ", ".join(to_str(x) for x in arr) + "]"
else:
# 数值分支
v = float(arr)
s = f"{v:.2f}"
# 规整 -0.00 -> 0.00
if s == "-0.00":
s = "0.00"
return s

def softmax_stable(x, axis=-1):
# 数值稳定 softmax
m = np.max(x, axis=axis, keepdims=True)
ex = np.exp(x - m)
return ex / np.sum(ex, axis=axis, keepdims=True)

def multi_head_self_attention(X, WQ, WK, WV, WO, num_heads):
B, S, D = X.shape
assert D % num_heads == 0, "d_model 必须能被 num_heads 整除"
d_k = D // num_heads

# 1) 线性映射
Q = X @ WQ     # [B,S,D]
K = X @ WK
V = X @ WV

# 2) 分头 -> [B,H,S,d_k]
def split_heads(t):
t = t.reshape(B, S, num_heads, d_k)     # [B,S,H,d_k]
return np.transpose(t, (0, 2, 1, 3))    # [B,H,S,d_k]
Qh, Kh, Vh = split_heads(Q), split_heads(K), split_heads(V)

# 3) 注意力分数 [B,H,S,S]
# scores[b,h,i,j] = Qh[b,h,i,:] dot Kh[b,h,j,:] / sqrt(d_k)
# 利用矩阵乘法： (B,H,S,d_k) x (B,H,d_k,S) -> (B,H,S,S)
scores = (Qh @ np.transpose(Kh, (0,1,3,2))) / np.sqrt(d_k)

# 4) 因果掩码：允许关注自己及之前位置 => 下三角为1，其余为0
mask = np.tril(np.ones((S, S), dtype=np.float32))  # [S,S]
mask = mask[None, None, :, :]                      # [1,1,S,S] 广播到 [B,H,S,S]
scores = np.where(mask == 1, scores, -np.inf)

# 5) softmax
attn = softmax_stable(scores, axis=-1)  # [B,H,S,S]

# 6) 加权求和
heads = attn @ Vh                       # [B,H,S,d_k]

# 7) 拼回 + 输出投影
heads = np.transpose(heads, (0, 2, 1, 3))      # [B,S,H,d_k]
concat = heads.reshape(B, S, D)                # [B,S,D]
out = concat @ WO                              # [B,S,D]

return out

def main():
raw = sys.stdin.read().strip()
# 按分号分割：num_heads;X;Q;K;V;W_O
parts = [p.strip() for p in raw.split(';')]
if len(parts) != 6:
raise ValueError("输入应包含6段参数：num_heads;X;Q;K;V;W_O")

num_heads = int(parts[0])
X = np.array(literal_eval(parts[1]), dtype=float)
WQ = np.array(literal_eval(parts[2]), dtype=float)
WK = np.array(literal_eval(parts[3]), dtype=float)
WV = np.array(literal_eval(parts[4]), dtype=float)
WO = np.array(literal_eval(parts[5]), dtype=float)

out = multi_head_self_attention(X, WQ, WK, WV, WO, num_heads)
out = np.around(out, 2)                 # 保留两位小数
# 转为嵌套列表输出
out = np.around(out, 2)
print(to_str(out.tolist()))

if __name__ == "__main__":
main()

C++
#include <bits/stdc++.h>
using namespace std;

// 解析二维数组，如 [[1,2],[3,4]]
static vector<vector<double>> parse2D(const string &s) {
vector<vector<double>> res;
vector<double> row;
int depth = 0;
int n = s.size();
for (int i = 0; i < n; ++i) {
char c = s[i];
if (c == '[') {
depth++;
if (depth == 2) row.clear();
} else if (c == ']') {
if (depth == 2) {
if (!row.empty()) res.push_back(row);
row.clear();
}
depth--;
} else {
// 读取数字
if (isdigit(c) || c=='-' || c=='+' || c=='.' || c=='e' || c=='E') {
int j = i;
while (j < n && (isdigit(s[j]) || s[j]=='-' || s[j]=='+' || s[j]=='.' || s[j]=='e' || s[j]=='E')) j++;
double val = stod(s.substr(i, j - i));
row.push_back(val);
i = j - 1;
}
}
}
return res;
}

// 解析三维数组，如 [[[...],[...]], [[...],[...]]]
static vector<vector<vector<double>>> parse3D(const string &s) {
vector<vector<vector<double>>> res;
vector<vector<double>> mat;
vector<double> row;
int depth = 0;
int n = s.size();
for (int i = 0; i < n; ++i) {
char c = s[i];
if (c == '[') {
depth++;
if (depth == 2) mat.clear();
if (depth == 3) row.clear();
} else if (c == ']') {
if (depth == 3) {
if (!row.empty()) mat.push_back(row);
row.clear();
} else if (depth == 2) {
if (!mat.empty()) res.push_back(mat);
mat.clear();
}
depth--;
} else {
// 读取数字
if (isdigit(c) || c=='-' || c=='+' || c=='.' || c=='e' || c=='E') {
int j = i;
while (j < n && (isdigit(s[j]) || s[j]=='-' || s[j]=='+' || s[j]=='.' || s[j]=='e' || s[j]=='E')) j++;
double val = stod(s.substr(i, j - i));
row.push_back(val);
i = j - 1;
}
}
}
return res;
}

// X[b][t][d] * W[d][d] -> Y[b][t][d]
static vector<vector<vector<double>>> matmul3D2D(
const vector<vector<vector<double>>> &X,
const vector<vector<double>> &W) {
int B = (int)X.size();
int T = (int)X[0].size();
int D = (int)X[0][0].size();
vector<vector<vector<double>>> Y(B, vector<vector<double>>(T, vector<double>(D, 0.0)));
for (int b = 0; b < B; ++b) {
for (int t = 0; t < T; ++t) {
for (int j = 0; j < D; ++j) {
double sum = 0.0;
for (int k = 0; k < D; ++k) sum += X[b][t][k] * W[k][j];
Y[b][t][j] = sum;
}
}
}
return Y;
}

// 打印三维数组，保留两位小数
static void print3D(const vector<vector<vector<double>>> &A) {
cout << "[";
for (int b = 0; b < (int)A.size(); ++b) {
if (b) cout << ", ";
cout << "[";
for (int i = 0; i < (int)A[b].size(); ++i) {
if (i) cout << ", ";
cout << "[";
for (int j = 0; j < (int)A[b][i].size(); ++j) {
if (j) cout << ", ";
double v = A[b][i][j];
if (fabs(v) < 0.005) v = 0.0; // 避免-0.00
cout.setf(std::ios::fixed); cout<<setprecision(2)<<v;
}
cout << "]";
}
cout << "]";
}
cout << "]\n";
}

int main() {
// 读取整份输入（可能包含空格与换行）
std::ostringstream oss;
string line;
while (std::getline(cin, line)) {
oss << line;
}
string all = oss.str();

// 以分号拆分为6段：num_heads ; X ; W_Q ; W_K ; W_V ; W_O
vector<string> parts;
{
string cur;
for (char c : all) {
if (c == ';') {
parts.push_back(cur);
cur.clear();
} else {
cur.push_back(c);
}
}
if (!cur.empty()) parts.push_back(cur);
}
if (parts.size() != 6) return 0;

// 解析num_heads
int num_heads = 0;
{
string s = parts[0];
// 用替换字符+输入流：将非数字转空格
for (char &c : s) if (!(isdigit(c) || c=='-' || c=='+')) c = ' ';
istringstream iss(s);
iss >> num_heads;
}

// 解析X与四个权重
auto X  = parse3D(parts[1]);
auto WQ = parse2D(parts[2]);
auto WK = parse2D(parts[3]);
auto WV = parse2D(parts[4]);
auto WO = parse2D(parts[5]);

int B = (int)X.size();
int T = (int)X[0].size();
int D = (int)X[0][0].size();
int H = num_heads;
int d_k = D / H;

// 1) 生成Q/K/V
auto Q = matmul3D2D(X, WQ);
auto K = matmul3D2D(X, WK);
auto V = matmul3D2D(X, WV);

// 2) 重排为多头 [B,H,T,d_k]
auto to_heads = [&](const vector<vector<vector<double>>> &A){
vector<vector<vector<vector<double>>>> Ah(
B, vector<vector<vector<double>>>(H, vector<vector<double>>(T, vector<double>(d_k, 0.0)))
);
for (int b = 0; b < B; ++b)
for (int t = 0; t < T; ++t)
for (int d = 0; d < D; ++d) {
int h = d / d_k, r = d % d_k;
Ah[b][h][t][r] = A[b][t][d];
}
return Ah;
};
auto Qh = to_heads(Q);
auto Kh = to_heads(K);
auto Vh = to_heads(V);

// 3-6) 注意力(带因果mask)
double inv_sqrt = 1.0 / sqrt((double)d_k);
vector<vector<vector<vector<double>>>> Ah( // attention后的值 [B,H,T,d_k]
B, vector<vector<vector<double>>>(H, vector<vector<double>>(T, vector<double>(d_k, 0.0)))
);

for (int b = 0; b < B; ++b) {
for (int h = 0; h < H; ++h) {
// 预计算 scores [T][T]
vector<vector<double>> scores(T, vector<double>(T, 0.0));
for (int i = 0; i < T; ++i) {
for (int j = 0; j < T; ++j) {
double dot = 0.0;
for (int r = 0; r < d_k; ++r) dot += Qh[b][h][i][r] * Kh[b][h][j][r];
scores[i][j] = dot * inv_sqrt;
}
}
// softmax with causal mask
for (int i = 0; i < T; ++i) {
double maxv = -1e100;
for (int j = 0; j < T; ++j) {
if (j > i) scores[i][j] = -1e9; // mask未来位置
if (scores[i][j] > maxv) maxv = scores[i][j];
}
double sumexp = 0.0;
vector<double> p(T, 0.0);
for (int j = 0; j < T; ++j) {
double e = exp(scores[i][j] - maxv);
p[j] = e;
sumexp += e;
}
// attention * V
for (int r = 0; r < d_k; ++r) {
double acc = 0.0;
for (int j = 0; j < T; ++j) {
double w = (sumexp == 0.0 ? 0.0 : p[j] / sumexp);
acc += w * Vh[b][h][j][r];
}
Ah[b][h][i][r] = acc;
}
}
}
}

// 7) 拼接头 -> [B,T,D]
vector<vector<vector<double>>> concat(B, vector<vector<double>>(T, vector<double>(D, 0.0)));
for (int b = 0; b < B; ++b)
for (int t = 0; t < T; ++t)
for (int h = 0; h < H; ++h)
for (int r = 0; r < d_k; ++r)
concat[b][t][h*d_k + r] = Ah[b][h][t][r];

// 线性投影 WO
auto Y = matmul3D2D(concat, WO);

// 输出
print3D(Y);
return 0;
}

Java
import java.io.*;
import java.util.*;

public class Main {

// 解析二维数组 [[...],[...]]
static List<List<Double>> parse2D(String s) {
List<List<Double>> res = new ArrayList<>();
List<Double> row = new ArrayList<>();
int depth = 0, n = s.length();
for (int i = 0; i < n; i++) {
char c = s.charAt(i);
if (c == '[') {
depth++;
if (depth == 2) row = new ArrayList<>();
} else if (c == ']') {
if (depth == 2) {
if (!row.isEmpty()) res.add(row);
row = new ArrayList<>();
}
depth--;
} else {
if (Character.isDigit(c) || c=='-' || c=='+' || c=='.' || c=='e' || c=='E') {
int j = i;
while (j < n) {
char cj = s.charAt(j);
if (Character.isDigit(cj) || cj=='-' || cj=='+' || cj=='.' || cj=='e' || cj=='E') j++;
else break;
}
double val = Double.parseDouble(s.substring(i, j));
row.add(val);
i = j - 1;
}
}
}
return res;
}

// 解析三维数组 [[[...],[...]], [[...],[...]]]
static List<List<List<Double>>> parse3D(String s) {
List<List<List<Double>>> res = new ArrayList<>();
List<List<Double>> mat = new ArrayList<>();
List<Double> row = new ArrayList<>();
int depth = 0, n = s.length();
for (int i = 0; i < n; i++) {
char c = s.charAt(i);
if (c == '[') {
depth++;
if (depth == 2) mat = new ArrayList<>();
if (depth == 3) row = new ArrayList<>();
} else if (c == ']') {
if (depth == 3) {
if (!row.isEmpty()) mat.add(row);
row = new ArrayList<>();
} else if (depth == 2) {
if (!mat.isEmpty()) res.add(mat);
mat = new ArrayList<>();
}
depth--;
} else {
if (Character.isDigit(c) || c=='-' || c=='+' || c=='.' || c=='e' || c=='E') {
int j = i;
while (j < n) {
char cj = s.charAt(j);
if (Character.isDigit(cj) || cj=='-' || cj=='+' || cj=='.' || cj=='e' || cj=='E') j++;
else break;
}
double val = Double.parseDouble(s.substring(i, j));
row.add(val);
i = j - 1;
}
}
}
return res;
}

// X[b][t][d] * W[d][d]
static double[][][] matmul3D2D(double[][][] X, double[][] W) {
int B = X.length, T = X[0].length, D = X[0][0].length;
double[][][] Y = new double[B][T][D];
for (int b = 0; b < B; b++) {
for (int t = 0; t < T; t++) {
for (int j = 0; j < D; j++) {
double sum = 0.0;
for (int k = 0; k < D; k++) sum += X[b][t][k] * W[k][j];
Y[b][t][j] = sum;
}
}
}
return Y;
}

static String fmt2(double v) {
if (Math.abs(v) < 0.005) v = 0.0; // 避免-0.00
return String.format(java.util.Locale.US, "%.2f", v);
}

public static void main(String[] args) throws Exception {
// 读取整份输入
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringBuilder sbAll = new StringBuilder();
String line;
while ((line = br.readLine()) != null) sbAll.append(line);
String all = sbAll.toString();

// 拆分为6段：num_heads ; X ; WQ ; WK ; WV ; WO
List<String> parts = new ArrayList<>();
{
StringBuilder cur = new StringBuilder();
for (int i = 0; i < all.length(); i++) {
char c = all.charAt(i);
if (c == ';') {
parts.add(cur.toString());
cur.setLength(0);
} else {
cur.append(c);
}
}
if (cur.length() > 0) parts.add(cur.toString());
}
if (parts.size() != 6) return;

// 解析num_heads：替换非数字为空格+输入流风格
int numHeads = 0;
{
String s = parts.get(0);
StringBuilder t = new StringBuilder();
for (int i = 0; i < s.length(); i++) {
char c = s.charAt(i);
if (Character.isDigit(c) || c=='-' || c=='+') t.append(c);
else t.append(' ');
}
Scanner sc = new Scanner(t.toString());
if (sc.hasNextInt()) numHeads = sc.nextInt();
}

// 解析X与权重
List<List<List<Double>>> Xlist = parse3D(parts.get(1));
List<List<Double>> WQl = parse2D(parts.get(2));
List<List<Double>> WKl = parse2D(parts.get(3));
List<List<Double>> WVl = parse2D(parts.get(4));
List<List<Double>> WOl = parse2D(parts.get(5));

int B = Xlist.size();
int T = Xlist.get(0).size();
int D = Xlist.get(0).get(0).size();
int H = numHeads;
int dk = D / H;

// 转为原生数组
double[][][] X = new double[B][T][D];
for (int b = 0; b < B; b++)
for (int t2 = 0; t2 < T; t2++)
for (int d = 0; d < D; d++)
X[b][t2][d] = Xlist.get(b).get(t2).get(d);

double[][] WQ = new double[D][D], WK = new double[D][D], WV = new double[D][D], WO = new double[D][D];
for (int i = 0; i < D; i++)
for (int j = 0; j < D; j++) {
WQ[i][j] = WQl.get(i).get(j);
WK[i][j] = WKl.get(i).get(j);
WV[i][j] = WVl.get(i).get(j);
WO[i][j] = WOl.get(i).get(j);
}

// 1) Q/K/V
double[][][] Q = matmul3D2D(X, WQ);
double[][][] K = matmul3D2D(X, WK);
double[][][] V = matmul3D2D(X, WV);

// 2) 重排到多头 [B][H][T][dk]
double[][][][] Qh = new double[B][H][T][dk];
double[][][][] Kh = new double[B][H][T][dk];
double[][][][] Vh = new double[B][H][T][dk];
for (int b = 0; b < B; b++)
for (int t2 = 0; t2 < T; t2++)
for (int d = 0; d < D; d++) {
int h = d / dk, r = d % dk;
Qh[b][h][t2][r] = Q[b][t2][d];
Kh[b][h][t2][r] = K[b][t2][d];
Vh[b][h][t2][r] = V[b][t2][d];
}

// 3-6) 注意力(带因果mask)
double invSqrt = 1.0 / Math.sqrt((double)dk);
double[][][][] Ah = new double[B][H][T][dk];
for (int b = 0; b < B; b++) {
for (int h = 0; h < H; h++) {
// scores [T][T]
double[][] scores = new double[T][T];
for (int i = 0; i < T; i++) {
for (int j = 0; j < T; j++) {
double dot = 0.0;
for (int r = 0; r < dk; r++) dot += Qh[b][h][i][r] * Kh[b][h][j][r];
scores[i][j] = dot * invSqrt;
}
}
// softmax per i with causal mask
for (int i = 0; i < T; i++) {
double maxv = -1e100;
for (int j = 0; j < T; j++) {
if (j > i) scores[i][j] = -1e9; // mask
if (scores[i][j] > maxv) maxv = scores[i][j];
}
double[] p = new double[T];
double sumexp = 0.0;
for (int j = 0; j < T; j++) {
double e = Math.exp(scores[i][j] - maxv);
p[j] = e;
sumexp += e;
}
for (int r = 0; r < dk; r++) {
double acc = 0.0;
for (int j = 0; j < T; j++) {
double w = (sumexp == 0.0 ? 0.0 : p[j] / sumexp);
acc += w * Vh[b][h][j][r];
}
Ah[b][h][i][r] = acc;
}
}
}
}

// 7) 拼接多头 -> [B][T][D]
double[][][] concat = new double[B][T][D];
for (int b2 = 0; b2 < B; b2++)
for (int t2 = 0; t2 < T; t2++)
for (int h = 0; h < H; h++)
for (int r = 0; r < dk; r++)
concat[b2][t2][h*dk + r] = Ah[b2][h][t2][r];

// 线性投影 WO
double[][][] Y = matmul3D2D(concat, WO);

// 输出 List 形式
StringBuilder out = new StringBuilder();
out.append("[");
for (int b2 = 0; b2 < B; b2++) {
if (b2 > 0) out.append(", ");
out.append("[");
for (int t2 = 0; t2 < T; t2++) {
if (t2 > 0) out.append(", ");
out.append("[");
for (int d2 = 0; d2 < D; d2++) {
if (d2 > 0) out.append(", ");
out.append(fmt2(Y[b2][t2][d2]));
}
out.append("]");
}
out.append("]");
}
out.append("]\n");
System.out.print(out.toString());
}
}

---

### 第3题-灌溉农场（P3846）
- 链接：https://codefun2000.com/p/P3846

> 页面标题：#P3846. 第3题-灌溉农场

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一片 n∗mn*mn∗m 大小的网格农场需要灌溉，每个格子中的数值 V[i][j]V[i][j]V[i][j] 表示为：
1、如果 V[i][j]V[i][j]V[i][j] 大于 000，代表该格子中为价值为 VVV 的经济作物;
2、如果 V[i][j]V[i][j]V[i][j] 小于 000 ，代表该格子中为浇灌半径为 −V-V−V 的浇灌器;
3、如果 V[i][j]V[i][j]V[i][j] 等于 000 ，代表该格子为空地;
假设位置 x1、y1x1、y1x1、y1 为一个浇灌器，其浇灌半径为 VVV ，对于其周围的作物 x2、y2x2、y2x2、y2 而言，当满足当 (x1−x2)2+(y1−y2)2<=(V[x1][y1])2(x1-x2)^2+(y1-y2)^2<=(V[x1][y1])^2(x1−x2)2+(y1−y2)2<=(V[x1][y1])2 时，视为该方格能被灌溉器完全覆盖
如果作物 (i、ji、ji、j 位置处)未被灌溉器覆盖，则无法收获提供价值，如果某个方格被 kkk 个灌溉器覆盖，当 kkk 越大时则会使其因过度灌溉而导致价值下降为 V[i][j]/kV[i][j]/kV[i][j]/k ;
现在需要合理选择需要打开哪些浇灌器，使得作物价值最大化;
请计算总价值最大是多少(价值只输出整数部分，即向下取整)?
总价值最大时最少需要打开多少个浇灌器?
输入描述
第一行两个整数 nnn 和 m(1<=n,m<=600)m(1<=n,m<=600)m(1<=n,m<=600),表示大小为 nnn 行 mmm 列的网格农场。
接下来为 nnn 行，每行 mmm 个元素，第 iii 行 jjj 列为 a[i][j],(−800<=a[i][j]<=1000)a[i][j],(-800<=a[i][j]<=1000)a[i][j],(−800<=a[i][j]<=1000) ,
当 a[i][j]>0a[i][j]>0a[i][j]>0 时表示有价值 a[i][j]a[i][j]a[i][j] 的经济作物，
当 a[i][j]=0a[i][j]=0a[i][j]=0 时表示为空地，
当 a[i][j]<0a[i][j]<0a[i][j]<0 时表示为喷射半径为 −a[i][j]-a[i][j]−a[i][j] 的浇灌器。
其中浇灌器的总数(即 a[i][j]<0a[i][j]<0a[i][j]<0 的格子数)记为 irrirrirr_num(0<=11)num(0<=11)num(0<=11)。
输出描述
输出使用空格分开的两个整数 valvalval 和 usedusedused_numnumnum，表示能获得的最大总价值和总价值最大时最少需要打开的浇灌器数量。
总价值只需要输出整数部分即可。
样例1
输入
3 3
11 2 10
1 -1 15
12 2 0

输出
20 1

说明
浇灌器位于 (2,2)(2,2)(2,2) 位置处，位置 (1,1)(1,1)(1,1) 处的作物不满足 (2−1)2+(2−1)2<=1(2-1)^2+(2-1)^2<=1(2−1)2+(2−1)2<=1，所以无法浇灌到，位置 (1,2)(1,2)(1,2) 处的作物满足 (1−1)2+(2−1)2<=1(1-1)^2+(2-1)^2<=1(1−1)2+(2−1)2<=1，所以可以浇灌到；
同理，可以计算出，满足浇灌条件的作物分别位于 (1,2)、(2,1)、(2,3)(1,2)、(2,1)、(2,3)(1,2)、(2,1)、(2,3) 和 (3,2)(3,2)(3,2) 共四处；
这四处作物的经济价值分别为：2、1、152、1、152、1、15 和 222 ，总价值为 202020 ；
所以输出为：202020 111 ；
表示总价值为 202020，使用一个浇灌器；
样例2
输入
3 5
11 2 10 1 3
1 -1 15 -1 1
12 2 23 8 2

输出
25 1

说明
该用例中，共有两个浇灌器，有三种组合方法，分别解释如下：
1、如果打开所有浇灌器：
(2,2)(2,2)(2,2) 位置的浇灌器可以覆盖 (1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2) 一共四个作物
(2,4)(2,4)(2,4) 处的浇灌器可以覆盖 (1,4)(2,3)(2,5)(3,4)(1,4)(2,3)(2,5)(3,4)(1,4)(2,3)(2,5)(3,4) 一共四个作物
其中 (2,3)(2,3)(2,3) 位置处的作物被覆盖了两次，价值降低为 15/2=715/2=715/2=7 (向下取整)
最后总价值为 222222 ；
2、如果只打开位置 (2,2)(2,2)(2,2) 处的浇灌器，可以覆盖 (1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2) 一共四个作物；
总价值为 202020 ；
3、如果只打开 (2,4)(2,4)(2,4) 处的浇灌器，可以覆盖 (1,4)(2,3)(2,5)(3,4)(1,4)(2,3)(2,5)(3,4)(1,4)(2,3)(2,5)(3,4) 一共四个作物；总价值为 252525 ；
25>22>2025>22>2025>22>20 ：因此选择第三种方法，即：只打开 (2,4)(2,4)(2,4) 位置处的浇灌器即可，总价值为 252525 ；
所以输出为：252525 111
样例3
输入
4 5
11 2 10 1 3
1 -1 7 33 1
12 19 23 8 2
1 -1 0 31 7

输出
29 1

说明
该用例中，共有两个浇灌器，有三种组合方法，分别解释如下：
1、如果打开所有浇灌器：
(2,2)(2,2)(2,2) 位置的浇灌器可以覆盖 (1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2) 一共四个作物
(4.2)(4.2)(4.2) 处的浇灌器可以覆盖 (3,2)(4,1)(3,2)(4,1)(3,2)(4,1) 一共两个作物
其中 (3,2)(3,2)(3,2) 位置处的作物被覆盖了两次，价值降低为 19/2=919/2=919/2=9 (向下取整)
最后总价值为 292929 ；
2、如果只打开位置 (2,2)(2,2)(2,2) 处的浇灌器，可以覆盖 (1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2)(1,2)(2,1)(2,3)(3,2) 一共四个作物；
总价值为 292929；
3、如果只打开 (4,2)(4,2)(4,2) 处的浇灌器，可以覆盖 (3,2)(4,1)(4,3)(3,2)(4,1)(4,3)(3,2)(4,1)(4,3) 一共两个作物；
总价值为 202020 ；
29==29>2029 ==29 >2029==29>20 ； 当总价值相同的时候，选择使用浇灌器更少的方法，因此选择第二种方法，即：只打开 (2,2)(2,2)(2,2) 位置处的浇灌器即可，总价值为 292929 ；
所以输出为：292929 111

#### TextSol

解题思路

网格大小为 n*m。

a[i][j] > 0：价值为 a[i][j] 的作物；
a[i][j] = 0：空地；
a[i][j] < 0：半径为 -a[i][j] 的洒灌器（欧氏距离，含边界）。

若一个作物格被激活的洒灌器覆盖了 k ≥ 1 次，价值变为 v/k；未覆盖则价值为 0。目标：选择要开启的洒灌器，使总价值最大；若最大价值有多解，洒灌器开启数量取最小。输出总价值的整数部分（向下取整）及最少开启数量。

核心算法

洒灌器数量上限小：题面给出洒灌器总数 irr_num ≤ 11。
因此可对洒灌器集合进行子集枚举（至多 2^11 = 2048 个子集）。

覆盖掩码聚合：

先枚举每个作物格，计算它被哪些洒灌器覆盖，得到一个长度为 irr_num 的位掩码 mask（第 t 位为 1 表示第 t 个洒灌器覆盖该格）。
将所有作物按 mask 聚合，记 sum[mask] 为该类作物原始价值之和（mask=0 无法被任何洒灌器覆盖，可忽略）。

评估每个开启方案：

对每个子集 S（表示开启的洒灌器），总价值

取 f(S) 最大的方案；若多个方案达到同一最大值（以微小 eps 判等），取 |S|（开启数量）最小的。

实现要点

计算覆盖采用欧氏距离平方比较：(x1-x2)^2 + (y1-y2)^2 <= r^2。
为避免重复扫描整图：只对 a[i][j]>0 的格子计算其覆盖 mask。
评估阶段只遍历出现过的 mask（sum[mask]>0）。
浮点误差处理：比较时使用 eps = 1e-9，最终对最大价值做 floor（或 int(ans+1e-9)）。

复杂度分析

设洒灌器数量为 k (≤11)，网格大小 N=n*m (≤ 360000)。
预处理（给每个作物求覆盖掩码）：O(N * k)（最多约 4e6 次简单运算）
枚举方案并计算总价值：O(2^k * M)，其中 M ≤ 2^k-1 为出现过的掩码数量。最坏 O(4^k)，k≤11 时约 420 万次，足够快。
额外空间：O(2^k) 存储 sum[mask]。

代码实现
Python
# -*- coding: utf-8 -*-
import sys
from math import floor

EPS = 1e-9

def calc_best_value(n, m, a):
sprinklers = []  # (x, y, r)
for i in range(n):
for j in range(m):
if a[i][j] < 0:
sprinklers.append((i, j, -a[i][j]))
k = len(sprinklers)
if k == 0:
return 0, 0  # 没有洒灌器，价值为0，打开数量为0

# 预聚合：sum[mask] 为被 mask 覆盖模式的作物价值之和
sums = [0.0] * (1 << k)
for i in range(n):
for j in range(m):
v = a[i][j]
if v > 0:
mask = 0
# 计算该作物的覆盖掩码
for t, (x, y, r) in enumerate(sprinklers):
dx = i - x
dy = j - y
if dx * dx + dy * dy <= r * r:
mask |= (1 << t)
if mask != 0:
sums[mask] += v

best_val = 0.0
best_cnt = 0

# 子集枚举：S 表示打开的洒灌器集合
for S in range(1 << k):
total = 0.0
if S != 0:
for mask in range(1, 1 << k):
sv = sums[mask]
if sv == 0.0:
continue
inter = mask & S
if inter != 0:
c = inter.bit_count()
total += sv / c
# 比较并记录答案（tie 时开启数量更小）
cnt = S.bit_count()
if total > best_val + EPS or (abs(total - best_val) <= EPS and cnt < best_cnt):
best_val, best_cnt = total, cnt

return int(best_val + EPS), best_cnt

def main():
data = list(map(int, sys.stdin.read().strip().split()))
if not data:
return
it = iter(data)
n = next(it); m = next(it)
a = [[0]*m for _ in range(n)]
for i in range(n):
for j in range(m):
a[i][j] = next(it)
val, used = calc_best_value(n, m, a)
print(val, used)

if __name__ == "__main__":
main()

Java
// -*- coding: utf-8 -*-
// ACM 风格，主类名 Main
import java.io.*;
import java.util.*;

public class Main {
static final double EPS = 1e-9;

// 计算答案的外部函数
static long[] solve(int n, int m, int[][] a) {
List<int[]> spr = new ArrayList<>(); // (x,y,r)
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
if (a[i][j] < 0) spr.add(new int[]{i, j, -a[i][j]});
}
}
int k = spr.size();
if (k == 0) return new long[]{0L, 0L};

double[] sums = new double[1 << k]; // sum[mask]

// 仅遍历作物格，计算覆盖掩码
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int v = a[i][j];
if (v > 0) {
int mask = 0;
for (int t = 0; t < k; t++) {
int[] s = spr.get(t);
int dx = i - s[0];
int dy = j - s[1];
int r = s[2];
if ((long)dx * dx + (long)dy * dy <= (long)r * r) {
mask |= (1 << t);
}
}
if (mask != 0) sums[mask] += v;
}
}
}

double bestVal = 0.0;
int bestCnt = 0;

// 枚举所有开启方案
int lim = 1 << k;
for (int S = 0; S < lim; S++) {
double total = 0.0;
if (S != 0) {
for (int mask = 1; mask < lim; mask++) {
double sv = sums[mask];
if (sv == 0.0) continue;
int inter = mask & S;
if (inter != 0) {
int c = Integer.bitCount(inter);
total += sv / c;
}
}
}
int cnt = Integer.bitCount(S);
if (total > bestVal + EPS || (Math.abs(total - bestVal) <= EPS && cnt < bestCnt)) {
bestVal = total;
bestCnt = cnt;
}
}
long valInt = (long) Math.floor(bestVal + EPS);
return new long[]{valInt, bestCnt};
}

// 读入与输出在主函数中
public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st;

st = new StringTokenizer(br.readLine());
int n = Integer.parseInt(st.nextToken());
int m = Integer.parseInt(st.nextToken());
int[][] a = new int[n][m];
for (int i = 0; i < n; i++) {
st = new StringTokenizer(br.readLine());
for (int j = 0; j < m; j++) {
a[i][j] = Integer.parseInt(st.nextToken());
}
}
long[] ans = solve(n, m, a);
System.out.println(ans[0] + " " + ans[1]);
}
}

C++
// -*- coding: utf-8 -*-
// ACM 风格：主函数读写，功能在外部函数 solve 中
#include <bits/stdc++.h>
using namespace std;

const long double EPS = 1e-9L;

pair<long long,int> solve(int n, int m, const vector<vector<int>>& a){
struct S {int x,y,r;};
vector<S> spr;
for(int i=0;i<n;i++)
for(int j=0;j<m;j++)
if(a[i][j] < 0) spr.push_back({i,j,-a[i][j]});
int k = (int)spr.size();
if(k==0) return {0LL, 0};

int LIM = 1<<k;
vector<long double> sums(LIM, 0.0L); // sum[mask]

// 仅对作物格计算覆盖掩码
for(int i=0;i<n;i++){
for(int j=0;j<m;j++){
int v = a[i][j];
if(v>0){
int mask = 0;
for(int t=0;t<k;t++){
long long dx = i - spr[t].x;
long long dy = j - spr[t].y;
long long rr = spr[t].r;
if(dx*dx + dy*dy <= rr*rr) mask |= (1<<t);
}
if(mask) sums[mask] += (long double)v;
}
}
}

long double bestVal = 0.0L;
int bestCnt = 0;

for(int S=0; S<LIM; S++){
long double total = 0.0L;
if(S!=0){
for(int mask=1; mask<LIM; mask++){
if(sums[mask]==0.0L) continue;
int inter = mask & S;
if(inter){
int c = __builtin_popcount((unsigned)inter);
total += sums[mask] / (long double)c;
}
}
}
int cnt = __builtin_popcount((unsigned)S);
if(total > bestVal + EPS || (fabsl(total - bestVal) <= EPS && cnt < bestCnt)){
bestVal = total;
bestCnt = cnt;
}
}
long long valInt = (long long)floor(bestVal + EPS);
return {valInt, bestCnt};
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n,m;
if(!(cin>>n>>m)) return 0;
vector<vector<int>> a(n, vector<int>(m));
for(int i=0;i<n;i++)
for(int j=0;j<m;j++)
cin>>a[i][j];

auto ans = solve(n,m,a);
cout<<ans.first<<" "<<ans.second<<"\n";
return 0;
}

---

### 第3题-电车路线规划（P3795）
- 链接：https://codefun2000.com/p/P3795

> 页面标题：#P3795. 第3题-电车路线规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

为了方便城市居民有序流动，城市 AAA 开通了一系列有轨电车路线，每列电车会沿固定的路线循环行驶，电车票价实行一票制，不论乘坐多少站，均按固定价格收费，循环坐车时不重复收费。请计算你在城市里面，从出发点到目的地，乘坐电车的最低费用。
输入描述
第 111 行：MMM XXX YYY ZZZ ，其中：MMM 代表电车线路总数量，XXX 代表起点编号，YYY 代表终点编号，ZZZ 代表身上的金钱数。1<=M<=50;0<=X,Y<=500;X丨=Y:1<=Z<=5001<=M<=50;0<=X,Y<=500;X丨=Y:1<=Z<=5001<=M<=50;0<=X,Y<=500;X丨=Y:1<=Z<=500 。输入以空格分隔。下面跟着 MMM 行相同格式的数据。
第 222 行：pricepriceprice nnn station1station_1station1​ station2station_2station2​ station3station_3station3​ - sationnsation_nsationn​ ，其中：pricepriceprice 代表本条电车线路的票价，nnn 代表本条电车路线经过的站点数量、后面跟着 nnn 个数字，station1,station2,station3,...,stationnstation_1,station_2,station_3,...,station_nstation1​,station2​,station3​,...,stationn​ 代表本条电本线路经过的站点的站点编号，站点编号可能比站点总的数星大，stationnstation_nstationn​ 可能大于 nnn 。1<=n<=10,0<=stationn<=500;1<=price<=101<=n<=10,0<=station_n<=500;1<=price<=101<=n<=10,0<=stationn​<=500;1<=price<=10;
第 M+1M+1M+1 行：pricepriceprice nnn station1station_1station1​ staton2staton_2staton2​ sation3sation_3sation3​ ... stationnstation_nstationn​ 。
输出描述
需要花费的金钱数。如果无法达到或身上的金钱数不够达到，返回 −1-1−1 。
样例1
输入
5 15 12 4
2 2 7 12
3 3 4 5 15
4 1 6
3 2 15 7
1 3 12 13 7

输出
4

说明
共 555 条电车路线，要求从 151515 到 121212，可选路线包括：
aaa：乘坐线路 4(15−>7)4(15->7)4(15−>7) ，在 777 站点换乘线路 1(7−>12)1(7->12)1(7−>12)
bbb ：乘坐线路 4(15−>7)4(15->7)4(15−>7) ，在 777 站点换乘线路 5(7−>3−>12−>13)5(7->3->12->13)5(7−>3−>12−>13)
第二种乘坐方式花费更小，只需要 444
样例2
输入
2 1 6 5
2 3 1 2 7
3 3 3 6 7

输出
5

说明
从第一行输入可知，电车线路总数为 222 ，出发点编号为 111 ，终点编号为 666 ，身上的金钱数为 555 。后面接着有 222 行不定长数据。
从第二行输入可知，第一条电车路线的票价为 222 ，经过 333 个站点，站点路线为 [1,2,7][1,2,7][1,2,7] 。
从第三行输入可知，第二条电车路线的票价为 333 ，经过 333 个站点，点路线为 [3,6,7][3,6,7][3,6,7] 。
分析可得最优的乘坐策略是在 111 站点先乘坐第一辆电车到达车站 777 ，然后换乘第二辆电车到车站 666 。共花费金钱 555 ，没有超过身上的金钱数 555 ，故应返回结果 555 。

#### TextSol

解题思路
给定若干条电车线路，每条线路有固定票价 price，并给出它依次经过的一组站点。上车一次只收该线路的固定票价，在线路内任意移动不再收费；在换乘点（出现在多条线路中的同一站点）换乘到另一条线路时，需要再付那条线路的票价。求从起点站 X 到终点站 Y 的最小总票价；若不可达或最小票价大于身上钱数 Z，输出 -1。
建模与算法

将“站点内免费移动、换乘才付费”转化为线路图：
把每一条电车线路看作图中的一个节点；若两条线路有共同站点，则在它们之间连一条无权边。
费用在“进入一条线路时支付”。因此可在节点带权图上跑最短路：
初始把所有包含起点 X 的线路加入优先队列，起始代价为该线路的 price；从一条线路 u 走到相邻线路 v 的代价增量是 price[v]。当弹出队首线路已包含终点 Y 时，其代价就是最小总票价。
算法可用 Dijkstra（对非负权）实现；由于 M ≤ 50，构图也可用“站点 → 所属线路列表”的映射快速建立相邻关系。

复杂度分析

设线路数为 M (≤50)，每条线路经过站点数不超过 10。
建图：把每个站点出现的所有线路两两相连，总体 O(总站点出现次数 + M²)，数据范围下极小。
Dijkstra：O(M log M)。
额外空间：存图与队列，O(M)。

代码实现
Python
# 题面功能：给出线路与价格，求从X到Y的最小总票价；若不可达或超过Z则输出-1
import sys
import heapq

def min_cost(M, X, Y, Z, lines):
# lines: List[(price, [stations...])]
# 1) 站点 -> 线路索引列表
station_to_lines = {}
for i, (price, stations) in enumerate(lines):
for s in stations:
station_to_lines.setdefault(s, []).append(i)

# 2) 建立“线路图”邻接表（两条线路若有公共站点则相连）
adj = [set() for _ in range(M)]
for _, idxs in station_to_lines.items():
for i in idxs:
for j in idxs:
if i != j:
adj[i].add(j)

# 3) Dijkstra：进入一条线路需要支付它的price
INF = 10**18
dist = [INF] * M
start_lines = station_to_lines.get(X, [])
target_lines = set(station_to_lines.get(Y, []))
if not start_lines or not target_lines:
return -1

pq = []
for i in start_lines:
dist[i] = lines[i][0]  # 上第一条包含X的线路需付它的票价
heapq.heappush(pq, (dist[i], i))

while pq:
d, u = heapq.heappop(pq)
if d != dist[u]:
continue
if u in target_lines:          # 该线路包含Y，当前代价即最小票价
return d if d <= Z else -1
for v in adj[u]:
nd = d + lines[v][0]       # 换乘到v，需要支付v的票价
if nd < dist[v]:
dist[v] = nd
heapq.heappush(pq, (nd, v))
return -1

def main():
data = list(map(int, sys.stdin.read().split()))
it = iter(data)
M = next(it); X = next(it); Y = next(it); Z = next(it)
lines = []
for _ in range(M):
price = next(it)
n = next(it)
stations = [next(it) for _ in range(n)]
lines.append((price, stations))
ans = min_cost(M, X, Y, Z, lines)
print(ans)

if __name__ == "__main__":
main()

Java
// ACM风格：输入输出在main里，核心逻辑在外部函数；类名固定为Main
import java.util.*;

public class Main {
// 求最小总票价；不可达或超过Z则返回-1
static int minCost(int M, int X, int Y, int Z, int[] price, List<List<Integer>> lineStations) {
// 1) 站点 -> 线路索引列表
Map<Integer, List<Integer>> stationToLines = new HashMap<>();
for (int i = 0; i < M; i++) {
for (int s : lineStations.get(i)) {
stationToLines.computeIfAbsent(s, k -> new ArrayList<>()).add(i);
}
}
// 2) 邻接关系：两条线路有共同站点则相邻
List<Set<Integer>> adj = new ArrayList<>();
for (int i = 0; i < M; i++) adj.add(new HashSet<>());
for (List<Integer> idxs : stationToLines.values()) {
int sz = idxs.size();
for (int i = 0; i < sz; i++) {
for (int j = 0; j < sz; j++) {
if (i != j) adj.get(idxs.get(i)).add(idxs.get(j));
}
}
}

List<Integer> start = stationToLines.get(X);
List<Integer> target = stationToLines.get(Y);
if (start == null || target == null) return -1;
boolean[] isTarget = new boolean[M];
for (int t : target) isTarget[t] = true;

// 3) Dijkstra：进入一条线路即付该线路票价
long INF = (long)1e18;
long[] dist = new long[M];
Arrays.fill(dist, INF);
PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[0]));

for (int s : start) {
dist[s] = price[s];
pq.offer(new long[]{dist[s], s});
}

while (!pq.isEmpty()) {
long[] cur = pq.poll();
long d = cur[0];
int u = (int)cur[1];
if (d != dist[u]) continue;
if (isTarget[u]) return d <= Z ? (int)d : -1;
for (int v : adj.get(u)) {
long nd = d + price[v]; // 换乘到v要支付v的票价
if (nd < dist[v]) {
dist[v] = nd;
pq.offer(new long[]{nd, v});
}
}
}
return -1;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int M = sc.nextInt(), X = sc.nextInt(), Y = sc.nextInt(), Z = sc.nextInt();
int[] price = new int[M];
List<List<Integer>> lineStations = new ArrayList<>();
for (int i = 0; i < M; i++) {
int p = sc.nextInt(), n = sc.nextInt();
price[i] = p;
List<Integer> st = new ArrayList<>();
for (int k = 0; k < n; k++) st.add(sc.nextInt());
lineStations.add(st);
}
int ans = minCost(M, X, Y, Z, price, lineStations);
System.out.println(ans);
sc.close();
}
}

C++
// ACM风格：读入->主函数，核心逻辑放外部函数；注释中文说明思路
#include <bits/stdc++.h>
using namespace std;

// 求最小总票价；不可达或超过Z则返回-1
int min_cost(int M, int X, int Y, int Z,
const vector<int>& price,
const vector<vector<int>>& lineStations) {
// 1) 站点 -> 线路索引列表
unordered_map<int, vector<int>> stationToLines;
for (int i = 0; i < M; ++i) {
for (int s : lineStations[i]) stationToLines[s].push_back(i);
}

// 2) 建邻接：两条线路若有公共站点则相连
vector<vector<int>> adj(M);
for (auto &kv : stationToLines) {
const vector<int>& idxs = kv.second;
for (int i = 0; i < (int)idxs.size(); ++i) {
for (int j = 0; j < (int)idxs.size(); ++j) {
if (i != j) adj[idxs[i]].push_back(idxs[j]);
}
}
}

if (!stationToLines.count(X) || !stationToLines.count(Y)) return -1;
vector<char> isTarget(M, 0);
for (int t : stationToLines[Y]) isTarget[t] = 1;

// 3) Dijkstra：进入新线路需支付该线路的price
const long long INF = (long long)4e18;
vector<long long> dist(M, INF);
using P = pair<long long,int>;
priority_queue<P, vector<P>, greater<P>> pq;

for (int s : stationToLines[X]) {
dist[s] = price[s];
pq.emplace(dist[s], s);
}

while (!pq.empty()) {
auto [d, u] = pq.top(); pq.pop();
if (d != dist[u]) continue;
if (isTarget[u]) return d <= Z ? (int)d : -1;
for (int v : adj[u]) {
long long nd = d + price[v]; // 换乘到v，支付v票价
if (nd < dist[v]) {
dist[v] = nd;
pq.emplace(nd, v);
}
}
}
return -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int M, X, Y, Z;
if (!(cin >> M >> X >> Y >> Z)) return 0;
vector<int> price(M);
vector<vector<int>> lineStations(M);
for (int i = 0; i < M; ++i) {
int p, n; cin >> p >> n;
price[i] = p;
lineStations[i].resize(n);
for (int j = 0; j < n; ++j) cin >> lineStations[i][j];
}
int ans = min_cost(M, X, Y, Z, price, lineStations);
cout << ans << "\n";
return 0;
}

---

## 2025年9月24日-AI岗

### 第2题-无线网络优化中的基站聚类分析（P3791）
- 链接：https://codefun2000.com/p/P3791

> 页面标题：#P3791. 第2题-无线网络优化中的基站聚类分析

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

【问题背景】在无线网络优化中，基站的位置分布直接影响信号覆盖质量。密集区域的基站可能造成资源浪费，而稀疏区域则会出现信号覆盖不足。
【任务要求】给定nnn个基站的二维坐标，使用K-Means算法将其划分为kkk个簇，再通过计算每个簇的轮廓系数（Silhouette Coefficient），识别信号覆盖最差的簇（轮廓系数最低），并在该簇中心新增基站以优化信号覆盖。
【算法过程】

使用前kkk个基站作为初始聚类中心，执行K-Means算法。K-means的结束条件为：最大迭代次数100或者所有簇中心点移动距离都不大于1e−61e-61e−6。
计算每个簇的轮廓系数（簇内所有点的轮廓系数平均值）。
找出轮廓系数最低的簇。
输出该簇的中心坐标（保留两位小数），作为新增基站的位置。

K-Means和轮廓系数的详细介绍见“提示”。
输入描述
第一行：基站数量 nnn 和聚类簇数 kkk，之间以空格分开，其中 nnn 取值范围为 [1,500][1,500][1,500]，kkk 取值范围为 [1,120][1,120][1,120]。
接下来 nnn 行：每行两个整数，表示基站的坐标 xxx 和 yyy，其中 xxx 取值范围为 [0,5000][0,5000][0,5000]，yyy 取值范围为 [0,3000][0,3000][0,3000]。
输出描述
新增基站的坐标：x,yx,yx,y （输出结果四舍五入保留两位小数，采用 RoundingMode.HALF_EVEN）
样例1
输入
6 2
0 0
1 1
2 2
10 10
11 11
5 5

输出
8.67,8.67

说明
簇划分结果：簇 0:[(0,0),(1,1),(2,2)]0:[(0,0),(1,1),(2,2)]0:[(0,0),(1,1),(2,2)]，中心 (1,1);(1,1);(1,1); 簇 1:[(5,5),(10,10)(11,11)]1:[(5,5),(10,10)(11,11)]1:[(5,5),(10,10)(11,11)]，中心 (8.67,8.67)(8.67,8.67)(8.67,8.67) 轮廓系数:簇 000 的轮廓系数: 0.820.820.82 ;簇 111 轮廓系数: 0.350.350.35 答案:输簇 111 的中心点: (8.67,8.67)(8.67,8.67)(8.67,8.67)
样例2
输入
4 2
0 0
0 1
1 0
10 10

输出
0.33,0.33

说明
簇划分结果：簇 000 : [(0,0),(0,1)(1,0)][(0,0),(0,1)(1,0)][(0,0),(0,1)(1,0)] ，中心点: (0.33,0.33)(0.33,0.33)(0.33,0.33) ; 簇 [(10.10)][(10.10)][(10.10)] ，中心点: (10,10)(10,10)(10,10)
轮廓系数:线 000 的轮廓系数: 0.920.920.92 ;簇 111 的轮廓系数: 1.01.01.0 答案:输出簇 000 的中心点: 0.33,0.330.33,0.330.33,0.33
簇 0:[A(0,0),B(0,1),C(1,0)]0:[A(0,0),B(0,1),C(1, 0)]0:[A(0,0),B(0,1),C(1,0)] ;
簇 111 : [(10.10)][(10. 10)][(10.10)]
簇 000 的轮廓系数计算:
计算点 A(0,0)A(0,0)A(0,0) :
1、AAA 同簇平均距离为 111 : AAA 到 B(0,1)B(0,1)B(0,1) 距离 111 ，AAA 到 C(1,0)C(1,0)C(1,0) 距离 111
2、AAA 到簇 111 平均距离为 14.14214.14214.142 : AAA 到 D(10,10)D(10,10)D(10,10) 距离 14.14214.14214.142
3、AAA 的轮廓系数 s(A):0.929s(A):0.929s(A):0.929
计算点 B(0,1)B(0,1)B(0,1) :
1、BBB 同簇平均距离为 1.207:B1.207:B1.207:B 到 A(0,0)A (0,0)A(0,0) 距离 111 ，BBB 到 C(1,0)C(1,0)C(1,0) 距离 1.4141.4141.414
2、BBB 到簇 111 平均距离为 13.454:B13.454:B13.454:B 到 D(10,10)D(10,10)D(10,10) 距离 13.45413.45413.454
3、BBB 的轮廓系数 s(B):0.910s(B):0.910s(B):0.910
计算点 C(1,0):C(1,0):C(1,0):
1、CCC 同簇平均距离为 1.207:C1.207:C1.207:C 到 A(0,0)A(0,0)A(0,0) 距离 1，C1，C1，C 到 B(0,1)B(0,1)B(0,1) 距离 1.4141.4141.414
2、CCC 到簇 111 平均距离为 13.454:C13.454:C13.454:C 到 D(10,10)D(10,10)D(10,10) 距离 13.45413.45413.454
3、CCC 的轮廓数 s(C):0.910s(C):0.910s(C):0.910
簇 000 轮廓系数: (s(A)+s(b)+s(b))/3=2.749/3=0.92(s(A)+s(b)+s(b))/3=2.749/3=0.92(s(A)+s(b)+s(b))/3=2.749/3=0.92
提示
K-means的算法步骤为：

选择初始化的前 kkk 个样本作为初始聚类中心。

针对数据集中每个样本 xix_ixi​，计算它到 kkk 个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中。

针对每个类别 aja_jaj​，重新计算它的聚类中心
aj=1ci∑x∈cixa_j = \frac{1}{c_i} \sum_{x \in c_i} x
aj​=ci​1​x∈ci​∑​x
（即属于该类的所有样本的质心）。

重复上面2、3两步操作，直到达到某个中止条件（迭代次数、最小误差变化等）。

轮廓系数 (Silhouette Coefficient Index)：
1、对于一个数据点 iii，先计算它和簇内其他数据点的平均距离 aia_iai​。
2、然后计算该点与不包含该点所在簇的其他簇内数据点的平均距离 bib_ibi​（簇间相似度），选取其中距离最小的那个作为 iii 的簇间平均距离。
3、最后，计算数据点 iii 的轮廓系数：
si=bi−aimax⁡(ai,bi)
s_i = \frac{b_i - a_i}{\max(a_i, b_i)}
si​=max(ai​,bi​)bi​−ai​​
将所有数据点的轮廓系数取平均值，即得到聚类算法的整体轮廓系数。
若某个数据点所在簇的数据点数量小于等于1，则该点的轮廓系数为 000。
RoundingMode.HALF_EVEN：
1、Python默认的HALF_EVEN模式，其他语言按照如下规则处理：
HALF_EVEN也称为“银行家舍入”或“向偶数舍入”。这种模式下，当小数部分恰好为0.50.50.5时，round()会将结果舍入到最近的偶数。

round(2.55, 1) 会返回 2.62.62.6 （因为6是偶数）
round(2.65, 1) 会返回 2.62.62.6 （因为6是偶数）
round(2.75, 1) 会返回 2.82.82.8 （因为8是偶数）
round(1.15, 1) 会返回 1.21.21.2 （因为2是偶数）

▶️

#### TextSol

video solution

解题思路
相关算法与实现要点

K-Means

初始中心：取前 kkk 个点作为初始中心（简单且可重复）。

迭代过程：

分配：每个点归到欧氏距离最近的中心；
更新：每个簇的新中心为簇内点坐标的均值；

终止条件：迭代次数上限 100 次，或所有中心移动距离之和 ≤1e−6\le 1e{-6}≤1e−6。

若出现空簇，保持其中心不变（在本题给定范围下可稳定收敛；也可按需要将最远点“拉”成新簇中心，本文实现采用保持不变的简洁策略）。

轮廓系数（Silhouette）
对于样本 ppp：

a(p)a(p)a(p)：与同簇其它点的平均距离；若该簇仅单个样本，则 a(p)=0a(p)=0a(p)=0；
b(p)b(p)b(p)：与最近的其它簇内全部点的平均距离；
轮廓值：$s(p)=\dfrac{b(p)-a(p)}{\max\{a(p),\,b(p)\}} \in [-1,1]$。
簇的轮廓系数为簇内样本的 s(p)s(p)s(p) 平均值。
实现时按定义直接枚举计算，时间复杂度 O(n2)O(n^2)O(n2)，对 n≤500n\le 500n≤500 可接受。

输出与舍入

输出为被选中簇中心的 (x,y)(x,y)(x,y)，采用银行家舍入保留两位：

Python：Decimal(...).quantize(Decimal('0.00'), ROUND_HALF_EVEN)
Java：BigDecimal.setScale(2, RoundingMode.HALF_EVEN)
C++：自写“半舍六入五留双”的函数，避免默认“四舍五入”。

代码实现
Python
import sys
from decimal import Decimal, ROUND_HALF_EVEN

def kmeans(pts, k):
n = len(pts)
centers = [list(pts[i]) for i in range(k)]           # 前 k 个点做初始中心
labels = [0] * n
for _ in range(100):                                  # 最多 100 轮
# 分配：找最近中心
for i in range(n):
bi, bd = 0, (pts[i][0]-centers[0][0])**2 + (pts[i][1]-centers[0][1])**2
for c in range(1, k):
d = (pts[i][0]-centers[c][0])**2 + (pts[i][1]-centers[c][1])**2
if d < bd:
bd, bi = d, c
labels[i] = bi
# 更新：按均值重算中心
sx = [0.0]*k; sy = [0.0]*k; cnt = [0]*k
for i in range(n):
c = labels[i]; sx[c] += pts[i][0]; sy[c] += pts[i][1]; cnt[c] += 1
moved = 0.0
for c in range(k):
nx = centers[c][0]; ny = centers[c][1]
if cnt[c] > 0:
nx, ny = sx[c]/cnt[c], sy[c]/cnt[c]
moved += abs(nx - centers[c][0]) + abs(ny - centers[c][1])
centers[c][0], centers[c][1] = nx, ny
if moved <= 1e-6:                                 # 中心几乎不动则停止
break
return labels, centers

def silhouette(pts, labels, k):
n = len(pts)
groups = [[] for _ in range(k)]
for i, c in enumerate(labels): groups[c].append(i)

def dist(i, j):
dx = pts[i][0]-pts[j][0]; dy = pts[i][1]-pts[j][1]
return (dx*dx+dy*dy) ** 0.5

avg = [0.0]*k
for c in range(k):
idx = groups[c]
if not idx:
avg[c] = 0.0
continue
ssum = 0.0
for i in idx:
# a(p)
if len(idx) == 1: a = 0.0
else:
t = 0.0
for j in idx:
if j != i: t += dist(i, j)
a = t / (len(idx)-1)
# b(p)
b = float('inf')
for c2 in range(k):
if c2 == c or not groups[c2]:
continue
t = 0.0
for j in groups[c2]: t += dist(i, j)
b = min(b, t/len(groups[c2]))
if b == float('inf'): sp = 0.0
else:
m = max(a, b)
sp = 0.0 if m == 0 else (b - a) / m
ssum += sp
avg[c] = ssum / len(idx)
return avg

def rnd2(v):
return f"{Decimal(str(v)).quantize(Decimal('0.00'), rounding=ROUND_HALF_EVEN):.2f}"

def main():
data = list(map(float, sys.stdin.read().strip().split()))
if not data: return
n = int(data[0]); k = int(data[1])
pts = [(data[i], data[i+1]) for i in range(2, 2+2*n, 2)]
labels, centers = kmeans(pts, k)
sil = silhouette(pts, labels, k)
bad = min(range(k), key=lambda c: (sil[c], c))        # 轮廓系数最低
x, y = centers[bad]
print(f"{rnd2(x)},{rnd2(y)}")

if __name__ == "__main__":
main()

Java
import java.util.*;
import java.math.*;

public class Main {

static class Res {
int[] lab; double[][] cen;
Res(int[] l, double[][] c){ lab=l; cen=c; }
}

static Res kmeans(double[][] pts, int k){
int n = pts.length;
double[][] cen = new double[k][2];
for(int c=0;c<k;c++){ cen[c][0]=pts[c][0]; cen[c][1]=pts[c][1]; }
int[] lab = new int[n];

for(int it=0; it<100; it++){
// 分配
for(int i=0;i<n;i++){
int bi=0; double bd=dist2(pts[i], cen[0]);
for(int c=1;c<k;c++){
double d = dist2(pts[i], cen[c]);
if(d<bd){ bd=d; bi=c; }
}
lab[i]=bi;
}
// 更新
double[] sx=new double[k], sy=new double[k]; int[] cnt=new int[k];
for(int i=0;i<n;i++){ int c=lab[i]; sx[c]+=pts[i][0]; sy[c]+=pts[i][1]; cnt[c]++; }
double moved=0;
for(int c=0;c<k;c++){
double nx=cen[c][0], ny=cen[c][1];
if(cnt[c]>0){ nx=sx[c]/cnt[c]; ny=sy[c]/cnt[c]; }
moved += Math.abs(nx-cen[c][0])+Math.abs(ny-cen[c][1]);
cen[c][0]=nx; cen[c][1]=ny;
}
if(moved<=1e-6) break;
}
return new Res(lab, cen);
}

static double dist2(double[] a, double[] b){
double dx=a[0]-b[0], dy=a[1]-b[1];
return dx*dx+dy*dy;
}

static double[] silhouette(double[][] pts, int[] lab, int k){
int n=pts.length;
ArrayList<Integer>[] g=new ArrayList[k];
for(int i=0;i<k;i++) g[i]=new ArrayList<>();
for(int i=0;i<n;i++) g[lab[i]].add(i);

double[] avg=new double[k];
for(int c=0;c<k;c++){
ArrayList<Integer> idx=g[c];
if(idx.isEmpty()){ avg[c]=0; continue; }
double sum=0;
for(int id: idx){
double a;
if(idx.size()==1) a=0;
else{
double t=0;
for(int j: idx) if(j!=id)
t += Math.hypot(pts[id][0]-pts[j][0], pts[id][1]-pts[j][1]);
a = t/(idx.size()-1);
}
double b=Double.POSITIVE_INFINITY;
for(int c2=0;c2<k;c2++){
if(c2==c || g[c2].isEmpty()) continue;
double t=0;
for(int j: g[c2])
t += Math.hypot(pts[id][0]-pts[j][0], pts[id][1]-pts[j][1]);
b = Math.min(b, t/g[c2].size());
}
double s;
if(Double.isInfinite(b)) s=0;
else{
double m=Math.max(a,b);
s = (m==0)?0:(b-a)/m;
}
sum += s;
}
avg[c]=sum/idx.size();
}
return avg;
}

static String r2(double v){
BigDecimal bd=new BigDecimal(Double.toString(v)).setScale(2, RoundingMode.HALF_EVEN);
return String.format(java.util.Locale.US, "%.2f", bd.doubleValue());
}

public static void main(String[] args){
Scanner sc=new Scanner(System.in);
if(!sc.hasNext()) return;
int n=sc.nextInt(), k=sc.nextInt();
double[][] pts=new double[n][2];
for(int i=0;i<n;i++){ pts[i][0]=sc.nextDouble(); pts[i][1]=sc.nextDouble(); }
Res r=kmeans(pts,k);
double[] sil=silhouette(pts, r.lab, k);
int bad=0;
for(int c=1;c<k;c++) if(sil[c]<sil[bad]) bad=c;
System.out.println(r2(r.cen[bad][0])+","+r2(r.cen[bad][1]));
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

static inline double dist2(double x1,double y1,double x2,double y2){
double dx=x1-x2, dy=y1-y2; return dx*dx+dy*dy;
}
static inline double dist(double x1,double y1,double x2,double y2){
return hypot(x1-x2, y1-y2);
}

// 银行家舍入到两位
string r2(double v){
long double s = (long double)v * 100.0L;
long double f = floor(s);
long double frac = s - f;
const long double EPS = 1e-12L;
long long u;
if(frac > 0.5L + EPS) u = (long long)f + 1;
else if(frac < 0.5L - EPS) u = (long long)f;
else u = ((long long)f % 2 == 0) ? (long long)f : (long long)f + 1;
long long ip = u / 100, fp = llabs(u % 100);
ostringstream os; os<<ip<<'.'<<setw(2)<<setfill('0')<<fp; return os.str();
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n,k; if(!(cin>>n>>k)) return 0;
vector<double> x(n), y(n);
for(int i=0;i<n;i++) cin>>x[i]>>y[i];

// K-Means：前 k 个点为初始中心
vector<double> cx(k), cy(k);
for(int c=0;c<k;c++){ cx[c]=x[c]; cy[c]=y[c]; }
vector<int> lab(n);

for(int it=0; it<100; ++it){
// 分配
for(int i=0;i<n;i++){
int bi=0; double bd=dist2(x[i],y[i],cx[0],cy[0]);
for(int c=1;c<k;c++){
double d=dist2(x[i],y[i],cx[c],cy[c]);
if(d<bd){ bd=d; bi=c; }
}
lab[i]=bi;
}
// 更新
vector<double> sx(k,0), sy(k,0); vector<int> cnt(k,0);
for(int i=0;i<n;i++){ int c=lab[i]; sx[c]+=x[i]; sy[c]+=y[i]; cnt[c]++; }
double moved=0;
for(int c=0;c<k;c++){
double nx=cx[c], ny=cy[c];
if(cnt[c]>0){ nx=sx[c]/cnt[c]; ny=sy[c]/cnt[c]; }
moved += fabs(nx-cx[c])+fabs(ny-cy[c]);
cx[c]=nx; cy[c]=ny;
}
if(moved<=1e-6) break;
}

// 轮廓系数
vector<vector<int>> g(k);
for(int i=0;i<n;i++) g[lab[i]].push_back(i);
vector<double> sil(k,0.0);
for(int c=0;c<k;c++){
if(g[c].empty()) { sil[c]=0; continue; }
double sum=0;
for(int id: g[c]){
double a=0;
if(g[c].size()>1){
for(int j: g[c]) if(j!=id) a += dist(x[id],y[id],x[j],y[j]);
a /= (int)g[c].size()-1;
}
double b = numeric_limits<double>::infinity();
for(int c2=0;c2<k;c2++){
if(c2==c || g[c2].empty()) continue;
double t=0;
for(int j: g[c2]) t += dist(x[id],y[id],x[j],y[j]);
b = min(b, t/(int)g[c2].size());
}
double s = isinf(b)?0:((max(a,b)==0)?0:(b-a)/max(a,b));
sum += s;
}
sil[c] = sum / (int)g[c].size();
}

int bad=0;
for(int c=1;c<k;c++) if(sil[c]<sil[bad]) bad=c;
cout<<r2(cx[bad])<<","<<r2(cy[bad])<<"\n";
return 0;
}

---

### 第2题-移动最少的物品（P3721）
- 链接：https://codefun2000.com/p/P3721

> 页面标题：#P3721. 第2题-移动最少的物品

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一个长度为 NNN 的置物架，上面一级放置着 MMM 个物品，每个物品大小不同，占用了置物架不同大小的长度空间，且物品之间不一定连续放置，可能存在空隙。现在你想放置你自己的物品，且希望在保持物品原有顺序的情况下，尽可能不去移动置物架上已存在的物品，即你的策略是：
1.如果存在足够的长度空间能放置你的物品，则直接放置你的物品，此时移动的物品数量为 000 ;
2.或者，你可以选择从 iii 号物品开始的连续 KKK 个物品，将它们紧密排列，以获得空间，此时移动物品的数量为 KKK ，同时你将获得 KKK 个物品中间的空隙，iii 号物品向前的空隙，以及 i+ki+ki+k 号物品向后的空隙，这三个空隙1的总和空间。
给你指定的长度、物品的排列，和你需要放置的物品大小，计算移动的物品数量的最小值。
输入描述
输入格式
1.输入为 M+1M +1M+1 行
2.第一行包含三个数字: NNN MMM KKK 。其中 NNN 为置物架长度，MMM 为已经存在的物品数量，KKK 为需要放置的物品大小
3.第二行开始，每一行描述一个已经在置物架上的物品。每一行包含两个数字 SiSiSi EiEiEi 。其中 SiSiSi 代表物品的起始位置，EiEiEi 代表物品的结束位置。用例保证输入的物品顺序是从小到大排序的。
输入约束
1.0＜N＜=5∗1050＜N＜=5*10^50＜N＜=5∗105
2.0＜M＜=1050＜M＜=10^50＜M＜=105
3.0＜=Si＜Ei＜=5∗1050＜=Si＜Ei＜=5*10^50＜=Si＜Ei＜=5∗105 ，即物品一定具有长度，且不会超过置物架
4.所有数据均为整数，多个物品之间不会重叠，由输入保证
输出描述
输出数字，代表移动的物品数量的最小值
如果找不到放置的空间，输出 −1-1−1
样例1
输入
10 3 5
3 4
6 8
9 10

输出
1

说明
只需要把 [3,4)[3,4)[3,4) 物品移动到最前，则新排布为 [0,1)、[6,8)、[9,10)[0,1)、[6,8)、[9,10)[0,1)、[6,8)、[9,10)，则在区间 [1,6)[1,6)[1,6) 存在大小为 555 的空隙，可放入新物品

1、
移动前：

2、
丨       丨···丨          丨········丨          丨

3、
0          3    4            6          8           10

4、

5、
移动后：

6、
丨···丨          丨········丨          丨

7、
0     1          6         8          10

样例2
输入
16 6 6
0 1
4 6
8 9
10 11
12 13
14 15

输出
2

说明
将位于 [4,6)[4,6)[4,6) 位置的 111 号物品 和 位于 [8,9)[8,9)[8,9) 的 222 号物品、和 000 号物品紧密排列，则最新的物品排列如下图所示，可以获得大小为 666 的空间，足够放置新的大小为 555 的物品。

1、
移动前：

2、
丨···丨        丨······丨          丨···丨         丨···丨         丨···丨          丨···丨         丨

3、
0      1          4       6            8     9         10    11         12    13        14    15      1

4、
6

5、
移动后：

6、
丨···丨······丨···丨                                丨···丨           丨···丨            丨···丨             丨

7、
0      1       3     4                               10    11         12    13           14    15           16

虽然移动 [8,9)、[10,11)、[12,13)、[14,15)[8,9)、[10,11)、[12,13)、[14,15)[8,9)、[10,11)、[12,13)、[14,15) 四个物品也可以获得足够的空间，但是需要移动更多的物品

1、
移动前：

2、
丨···丨        丨······丨          丨···丨         丨···丨         丨···丨          丨···丨         丨

3、
0     1           4       6         8     9          10    11        12   13         14    15         16

4、

5、
移动后：

6、
丨···丨               丨······丨···丨···丨···丨···丨                                        丨

7、
0      1               4        6     7    8    9   10                                           16

#### TextSol

解题思路
这道题目需要我们在一个已经放置了若干物品的置物架上，找到放置新物品的最小移动成本。核心思路是检查所有可能的空隙和通过移动物品能创造的空隙，找到满足条件的最小移动次数。
具体步骤如下：

检查现有空隙：首先遍历所有已存在物品之间的空隙，以及置物架两端的空隙，看是否有足够大的空间直接放置新物品。如果有，直接返回0。
检查移动物品后的空隙：如果没有现成的足够大空隙，我们需要考虑移动连续的K个物品来创造空间。对于每个可能的连续K个物品的移动，计算移动后能获得的总空间（包括移动物品前后的空隙和物品之间的空隙），看是否能满足新物品的大小需求。
寻找最小K：我们需要找到满足条件的最小K值。可以使用滑动窗口的方法来高效地检查所有可能的连续K个物品的移动情况。

算法选择上，这属于贪心算法的应用，我们试图在每一步找到局部最优解（最小的K值），最终得到全局最优解。
复杂度分析

时间复杂度：O(M)，其中M是已有物品的数量。我们需要遍历所有物品一次来检查现有空隙，然后使用滑动窗口检查所有可能的连续K个物品的移动情况。
空间复杂度：O(M)，用于存储已有物品的位置信息。在最坏情况下，我们需要存储所有物品的起始和结束位置。

代码实现
Python
def solve():
import sys
input = sys.stdin.read().split()
ptr = 0
N = int(input[ptr])
ptr += 1
M = int(input[ptr])
ptr += 1
K = int(input[ptr])
ptr += 1

items = []
for _ in range(M):
s = int(input[ptr])
e = int(input[ptr+1])
items.append((s, e))
ptr += 2

min_moves = float('inf')

# 检查现有空隙
# 检查最前面的空隙
if items[0][0] >= K:
print(0)
return

# 检查物品之间的空隙
for i in range(M - 1):
gap = items[i+1][0] - items[i][1]
if gap >= K:
print(0)
return

# 检查最后面的空隙
if N - items[-1][1] >= K:
print(0)
return

# 需要移动物品的情况
# 使用滑动窗口找最小的K
left = 0
total_gap = 0

for right in range(M):
if right > 0:
total_gap += items[right][0] - items[right-1][1]

# 维护窗口大小，确保窗口内物品数量足够
while left <= right and (right - left + 1) > 0:
# 计算总可用空间
# 前面的空隙
front_gap = items[left][0] - (0 if left == 0 else items[left-1][1])
# 后面的空隙
back_gap = (N if right == M-1 else items[right+1][0]) - items[right][1]
# 总空间
total_space = front_gap + total_gap + back_gap

if total_space >= K:
min_moves = min(min_moves, right - left + 1)
# 尝试缩小窗口
if left < right:
total_gap -= items[left+1][0] - items[left][1]
left += 1
else:
break
else:
break

if min_moves != float('inf'):
print(min_moves)
else:
print(-1)

solve()

Java
import java.util.*;
import java.io.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] firstLine = br.readLine().split(" ");
int N = Integer.parseInt(firstLine[0]);
int M = Integer.parseInt(firstLine[1]);
int K = Integer.parseInt(firstLine[2]);

List<int[]> items = new ArrayList<>();
for (int i = 0; i < M; i++) {
String[] line = br.readLine().split(" ");
int s = Integer.parseInt(line[0]);
int e = Integer.parseInt(line[1]);
items.add(new int[]{s, e});
}

int minMoves = Integer.MAX_VALUE;

// 检查现有空隙
// 检查最前面的空隙
if (items.get(0)[0] >= K) {
System.out.println(0);
return;
}

// 检查物品之间的空隙
for (int i = 0; i < M - 1; i++) {
int gap = items.get(i+1)[0] - items.get(i)[1];
if (gap >= K) {
System.out.println(0);
return;
}
}

// 检查最后面的空隙
if (N - items.get(M-1)[1] >= K) {
System.out.println(0);
return;
}

// 需要移动物品的情况
int left = 0;
int totalGap = 0;

for (int right = 0; right < M; right++) {
if (right > 0) {
totalGap += items.get(right)[0] - items.get(right-1)[1];
}

while (left <= right) {
// 计算总可用空间
int frontGap = items.get(left)[0] - (left == 0 ? 0 : items.get(left-1)[1]);
int backGap = (right == M-1 ? N : items.get(right+1)[0]) - items.get(right)[1];
int totalSpace = frontGap + totalGap + backGap;

if (totalSpace >= K) {
minMoves = Math.min(minMoves, right - left + 1);
if (left < right) {
totalGap -= items.get(left+1)[0] - items.get(left)[1];
left++;
} else {
break;
}
} else {
break;
}
}
}

if (minMoves != Integer.MAX_VALUE) {
System.out.println(minMoves);
} else {
System.out.println(-1);
}
}
}

C++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, M, K;
cin >> N >> M >> K;

vector<pair<int, int>> items;
for (int i = 0; i < M; ++i) {
int s, e;
cin >> s >> e;
items.emplace_back(s, e);
}

int min_moves = INT_MAX;

// 检查现有空隙
// 检查最前面的空隙
if (items[0].first >= K) {
cout << 0 << endl;
return 0;
}

// 检查物品之间的空隙
for (int i = 0; i < M - 1; ++i) {
int gap = items[i+1].first - items[i].second;
if (gap >= K) {
cout << 0 << endl;
return 0;
}
}

// 检查最后面的空隙
if (N - items.back().second >= K) {
cout << 0 << endl;
return 0;
}

// 需要移动物品的情况
int left = 0;
int total_gap = 0;

for (int right = 0; right < M; ++right) {
if (right > 0) {
total_gap += items[right].first - items[right-1].second;
}

while (left <= right) {
// 计算总可用空间
int front_gap = items[left].first - (left == 0 ? 0 : items[left-1].second);
int back_gap = (right == M-1 ? N : items[right+1].first) - items[right].second;
int total_space = front_gap + total_gap + back_gap;

if (total_space >= K) {
min_moves = min(min_moves, right - left + 1);
if (left < right) {
total_gap -= items[left+1].first - items[left].second;
++left;
} else {
break;
}
} else {
break;
}
}
}

if (min_moves != INT_MAX) {
cout << min_moves << endl;
} else {
cout << -1 << endl;
}

return 0;
}

---

### 第3题-基于决策树的无线状态预策（P3792）
- 链接：https://codefun2000.com/p/P3792

> 页面标题：#P3792. 第3题-基于决策树的无线状态预策

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

通过分析基站的关键性能指标（如信息强度，干扰水平，用户数量等）。可以预测网络是否处于正常状态（标签0）或劣化状态（标签1）.决策树算法因其直观的判断逻辑和快速的响应能力，被广泛应用于无线网络智能运维场景。
给定一组基站性能特征数据和对应的网络质量标签，请实现一个基于信息增益的决策树分类器。用于判断网络质量是否劣化。信息熵定义为：
H(S)=−∑i∈Spilog⁡2(pi)H(S) = -\sum_{i \in S} p_i \log_2(p_i)
H(S)=−i∈S∑​pi​log2​(pi​)
信息熵 = 划分前熵 - 划分后条件熵
特殊情况处理：

当多个特征对应的信息增益相等时，优先选择索引较小的特征进行样本划分；
当没有特征对样本进一步划分时，该节点预测为样本数较多的标签（若标签0和标签1数量一致，则默认该节点预测为0）。

输入描述
第一行：整数 n (1≤n≤1000)n \ (1 \leq n \leq 1000)n (1≤n≤1000)，表示训练样本数量，整数 m (2≤m≤10)m \ (2 \leq m \leq 10)m (2≤m≤10) 表示特征数。
接下来 nnn 行，每行包含 m+1m + 1m+1 个整数，前  mmm 个是特征 1 ~ 特征 mmm 对应的特征值（取值为 0 或 1），最后一个是要预测的标签（ 0 或 1）。
下一行，整数 q(1≤q≤100)q (1 \le q \le 100)q(1≤q≤100)，表示查询样本数量。
接下来 qqq 行，每行包括 mmm 个整数，表示查询样本的特征值 (0 或 1)。
输出描述
输出 qqq 行，每行为一个整数（0或1），表示对应查询样本的预测类别。
样例1
输入
10 3
1 0 1 1
1 0 0 0
1 1 1 1
1 1 0 1
0 0 1 0
0 0 0 0
0 1 1 1
0 1 0 0
1 0 1 1
0 1 1 1
3
1 0 1
0 0 0
1 1 0

输出
1
0
1

说明
数据包含 101010 个样本，每个样本包含三个特征。基于训练数据，可以构建出如下决策树：

1.
[特征3]

2.
/                                                                   \

3.
/                                                                       \

4.
[特征1]                                                              [特征1]

5.
/                   \                                                     /                   \

6.
/                          \                                               /                         \

7.
标签=0                [特征2]                                   [特征2]                 标签=1

8.
/                \                            /                \

9.
/                    \                        /                    \

10.
标签=0             标签=1             标签=0           标签=1

样例2
输入
6 2
1 1 1
0 0 0
1 0 1
0 1 0
1 1 1
0 0 0
2
1 1
0 0

输出
1
0

说明
训练数据包含 666 个样本，每个样本包含两个特征(特征 111 和特征 222 )，构建得到的决策树如下：

1.
特征1

2.
/                     \

3.
/                           \

4.
标签=0                 标签=1

原始信息熵：−1/2-1/2−1/2 log(1/2)−1/2log(1/2)=1log(1/2)-1/2log(1/2)=1log(1/2)−1/2log(1/2)=1
使用特征 111 进行划分后：信息熵 =1log(1)=0=1log(1)=0=1log(1)=0 ，增益为 111
使用特征 222 进行划分后：信息熵 =0.5×0.9183+0.5×0.9183=0.9183=0.5×0.9183+0.5×0.9183=0.9183=0.5×0.9183+0.5×0.9183=0.9183，增益为 0.08170.08170.0817

#### TextSol

解题思路
本题要求用训练样本（m 个二值特征，标签为 0/1）构建一个二叉决策树（ID3），再对 q 个查询样本进行预测。
核心要点：

划分准则：使用信息增益（Entropy + Information Gain）。

节点样本集合 SSS 的熵 H(S)=−∑pilog⁡2piH(S)=-\sum p_i\log_2 p_iH(S)=−∑pi​log2​pi​（二分类时就是看 0/1 的占比）。
选择尚未使用的特征 fff 进行二分（按 0/1 分到 S0,S1S_0,S_1S0​,S1​），条件熵为
$H(S|f)=\frac{|S_0|}{|S|}H(S_0)+\frac{|S_1|}{|S|}H(S_1)$，
信息增益 IG=H(S)−H(S∣f)IG=H(S)-H(S|f)IG=H(S)−H(S∣f)。
在信息增益最大的特征上划分；若增益相等，选索引更小的特征。

停止与叶子规则（与题面特殊情况一致）：

若当前样本全为同一标签 → 返回该标签。
若没有可带来进一步划分的特征（所有剩余特征信息增益 ≤0\le 0≤0 或已用尽）→ 返回多数标签（平票返回 0）。
实现时，为了保证预测分支完整：当某次划分出现一侧子集为空，也令该子结点为多数标签叶子（平票 0）。

预测：从根开始，按结点记录的特征索引读查询样本的该特征值（0/1）走向子结点，直到叶子输出标签。

实现细节：

递归建树，传入：样本下标集合、剩余可用特征（或 used 标记）。
计算信息增益时用双计数即可（统计在该特征取 0/1 时两类数量）。
为避免浮点误差，用一个很小的 ε=1e−12\varepsilon=1e{-12}ε=1e−12 比较大小。

代码实现
Python
import sys
import math
from typing import List, Dict, Any

# 计算集合 S 的熵（S 给出为标签列表 0/1）
def entropy(labels: List[int]) -> float:
n = len(labels)
if n == 0:
return 0.0
c1 = sum(labels)
c0 = n - c1
res = 0.0
for c in (c0, c1):
if c == 0:
continue
p = c / n
res -= p * math.log2(p)
return res

# 返回多数标签（平票返回 0）
def majority_label(labels: List[int]) -> int:
c1 = sum(labels)
c0 = len(labels) - c1
return 1 if c1 > c0 else 0

# 递归建树；features 为可用特征下标列表
def build_tree(X: List[List[int]], y: List[int], idxs: List[int], features: List[int]) -> Dict[str, Any]:
# 若纯节点，直接返回叶子
labels = [y[i] for i in idxs]
if all(l == labels[0] for l in labels):
return {"leaf": True, "label": labels[0]}

# 若没有可用特征，或所有增益 <= 0，则返回多数标签
base_H = entropy(labels)
best_gain = -1.0
best_f = -1
eps = 1e-12

for f in features:
# 按特征 f 二分，统计 0/1 两侧标签
idx0, idx1 = [], []
lab0, lab1 = [], []
for i in idxs:
if X[i][f] == 0:
idx0.append(i)
lab0.append(y[i])
else:
idx1.append(i)
lab1.append(y[i])
cond = (len(idx0) / len(idxs)) * entropy(lab0) + (len(idx1) / len(idxs)) * entropy(lab1)
gain = base_H - cond
if gain > best_gain + eps or (abs(gain - best_gain) <= eps and f < best_f):
best_gain = gain
best_f = f

if best_gain <= eps or best_f == -1:
return {"leaf": True, "label": majority_label(labels)}

# 根据最优特征划分
idx0, idx1 = [], []
for i in idxs:
(idx0 if X[i][best_f] == 0 else idx1).append(i)

# 子结点：空子集用多数标签叶子填充，保证可预测
next_features = [f for f in features if f != best_f]
if len(idx0) == 0:
left_node = {"leaf": True, "label": majority_label(labels)}
else:
left_node = build_tree(X, y, idx0, next_features)

if len(idx1) == 0:
right_node = {"leaf": True, "label": majority_label(labels)}
else:
right_node = build_tree(X, y, idx1, next_features)

return {"leaf": False, "feat": best_f, "left": left_node, "right": right_node}

# 用树进行预测
def predict(tree: Dict[str, Any], x: List[int]) -> int:
node = tree
while not node["leaf"]:
f = node["feat"]
node = node["left"] if x[f] == 0 else node["right"]
return node["label"]

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
n = int(next(it))
m = int(next(it))
X, y = [], []
for _ in range(n):
row = [int(next(it)) for _ in range(m + 1)]
X.append(row[:m])
y.append(row[m])
q = int(next(it))
Q = [[int(next(it)) for _ in range(m)] for _ in range(q)]

idxs = list(range(n))
features = list(range(m))
tree = build_tree(X, y, idxs, features)

out = []
for x in Q:
out.append(str(predict(tree, x)))
print("\n".join(out))

if __name__ == "__main__":
main()

Java
import java.util.*;

/* 决策树(ID3)构建与预测：ACM 风格，读取输入并输出结果 */
public class Main {
static class Node {
boolean leaf;
int label;     // 叶子：标签
int feat;      // 非叶：特征下标
Node left;     // 特征值=0
Node right;    // 特征值=1
}

static double entropy(List<Integer> labels) {
int n = labels.size();
if (n == 0) return 0.0;
int c1 = 0;
for (int v : labels) c1 += v;
int c0 = n - c1;
double res = 0.0;
if (c0 > 0) {
double p = 1.0 * c0 / n;
res -= p * (Math.log(p) / Math.log(2));
}
if (c1 > 0) {
double p = 1.0 * c1 / n;
res -= p * (Math.log(p) / Math.log(2));
}
return res;
}

static int majorityLabel(List<Integer> labels) {
int c1 = 0;
for (int v : labels) c1 += v;
int c0 = labels.size() - c1;
return (c1 > c0) ? 1 : 0; // 平票返回 0
}

static Node buildTree(int[][] X, int[] y, List<Integer> idxs, boolean[] used) {
// 若纯节点
int first = y[idxs.get(0)];
boolean pure = true;
for (int id : idxs) if (y[id] != first) { pure = false; break; }
if (pure) {
Node leaf = new Node();
leaf.leaf = true;
leaf.label = first;
return leaf;
}

// 选择最佳特征
List<Integer> labels = new ArrayList<>();
for (int id : idxs) labels.add(y[id]);
double baseH = entropy(labels);
double bestGain = -1.0;
int bestF = -1;
double eps = 1e-12;

int m = X[0].length;
for (int f = 0; f < m; f++) {
if (used[f]) continue;
List<Integer> lab0 = new ArrayList<>();
List<Integer> lab1 = new ArrayList<>();
for (int id : idxs) {
if (X[id][f] == 0) lab0.add(y[id]);
else lab1.add(y[id]);
}
double cond = (lab0.size() * 1.0 / idxs.size()) * entropy(lab0)
+ (lab1.size() * 1.0 / idxs.size()) * entropy(lab1);
double gain = baseH - cond;
if (gain > bestGain + eps || (Math.abs(gain - bestGain) <= eps && f < bestF)) {
bestGain = gain;
bestF = f;
}
}

if (bestF == -1 || bestGain <= eps) {
Node leaf = new Node();
leaf.leaf = true;
leaf.label = majorityLabel(labels);
return leaf;
}

// 真正划分
List<Integer> idx0 = new ArrayList<>();
List<Integer> idx1 = new ArrayList<>();
for (int id : idxs) {
if (X[id][bestF] == 0) idx0.add(id); else idx1.add(id);
}

Node cur = new Node();
cur.leaf = false;
cur.feat = bestF;

used[bestF] = true;
if (idx0.isEmpty()) {
Node lf = new Node();
lf.leaf = true;
lf.label = majorityLabel(labels);
cur.left = lf;
} else {
cur.left = buildTree(X, y, idx0, used);
}
if (idx1.isEmpty()) {
Node rf = new Node();
rf.leaf = true;
rf.label = majorityLabel(labels);
cur.right = rf;
} else {
cur.right = buildTree(X, y, idx1, used);
}
used[bestF] = false; // 回溯
return cur;
}

static int predict(Node root, int[] x) {
Node p = root;
while (!p.leaf) {
p = (x[p.feat] == 0) ? p.left : p.right;
}
return p.label;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt(), m = sc.nextInt();
int[][] X = new int[n][m];
int[] y = new int[n];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) X[i][j] = sc.nextInt();
y[i] = sc.nextInt();
}
int q = sc.nextInt();
int[][] Q = new int[q][m];
for (int i = 0; i < q; i++) {
for (int j = 0; j < m; j++) Q[i][j] = sc.nextInt();
}

List<Integer> idxs = new ArrayList<>();
for (int i = 0; i < n; i++) idxs.add(i);
boolean[] used = new boolean[m];
Node root = buildTree(X, y, idxs, used);

StringBuilder sb = new StringBuilder();
for (int i = 0; i < q; i++) {
sb.append(predict(root, Q[i])).append('\n');
}
System.out.print(sb.toString());
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

/* ID3 决策树：二值特征，信息增益最大化；相等时选更小的特征索引 */

struct Node {
bool leaf;
int label;   // 叶子标签
int feat;    // 非叶特征下标
Node* left;  // 特征值 = 0
Node* right; // 特征值 = 1
Node(): leaf(true), label(0), feat(-1), left(nullptr), right(nullptr) {}
};

double entropy(const vector<int>& labels) {
int n = (int)labels.size();
if (n == 0) return 0.0;
int c1 = 0;
for (int v : labels) c1 += v;
int c0 = n - c1;
double res = 0.0;
if (c0 > 0) {
double p = 1.0 * c0 / n;
res -= p * (log(p) / log(2.0));
}
if (c1 > 0) {
double p = 1.0 * c1 / n;
res -= p * (log(p) / log(2.0));
}
return res;
}

int majorityLabel(const vector<int>& labels) {
int c1 = 0;
for (int v : labels) c1 += v;
int c0 = (int)labels.size() - c1;
return (c1 > c0) ? 1 : 0; // 平票返回 0
}

Node* buildTree(const vector<vector<int>>& X, const vector<int>& y,
const vector<int>& idxs, vector<char>& used) {
// 如果全同标签，返回叶子
bool pure = true;
for (int id : idxs) if (y[id] != y[idxs[0]]) { pure = false; break; }
if (pure) {
Node* leaf = new Node();
leaf->leaf = true;
leaf->label = y[idxs[0]];
return leaf;
}

// 选择信息增益最大的特征
vector<int> labels; labels.reserve(idxs.size());
for (int id : idxs) labels.push_back(y[id]);
double baseH = entropy(labels);
double bestGain = -1.0, eps = 1e-12;
int bestF = -1;
int m = (int)X[0].size();

for (int f = 0; f < m; ++f) {
if (used[f]) continue;
vector<int> lab0, lab1;
for (int id : idxs) {
if (X[id][f] == 0) lab0.push_back(y[id]);
else lab1.push_back(y[id]);
}
double cond = (lab0.size() * 1.0 / idxs.size()) * entropy(lab0)
+ (lab1.size() * 1.0 / idxs.size()) * entropy(lab1);
double gain = baseH - cond;
if (gain > bestGain + eps || (fabs(gain - bestGain) <= eps && f < bestF)) {
bestGain = gain; bestF = f;
}
}

if (bestF == -1 || bestGain <= eps) {
Node* leaf = new Node();
leaf->leaf = true;
leaf->label = majorityLabel(labels);
return leaf;
}

// 划分并递归
vector<int> idx0, idx1;
for (int id : idxs) {
if (X[id][bestF] == 0) idx0.push_back(id);
else idx1.push_back(id);
}

Node* cur = new Node();
cur->leaf = false;
cur->feat = bestF;
used[bestF] = 1;

if (idx0.empty()) {
Node* lf = new Node();
lf->leaf = true;
lf->label = majorityLabel(labels);
cur->left = lf;
} else cur->left = buildTree(X, y, idx0, used);

if (idx1.empty()) {
Node* rf = new Node();
rf->leaf = true;
rf->label = majorityLabel(labels);
cur->right = rf;
} else cur->right = buildTree(X, y, idx1, used);

used[bestF] = 0; // 回溯
return cur;
}

int predict(Node* root, const vector<int>& x) {
Node* p = root;
while (!p->leaf) {
p = (x[p->feat] == 0) ? p->left : p->right;
}
return p->label;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, m;
if (!(cin >> n >> m)) return 0;
vector<vector<int>> X(n, vector<int>(m));
vector<int> y(n);
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) cin >> X[i][j];
cin >> y[i];
}
int q; cin >> q;
vector<vector<int>> Q(q, vector<int>(m));
for (int i = 0; i < q; ++i)
for (int j = 0; j < m; ++j) cin >> Q[i][j];

vector<int> idxs(n);
iota(idxs.begin(), idxs.end(), 0);
vector<char> used(m, 0);
Node* root = buildTree(X, y, idxs, used);

for (int i = 0; i < q; ++i) {
cout << predict(root, Q[i]) << "\n";
}
return 0;
}

---

### 第3题-基站维护最小开销（P3722）
- 链接：https://codefun2000.com/p/P3722

> 页面标题：#P3722. 第3题-基站维护最小开销

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在大小为 m∗mm*mm∗m 的城市中分布着一些基站，这些基站需要进行例行的维护工作。维护工作由多个工作站中的工作人员来完成。工作人员可以从工作站出发，只能上下左右移动，每走一次消耗时间 111 分钟，忽略维护的手机开销（到达即完成维护）。
城市中有一些工作人员无法跨越的障碍，遇到阻碍需要绕过，假定每个工作站中工作人员数量不限。请输出最少需要多少时间，工作人员可以维护完所有的基站。请输出最少多少制间完成所有可维护基站的维护，如果出现所有基站都无法维护的情况，请返回 −1-1−1 。不考虑整个城市中都没有基站的情况，用例保证一定有需要维护的基站。
地图中，000 代表空地，可以穿过。111 代表基站，也可以穿过。222 代表障碍，无法穿过。333 代表工作站。

输入描述
第一行给出一个正整数 m(0<1000)m(0<1000)m(0<1000) 。第二行开始到第 m+1m+1m+1 行，每一行 mmm 个数字，代表地图中第 111 到 第 mmm 行的空地、基站、障碍、工作站等信息。
输出描述
请输出维护花费的最小时间
样例1
输入
3
3 2 3
2 1 2
1 0 0

输出
-1

说明
位置 [0,0][0,0][0,0] 和 [0,2][0,2][0,2] 的工作站都被障碍完全阻隔无法派出工作人员，所有基站都无法维护。
样例2
输入
3
3 1 0
1 3 0
1 0 1

输出
2

说明
工作站位置在地图的 [0,0][0,0][0,0] 和 [1,1][1,1][1,1] ，工作站同时派出工作人员维护的位置在 [0,1]、[1,0]、[2,0]、[2,2][0,1]、[1,0]、[2,0]、[2,2][0,1]、[1,0]、[2,0]、[2,2] 位置的 444 个基站，工作站 [1,1][1,1][1,1] 的工作人员维护 [2,2][2,2][2,2] 基站需要走 222 步。
工作站 [0,0][0,0][0,0] 的工作人员派出 333 名工作人员，维护位置在 [0,1]、[1,0]、[2,0][0,1]、[1,0]、[2,0][0,1]、[1,0]、[2,0] 的 333 个基站，最多需要走 222 步。维护所有基站花费的最小时间是 222 分钟。

#### TextSol

解题思路
本题本质是一个网格图上的最短路问题。由于每个工作站都可以同时、无限量地派出工作人员，并且移动代价一致（上下左右、每步 1 分钟），因此从所有工作站同时出发，在可通行的格子（0、1、3）上进行多源 BFS（图论），即可一次性得到每个位置到最近工作站的最短时间。

将所有值为 3 的工作站位置同时入队，距离置为 0。

进行 BFS 扩展：只能走到非障碍（不为 2）且未访问过的位置，邻居距离为当前距离 + 1。

BFS 完成后：

在所有基站位置（值为 1）中，取其被访问到的距离的最大值，这就是完成所有可维护（可达）基站所需的最小时间（最后到达的那一个决定总耗时）。
若不存在任何一个可达的基站（即所有 1 的位置都未被访问），按题意输出 -1。
注意：题面要求“完成所有可维护基站”，因此无法到达的基站不计入；只有在“所有基站都不可达”时才输出 -1。

该方法一次 BFS 即可获得答案，简洁高效。无需贪心、动态规划或二分等额外技巧；如果用二分时间 + 可达性检查也能做，但属于多余开销。
复杂度分析

设网格大小为 m × m，节点数 N = m^2。
时间复杂度：BFS 仅遍历每个格子及边常数次，O(N)。
空间复杂度：距离数组/访问标记与队列最多存放 N 个元素，O(N)。
在 m < 1000 的范围内，该复杂度完全可行。

代码实现
Python
import sys
import ast
from collections import deque

def min_time_to_maintain(grid, m):
# 四个方向
dirs = [(1,0), (-1,0), (0,1), (0,-1)]
# 距离数组，-1 表示未访问
dist = [[-1]*m for _ in range(m)]
q = deque()

# 收集所有工作站作为多源起点
for i in range(m):
for j in range(m):
if grid[i][j] == 3:
dist[i][j] = 0
q.append((i, j))

# BFS
while q:
x, y = q.popleft()
for dx, dy in dirs:
nx, ny = x + dx, y + dy
# 越界检查 + 非障碍 + 未访问
if 0 <= nx < m and 0 <= ny < m and grid[nx][ny] != 2 and dist[nx][ny] == -1:
dist[nx][ny] = dist[x][y] + 1
q.append((nx, ny))

# 统计所有可达基站的最大距离
ans = -1
has_base = False
for i in range(m):
for j in range(m):
if grid[i][j] == 1:
has_base = True
if dist[i][j] != -1:
ans = max(ans, dist[i][j])

# 如果存在基站但没有任何可达的基站，则返回-1；否则返回最大距离
return -1 if ans == -1 else ans

def main():
data = sys.stdin.read().strip().splitlines()
m = int(data[0].strip())
grid = []
# Python 优先使用 literal_eval：将每行空格分隔数字转成列表
# 这里通过替换空格为逗号并加上方括号，使其成为合法的Python列表字面量
for i in range(1, m + 1):
line = data[i].strip()
row = list(map(int, ast.literal_eval('[' + line.replace(' ', ',') + ']')))
grid.append(row)

print(min_time_to_maintain(grid, m))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {

static int[] dx = {1, -1, 0, 0};
static int[] dy = {0, 0, 1, -1};

// 外部函数：计算最小时间
static int minTimeToMaintain(int[][] grid, int m) {
int[][] dist = new int[m][m];
for (int i = 0; i < m; i++) {
for (int j = 0; j < m; j++) dist[i][j] = -1;
}

Queue<int[]> q = new ArrayDeque<>();

// 所有工作站作为多源起点
for (int i = 0; i < m; i++) {
for (int j = 0; j < m; j++) {
if (grid[i][j] == 3) {
dist[i][j] = 0;
q.offer(new int[]{i, j});
}
}
}

// BFS
while (!q.isEmpty()) {
int[] cur = q.poll();
int x = cur[0], y = cur[1];
for (int k = 0; k < 4; k++) {
int nx = x + dx[k];
int ny = y + dy[k];
if (nx >= 0 && nx < m && ny >= 0 && ny < m) {
if (grid[nx][ny] != 2 && dist[nx][ny] == -1) { // 非障碍且未访问
dist[nx][ny] = dist[x][y] + 1;
q.offer(new int[]{nx, ny});
}
}
}
}

// 统计所有可达基站的最大距离
int ans = -1;
boolean hasBase = false;
for (int i = 0; i < m; i++) {
for (int j = 0; j < m; j++) {
if (grid[i][j] == 1) {
hasBase = true;
if (dist[i][j] != -1) {
ans = Math.max(ans, dist[i][j]);
}
}
}
}

return ans == -1 ? -1 : ans;
}

public static void main(String[] args) throws IOException {
// 依据数据规模使用 BufferedReader + StringTokenizer（比 Scanner 更稳）
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int m = Integer.parseInt(br.readLine().trim());
int[][] grid = new int[m][m];

for (int i = 0; i < m; i++) {
String line = br.readLine();
StringTokenizer st = new StringTokenizer(line, " ");
for (int j = 0; j < m; j++) {
grid[i][j] = Integer.parseInt(st.nextToken());
}
}

int ans = minTimeToMaintain(grid, m);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int minTimeToMaintain(const vector<vector<int>>& grid, int m) {
// 四方向数组
const int dx[4] = {1, -1, 0, 0};
const int dy[4] = {0, 0, 1, -1};

// 距离数组，-1表示未访问
vector<vector<int>> dist(m, vector<int>(m, -1));
queue<pair<int,int>> q;

// 多源起点：所有工作站位置
for (int i = 0; i < m; ++i) {
for (int j = 0; j < m; ++j) {
if (grid[i][j] == 3) {
dist[i][j] = 0;
q.push({i, j});
}
}
}

// BFS
while (!q.empty()) {
auto [x, y] = q.front(); q.pop();
for (int k = 0; k < 4; ++k) {
int nx = x + dx[k];
int ny = y + dy[k];
// 越界检查 + 非障碍 + 未访问
if (nx >= 0 && nx < m && ny >= 0 && ny < m) {
if (grid[nx][ny] != 2 && dist[nx][ny] == -1) {
dist[nx][ny] = dist[x][y] + 1;
q.push({nx, ny});
}
}
}
}

// 统计可达基站的最大距离
int ans = -1;
bool hasBase = false;
for (int i = 0; i < m; ++i) {
for (int j = 0; j < m; ++j) {
if (grid[i][j] == 1) {
hasBase = true;
if (dist[i][j] != -1) {
ans = max(ans, dist[i][j]);
}
}
}
}

return (ans == -1 ? -1 : ans);
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m;
if (!(cin >> m)) return 0;
vector<vector<int>> grid(m, vector<int>(m, 0));
for (int i = 0; i < m; ++i) {
for (int j = 0; j < m; ++j) {
cin >> grid[i][j]; // 空格分隔读取
}
}

int ans = minTimeToMaintain(grid, m);
cout << ans << "\n";
return 0;
}

---

## 2025年9月18日(留学生)-AI岗

### 第2题-最大能量路径（P3718）
- 链接：https://codefun2000.com/p/P3718

> 页面标题：#P3718. 第2题-最大能量路径

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在自动驾驶系统中，车道线识别是核心功能之一。车道线通常具有连续性，从图像左侧到右侧逐渐展开。
为了识别出最可能的车道线路径，我们可以在图像中找到一条路径，使得路径上所有像素的信号值与策略矩阵的乘积之和最大。
现定义每个位置的能量值为策略矩阵与该位置周边信号值的乘积和。
给定一个 H×WH×WH×W 的图像以及一个 K×KK×KK×K 的策略矩阵，用于模拟不同方向的路径选择策略。
你需要从图像的第一列任意像素出发，走到最后一列任意像素，每一步只能向右、右上、右下移动一格。
在行进的过程中，需要实时的收集能量值，请找到一条路径，使得路径上的能量值之和最大。
输入描述
第一行输入 HHH WWW KKK KKK ，分表表示给定图像及策略矩阵的维度
接下来
HHH 行输入图像矩阵
KKK 行输入策略矩阵
输出描述
输出最大能量值
样例1
输入
1 1 1 1
5
1

输出
5.0

说明
有且仅有一条路径，最大能量值为 5∗15*15∗1 为 5.05.05.0
样例2
输入
3 3 3 3
1 2 3
4 5 6
7 8 9
1 2 2
1 1 1
1 1 1

输出
119.0

说明
输入第一行是一个 3×33×33×3 的图像以及 3×33×33×3 的策略矩阵
每个位置的能量图：
[[12.21.16.][[12.21.16.][[12.21.16.]
[30.50.36.][30.50.36.][30.50.36.]
[33.50.34.]][33.50.34.]][33.50.34.]]
最大能量路径的值：119.0119.0119.0 最大能量路径：(2,0)−>(1,1)−>(1,2)(2,0)->(1,1)->(1,2)(2,0)−>(1,1)−>(1,2)
提示
1.1.1.策略矩阵为奇数，边缘处用零填充
2.2.2.输出保留一位小数

#### TextSol

解题思路
本题可分两步完成：

能量图计算（二维相关）
将策略矩阵视为卷积核，但无需翻转（即做二维相关，correlation）：
设图像为 I（H×W），策略矩阵为 S（K×K，K 为奇数，p = K//2）。
对于每个像素 (r,c)，其能量定义为
$$E[r][c] = \sum_{i=0}^{K-1}\sum_{j=0}^{K-1} S[i][j]\cdot I[r+i-p][c+j-p]$$超出边界的图像像素按 0 填充。这样得到一幅 H×W 的能量图 E。

最大能量路径（列向动态规划）
从第一列任意行出发，到最后一列任意行，允许的移动：右上 (r-1,c+1)、右 (r,c+1)、右下 (r+1,c+1)。
设 dp[r][c] 为到达 (r,c) 的最大能量和：

初始化：dp[r][0] = E[r][0]

转移：
$$dp[r][c] = E[r][c] + \max\big(dp[r][c-1],\ dp[r-1][c-1]\ (\text{若}r>0),\ dp[r+1][c-1]\ (\text{若}r<H-1)\big)$$

答案：max⁡0≤r<Hdp[r][W−1]\max_{0\le r<H} dp[r][W-1]max0≤r<H​dp[r][W−1]

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读取首行，兼容空格或反斜杠分隔
string first;
// 跳过可能的空行
do {
if (!getline(cin, first)) return 0;
} while (first.find_first_not_of(" \t\r\n") == string::npos);

for (char &c : first) if (c == '\\') c = ' ';
stringstream ss(first);
int H, W, K;
ss >> H >> W >> K;

// 读取图像矩阵
vector<vector<double>> I(H, vector<double>(W));
for (int i = 0; i < H; ++i) {
for (int j = 0; j < W; ++j) {
cin >> I[i][j];
}
}
// 读取策略(卷积核)矩阵
vector<vector<double>> P(K, vector<double>(K));
for (int i = 0; i < K; ++i) {
for (int j = 0; j < K; ++j) {
cin >> P[i][j];
}
}

// 计算能量矩阵 E，按0填充的卷积（相关）方式
vector<vector<double>> E(H, vector<double>(W, 0.0));
int pad = K / 2;
for (int i = 0; i < H; ++i) {
for (int j = 0; j < W; ++j) {
double s = 0.0;
// 遍历核
for (int a = 0; a < K; ++a) {
for (int b = 0; b < K; ++b) {
int ii = i + a - pad;
int jj = j + b - pad;
if (0 <= ii && ii < H && 0 <= jj && jj < W) {
s += P[a][b] * I[ii][jj];
}
}
}
E[i][j] = s;
}
}

// 动态规划：从第0列走到第W-1列，允许右、右上、右下
vector<vector<double>> dp(H, vector<double>(W, -1e300));
for (int i = 0; i < H; ++i) dp[i][0] = E[i][0];

for (int j = 1; j < W; ++j) {
for (int i = 0; i < H; ++i) {
double best = dp[i][j-1];
if (i > 0) best = max(best, dp[i-1][j-1]);
if (i + 1 < H) best = max(best, dp[i+1][j-1]);
dp[i][j] = best + E[i][j];
}
}

double ans = -1e300;
for (int i = 0; i < H; ++i) ans = max(ans, dp[i][W-1]);

cout.setf(std::ios::fixed);
cout << setprecision(1) << ans << "\n";
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
H = int(next(it)); W = int(next(it)); K1 = int(next(it)); K2 = int(next(it))
K = K1  # 题面给了两个K，这里取第一个；通常两者相等

# 读图像矩阵
I = [[float(next(it)) for _ in range(W)] for _ in range(H)]
# 读策略矩阵
P = [[float(next(it)) for _ in range(K)] for _ in range(K)]

# 计算能量图（零填充卷积）
r = K // 2
E = [[0.0]*W for _ in range(H)]
for i in range(H):
for j in range(W):
s = 0.0
for u in range(K):
ii = i + (u - r)
if 0 <= ii < H:
rowI = I[ii]
rowP = P[u]
for v in range(K):
jj = j + (v - r)
if 0 <= jj < W:
s += rowP[v] * rowI[jj]
E[i][j] = s

# 动态规划
NEG = -1e300
prev = [NEG]*H
for i in range(H):
prev[i] = E[i][0]

for j in range(1, W):
cur = [NEG]*H
for i in range(H):
best = prev[i]
if i-1 >= 0:
best = max(best, prev[i-1])
if i+1 < H:
best = max(best, prev[i+1])
cur[i] = E[i][j] + best
prev = cur

ans = max(prev)
print(f"{ans:.1f}")

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;
import java.util.Locale;

public class Main {
public static void main(String[] args) throws Exception {
Locale.setDefault(Locale.US); // 确保小数点为 '.'
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
List<Double> tokens = new ArrayList<>();
String line;
// 读取所有数字（支持以空格或换行分隔）
while ((line = br.readLine()) != null) {
line = line.trim();
if (line.isEmpty()) continue;
String[] parts = line.split("\\s+");
for (String p : parts) tokens.add(Double.parseDouble(p));
}
int idx = 0;
int H = tokens.get(idx++).intValue();
int W = tokens.get(idx++).intValue();
int K1 = tokens.get(idx++).intValue();
int K2 = tokens.get(idx++).intValue();
int K = K1; // 题面给了两个K

double[][] I = new double[H][W];
for (int i = 0; i < H; i++)
for (int j = 0; j < W; j++)
I[i][j] = tokens.get(idx++);

double[][] P = new double[K][K];
for (int i = 0; i < K; i++)
for (int j = 0; j < K; j++)
P[i][j] = tokens.get(idx++);

// 计算能量图（零填充卷积）
int r = K / 2;
double[][] E = new double[H][W];
for (int i = 0; i < H; i++) {
for (int j = 0; j < W; j++) {
double s = 0.0;
for (int u = 0; u < K; u++) {
int ii = i + (u - r);
if (0 <= ii && ii < H) {
for (int v = 0; v < K; v++) {
int jj = j + (v - r);
if (0 <= jj && jj < W) {
s += P[u][v] * I[ii][jj];
}
}
}
}
E[i][j] = s;
}
}

// 动态规划：只能右、右上、右下
double NEG = -1e300;
double[] prev = new double[H];
double[] cur = new double[H];
Arrays.fill(prev, NEG);
for (int i = 0; i < H; i++) prev[i] = E[i][0];

for (int j = 1; j < W; j++) {
Arrays.fill(cur, NEG);
for (int i = 0; i < H; i++) {
double best = prev[i];
if (i - 1 >= 0) best = Math.max(best, prev[i - 1]);
if (i + 1 < H) best = Math.max(best, prev[i + 1]);
cur[i] = E[i][j] + best;
}
double[] tmp = prev; prev = cur; cur = tmp;
}

double ans = NEG;
for (int i = 0; i < H; i++) ans = Math.max(ans, prev[i]);

System.out.printf("%.1f%n", ans);
}
}

---

### 第3题-数据中心水温调节档位决策（P3719）
- 链接：https://codefun2000.com/p/P3719

> 页面标题：#P3719. 第3题-数据中心水温调节档位决策

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

数据中心的机房需要散热，一般通过水冷系统调控机房的温度。出于节能的目的，需要收集数据中心最近一段时间的业务负裁，同时结合历史信息，外界气温、湿度等因素调高或调低冷机的出水温度。
逻辑回归是比轻量的模型，其输出 000 或 111 可以分别表示调低或调高温度。
在实际使用场景中，仅判断调低或调高不能满足业务要求，需要细化到调低 111 度、调高 0.50.50.5度、维持不变、调高 0.50.50.5 度、调高 111 度等不同的"档位"。
因此，可以对逻辑回归进行改造，将其输出更改为 softmaxsoftmaxsoftmax 可满足要求。
请根据提供的观测数据，训练改造后的模型，并根据给定样本数据预测调节的档位。
优化后的模型：O=XW+b，P=softmax(O)O=XW+b，P=softmax(O)O=XW+b，P=softmax(O)。
X∈R(m,n)X∈R(m,n)X∈R(m,n) 表示 mmm 条样本，每个样本有 nnn 个特征；
W∈R(n,k)W∈R(n,k)W∈R(n,k) 为权重；kkk 是档位数(即 kkk 个分类)；
b∈R(1,k)b∈R(1,k)b∈R(1,k) 为偏置。WWW 和 bbb 通过训练得到。
P∈R(m,k)P∈R(m,k)P∈R(m,k) 表示预测的概率，取概率最大的作为输出档位。
输入描述
1.第一行是数据 schemaschemaschema，分别表示特征数 nnn ，分类数 kkk ，第 000 类样本数(即档位 000 )，第 111 类样本数，…，，…，，…，第 k−1k-1k−1 类样本数，待预测样本数 mmm ；数据均为 intintint 类型
2.后续的多行是 kkk 个分类的训练样本(按照分类 000 的多条样本、分类 111 的多条样本 、…、…、… 依次排列，一行一个样本)和 mmm 条待预测样本(一行个样本)；数据均为 floatfloatfloat 类型
输出描述
每个待预测样本所所属的分类，一行输出一个样本的预测结果
样例1
输入
2 3 2 3 2 3
9 95
33 53
53 55
69 21
68 31
70 85
80 83
25 70
45 30
79 86

输出
0
1
2

说明
1.第一行数据 222 333 222 333 222 333 ，表示每条样本 222 个特征，共有 333 个分类；分类 000 样本 222 条，分类 111 样本 333 条，分类 222 样本 222 条；测试用例 333 条
2.第 222~333 行为分类 000 样本(标签为 000 )，444~666 行为分类 111 样本(标签 111 )，777~888 行为分类 222 样本(标签为 222 )
3.最后 333 行是待预测样本
输出：333 个待预测样本的预测结果为分类 000 、分类 111 、分类 222
样例2
输入
3 3 4 3 4 5
9 95 7
33 53 13
45 43 6
40 50 11
53 55 36
69 21 55
68 31 43
70 85 23
80 83 46
70 73 55
76 78 53
25 70 6
20 69 16
45 30 50
79 86 51
70 76 36

输出
0
0
1
2
2

说明
1、第一行数据 333 333 444 333 444 555 ，表示每条样本 333 个特征，共有 333 个分类；分类 000 样本 444 条，分类 111 样本 333 条，分类 222 样本 444 条；测试用例 555 条
2.第 222~555 行为分类 000 样本(标签为 000)，666~888 行为分类 111 样本(标签 111 )，999~121212 行为分类 222 样本(标签为 222 )
3.最后 555 行是待预测样本
输出：
555 个待预测样本的预测结果为分类 000 (即档位 000 )、分类 000 、分类 111 、分类 222 、分类 222
提示
1.使用交叉熵损失函数，标签值需转为 one−hotone-hotone−hot 编码；梯度求解函数如下方公式所示，YYY 为真实标签(即 one−hotone-hotone−hot 编码)；PPP 为预测的概率(即 softmaxsoftmaxsoftmax 的输出)
2.采用批梯度下降优化参数；选择比较好的学习率(根据经验，为了加快收敛速度，初始学习率可设置较大的数值，例如 555 )；适当增加迭代次数有助于获得更精确的结果；
3.原始数据值域一般在 100100100 以内，为避免计算 softmaxsoftmaxsoftmax 越界，需要对数据集执行归一化操作。
交叉熵函数
$-\frac{1}{m} \sum_{i=1}^{m} \sum_{j=1}^{k} Y_{i, j} \log \left(P_{i, j}\right)$
损失函数对 WWW 的梯度
1mXT(P−Y)\frac{1}{m} X^{T}(P-Y)m1​XT(P−Y)
损失函数对 bbb 的梯度
$\frac{1}{m} \sum_{i=1}^{m}\left(P_{i,:}-Y_{i,:}\right)$

#### TextSol

模型与目标

线性部分：O=XW+bO=XW+bO=XW+b，其中 X∈RN×nX\in\mathbb{R}^{N\times n}X∈RN×n、W∈Rn×kW\in\mathbb{R}^{n\times k}W∈Rn×k、b∈R1×kb\in\mathbb{R}^{1\times k}b∈R1×k。

概率：PPP=softmax(O)\mathrm{softmax}(O)softmax(O)，对每行做
（减去按行最大值做数值稳定）。

损失（带 L2L_2L2​ 正则）：

梯度：

预测：对每个样本取 arg⁡max⁡jpij\arg\max_j p_{ij}argmaxj​pij​ 得到分类 0∼k−10\sim k-10∼k−1。

C++
#include <bits/stdc++.h>
using namespace std;

// 说明：实现一个多分类 softmax 回归，使用全批量梯度下降与L2正则。
// 输入：n, k, 每类样本数（k个），m；随后 N 行训练样本、m 行待预测样本
// 输出：m 行，每行一个预测类别编号

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, k;
if (!(cin >> n >> k)) return 0;

vector<int> cnt(k);
long long N = 0;
for (int i = 0; i < k; ++i) { cin >> cnt[i]; N += cnt[i]; }

int m; cin >> m;

// 读取训练数据
vector<vector<double>> X_train(N, vector<double>(n, 0.0));
for (long long i = 0; i < N; ++i) {
for (int j = 0; j < n; ++j) cin >> X_train[i][j];
}

// 生成标签（按类别顺序）
vector<int> y_train;
y_train.reserve(N);
for (int c = 0; c < k; ++c) {
for (int t = 0; t < cnt[c]; ++t) y_train.push_back(c);
}

// 读取待预测数据
vector<vector<double>> X_test(m, vector<double>(n, 0.0));
for (int i = 0; i < m; ++i) {
for (int j = 0; j < n; ++j) cin >> X_test[i][j];
}

// 特征标准化：计算均值和标准差（仅训练集）
const double eps = 1e-8;
vector<double> mu(n, 0.0), sigma(n, 0.0);
for (int j = 0; j < n; ++j) {
double s = 0.0;
for (long long i = 0; i < N; ++i) s += X_train[i][j];
mu[j] = (N ? s / N : 0.0);
}
for (int j = 0; j < n; ++j) {
double ss = 0.0;
for (long long i = 0; i < N; ++i) {
double d = X_train[i][j] - mu[j];
ss += d * d;
}
sigma[j] = sqrt((N ? ss / max(1LL, N - 1) : 0.0));
if (sigma[j] < eps) sigma[j] = 1.0; // 方差过小则置1
}
auto standardize = [&](vector<vector<double>>& X) {
for (auto &row : X) {
for (int j = 0; j < n; ++j) row[j] = (row[j] - mu[j]) / (sigma[j] + eps);
}
};
standardize(X_train);
standardize(X_test);

// 参数：W (n x k), b (k)
vector<vector<double>> W(n, vector<double>(k, 0.0));
vector<double> b(k, 0.0);

// 训练超参
int epochs = 600;        // 训练轮数
double lr = 0.1;         // 学习率
double reg = 1e-4;       // L2 正则

// 训练
vector<double> logits(k), probs(k);
for (int epoch = 0; epoch < epochs; ++epoch) {
// 梯度清零
vector<vector<double>> dW(n, vector<double>(k, 0.0));
vector<double> db(k, 0.0);

// 全批量：逐样本累积梯度
for (long long i = 0; i < N; ++i) {
// 计算 logits = X_i * W + b
for (int j = 0; j < k; ++j) {
double s = b[j];
for (int f = 0; f < n; ++f) s += X_train[i][f] * W[f][j];
logits[j] = s;
}
// softmax（数值稳定：减最大值）
double mx = *max_element(logits.begin(), logits.end());
double sumExp = 0.0;
for (int j = 0; j < k; ++j) { probs[j] = exp(logits[j] - mx); sumExp += probs[j]; }
for (int j = 0; j < k; ++j) probs[j] /= (sumExp + eps);

// 残差 = p - y_onehot
int y = y_train[i];
for (int j = 0; j < k; ++j) {
double diff = probs[j] - (j == y ? 1.0 : 0.0);
// 累积 dW 与 db
for (int f = 0; f < n; ++f) dW[f][j] += X_train[i][f] * diff;
db[j] += diff;
}
}
// 平均并加正则
double invN = (N ? 1.0 / (double)N : 1.0);
for (int f = 0; f < n; ++f) {
for (int j = 0; j < k; ++j) {
dW[f][j] = dW[f][j] * invN + reg * W[f][j];
}
}
for (int j = 0; j < k; ++j) db[j] *= invN;

// 参数更新
for (int f = 0; f < n; ++f)
for (int j = 0; j < k; ++j)
W[f][j] -= lr * dW[f][j];
for (int j = 0; j < k; ++j) b[j] -= lr * db[j];

// 可选：学习率轻微衰减（稳定训练）
if ((epoch + 1) % 150 == 0) lr *= 0.9;
}

// 预测
for (int i = 0; i < m; ++i) {
for (int j = 0; j < k; ++j) {
double s = b[j];
for (int f = 0; f < n; ++f) s += X_test[i][f] * W[f][j];
logits[j] = s;
}
int argmax = 0;
for (int j = 1; j < k; ++j) if (logits[j] > logits[argmax]) argmax = j;
cout << argmax << "\n";
}
return 0;
}

Python
# 说明：多分类 softmax 回归，使用全批量梯度下降与L2正则
# 输入输出同题面描述

import sys
import math

def read_ints():
return list(map(float, sys.stdin.readline().strip().split()))

# 为了稳妥处理空白行，使用迭代读取
tokens = []
for line in sys.stdin:
parts = line.strip().split()
if parts:
tokens.extend(parts)

it = iter(tokens)
def next_int():
return int(next(it))
def next_float():
return float(next(it))

n = next_int()
k = next_int()
cnt = [next_int() for _ in range(k)]
N = sum(cnt)
m = next_int()

# 读取训练与预测
X_train = [[next_float() for _ in range(n)] for _ in range(N)]
y_train = []
for c in range(k):
for _ in range(cnt[c]):
y_train.append(c)
X_test = [[next_float() for _ in range(n)] for _ in range(m)]

# 标准化
eps = 1e-8
mu = [0.0]*n
sigma = [0.0]*n

for j in range(n):
s = sum(X_train[i][j] for i in range(N)) if N > 0 else 0.0
mu[j] = s / N if N > 0 else 0.0
for j in range(n):
ss = 0.0
for i in range(N):
d = X_train[i][j] - mu[j]
ss += d*d
sigma[j] = math.sqrt((ss / max(1, N-1))) if N > 1 else 1.0
if sigma[j] < eps: sigma[j] = 1.0

def standardize(X):
for i in range(len(X)):
row = X[i]
for j in range(n):
row[j] = (row[j] - mu[j]) / (sigma[j] + eps)

standardize(X_train)
standardize(X_test)

# 参数
W = [[0.0]*k for _ in range(n)]
b = [0.0]*k

# 超参
epochs = 600
lr = 0.1
reg = 1e-4

# 训练
for epoch in range(epochs):
dW = [[0.0]*k for _ in range(n)]
db = [0.0]*k

for i in range(N):
# logits
logits = [b[j] + sum(X_train[i][f]*W[f][j] for f in range(n)) for j in range(k)]
mx = max(logits)
exps = [math.exp(v - mx) for v in logits]
s = sum(exps) + eps
probs = [v/s for v in exps]

y = y_train[i]
for j in range(k):
diff = probs[j] - (1.0 if j == y else 0.0)
for f in range(n):
dW[f][j] += X_train[i][f] * diff
db[j] += diff

invN = (1.0 / N) if N > 0 else 1.0
for f in range(n):
for j in range(k):
dW[f][j] = dW[f][j] * invN + reg * W[f][j]
for j in range(k):
db[j] *= invN

for f in range(n):
for j in range(k):
W[f][j] -= lr * dW[f][j]
for j in range(k):
b[j] -= lr * db[j]

if (epoch + 1) % 150 == 0:
lr *= 0.9  # 轻微衰减

# 预测
out_lines = []
for i in range(m):
logits = [b[j] + sum(X_test[i][f]*W[f][j] for f in range(n)) for j in range(k)]
argmax = max(range(k), key=lambda j: logits[j])
out_lines.append(str(argmax))

print("\n".join(out_lines))

Java
import java.io.*;
import java.util.*;

// 说明：多分类 softmax 回归，使用全批量梯度下降与L2正则
public class Main {
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
while ((c = read()) <= ' ' && c != -1) ;
if (c == -1) return null;
do { sb.append((char)c); c = read(); } while (c > ' ');
return sb.toString();
}
int nextInt() throws IOException { return Integer.parseInt(next()); }
double nextDouble() throws IOException { return Double.parseDouble(next()); }
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);
String token = fs.next();
if (token == null) return;
int n = Integer.parseInt(token);
int k = Integer.parseInt(fs.next());

int[] cnt = new int[k];
long N = 0;
for (int i = 0; i < k; i++) { cnt[i] = Integer.parseInt(fs.next()); N += cnt[i]; }
int m = Integer.parseInt(fs.next());

double[][] Xtrain = new double[(int)N][n];
for (int i = 0; i < N; i++) {
for (int j = 0; j < n; j++) Xtrain[i][j] = fs.nextDouble();
}
int[] y = new int[(int)N];
int idx = 0;
for (int c = 0; c < k; c++) {
for (int t = 0; t < cnt[c]; t++) y[idx++] = c;
}
double[][] Xtest = new double[m][n];
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) Xtest[i][j] = fs.nextDouble();
}

// 标准化
double eps = 1e-8;
double[] mu = new double[n];
double[] sigma = new double[n];
Arrays.fill(mu, 0.0);
Arrays.fill(sigma, 0.0);

for (int j = 0; j < n; j++) {
double s = 0.0;
for (int i = 0; i < N; i++) s += Xtrain[i][j];
mu[j] = (N > 0) ? s / N : 0.0;
}
for (int j = 0; j < n; j++) {
double ss = 0.0;
for (int i = 0; i < N; i++) {
double d = Xtrain[i][j] - mu[j];
ss += d * d;
}
sigma[j] = (N > 1) ? Math.sqrt(ss / Math.max(1, (int)N - 1)) : 1.0;
if (sigma[j] < eps) sigma[j] = 1.0;
}
standardizeInPlace(Xtrain, mu, sigma, eps);
standardizeInPlace(Xtest, mu, sigma, eps);

// 参数
double[][] W = new double[n][k];
double[] b = new double[k];

// 超参
int epochs = 600;
double lr = 0.1;
double reg = 1e-4;

// 训练
double[][] dW = new double[n][k];
double[] db = new double[k];
double[] logits = new double[k];
double[] probs = new double[k];

for (int epoch = 0; epoch < epochs; epoch++) {
// 梯度清零
for (int f = 0; f < n; f++) Arrays.fill(dW[f], 0.0);
Arrays.fill(db, 0.0);

for (int i = 0; i < N; i++) {
// logits
for (int j = 0; j < k; j++) {
double s = b[j];
for (int f = 0; f < n; f++) s += Xtrain[i][f] * W[f][j];
logits[j] = s;
}
// softmax（数值稳定）
double mx = logits[0];
for (int j = 1; j < k; j++) if (logits[j] > mx) mx = logits[j];
double sumExp = 0.0;
for (int j = 0; j < k; j++) {
probs[j] = Math.exp(logits[j] - mx);
sumExp += probs[j];
}
sumExp += eps;
for (int j = 0; j < k; j++) probs[j] /= sumExp;

int yy = y[i];
for (int j = 0; j < k; j++) {
double diff = probs[j] - (j == yy ? 1.0 : 0.0);
for (int f = 0; f < n; f++) dW[f][j] += Xtrain[i][f] * diff;
db[j] += diff;
}
}

double invN = (N > 0) ? (1.0 / N) : 1.0;
for (int f = 0; f < n; f++) {
for (int j = 0; j < k; j++) {
dW[f][j] = dW[f][j] * invN + reg * W[f][j];
}
}
for (int j = 0; j < k; j++) db[j] *= invN;

for (int f = 0; f < n; f++)
for (int j = 0; j < k; j++)
W[f][j] -= lr * dW[f][j];
for (int j = 0; j < k; j++) b[j] -= lr * db[j];

if ((epoch + 1) % 150 == 0) lr *= 0.9; // 轻微衰减
}

// 预测
StringBuilder sb = new StringBuilder();
for (int i = 0; i < m; i++) {
for (int j = 0; j < k; j++) {
double s = b[j];
for (int f = 0; f < n; f++) s += Xtest[i][f] * W[f][j];
logits[j] = s;
}
int argmax = 0;
for (int j = 1; j < k; j++) if (logits[j] > logits[argmax]) argmax = j;
sb.append(argmax).append('\n');
}
System.out.print(sb.toString());
}

static void standardizeInPlace(double[][] X, double[] mu, double[] sigma, double eps) {
int rows = X.length, n = mu.length;
for (int i = 0; i < rows; i++) {
for (int j = 0; j < n; j++) {
X[i][j] = (X[i][j] - mu[j]) / (sigma[j] + eps);
}
}
}
}

---

## 2025年9月17日-AI岗

### 第2题-大模型Attention模块开发（P3712）
- 链接：https://codefun2000.com/p/P3712

> 页面标题：#P3712. 第2题-大模型Attention模块开发

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

已知大模型常用的 Attention 模块定义如下：
$Y = \text{softmax}\left(\frac{QK^T}{\sqrt{h}}\right)V$
此处考虑二维情况，其中
$Q, K, V = XW_1, XW_2, XW_3 \in \mathbb{R}^{n \times h}, \quad X \in \mathbb{R}^{n \times m}, \quad W_1, W_2, W_3 \in \mathbb{R}^{m \times h}$
注意：

为简便起见，所有输入初始化为全1 1 1矩阵，所有权重矩阵初始化为上三角全 111 矩阵。

对任意矩阵 ( M ) 的 softmaxsoftmaxsoftmax 计算简化为：

$\text{softmax}(M)_{ij} = \frac{M_{ij}}{M_i}, \quad M_i = \sum_j M_{ij}$
输入描述
输入为维度参数 n,mn, mn,m和h hh，参数间使用空格隔开，均为小于 100100100 的正整数
输出描述
输出为结果矩阵  Y∈Rn×hY \in \mathbb{R}^{n \times h}Y∈Rn×h的所有元素之和，例如 151515，输出在四舍五入后保留整数
样例1
输入
3 3 3

输出
18

说明
$X =
\begin{pmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{pmatrix}, \quad
W_1, W_2, W_3 =
\begin{pmatrix}
1 & 1 & 1 \\
0 & 1 & 1 \\
0 & 0 & 1
\end{pmatrix}$
$Q, K, V =
\begin{pmatrix}
1 & 2 & 3 \\
1 & 2 & 3 \\
1 & 2 & 3
\end{pmatrix}, \quad
Y =
\begin{pmatrix}
1 & 2 & 3 \\
1 & 2 & 3 \\
1 & 2 & 3
\end{pmatrix}$
输出为：181818
样例2
输入
2 3 1

输出
2

说明
$X =
\begin{pmatrix}
1 & 1 & 1 \\
1 & 1 & 1
\end{pmatrix}, \quad
W_1, W_2, W_3 =
\begin{pmatrix}
1 \\
0 \\
0
\end{pmatrix}$
$Q, K, V =
\begin{pmatrix}
1 \\
1
\end{pmatrix}, \quad
Y =
\begin{pmatrix}
1 \\
1
\end{pmatrix}$
输出为：222
提示
输入参数不包含 000，为正整数

#### TextSol

解题思路

按题意用“暴力模拟”完整走一遍计算图：

构造 X 为 n×m 的全 1；构造 W1、W2、W3 为 m×h 的上三角全 1。
计算 Q=X·W1，K=X·W2，V=X·W3（普通三重循环矩阵乘法）。
计算 M=(Q·K^T)/sqrt(h)。
按“简化 softmax”把 M 的每一行做归一化：A[i][j]=M[i][j]/(该行元素和)。
计算 Y=A·V。
将 Y 全部元素求和，四舍五入输出整数。

算法类型：暴力模拟/矩阵运算。

由于 n、m、h < 100，直接模拟即可在时空限制内通过。

复杂度分析

矩阵乘法开销：

计算 Q、K、V：O(n·m·h)
计算 M=Q·K^T：O(n²·h)
行归一化：O(n²)
计算 Y=A·V：O(n²·h)

总时间复杂度：O(n·m·h + n²·h)。

空间复杂度：O(n·h + n²)（保存 Q、K、V、A 或 M 等中间结果）。

代码实现
Python
import sys
import ast
import numpy as np

def solve(n, m, h):
# 1) 构造 X 全 1，W 上三角全 1
X = np.ones((n, m), dtype=float)
W = np.triu(np.ones((m, h), dtype=float))  # W1=W2=W3 相同

# 2) 计算 Q, K, V（矩阵乘法）
Q = X @ W
K = X @ W
V = X @ W

# 3) 计算 M=(Q·K^T)/sqrt(h)
M = (Q @ K.T) / np.sqrt(float(h))

# 4) “简化 softmax”：按行除以行和
row_sum = M.sum(axis=1, keepdims=True)

A = M / (row_sum + 1e-12)

# 5) 计算 Y=A·V 并求和
Y = A @ V
total = float(Y.sum())

# 6) 四舍五入输出整数
return int(np.rint(total))

def main():
s = sys.stdin.read().strip()
try:
val = ast.literal_eval(s)
if isinstance(val, (list, tuple)) and len(val) == 3:
n, m, h = map(int, val)
else:
n, m, h = map(int, s.split())
except Exception:
n, m, h = map(int, s.split())

print(solve(n, m, h))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
static double[][] matmul(double[][] A, double[][] B){
int n=A.length, m=B[0].length, k=B.length;
double[][] C=new double[n][m];
for(int i=0;i<n;i++)
for(int t=0;t<k;t++){
double v=A[i][t]; if(v==0) continue;
for(int j=0;j<m;j++) C[i][j]+=v*B[t][j];
}
return C;
}
static double[][] trans(double[][] M){
int n=M.length,m=M[0].length;
double[][] T=new double[m][n];
for(int i=0;i<n;i++) for(int j=0;j<m;j++) T[j][i]=M[i][j];
return T;
}
static void rowNorm(double[][] M){
for(double[] r:M){
double s=0; for(double x:r) s+=x;
if(s==0) continue; double inv=1.0/s;
for(int j=0;j<r.length;j++) r[j]*=inv;
}
}
public static void main(String[] args){
Scanner sc=new Scanner(System.in);
int n=sc.nextInt(), m=sc.nextInt(), h=sc.nextInt();

double[][] X=new double[n][m];
for(int i=0;i<n;i++) Arrays.fill(X[i],1.0);
double[][] W=new double[m][h];
for(int i=0;i<m;i++) for(int j=i;j<h;j++) W[i][j]=1.0;

double[][] Q=matmul(X,W), K=Q, V=Q;
double[][] M=matmul(Q, trans(K));
double s=Math.sqrt(h);
if(s!=0) for(int i=0;i<M.length;i++) for(int j=0;j<M[0].length;j++) M[i][j]/=s;

rowNorm(M);
double[][] Y=matmul(M,V);

double total=0;
for(double[] r:Y) for(double x:r) total+=x;
System.out.println(Math.round(total));
sc.close();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

using Mat = vector<vector<double>>;

Mat matmul(const Mat& A, const Mat& B) {
int n=A.size(), m=B[0].size(), k=B.size();
Mat C(n, vector<double>(m, 0.0));
for (int i=0;i<n;++i)
for (int t=0;t<k;++t) if (A[i][t]!=0.0) {
double v=A[i][t];
for (int j=0;j<m;++j) C[i][j]+=v*B[t][j];
}
return C;
}
Mat trans(const Mat& M){
int n=M.size(), m=M[0].size();
Mat T(m, vector<double>(n));
for(int i=0;i<n;++i) for(int j=0;j<m;++j) T[j][i]=M[i][j];
return T;
}
void row_norm(Mat& M){ // 简化 softmax：每行除以行和
for (auto& row : M){
double s=0; for(double x:row) s+=x;
if (s==0) continue; double inv=1.0/s;
for(double& x:row) x*=inv;
}
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n,m,h; if(!(cin>>n>>m>>h)) return 0;

// X: n×m 全1；W: m×h 上三角全1
Mat X(n, vector<double>(m,1.0));
Mat W(m, vector<double>(h,0.0));
for(int i=0;i<m;++i) for(int j=i;j<h;++j) W[i][j]=1.0;

Mat Q = matmul(X,W);       // W1=W2=W3，相同
Mat K = Q, V = Q;

Mat M = matmul(Q, trans(K));
double s = sqrt((double)h);
if (s!=0) for(auto& r:M) for(double& x:r) x/=s;

row_norm(M);               // A
Mat Y = matmul(M, V);

double total=0; for(auto& r:Y) for(double x:r) total+=x;
cout << llround(total) << "\n";
return 0;
}

---

### 第2题-最大化城市CDN节点建设的最小服务质量（P3715）
- 链接：https://codefun2000.com/p/P3715

> 页面标题：#P3715. 第2题-最大化城市CDN节点建设的最小服务质量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

CDNCDNCDN(content delivery network，内容分发网络)机房可以加速网站内容的加载速度，通过在地理位置上靠近用户的地点存储网站的内容副本。
给定一个下标从 000 开始长度为 nnn 的整数数组 citiescitiescities ，其中 citiescitiescities 表示第 iii 座
城市中现有的 CDNCDNCDN 机房数量。
每个 CDNCDNCDN 机房能够服务的城市覆盖范围由其所在位置决定，所有节点具有相同的城市盖范围。
如果给定的覆盖范围是 rrr ，则位于城市 iii 的 CDNCDNCDN 机房可以为其周围 ∣i−j∣<=r∣i-j∣<=r∣i−j∣<=r 范围内的所有城市提供服务，这里 ∣x∣∣x∣∣x∣ 表示 xxx 的绝对值。例如，∣5−3∣=2，∣4−9∣=5∣5-3∣=2，∣4-9∣=5∣5−3∣=2，∣4−9∣=5 。
一座城市的“服务质量”定义为能够访问到的 CDNCDNCDN 机房的数量，你的任务是在全国范围内选择多个城市来新建 kkk 个 CDNCDNCDN 机房(同一个城市可重复建设)，以确保即使在网络流量高峰时期也能提供最佳的服务质量。
现在给定两个整数 rrr 和 kkk ，你需要决定在哪些城市新建 kkk 个 CDNCDNCDN 机房，使所有城市中最小的服务质量达到最大，并返回最小服务质量。
输入描述
第一行数字为 rrr ，第二行数字为 kkk ，第三行数字为城市数量 nnn ，第四行 nnn 个数字为 citiescitiescities 的值
输入限制：
1<=n<=1000001<=n<=1000001<=n<=100000
0<=cities[i]<=1000000<=cities[i]<=1000000<=cities[i]<=100000
0<=r<=n−10<=r<=n-10<=r<=n−1
0<=k<=1090<=k<=10^90<=k<=109
输出描述
返回所有城市中最小服务质量达到最大时的 CDNCDNCDN 节点数
样例1
输入
1
2
5
1 2 4 9 3

输出
5

说明
输入转换成 cities=[1,2,4,9,3]，r=1，k=2cities=[1,2,4,9,3]，r=1，k=2cities=[1,2,4,9,3]，r=1，k=2
最优方案之一是把 222 个节点都建在城市 111 ，建设完后每座城市的CDN节点数目分别为 [1,4,4,9,3][1,4,4,9,3][1,4,4,9,3] 。

城市 000 的节点数目为 1+4=51+4=51+4=5。

城市 111 的节点数目为 1+4+4=91+4+4=91+4+4=9 。

城市 222 的节点数目为 4+4+9=174+4+9=174+4+9=17 。

城市 333 的节点数目为 4+9+3=164+9+3=164+9+3=16 。

城市 444 的节点数目为 9+3=129+3=129+3=12 。

这些城市中节点数最小的是 555 ，已无法使得这个最小值更大。
样例2
输入
0
3
4
5 5 5 5

输出
5

说明
输入转换成 cities=[5,5,5,5]，r=0，k=3cities=[5,5,5,5]，r=0，k=3 cities=[5,5,5,5]，r=0，k=3。无论如何安排，总有一座城市的 CDNCDNCDN 节点数目是 555 ，所以最优解是 555 。

▶️

#### TextSol

video solution

题解思路
对于长度为 n 的城市数组 cities，每座城市初始拥有若干 CDN 机房。每个机房的服务半径为 r，相当于它能为相距不超过 r 的城市提供服务。给定还可以新建 k 个机房，允许在同一城市重复建设，目标是使所有城市的最小“服务质量”（即能访问到的机房总数）最大化。
我们可以抽象为：让每个城市 i “窗口”内（[i–r, i+r]）的机房总和至少达到 m，问是否能用不超过 k 次增量操作做到这一点。增量操作：在某个城市 j 新增一台机房，会使得所有覆盖到 j 的城市窗口内总和加 1。

二分答案：对最小服务质量 m 进行二分搜索。
可行性检验：固定候选值 m，判断是否在 k 次新增内使所有城市窗口和 ≥ m。
贪心策略：从城市 0 到 n–1 遍历，维护当前对每个城市由新增机房带来的累计增量 cur_add（通过差分数组模拟区间加法）。若某城市窗口和 initial[i] + cur_add 小于 m，则在最右能覆盖该城市的点 j = min(n–1, i+r) 上新增所需的机房数 need = m – (initial[i] + cur_add)，并将 need 加到差分数组上。若累计新增量超出 k，则判定不可行。

这样，每次检验的时间复杂度为 O(n)，二分需要 O(log T) 次，其中 T 约为初始最小窗口和 + k。
算法流程

前缀和
计算城市机房数的前缀和 ps，用以快速求任意区间和。

初始窗口和
对每座城市 i，计算其初始服务质量
initial[i] = sum(cities[max(0, i-r) .. min(n-1, i+r)])
= ps[min(n-1,i+r)] - ps[max(0,i-r)-1]

二分答案

lo = 0, hi = min(initial) + k
循环直至 lo < hi：设 mid = (lo + hi + 1) // 2

若 check(mid) 可行，则 lo = mid
否则 hi = mid - 1

可行性检验 check(m)

设差分数组 diff[n] 全 0，cur_add = 0，used = 0
对 i 从 0 遍历到 n-1：

cur_add += diff[i]
计算当前覆盖：cover = initial[i] + cur_add
若 cover < m，需新增 need = m - cover：

used += need，若 used > k 返回 false
选点 j = min(n-1, i+r)，其增量区间 [L = max(0,j-r), R = min(n-1,j+r)]，而此时 L=i，故：cur_add += need
if R+1 < n: diff[R+1] -= need

若遍历结束仍未超出 k，则返回 true。

返回 最终二分出的 lo。

复杂度分析

计算初始前缀和和窗口和：O(n)
每次可行性检验：O(n)
二分次数：O(log(初始最小窗口和 + k))，该值上限约 O(log(n·max(cities)+k))
总复杂度：O(n log (n·max(cities)+k))，对 n ≤ 10^5 完全可行。

代码实现
Python 实现
def max_min_service(cities, r, k):
n = len(cities)
# 1. 前缀和
ps = [0] * n
ps[0] = cities[0]
for i in range(1, n):
ps[i] = ps[i-1] + cities[i]
# 2. 初始窗口和
initial = [0] * n
for i in range(n):
L = max(0, i - r)
R = min(n - 1, i + r)
initial[i] = ps[R] - (ps[L - 1] if L > 0 else 0)
# 二分上下界
lo, hi = 0, min(initial) + k

def check(m):
diff = [0] * (n + 1)  # 差分数组，多一位便于操作
cur_add = used = 0
for i in range(n):
cur_add += diff[i]
cover = initial[i] + cur_add
if cover < m:
need = m - cover
used += need
if used > k:
return False
# 在 j 位置新增 need 台机房
j = min(n - 1, i + r)
R = min(n - 1, j + r)
# 新增在 i 开始生效，到 R 结束
cur_add += need
diff[R + 1] -= need
return True

# 二分寻找最大可行 m
while lo < hi:
mid = (lo + hi + 1) // 2
if check(mid):
lo = mid
else:
hi = mid - 1
return lo

# 读入输出
if __name__ == "__main__":
import sys
data = sys.stdin.read().split()
r, k, n = map(int, data[:3])
cities = list(map(int, data[3:]))
print(max_min_service(cities, r, k))

Java 实现
import java.io.*;
import java.util.*;

public class Main {
public static long maxMinService(int[] cities, int r, long k) {
int n = cities.length;
// 1. 前缀和
long[] ps = new long[n];
ps[0] = cities[0];
for (int i = 1; i < n; i++) {
ps[i] = ps[i-1] + cities[i];
}
// 2. 初始窗口和
long[] initial = new long[n];
for (int i = 0; i < n; i++) {
int L = Math.max(0, i - r);
int R = Math.min(n - 1, i + r);
initial[i] = ps[R] - (L > 0 ? ps[L-1] : 0);
}
long lo = 0, hi = Arrays.stream(initial).min().getAsLong() + k;

// 检验函数
class Checker {
boolean check(long m) {
long[] diff = new long[n + 1];
long curAdd = 0, used = 0;
for (int i = 0; i < n; i++) {
curAdd += diff[i];
long cover = initial[i] + curAdd;
if (cover < m) {
long need = m - cover;
used += need;
if (used > k) return false;
int j = Math.min(n - 1, i + r);
int R = Math.min(n - 1, j + r);
curAdd += need;
diff[R + 1] -= need;
}
}
return true;
}
}

Checker checker = new Checker();
while (lo < hi) {
long mid = (lo + hi + 1) >>> 1;
if (checker.check(mid)) lo = mid;
else hi = mid - 1;
}
return lo;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int r = Integer.parseInt(br.readLine());
long k = Long.parseLong(br.readLine());
int n = Integer.parseInt(br.readLine());
String[] parts = br.readLine().split(" ");
int[] cities = new int[n];
for (int i = 0; i < n; i++) cities[i] = Integer.parseInt(parts[i]);
System.out.println(maxMinService(cities, r, k));
}
}

C++ 实现
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll maxMinService(const vector<int>& cities, int r, ll k) {
int n = cities.size();
// 1. 前缀和
vector<ll> ps(n);
ps[0] = cities[0];
for (int i = 1; i < n; i++) {
ps[i] = ps[i-1] + cities[i];
}
// 2. 初始窗口和
vector<ll> initial(n);
for (int i = 0; i < n; i++) {
int L = max(0, i - r);
int R = min(n - 1, i + r);
initial[i] = ps[R] - (L > 0 ? ps[L-1] : 0);
}
ll lo = 0, hi = *min_element(initial.begin(), initial.end()) + k;

// 检验函数
auto check = [&](ll m) {
vector<ll> diff(n+1, 0);
ll curAdd = 0, used = 0;
for (int i = 0; i < n; i++) {
curAdd += diff[i];
ll cover = initial[i] + curAdd;
if (cover < m) {
ll need = m - cover;
used += need;
if (used > k) return false;
int j = min(n - 1, i + r);
int R = min(n - 1, j + r);
curAdd += need;
diff[R+1] -= need;
}
}
return true;
};

// 二分
while (lo < hi) {
ll mid = (lo + hi + 1) >> 1;
if (check(mid)) lo = mid;
else hi = mid - 1;
}
return lo;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int r; ll k; int n;
cin >> r >> k >> n;
vector<int> cities(n);
for (int i = 0; i < n; i++) {
cin >> cities[i];
}
cout << maxMinService(cities, r, k) << "\n";
return 0;
}

---

### 第3题-大模型分词（P3713）
- 链接：https://codefun2000.com/p/P3713

> 页面标题：#P3713. 第3题-大模型分词

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

您正在为一种罕见的语言构建一个专用的大语言模型。由于训练样本缺失，传统BPE BPE BPE等标准的分词器效果不佳，使得大模型推理生成的句子不理想。
幸运的是，一位语言学家为罕见的语言的已知词根和词缀(我们统称为“词元"或“TokenTokenToken”)都标注了一个“置信度”分数，这个分数代表了该词元作为一个“独立单位”的合理性，同时，语言学家还总结出了一个转移分数表，表示当前词元选择对下一个词元"置信度"的影响。
您的任务是设计并实现一个“最优分词器”，它能将输入的罕见语言句子(一个不含空格的英文小写字符多也串)切分成一系列词元，并使得所有词元的置信度分数之和达到最大，从而帮助大语言模型在后续处理中能够输出更合理的句了
输入描述
第一行输入待分词的字符串 texttexttext，假设只包含英文小写字母；
接着输入词典词条数 nnn；
然后输入nn n行，每一行包含一个单词和对应的分值，以空格分隔。
第 n+3n+3n+3 行为转移分数的个数 mmm。
随后mmm行为转移分数数据。包括起始词、下一个词、转移分数加分XXX。以空格分隔。
参数范围说明：

0<len(text)≤1000 < len(text) \leq 1000<len(text)≤100
−100≤-100 \leq−100≤ 词典中单词的得分 ≤100 \leq 100≤100
−100≤-100 \le−100≤ 词汇表置信度分数P≤100P \le 100P≤100
输入的字符串都是英文小写字母
0<0 < 0<词汇表大小 n≤100n \le 100n≤100

输出描述
返回最高的分词得分，若根据已知间汇表无法拆分则返回000、我们约定若切分成一系列词元中含有不在已知词汇表中的词，则最终得分为000。
样例1
输入
applepie
2
pen 3
apple 10
2
pen apple 5
pie apple 2

输出
0

说明
texttexttext中的字符不能和词典词条匹配出切分结果，无法计算得分。
样例2
输入
goodeats
4
good 15
goo 12
deats 14
eats 10
1
good eats -5

输出
26

说明
切分为["goodgoodgood","eatseatseats"] 的总分=15+10−5=20 = 15 + 10 - 5 = 20=15+10−5=20；
切分为 ["googoogoo","deatsdeatsdeats"] 的总分=12+14=26 = 12 + 14 = 26=12+14=26；
所以最大得分为 262626。

▶️

#### TextSol

video solution

解题思路
本题要求把一段不含空格的小写英文字符串切分为若干“词元”，并最大化：
所有词元的置信度分数之和 + 相邻词元之间的转移加分之和。
若无法完全用词表中的词覆盖整句，则输出 0。
核心算法：动态规划（DP）

设原串为 text，长度为 L。

用哈希表保存词表 score[w]（词 w 的置信度分数）与转移加分 bonus[u][v]（从词 u 到 v 的转移分）。

令 dp[i] 表示能切到下标 i（前缀 text[0:i]）的所有方案中，“以某个词结尾”的最优分数集合。

具体用：dp[i] 是一个映射 {last_word -> best_score}，表示前缀 text[0:i] 且最后一个词为 last_word 的最优总分。

转移：枚举以 i 结尾的词 w = text[j:i]（w 必须在词表中），再看前一段的结尾：

若 j == 0：这是首个词，dp[i][w] = max(dp[i][w], score[w])。
若 j > 0：需要从 dp[j] 的每个候选 u 转移，
dp[i][w] = max(dp[i][w], dp[j][u] + score[w] + bonus[u][w](若无则为0))。

答案是 dp[L] 中所有值的最大值；若 dp[L] 为空（无法完整切分），输出 0。

为降复杂度，可预先计算词表中最长词长 maxLen，只枚举长度不超过 maxLen 的后缀。

为什么不能用贪心？

因为转移加分依赖于相邻两个词，局部最优（当前词分高）并不一定带来全局最优（可能与下一词的转移分差）。因此需要 DP 统筹考虑上下文。

复杂度分析

设原串长度 L ≤ 100，词表大小 N ≤ 100，最长词长 maxLen ≤ L。
外层位置 i 共 L 次；对每个 i，仅尝试长度 ≤ maxLen 的后缀，近似 O(maxLen)；
对每个合法后缀 w，需遍历 dp[j] 的状态数（不超过词表大小 N）。
因此时间复杂度近似为 O(L × maxLen × N)，在给定数据范围内完全可行。
空间复杂度：dp 存每个位置最多 N 个词状态，故 O(L × N)。

代码实现
Python
import sys
from ast import literal_eval

def solve(text, vocab_list, trans_list):
# 构建词表分数
score = {}
max_len = 0
for w, p in vocab_list:
score[w] = p
if len(w) > max_len:
max_len = len(w)
# 构建转移加分表
bonus = {}
for u, v, x in trans_list:
if u not in bonus:
bonus[u] = {}
bonus[u][v] = x

L = len(text)
# dp[i]: dict {last_word: best_score} 覆盖 text[0:i]
dp = [dict() for _ in range(L + 1)]

# 枚举前缀终点 i
for i in range(1, L + 1):
# 只需要尝试不超过词表最长长度的后缀
up = min(max_len, i)
for l in range(1, up + 1):
w = text[i - l:i]
if w not in score:
continue
base = score[w]
j = i - l
if j == 0:
# 首词
dp[i][w] = max(dp[i].get(w, float("-inf")), base)
else:
if not dp[j]:
continue
# 从所有可能的前一词转移
for u, val in dp[j].items():
add = bonus.get(u, {}).get(w, 0)
cand = val + base + add
if cand > dp[i].get(w, float("-inf")):
dp[i][w] = cand

if not dp[L]:
return 0
return max(dp[L].values())

def main():
data = sys.stdin.read().strip().splitlines()
idx = 0
text = data[idx].strip(); idx += 1
n = literal_eval(data[idx].strip()); idx += 1

vocab_list = []
for _ in range(n):
parts = data[idx].strip().split()
w = parts[0]
p = literal_eval(parts[1])
vocab_list.append((w, p))
idx += 1

m = literal_eval(data[idx].strip()); idx += 1
trans_list = []
for _ in range(m):
parts = data[idx].strip().split()
u, v = parts[0], parts[1]
x = literal_eval(parts[2])
trans_list.append((u, v, x))
idx += 1

ans = solve(text, vocab_list, trans_list)
print(ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static int solve(String text, List<String> words, List<Integer> scores,
List<String[]> trans, List<Integer> adds) {
int L = text.length();

// 构建词表分数与最长词长
Map<String, Integer> score = new HashMap<>();
int maxLen = 0;
for (int i = 0; i < words.size(); i++) {
score.put(words.get(i), scores.get(i));
maxLen = Math.max(maxLen, words.get(i).length());
}

// 构建转移加分表 bonus[u][v] = x
Map<String, Map<String, Integer>> bonus = new HashMap<>();
for (int i = 0; i < trans.size(); i++) {
String u = trans.get(i)[0];
String v = trans.get(i)[1];
int x = adds.get(i);
if (!bonus.containsKey(u)) bonus.put(u, new HashMap<String, Integer>());
bonus.get(u).put(v, x);
}

// dp[i]: 以某个词结尾覆盖 text[0:i] 的最优分数集合
@SuppressWarnings("unchecked")
HashMap<String, Integer>[] dp = new HashMap[L + 1];
for (int i = 0; i <= L; i++) dp[i] = new HashMap<String, Integer>();

for (int i = 1; i <= L; i++) {
int up = Math.min(maxLen, i);
for (int len = 1; len <= up; len++) {
String w = text.substring(i - len, i);
if (!score.containsKey(w)) continue;
int base = score.get(w);
int j = i - len;
if (j == 0) {
int prev = dp[i].getOrDefault(w, Integer.MIN_VALUE / 4);
dp[i].put(w, Math.max(prev, base));
} else {
if (dp[j].isEmpty()) continue;
for (Map.Entry<String, Integer> e : dp[j].entrySet()) {
String u = e.getKey();
int val = e.getValue();
int add = 0;
if (bonus.containsKey(u)) {
add = bonus.get(u).getOrDefault(w, 0);
}
int cand = val + base + add;
int prev = dp[i].getOrDefault(w, Integer.MIN_VALUE / 4);
if (cand > prev) dp[i].put(w, cand);
}
}
}
}

if (dp[L].isEmpty()) return 0;
int ans = Integer.MIN_VALUE / 4;
for (int v : dp[L].values()) ans = Math.max(ans, v);
return ans;
}

public static void main(String[] args) throws Exception {
// 使用行读取 + 简单解析（替换字符/输入流组合）
BufferedReader br = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));
String text = br.readLine().trim();
int n = Integer.parseInt(br.readLine().trim());

List<String> words = new ArrayList<>();
List<Integer> scores = new ArrayList<>();
for (int i = 0; i < n; i++) {
String line = br.readLine().trim();
String[] parts = line.split("\\s+");
words.add(parts[0]);
scores.add(Integer.parseInt(parts[1]));
}

int m = Integer.parseInt(br.readLine().trim());
List<String[]> trans = new ArrayList<>();
List<Integer> adds = new ArrayList<>();
for (int i = 0; i < m; i++) {
String line = br.readLine().trim();
String[] parts = line.split("\\s+");
trans.add(new String[]{parts[0], parts[1]});
adds.add(Integer.parseInt(parts[2]));
}

int ans = solve(text, words, scores, trans, adds);
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string text;
if (!getline(cin, text)) return 0;
string line;

// 读取 n
getline(cin, line);
int n = stoi(line);

// 词表
unordered_map<string, int> score;
int maxLen = 0;
for (int i = 0; i < n; i++) {
getline(cin, line);
// 简单分割（替换字符+输入流）
stringstream ss(line);
string w; int p;
ss >> w >> p;
score[w] = p;
maxLen = max(maxLen, (int)w.size());
}

// 读取 m
getline(cin, line);
int m = stoi(line);

// 转移加分表
unordered_map<string, unordered_map<string, int>> bonus;
for (int i = 0; i < m; i++) {
getline(cin, line);
stringstream ss(line);
string u, v; int x;
ss >> u >> v >> x;
bonus[u][v] = x;
}

int L = (int)text.size();
// dp[i]: map<最后一个词, 最优总分>
vector<unordered_map<string, int>> dp(L + 1);

for (int i = 1; i <= L; i++) {
int up = min(maxLen, i);
for (int len = 1; len <= up; len++) {
string w = text.substr(i - len, len);
auto itw = score.find(w);
if (itw == score.end()) continue;
int base = itw->second;
int j = i - len;
if (j == 0) {
auto it = dp[i].find(w);
if (it == dp[i].end()) dp[i][w] = base;
else it->second = max(it->second, base);
} else {
if (dp[j].empty()) continue;
for (auto &pr : dp[j]) {
const string &u = pr.first;
int val = pr.second;
int add = 0;
auto itu = bonus.find(u);
if (itu != bonus.end()) {
auto itv = itu->second.find(w);
if (itv != itu->second.end()) add = itv->second;
}
int cand = val + base + add;
auto it = dp[i].find(w);
if (it == dp[i].end()) dp[i][w] = cand;
else it->second = max(it->second, cand);
}
}
}
}

if (dp[L].empty()) {
cout << 0 << "\n";
} else {
int ans = INT_MIN / 4;
for (auto &pr : dp[L]) ans = max(ans, pr.second);
cout << ans << "\n";
}
return 0;
}

---

### 第3题-虚拟货币挖矿算力匹配（P3716）
- 链接：https://codefun2000.com/p/P3716

> 页面标题：#P3716. 第3题-虚拟货币挖矿算力匹配

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一个虚拟货币挖矿系统中，每个矿工拥有一定的算力值nnn(范围在111 到101810^{18}1018之间)。系统需要为每个矿工分配一个算力档位，这个档位必须是小于等于矿工当前算力nnn的最大“稳定算力档”，并且这个档位的算力值各个数位之和必须是一个质数(质数又称素数。一个大于111的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数)。“稳定算力档”定义为从左到右每一位数字都不小于前一位数字，例如123、111、399123、111、399123、111、399都是符合要求的稳定算力档，像121、897121、897121、897
这种则不符合要求。合理分配算力档位有助于提高挖矿效率和稳定性。
输入描述
给定一个正整数n(1≤n≤1018)n(1≤n≤10^{18})n(1≤n≤1018)
输出描述
返回小于等于nnn的最大稳定算力档，且该整数的所有数位之和为质数。如果不存在这样的整数，则返回−1-1−1
样例1
输入
111

输出
111

说明
111111111本身即是"稳定算力档"，从左到右每一位数字都不小于前一位数字，1+1+1=31+1+1=31+1+1=3是质数，所以函数返回111111111
样例2
输入
1

输出
-1

说明
小于等于111的"稳定算力档"只有111,111的数位之和为111,111不是质数(质数定义为大于111的自然数中，除了111和它自身外，不能被其他自然数整除的数)，所以函数返回−1-1−1
样例3
输入
123

输出
122

说明
首先小于等于123123123的“稳定算力档"有 123、122、111123、122、111123、122、111等。123123123 的数位之和为1+2+3=61+2+3=61+2+3=6,不是质数，不符合条件。再继续找是122122122，数位之和为1+2+2=51+2+2=51+2+2=5是质数符合"稳定算力档条件。111111111的数位之和1+1+1=31+1+1=31+1+1=3也为质数也满足"稳定算力档"的条件，但111111111小于122122122，所以小于等于nnn的最大稳定算力档为122122122，函数返回122122122。

#### TextSol

解题思路
算法概述

转成字符串处理
将输入的正整数 nnn 转为长度为 LLL 的字符串 s。
贪心+回溯构造
从最高位到最低位逐位决定数字。对第 i 位，我们在合法范围内（若受上界约束则不超过 s[i]，否则不超过 9；且不小于前一位已定的数字）的候选数字中，从大到小尝试最优选择。
可行性剪枝
每选一个数字 d 之后，根据当前已选的数字和剩余位置，可算出可能的最小/最大剩余位数和：新和 newSum = sumSoFar + d
剩余位数 rem = L−i−1
最小可能总和 lo = newSum + d*rem
最大可能总和 hi = newSum + 9*rem

如果区间 [lo, hi] 中不存在质数，则跳过该 d。
多长度尝试
若在与 nnn 同长度下无法找到解，则依次尝试长度 L−1,L−2,…,1L−1,L−2,…,1L−1,L−2,…,1，每次将上界字符串设为全 ‘9’。

质数及前缀和预处理

最大可能的数位和为 9×18=1629\times18=1629×18=162，预先用线性筛算出 isPrime[0..162]，并构造前缀和数组 primeCnt[i] 表示小于等于 i 的质数个数。
区间 [lo, hi] 存在质数 当且仅当primeCnt[hi] − primeCnt[lo−1] > 0

复杂度分析

数字长度 L≤18L\le18L≤18。
每一位最多枚举 10 个候选数字，并做 O(1)O(1)O(1) 的区间质数查询。
回溯最坏情况也在 O(L×10)O(L\times10)O(L×10) 量级。
最多尝试 LLL 种不同长度，故总体复杂度 O(L2×10)O(L^2\times10)O(L2×10)，常数非常小，可视为 O(1)O(1)O(1) 级别。

代码实现
Python
import sys

def main():
s = sys.stdin.readline().strip()
L = len(s)
# 预处理质数和前缀和
MAXS = 9 * 18
is_prime = [False, False] + [True] * (MAXS - 1)
for i in range(2, int(MAXS**0.5) + 1):
if is_prime[i]:
for j in range(i*i, MAXS+1, i):
is_prime[j] = False
prime_cnt = [0] * (MAXS + 1)
cnt = 0
for i in range(MAXS + 1):
if is_prime[i]:
cnt += 1
prime_cnt[i] = cnt

# 在上界 bound_str 下搜索最大解，找不到返回空串
def search(bound_str):
m = len(bound_str)
bd = list(map(int, bound_str))
res = [0] * m

def dfs(pos, prev, tight, ssum):
if pos == m:
return is_prime[ssum]
max_d = bd[pos] if tight else 9
for d in range(max_d, prev - 1, -1):
new_sum = ssum + d
rem = m - pos - 1
lo = new_sum + d * rem
hi = new_sum + 9 * rem
# 区间 [lo, hi] 必须包含质数
if lo <= hi and prime_cnt[hi] - (prime_cnt[lo-1] if lo > 0 else 0) == 0:
continue
res[pos] = d
if dfs(pos+1, d, tight and d == max_d, new_sum):
return True
return False

return ''.join(map(str, res)) if dfs(0, 1, True, 0) else ''

# 主流程：先试原长度，再依次尝试全9的更短长度
ans = ''
for k in range(L, 0, -1):
bound = s if k == L else '9' * k
ans = search(bound)
if ans:
print(ans)
return
print(-1)

if __name__ == '__main__':
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static boolean[] isPrime;
static int[] primeCnt;
static int[] bd, res;
static int m;

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s = br.readLine().trim();
int L = s.length();
// 预处理
int MAXS = 9 * 18;
isPrime = new boolean[MAXS + 1];
Arrays.fill(isPrime, true);
isPrime[0] = isPrime[1] = false;
for (int i = 2; i * i <= MAXS; i++) {
if (isPrime[i]) {
for (int j = i * i; j <= MAXS; j += i) {
isPrime[j] = false;
}
}
}
primeCnt = new int[MAXS + 1];
int cnt = 0;
for (int i = 0; i <= MAXS; i++) {
if (isPrime[i]) cnt++;
primeCnt[i] = cnt;
}

// 先试原长度，再试全9的更短长度
for (int k = L; k >= 1; k--) {
String bound = (k == L ? s : String.join("", Collections.nCopies(k, "9")));
String ans = search(bound);
if (!ans.isEmpty()) {
System.out.println(ans);
return;
}
}
System.out.println(-1);
}

// 在字符串 bound 下搜索
static String search(String bound) {
m = bound.length();
bd = new int[m];
res = new int[m];
for (int i = 0; i < m; i++) bd[i] = bound.charAt(i) - '0';
return dfs(0, 1, true, 0) ? build() : "";
}

// 回溯尝试
static boolean dfs(int pos, int prev, boolean tight, int sum) {
if (pos == m) return isPrime[sum];
int maxD = tight ? bd[pos] : 9;
for (int d = maxD; d >= prev; d--) {
int newSum = sum + d;
int rem = m - pos - 1;
int lo = newSum + d * rem;
int hi = newSum + 9 * rem;
if (lo <= hi && primeCnt[hi] - (lo > 0 ? primeCnt[lo - 1] : 0) == 0)
continue;
res[pos] = d;
if (dfs(pos + 1, d, tight && d == maxD, newSum))
return true;
}
return false;
}

static String build() {
StringBuilder sb = new StringBuilder();
for (int d : res) sb.append(d);
return sb.toString();
}
}

C++
#include <bits/stdc++.h>
using namespace std;

const int MAXS = 9 * 18;
bool isPrime[MAXS+1];
int primeCnt[MAXS+1];
string boundStr;
vector<int> bd, res;
int m;

bool dfs(int pos, int prev, bool tight, int sum) {
if (pos == m) return isPrime[sum];
int maxD = tight ? bd[pos] : 9;
for (int d = maxD; d >= prev; d--) {
int newSum = sum + d;
int rem = m - pos - 1;
int lo = newSum + d * rem;
int hi = newSum + 9 * rem;
int cnt = primeCnt[min(hi, MAXS)] - (lo > 0 ? primeCnt[lo-1] : 0);
if (lo <= hi && cnt == 0) continue;
res[pos] = d;
if (dfs(pos+1, d, tight && d==maxD, newSum)) return true;
}
return false;
}

string searchBound(const string &s) {
boundStr = s;
m = s.size();
bd.assign(m, 0);
res.assign(m, 0);
for (int i = 0; i < m; i++) bd[i] = s[i] - '0';
if (!dfs(0, 1, true, 0)) return "";

string ans;
for (int d : res) ans += char('0' + d);
return ans;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

string s;
if (!(cin >> s)) return 0;
// 预处理质数和前缀和
fill(isPrime, isPrime+MAXS+1, true);
isPrime[0] = isPrime[1] = false;
for (int i = 2; i*i <= MAXS; i++) {
if (isPrime[i]) {
for (int j = i*i; j <= MAXS; j += i)
isPrime[j] = false;
}
}
int cnt = 0;
for (int i = 0; i <= MAXS; i++) {
if (isPrime[i]) cnt++;
primeCnt[i] = cnt;
}

int L = s.size();
for (int k = L; k >= 1; k--) {
string bound = (k==L ? s : string(k, '9'));
string ans = searchBound(bound);
if (!ans.empty()) {
cout << ans;
return 0;
}
}
cout << -1;
return 0;
}

---

## 2025年9月12日-AI岗

### 第2题-二叉树中序遍历的第k个祖先节点（P3657）
- 链接：https://codefun2000.com/p/P3657

> 页面标题：#P3657. 第2题-二叉树中序遍历的第k个祖先节点

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在大规模语言模型 (LLM(LLM(LLM MOE)MOE)MOE) 架构中，每一层的 MLPMLPMLP 模块中有若干个专家。用一颗二叉树把这些专家组织起来，二叉树的每个节点是一个专家。
现给定一个二叉树的根节点，以及两个整数 uuu 和 kkk 。任务是找出节点在二叉树中序遍历序列中的第 kkk 个祖先节点的值。
一个节点的祖先节点是指从根节点到该节点路径上的所有节点(不包括该节点本身)。
这里，“第 kkk 个祖先”指的是在中序遍历序列中，位于节点 uuu 前面的所有祖先节点中的第 kkk 个位置祖先节点。如果这样的祖先节点不存在，则返回 −1-1−1。
输入描述
输入将包含两行。
第一行是一个字符串，表示一棵二叉树：
<1>空节点用 '#' 表示;
<2>非空节点的值为整数;
<3>节点之间用一个空格分隔;
<4>树的层次遍历顺序给出比如，"123123123##454545“ 表示根节点为 111 ，左子节点为 222 ，右子节点为 333 ; 222 没有子节点; 333 的左子节点为 444 ，右子节点为 555 。
第二行包含两个整数 uuu 和 kkk ，分别表示目标节点的值和要查找的祖先节点的偏移量, 一个空格分隔这两个值。
输出描述
一个整数，表示在中序遍历序列中节点 uuu 的第 kkk 个祖先节点的值。如果不存在，则返回 −1-1−1 。
样例1
输入
30 15 45 7 20 35 50 # # 18 # # 40
40 3

输出
-1

说明
二叉树结构如下：

中序遍历的顺序是：7,15,18,20,30,35,40,45,507,15,18,20,30,35,40,45,507,15,18,20,30,35,40,45,50。
节点 u=40u=40u=40 。在中序遍历序列中，位于 404040 前面的节点有 7,15,18,20,30,357,15,18,20,30,357,15,18,20,30,35 。
节点 404040 的祖先节点有 30,45,3530,45,3530,45,35 。
在祖先节点中，在中序遍历序列中位于 404040 前面的有 30,3530,3530,35 。
按照中序遍历顺序，其前面的祖先节点有： 30,3530,3530,35。
第 K=3K=3K=3 个祖先节点(即在 404040 前面第三个位置的祖先节点)不存在。
样例2
输入
10 5 15 2 7 12 18
7 1

输出
5

说明
二叉树结构如下：

中序遍历的顺序是：2,5,7,10,12,15,182,5,7,10,12,15,182,5,7,10,12,15,18 。
节点 u=7u=7u=7 。在中序遍历序列中，位于 777 前面的节点有 2,52,52,5 。
第 k=1k=1k=1 个祖先(即在 777 前面第二个位置的祖先)是 555 。

▶️

#### TextSol

video solution

解题思路
关键定义回顾

祖先：根到节点 u 路径上的所有节点（不含 u）。
“中序前面的祖先”：把整棵树做一次中序遍历，沿序列从左到右走，记录在到达 u 之前出现的、同时又是 u 的祖先的那些节点，按出现顺序计数，第 k 个即答案；若不足 k 个返回 -1。

总体算法（一次建树 + 一次中序，O(n)）

按层次序列建树

输入是层次遍历（BFS）序列，空节点为 #。

用队列逐层挂接左右孩子；同时维护：

parent：节点 → 父节点 指针（便于之后找祖先）；
val2node：值 → 节点 指针（便于定位 u）。

说明：题目通常默认结点值唯一，若不唯一则需用“节点身份”而非“值”来定位；本题按样例与常规题型 默认值唯一。

若不存在值为 u 的节点：直接输出 -1。

得到祖先集合

从 val2node[u] 沿 parent 回溯到根，放入一个 anc 哈希集合，表示 u 的全部祖先。

一次中序遍历并计数

进行中序遍历（左—根—右），维护一个计数器 cnt。

每访问到一个节点 x：

若 x == u，停止遍历：若 cnt >= k 则答案在“前面的祖先”中第 k 个；反之 -1。
若 x 在 anc 集合中，则 cnt += 1，当 cnt == k 时把当前节点值记为 ans_k（因为之后还可能没到 u，先保存，等遇到 u 再输出）。

结束条件：遍历到 u 即可（不用遍历全树）。

该策略直接把“在中序序列里位于 u 之前且为祖先”的定义转化为一次遍历的在线计数，无需额外数组与二分。

复杂度分析

设节点数为 n。
建树：O(n)；构造 parent/val2node：O(n)；
中序遍历直到遇到 u：最坏 O(n)；
总时间复杂度：O(n)；空间复杂度：O(n)（队列、映射、祖先集合与递归/显式栈）。

代码实现
Python 实现
import sys
from collections import deque

class Node:
def __init__(self, v):
self.v = v
self.l = None
self.r = None

def build_tree(tokens):
# 空或首元素为# => 空树
if not tokens or tokens[0] == '#':
return None, {}, {}
it = 0
root = Node(int(tokens[it]))
it += 1
q = deque([root])
parent = {root: None}
val2node = {root.v: root}
# 逐个为队首节点挂接左右孩子
while q and it < len(tokens):
cur = q.popleft()
# 左孩子
if it < len(tokens):
t = tokens[it]; it += 1
if t != '#':
left = Node(int(t))
cur.l = left
parent[left] = cur
val2node[left.v] = left
q.append(left)
# 右孩子
if it < len(tokens):
t = tokens[it]; it += 1
if t != '#':
right = Node(int(t))
cur.r = right
parent[right] = cur
val2node[right.v] = right
q.append(right)
return root, parent, val2node

def kth_ancestor_in_inorder_before_u(root, parent, val2node, u, k):
# u不存在
if u not in val2node:
return -1
u_node = val2node[u]
# 收集u的全部祖先到集合
anc = set()
p = parent.get(u_node)
while p is not None:
anc.add(p)
p = parent.get(p)
# 中序遍历（显式栈），计数祖先并在遇到u时判定
stack = []
cur = root
cnt = 0
ans_k = None  # 提前保存第k个祖先的值
while stack or cur:
while cur:
stack.append(cur)
cur = cur.l
cur = stack.pop()
# 访问cur
if cur is u_node:
# 到达u，返回结果（若此前出现了第k个祖先）
return ans_k if cnt >= k else -1
if cur in anc:
cnt += 1
if cnt == k:
ans_k = cur.v
# 继续右子树
cur = cur.r
return -1

def main():
data = sys.stdin.read().strip().splitlines()
if len(data) < 2:
print(-1)
return
tokens = data[0].strip().split()
u, k = map(int, data[1].strip().split())
root, parent, val2node = build_tree(tokens)
ans = kth_ancestor_in_inorder_before_u(root, parent, val2node, u, k)
print(ans)

if __name__ == "__main__":
main()

Java 实现
import java.io.*;
import java.util.*;

public class Main {

static class Node {
int v;
Node l, r;
Node(int v) { this.v = v; }
}

static class BuildResult {
Node root;
Map<Node, Node> parent;
Map<Integer, Node> val2node;
BuildResult(Node root, Map<Node, Node> parent, Map<Integer, Node> val2node) {
this.root = root; this.parent = parent; this.val2node = val2node;
}
}

// 构建二叉树（层次遍历）
static BuildResult buildTree(String[] tok) {
if (tok.length == 0 || tok[0].equals("#")) {
return new BuildResult(null, new HashMap<>(), new HashMap<>());
}
int it = 0;
Node root = new Node(Integer.parseInt(tok[it++]));
Queue<Node> q = new ArrayDeque<>();
q.add(root);
Map<Node, Node> parent = new HashMap<>();
parent.put(root, null);
Map<Integer, Node> val2node = new HashMap<>();
val2node.put(root.v, root);

while (!q.isEmpty() && it < tok.length) {
Node cur = q.poll();
// 左孩子
if (it < tok.length) {
String t = tok[it++];
if (!t.equals("#")) {
Node left = new Node(Integer.parseInt(t));
cur.l = left;
parent.put(left, cur);
val2node.put(left.v, left);
q.add(left);
}
}
// 右孩子
if (it < tok.length) {
String t = tok[it++];
if (!t.equals("#")) {
Node right = new Node(Integer.parseInt(t));
cur.r = right;
parent.put(right, cur);
val2node.put(right.v, right);
q.add(right);
}
}
}
return new BuildResult(root, parent, val2node);
}

// 在中序序列中，位于u之前的祖先的第k个
static int kthAncestorInorderBeforeU(Node root, Map<Node, Node> parent,
Map<Integer, Node> val2node, int u, int k) {
Node uNode = val2node.get(u);
if (uNode == null) return -1;

// 祖先集合
HashSet<Node> anc = new HashSet<>();
Node p = parent.get(uNode);
while (p != null) {
anc.add(p);
p = parent.get(p);
}

// 显式栈做中序
Deque<Node> st = new ArrayDeque<>();
Node cur = root;
int cnt = 0;
Integer ansK = null;
while (!st.isEmpty() || cur != null) {
while (cur != null) {
st.push(cur);
cur = cur.l;
}
cur = st.pop();
// 访问cur
if (cur == uNode) {
return (cnt >= k) ? ansK : -1;
}
if (anc.contains(cur)) {
cnt++;
if (cnt == k) ansK = cur.v;
}
cur = cur.r;
}
return -1;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));
String line1 = br.readLine();
String line2 = br.readLine();
if (line1 == null || line2 == null) {
System.out.println(-1);
return;
}
String[] tok = line1.trim().split("\\s+");
String[] uv = line2.trim().split("\\s+");
int u = Integer.parseInt(uv[0]);
int k = Integer.parseInt(uv[1]);

BuildResult res = buildTree(tok);
int ans = kthAncestorInorderBeforeU(res.root, res.parent, res.val2node, u, k);
System.out.println(ans);
}
}

C++ 实现
// 按层序建树 + 中序遍历计数
#include <bits/stdc++.h>
using namespace std;

struct Node {
int v;
Node *l, *r;
Node(int _v): v(_v), l(NULL), r(NULL) {}
};

struct BuildResult {
Node* root;
unordered_map<Node*, Node*> parent;
unordered_map<int, Node*> val2node;
};

BuildResult buildTree(const vector<string>& tok) {
BuildResult res; res.root = NULL;
if (tok.empty() || tok[0] == "#") return res;
int it = 0;
res.root = new Node(stoi(tok[it++]));
queue<Node*> q;
q.push(res.root);
res.parent[res.root] = NULL;
res.val2node[res.root->v] = res.root;

while (!q.empty() && it < (int)tok.size()) {
Node* cur = q.front(); q.pop();
// 左孩子
if (it < (int)tok.size()) {
string t = tok[it++];
if (t != "#") {
Node* left = new Node(stoi(t));
cur->l = left;
res.parent[left] = cur;
res.val2node[left->v] = left;
q.push(left);
}
}
// 右孩子
if (it < (int)tok.size()) {
string t = tok[it++];
if (t != "#") {
Node* right = new Node(stoi(t));
cur->r = right;
res.parent[right] = cur;
res.val2node[right->v] = right;
q.push(right);
}
}
}
return res;
}

int kthAncestorInorderBeforeU(Node* root,
unordered_map<Node*, Node*>& parent,
unordered_map<int, Node*>& val2node,
int u, int k) {
if (!val2node.count(u)) return -1;
Node* uNode = val2node[u];
// 祖先集合
unordered_set<Node*> anc;
Node* p = parent[uNode];
while (p) { anc.insert(p); p = parent[p]; }

// 显式栈中序
stack<Node*> st;
Node* cur = root;
int cnt = 0;
int ansK = INT_MIN; // 记第k个祖先值
bool hasAns = false;

while (!st.empty() || cur) {
while (cur) { st.push(cur); cur = cur->l; }
cur = st.top(); st.pop();
// 访问cur
if (cur == uNode) {
return (cnt >= k) ? ansK : -1;
}
if (anc.count(cur)) {
cnt++;
if (cnt == k) { ansK = cur->v; hasAns = true; }
}
cur = cur->r;
}
return -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
string line1, line2;
if (!getline(cin, line1)) { cout << -1 << "\n"; return 0; }
if (!getline(cin, line2)) { cout << -1 << "\n"; return 0; }
// 分割
stringstream ss1(line1), ss2(line2);
vector<string> tok;
string t;
while (ss1 >> t) tok.push_back(t);
int u, k;
ss2 >> u >> k;

BuildResult res = buildTree(tok);
int ans = kthAncestorInorderBeforeU(res.root, res.parent, res.val2node, u, k);
cout << ans << "\n";
return 0;
}

---

### 第2题-命令行参数据示（P3654）
- 链接：https://codefun2000.com/p/P3654

> 页面标题：#P3654. 第2题-命令行参数据示

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在使用命令行工具时，经常会出现手工输入错字母的情况，如想要输入：
git clone

输入成了
git clane

因此为了命令行工具更易用，需要从支持的子命令列表中找到最相似的子命令提示给用户。最相似的定义为最短莱文斯坦距离：即两个字符串之间，由一个转成另一个所需的最少编辑操作次数。允许的编辑操作包括：
1.1.1.将一个字符替换成另一个字符
2.2.2.插入一个字符
3.3.3.删除一个字符
输入描述
第一行给出可提示的最短距离 DDD，第二行给出子命令数量N NN，后面 NN N行给出所有的子命令列表，最后一行给出用户输入的子命令。
约束：

1≤D≤51≤D≤51≤D≤5
1≤N≤300001≤N≤300001≤N≤30000
单个子命令长度 ，子命令只包含小写字母

输出描述
输出为分三种情况：
1.1.1.用户输入的子命令正确匹配上某个子命令参数，输出原命令。
2.2.2.用户输入的子命令没有匹配上某个子命令参数，但是符合提示要求，则输出提示命令，如 clonecloneclone；如果符合提示要求的子命令有多个，则按距离从小到大排序后输出，同一个距离内还有多个的按字母序从小到大输出。
3.3.3.用户输入的子命令没有匹配上某个子命令参数，且没有符合提示要求的子命令，则输出None NoneNone
样例1
输入
2
5
aprint
bprint
aaprint
bbprint
output
print

输出
aprint bprint aaprint bbprint

说明
子命令中有四个满足与 printprintprint的距离小于等于222，其中 aprintaprintaprint 与 bprintbprintbprint与目标的距离为111，先将其排序并输出，aaprint bbprintaaprint\ bbprintaaprint bbprint 与目标距离为222，排序后接在前面输出后继续输出
样例2
输入
2
3
clone
checkout
switch
create

输出
None

说明
输入的三个子命令中没有满足与 creatcreatcreat 距离小于等于222的，因此输出 NoneNoneNone
样例3
输入
2
3
clone
checkout
switch
clane

输出
clone

说明
第一行值为222，表示当前输入不能完全正确匹配某个子命令时，则将其最短距离小于222的子命令作为提示输出；第二行为333，表示命令行实际有333个子命令，分别为后续333行；最后一行为用户实际的输入。由于用户没有命中具体的子命令，而 clonecloneclone与用户输入的距离为111，满足小于222的要求，因此输出 clonecloneclone

▶️

#### TextSol

video solution

解题思路与方法
算法概述
本题要求在大量已知子命令中，根据用户输入的错误命令，找到与之最相似（即编辑距离最小）的子命令并提示。
最相似的定义为Levenshtein 距离，即将一个字符串通过 替换、插入、删除 三种基本操作变为另一个字符串所需的最少步数。
详细方法

逐一计算编辑距离

对用户输入串 s 和每个候选子命令 t，使用动态规划求它们的编辑距离 d(s,t)。

定义 dp[i][j] 表示 s[0..i) 转换成 t[0..j) 的最少操作数。

初始条件：

dp[0][j]=j（s 为空，插入 j 个字符），
dp[i][0]=i（删除 i 个字符）。

转移方程：
if s[i-1]==t[j-1]:
dp[i][j]=dp[i-1][j-1]
else:
dp[i][j]=min(
dp[i-1][j]+1,   // 删除 s[i-1]
dp[i][j-1]+1,   // 插入 t[j-1]
dp[i-1][j-1]+1  // 替换为 t[j-1]
)

查找最小距离或候选集

遍历所有子命令，若距离 =0，说明恰好匹配，直接输出该命令并结束。
否则，收集所有满足 1≤d(s,t)≤D 的命令，记录距离。

排序与输出

按距离从小到大排序，相同距离下按字典序升序排列。
若候选集非空，依次输出；否则输出 None。

复杂度分析

每次编辑距离计算的时间为 O(∣s∣×∣t∣)O(|s|\times|t|)O(∣s∣×∣t∣)，最坏长度均为 LLL，则为 O(L2)O(L^2)O(L2)。

总共 NNN 个子命令，时间复杂度为 O(N×L2)O(N\times L^2)O(N×L2)。

在本题中 N≤3×104,;L≤25N\le3\times10^4,;L\le25N≤3×104,;L≤25，NL2≈1.9×107N L^2\approx1.9\times10^7NL2≈1.9×107，在常数较小的实现下可接受。

空间复杂度若使用全表为 O(L2)O(L^2)O(L2)，也可优化为 O(L)O(L)O(L) 的滚动数组。

代码实现
Python
def edit_dist(a, b):
n, m = len(a), len(b)
dp = [list(range(m+1))] + [[i]+[0]*m for i in range(1, n+1)]
for i in range(1, n+1):
for j in range(1, m+1):
if a[i-1] == b[j-1]:
dp[i][j] = dp[i-1][j-1]
else:
dp[i][j] = min(
dp[i-1][j] + 1,    # 删除
dp[i][j-1] + 1,    # 插入
dp[i-1][j-1] + 1   # 替换
)
return dp[n][m]

def main():
D = int(input().strip())
N = int(input().strip())
cmds = [input().strip() for _ in range(N)]
inp = input().strip()

# 精确匹配
if inp in cmds:
print(inp)
return

# 计算距离并筛选
cand = []
for cmd in cmds:
d = edit_dist(inp, cmd)
if 1 <= d <= D:
cand.append((d, cmd))

# 输出结果
if not cand:
print("None")
else:
cand.sort(key=lambda x: (x[0], x[1]))
print(" ".join(cmd for _, cmd in cand))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
// 计算编辑距离
static int dist(String a, String b) {
int n = a.length(), m = b.length();
int[][] dp = new int[n+1][m+1];
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a.charAt(i-1) == b.charAt(j-1)) {
dp[i][j] = dp[i-1][j-1];
} else {
dp[i][j] = Math.min(
Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
dp[i-1][j-1] + 1
);
}
}
}
return dp[n][m];
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int D = sc.nextInt();
int N = sc.nextInt();
List<String> cmds = new ArrayList<>();
for (int i = 0; i < N; i++) cmds.add(sc.next());
String inp = sc.next();

// 精确匹配
if (cmds.contains(inp)) {
System.out.println(inp);
return;
}

// 筛选候选
List<int[]> cand = new ArrayList<>();
for (String cmd : cmds) {
int d = dist(inp, cmd);
if (d >= 1 && d <= D) {
cand.add(new int[]{d, cmds.indexOf(cmd)});
}
}

if (cand.isEmpty()) {
System.out.println("None");
} else {
// 排序
cand.sort((a, b) -> {
int da = a[0], db = b[0];
if (da != db) return da - db;
return cmds.get(a[1]).compareTo(cmds.get(b[1]));
});
// 输出
StringJoiner sj = new StringJoiner(" ");
for (int[] p : cand) sj.add(cmds.get(p[1]));
System.out.println(sj.toString());
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算编辑距离
int editDist(const string &a, const string &b) {
int n = a.size(), m = b.size();
vector<vector<int>> dp(n+1, vector<int>(m+1));
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1];
else dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1});
}
}
return dp[n][m];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int D, N;
cin >> D >> N;
vector<string> cmds(N);
for (int i = 0; i < N; i++) cin >> cmds[i];
string inp;
cin >> inp;

// 精确匹配
for (auto &cmd : cmds) {
if (cmd == inp) {
cout << inp << "\n";
return 0;
}
}

// 筛选候选
vector<pair<int,string>> cand;
for (auto &cmd : cmds) {
int d = editDist(inp, cmd);
if (d >= 1 && d <= D) {
cand.emplace_back(d, cmd);
}
}

if (cand.empty()) {
cout << "None\n";
} else {
sort(cand.begin(), cand.end(), [](auto &a, auto &b) {
if (a.first != b.first) return a.first < b.first;
return a.second < b.second;
});
bool first = true;
for (auto &p : cand) {
if (!first) cout << ' ';
cout << p.second;
first = false;
}
cout << '\n';
}
return 0;
}

---

### 第2题-VIP用户优先转发（P3642）
- 链接：https://codefun2000.com/p/P3642

> 页面标题：#P3642. 第2题-VIP用户优先转发

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

随着园区网络的高速发展,大带宽、大流量成了主旋律，但是当网络带宽超过设备的处理能力时，可能导致网络拥塞，挤占一些高优先级的业务(如VIPVIPVIP用户流量)，影响用户体验，所以对网络的用户体验优化成了园区网络的核心技术之一。
在你接到一个用户需求，希望提升VIPVIPVIP用户的流量优先级,在网络拥塞时优先调度。其中用户的唯一身份标识是其MACMACMAC地址(如:00−d8−61−ef−31−3e00-d8-61-ef-31-3e00−d8−61−ef−31−3e)，所以我们需要在网络中配置所有VIPVIPVIP用户的MACMACMAC地址白名单，以便网络芯片转发引擎在执行流量转发时优先转发对应MACMACMAC地址的报文。
网络系统中VIPVIPVIP用户MACMACMAC地址配置格式为xx−xx−xx−xx−xx−xx/Mxx-xx-xx-xx-xx-xx/Mxx−xx−xx−xx−xx−xx/M，其中标识MACMACMAC地址和掩码长度
MACMACMAC地址由MACMACMAC地址48bit48bit48bit，共666字节组成，通常表示为666个十六进制数，格式为xx−xx−xx−xx−xx−xxxx-xx-xx-xx-xx-xxxx−xx−xx−xx−xx−xx。
如:00−d8−61−ef−31−3e00-d8-61-ef-31-3e00−d8−61−ef−31−3e就是一个MACMACMAC地址掩码长度表示在进行MACMACMAC地址匹配时关注的BITBITBIT位数，如:掩码长度404040转换成MACMACMAC地址掩码为ff−ff−ff−ff−ff−00ff-ff-ff-ff-ff-00ff−ff−ff−ff−ff−00相当于MACMACMAC地址最后8bit8bit8bit不关注
如:配置00−e0−fc−01−01−01/3200-e0-fc-01-01-01/3200−e0−fc−01−01−01/32，其对应的MACMACMAC地址掩码为ff−ff−ff−ff−00−00ff-ff-ff-ff-00-00ff−ff−ff−ff−00−00,能匹配上的VIP MACVIP\ MACVIP MAC地址范围是00−e0−fc−01−00−0000-e0-fc-01-00-0000−e0−fc−01−00−00~00−e0−fc−01−ff−ff00-e0-fc-01-ff-ff00−e0−fc−01−ff−ff
输入描述
输入第一行为整数 n(1≤n≤100000)n (1 ≤n≤100000)n(1≤n≤100000)，代表需要配置为VIPVIPVIP的MACMACMAC地址及其掩码个数。
接下来nnn行是对应VIPVIPVIP用户MACMACMAC地址及其掩码长度，格式为xx−xx−xx−xx−xx−xx/Mxx-xx-xx-xx-xx-xx/Mxx−xx−xx−xx−xx−xx/M，其中M(0≤M≤48)M(0 ≤ M ≤48)M(0≤M≤48)，MAC地址由数字和小写英文字母组成
然后是转发引擎待处理的报文MACMACMAC地址数目m(1≤m≤100)m(1≤m≤100)m(1≤m≤100)
接下来mmm行是转发引擎待处理的报文MACMACMAC地址，格式为xx−xx−xx−xx−xx−xxxx-xx-xx-xx-xx-xxxx−xx−xx−xx−xx−xx
输出描述
输出mmm个转发引擎待处理的报文MACMACMAC地址是否可以优先调度，是输出YESYESYES，不是则输出NONONO
样例1
输入
1
00-d8-61-ef-31-3e/0
1
02-12-13-14-15-16

输出
YES

样例2
输入
2
00-d8-61-ef-31-3e/48
00-e0-fc-00-ed-50/40
2
00-e0-fc-00-ed-66
00-d8-61-ef-31-3f

输出
YES
NO

说明
00−e0−fc−00−ed−6600-e0-fc-00-ed-6600−e0−fc−00−ed−66在VIP MACVIP\  MACVIP MAC地址列表中可以匹配，因为00−e0−fc−00−ed−50/4800-e0-fc-
00-ed-50/4800−e0−fc−00−ed−50/48表示匹配范围为00−e0−fc−00−ed−xx00-e0-fc-00-ed-xx00−e0−fc−00−ed−xx,其中xxxxxx不关注。
00−d8−61−ef−31−3f00-d8-61-ef-31-3f00−d8−61−ef−31−3f在VIP MACVIP\ MACVIP MAC地址列表中无法匹配

#### TextSol

题面描述
随着园区网络的高速发展，大带宽、大流量成了主旋律，但是当网络带宽超过设备的处理能力时，可能导致网络拥塞，挤占一些高优先级的业务（如VIPVIPVIP用户流量），影响用户体验，所以对网络的用户体验优化成了园区网络的核心技术之一。
现有需求：希望提升VIPVIPVIP用户的流量优先级，在网络拥时优先调度。用户的唯一身份标识是其MACMACMAC地址（例如：000000-d8d8d8-010101-efefef-313131-3e3e3e），因此需要在网络中配置所有VIPVIPVIP用户的MACMACMAC地址白名单，以便网络芯片转发引擎在执行流量转发时优先转发对应MACMACMAC地址的报文。
网络系统中VIPVIPVIP用户MACMACMAC地址配置格式为 xx-xx-xx-xx-xx-xx/M，其中标识MACMACMAC地址和掩码长度。MACMACMAC地址由484848 bit，共666字节组成，通常表示为666个十六进制数，格式为 xx-xx-xx-xx-xx-xx。例如：00-d8-61-ef-31-3e 就是一个MACMACMAC地址。掩码长度表示在进行MACMACMAC地址匹配时关注的 bit 位数，如掩码长度 404040 转换成MACMACMAC地址掩码为 ff-ff-ff-ff-f0-00（高404040位关注，低888位不关注）；配置 00-e0-fc-01-01-01/323232，其对应的MACMACMAC地址掩码为 ff-ff-ff-ff-00-00（高323232位关注，低161616位不关注），能匹配的VIPMACVIP MACVIPMAC地址范围是 00-e0-fc-01-00-00 到 00-e0-fc-01-ff-ff。
思路

问题本质

这道题的本质是“前缀匹配”：给定若干个484848 位长度的地址前缀（带掩码长度MMM），然后对于每个查询地址，判断其前MMM位是否与某个前缀相同。
这与 IP 前缀匹配类似，但这里是MACMACMAC地址，共484848位，掩码长度范围000到484848。当掩码长度为000时表示不关心任何位，即可以匹配任意地址；掩码长度为484848时表示完全精确匹配。

数据表示

将每个MACMACMAC地址转换为一个484848 位的整数（可以用646464位整数类型存储）。例如：字符串 "00-d8-61-ef-31-3e" → 每个十六进制字节转换后依次左移拼成一个484848 位整数。
对于一个带掩码长度MMM的前缀 addr/M，构造其掩码：高MMM位为111，低48−M48-M48−M 位为 000。或者我们更方便的方式：我们只需要把地址右移(48−M)(48 - M)(48−M) 位，保留高MMM 位，称为“前缀值”。匹配时也将查询地址右移相同的(48−M)(48 - M)(48−M) 位，如果结果相等则匹配。
例如：掩码长度M=32M=32M=32，00-e0-fc-01-01-01 转整数后右移48−32=1648-32=1648−32=16 位，得到高 323232 位前缀。查询地址同样右移161616位再比较。

多前缀匹配加速

nnn最多可达100000100000100000，mmm可能也很大，暴力对每个查询遍历所有前缀显然不可行。

观察到掩码长度MMM的取值范围是000到484848，最多494949种可能。我们可以针对每个可能的掩码长度LLL，维护一个哈希集合（如 C++ 的 unordered_set<uint64_t>，Python 的 set，Java 的 HashSet<Long>），存储所有白名单前缀右移后的值。

具体：

读到一个前缀 addr/M，将 addr_int 右移(48−M)(48 - M)(48−M) 位得到 prefix_value，插入到对应掩码长度集合集合S[M]S[M]S[M]中。
查询时，对于当前查询地址 q_int，对每个存在白名单的掩码长度LLL（即S[L]S[L]S[L] 非空），计算 q_int >> (48 - L)，然后检查该值是否在S[L]S[L]S[L] 中。如果存在，则该查询答案为 YES，否则继续检查下一个掩码长度；若都不匹配，则为 NO。

因为掩码长度可能的值只有494949种，查询时最多做494949次哈希查找，时间是O(∣distinct masks∣)O(|distinct\ masks|)O(∣distinct masks∣)，通常远小于nnn，满足性能需求。

边界情况

掩码长度M=0M=0M=0：任何地址右移484848 位（即 >>48）得到000，如果存在一个M=0M=0M=0的前缀，则所有查询地址都匹配，答案始终 YES。
掩码长度M=48M=48M=48：需要精确匹配，右移(48−48)=0(48-48)=0(48−48)=0 位即不变，直接把完整484848 位整数存入集合，在查询时直接检查完整整数是否在集合中。
合法性：输入保证 MAC 字符串合法格式。注意要忽略大小写差异，可统一转换为小写或大写再解析。
空白和分隔：输入中 MAC 字节用 - 分隔，掩码用 / 紧跟在地址后。读取时按字符串解析即可。

时间空间复杂度

空间：需要存储nnn个前缀值在对应集合中，总数不超过nnn，所以O(n)O(n)O(n) 空间。
构造：逐条插入哈希表，平均O(1)O(1)O(1)，总O(n)O(n)O(n).
查询：每条查询最多对ddd个不同掩码长度做哈希查找，d≤49d \le 49d≤49，所以每条O(49)O(49)O(49) 平均。总共O(m×49)O(m \times 49)O(m×49)。当mmm很大时也足够快。
解析 MAC 为整数时间 O(1)O(1)O(1)，常数开销。

C++
#include <bits/stdc++.h>
using namespace std;

// 将 MAC 地址字符串解析为 48 位整数
// 格式假定为 "xx-xx-xx-xx-xx-xx"，xx 为十六进制表示的字节
uint64_t parse_mac_to_int(const string &mac_str) {
uint64_t mac = 0;
int len = mac_str.size();
// 逐段解析，中间以 '-' 分隔
// 简单方式：按 '-' 分割
uint64_t byte = 0;
int parts = 0;
size_t start = 0;
for (int i = 0; i <= len; ++i) {
if (i == len || mac_str[i] == '-') {
// mac_str[start..i-1] 是两位十六进制
string part = mac_str.substr(start, i - start);
// 转为整数
byte = std::stoul(part, nullptr, 16);
mac = (mac << 8) | (byte & 0xFF);
parts++;
start = i + 1;
if (parts == 6) break;
}
}
return mac;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
// 数组下标 0..48，每个位置存储该掩码长度对应的前缀集合
vector<unordered_set<uint64_t>> prefix_sets(49);
bool has_zero_mask = false;

string line;
for (int i = 0; i < n; ++i) {
cin >> line;  // 例如 "00-d8-61-ef-31-3e/48"
// 按 '/' 分割
size_t pos = line.find('/');
string mac_part = line.substr(0, pos);
int mask_len = stoi(line.substr(pos + 1));
// 解析 MAC 为整数
uint64_t mac_int = parse_mac_to_int(mac_part);
if (mask_len == 0) {
// 掩码长度为 0，匹配任意地址
has_zero_mask = true;
// 仍可在 prefix_sets[0] 中插入任意值，如 0
prefix_sets[0].insert(0ULL);
} else {
// 右移以保留高 mask_len 位
int shift = 48 - mask_len;
uint64_t prefix = (mac_int >> shift);
prefix_sets[mask_len].insert(prefix);
}
}

int m;
cin >> m;
string query_mac;
for (int qi = 0; qi < m; ++qi) {
cin >> query_mac;  // "xx-xx-xx-xx-xx-xx"
uint64_t q_int = parse_mac_to_int(query_mac);

bool matched = false;
// 如果存在掩码长度 0，则总匹配
if (has_zero_mask) {
matched = true;
} else {
// 遍历所有可能的掩码长度
for (int L = 1; L <= 48; ++L) {
if (prefix_sets[L].empty()) continue;
int shift = 48 - L;
uint64_t q_prefix = (q_int >> shift);
if (prefix_sets[L].count(q_prefix)) {
matched = true;
break;
}
}
}
if (matched) {
cout << "YES\n";
} else {
cout << "NO\n";
}
}

return 0;
}

Python
import sys

def parse_mac_to_int(mac_str: str) -> int:
# mac_str 形如 "xx-xx-xx-xx-xx-xx"
parts = mac_str.split('-')
mac_int = 0
for part in parts:
mac_int = (mac_int << 8) | int(part, 16)
return mac_int

def main():
data = sys.stdin
# 读取 n
line = data.readline().strip()
if not line:
return
n = int(line)
# prefix_sets[L] 存储掩码长度为 L 的前缀集合
prefix_sets = [set() for _ in range(49)]
has_zero_mask = False

for _ in range(n):
line = data.readline().strip()
# 可能有空行，要跳过
if not line:
continue
mac_part, mask_part = line.split('/')
mask_len = int(mask_part)
mac_int = parse_mac_to_int(mac_part)
if mask_len == 0:
has_zero_mask = True
prefix_sets[0].add(0)
else:
shift = 48 - mask_len
prefix = mac_int >> shift
prefix_sets[mask_len].add(prefix)

# 读取 m
line = data.readline().strip()
m = int(line)
for _ in range(m):
qline = data.readline().strip()
if not qline:
continue
q_int = parse_mac_to_int(qline)
matched = False
if has_zero_mask:
matched = True
else:
# 遍历所有掩码长度
for L in range(1, 49):
if not prefix_sets[L]:
continue
shift = 48 - L
q_prefix = q_int >> shift
if q_prefix in prefix_sets[L]:
matched = True
break
print("YES" if matched else "NO")

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

public class VipMacMatcher {

// 将 MAC 地址解析为 48 位整数，结果存储在 long 类型中
// 格式假定 "xx-xx-xx-xx-xx-xx"
private static long parseMacToLong(String macStr) {
String[] parts = macStr.split("-");
long mac = 0;
for (String part : parts) {
// Long.parseLong 可解析十六进制，需要指定基数 16
long byteVal = Long.parseLong(part, 16);
mac = (mac << 8) | (byteVal & 0xFF);
}
return mac;
}

public static void main(String[] args) throws IOException {
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String line = reader.readLine();
if (line == null || line.isEmpty()) {
return;
}
int n = Integer.parseInt(line.trim());
// prefixSets[L] 存放掩码长度为 L 的前缀集合
@SuppressWarnings("unchecked")
Set<Long>[] prefixSets = new HashSet[49];
for (int i = 0; i <= 48; i++) {
prefixSets[i] = new HashSet<>();
}
boolean hasZeroMask = false;

for (int i = 0; i < n; i++) {
line = reader.readLine().trim();
if (line.isEmpty()) {
i--;
continue;
}
String[] parts = line.split("/");
String macPart = parts[0];
int maskLen = Integer.parseInt(parts[1]);
long macInt = parseMacToLong(macPart);
if (maskLen == 0) {
hasZeroMask = true;
prefixSets[0].add(0L);
} else {
int shift = 48 - maskLen;
long prefix = macInt >>> shift;
prefixSets[maskLen].add(prefix);
}
}

line = reader.readLine().trim();
int m = Integer.parseInt(line);
for (int i = 0; i < m; i++) {
line = reader.readLine().trim();
if (line.isEmpty()) {
i--;
continue;
}
long qInt = parseMacToLong(line);
boolean matched = false;
if (hasZeroMask) {
matched = true;
} else {
for (int L = 1; L <= 48; L++) {
if (prefixSets[L].isEmpty()) {
continue;
}
int shift = 48 - L;
long qPrefix = qInt >>> shift;
if (prefixSets[L].contains(qPrefix)) {
matched = true;
break;
}
}
}
System.out.println(matched ? "YES" : "NO");
}
}
}

---

### 第3题-支持LoRA的Attention实现（P3658）
- 链接：https://codefun2000.com/p/P3658

> 页面标题：#P3658. 第3题-支持LoRA的Attention实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

相对于全量微调，LoRALoRALoRA微调提出了一种低秩分解的方法，只需在原模型参数基础上增加少量的可训练参数，大幅降低计算成本和内存占用。具体而言，对于原始的预训练权重矩阵WWW，LORALORALORA做以下改进：
W′=W+B×AW'=W+B×AW′=W+B×A
WWW为原始权重(冻结不变)，B∈Rd×rB∈R^{d×r}B∈Rd×r和 A∈Rr×dA ∈R^{r×d}A∈Rr×d为新增的低秩矩阵，r<<dr<<dr<<d，秩rrr一般很小。微调时只更新 A、BA、BA、B这两个矩阵，显著减少训练的参数数量。请实现支持LoRALoRALoRA的AttentionAttentionAttention计算
函数LoRA_Attention(x,Wa,Wk,Wv,A,B) LoRA\_Attention(x,W_a,W_k,W_v,A,B)LoRA_Attention(x,Wa​,Wk​,Wv​,A,B) 。为简化实现，仅需支持AttentionAttentionAttention中Q QQ的LoRALoRALoRA结构实现即可。实现时请使用float64float64float64位精度。
输入描述
第111行： b,d,rb,d,rb,d,r，其中b为batch sizeb为batch\ sizeb为batch size,ddd为特征的长度，rrr为LoRALoRALoRA矩阵的秩，b≥1,d≥1,r≥0b≥1,d≥1,r≥0b≥1,d≥1,r≥0
第222行：输入xxx，长度为b×db×db×d
第3−53-53−5行: Wq,Wk,WvW_q,W_k,W_vWq​,Wk​,Wv​,长度为d×dd×dd×d
若r>0r>0r>0，则:
第666行：AAA，长度为r×dr×dr×d
第777行：BBB，长度为d×rd×rd×r
输出描述
LoRAAttentionLoRA AttentionLoRAAttention计算的结果，输出保留四位小数，不足四位小数的补000
样例1
输入
2 5 3
-0.58 -0.52 -0.02 0.56 0.79 0.06 -0.64 -0.04 -0.20 -0.38
0.24 -0.72 -0.66 0.96 0.02 -0.43 -0.24 0.19 -0.85 -0.35 0.69 -0.09 0.99 0.21 -0.06 0.55 0.57 0.97 0.58 -0.16 0.64 0.02 -0.71 0.53 -0.90
0.07 -0.16 -0.47 -0.32 -0.92 0.13 -0.74 -0.87 0.05 0.33 0.37 0.75 0.57 0.14 -0.62 0.67 -0.62 -0.85 0.09 -0.90 0.22 0.97 -0.68 0.61 0.48
0.39 -0.74 0.84 0.21 0.44 -0.59 -0.07 -0.84 -0.70 0.86 -0.12 -0.06 0.45 -0.43 -0.09 -0.73 0.56 -0.62 0.36 -0.87 -0.97 -0.48 0.71 0.07 -0.28
0.25 0.58 -0.04 -0.94 0.45 -0.60 0.89 0.94 0.35 -0.76 -0.47 -0.40 0.10 0.23 0.25
-0.18 -0.11 0.60 0.37 0.75 0.51 -0.76 -0.39 -0.81 -0.88 -0.43 -0.88 0.15 -0.46 -0.24

输出
0.3499 0.0803 0.0376 -0.1791 0.3952 0.4112 0.2240 -0.0239 -0.2177 0.4478

样例2
输入
1 3 2
0.58 -0.65 -0.63
-0.74 -0.71 0.65 0.70 -0.14 0.01 -0.84 0.20 0.25
-0.60 0.51 -0.12 -0.35 0.57 -0.38 -0.44 -0.82 0.53
0.14 0.03 -0.27 0.10 -0.12 0.85 -0.55 0.10 -0.43
0.65 0.32 -0.42 -0.62 -0.88 -0.70
-0.66 0.49 0.09 -0.21 0.48 0.41

输出
0.2318 -0.3995 -0.1131

#### TextSol

1. LoRA 思路

原始权重 WqW_qWq​ 冻结；

新增低秩矩阵 $A\in \mathbb{R}^{r\times d}, B\in \mathbb{R}^{d\times r}$，形成：
Wq′=Wq+BAW_q' = W_q + BA
Wq′​=Wq​+BA

若 r=0r=0r=0，直接用原始 WqW_qWq​。

2. Attention 计算步骤

计算
$$Q = XW_q'^\top,\quad K = XW_k^\top,\quad V = XW_v^\top$$

打分并缩放
S=QK⊤dS = \frac{QK^\top}{\sqrt{d}}
S=d​QK⊤​

对每一行做 稳定 softmax。

输出
O=softmax(S)VO = \text{softmax}(S)V
O=softmax(S)V

题目样例输入输出描述不清，使用矩阵转置才能通过

3. 实现要点

float64 精度，避免溢出；
softmax 时对每行减去最大值；
输出拉平，保留四位小数，-0.0000 特判为 0.0000。

代码实现
import sys
import numpy as np

def softmax(x):
"""
计算softmax函数
"""
x = x.astype(np.float64)
max_vals = np.max(x, axis=1, keepdims=True)
exp_vals = np.exp(x - max_vals)
return exp_vals / np.sum(exp_vals, axis=1, keepdims=True)

def LoRA_Attention(x, wq, wk, wv, A, B):
"""
实现带有LoRA适配器的线性注意力机制
"""
d = x.shape[1]

# 应用LoRA适配器（如果提供）
if A is not None and B is not None and A.size > 0 and B.size > 0:
effective_wq = wq + B @ A
else:
effective_wq = wq

# 计算查询、键和值
Q = x @ effective_wq.T
K = x @ wk.T
V = x @ wv.T

# 计算注意力分数
scale_factor = 1.0 / np.sqrt(d)
attention_scores = (Q @ K.T) * scale_factor

# 应用softmax得到注意力权重
attention_weights = softmax(attention_scores)

# 计算输出
output = attention_weights @ V
return output

def format_output(values):
"""
格式化输出，确保-0.0000显示为0.0000
"""
formatted_values = []
for value in values:
formatted = f"{value:.4f}"
if formatted == "-0.0000":
formatted = "0.0000"
formatted_values.append(formatted)
return formatted_values

def main():
# 读取输入数据
data = list(map(float, sys.stdin.read().strip().split()))
it = iter(data)

# 读取维度参数
b = int(next(it))
d = int(next(it))
r = int(next(it))

# 读取输入矩阵
x = np.array([next(it) for _ in range(b * d)]).reshape(b, d)

# 读取权重矩阵
wq = np.array([next(it) for _ in range(d * d)]).reshape(d, d)
wk = np.array([next(it) for _ in range(d * d)]).reshape(d, d)
wv = np.array([next(it) for _ in range(d * d)]).reshape(d, d)

# 读取LoRA适配器参数（如果存在）
if r > 0:
A = np.array([next(it) for _ in range(r * d)]).reshape(r, d)
B = np.array([next(it) for _ in range(d * r)]).reshape(d, r)
else:
A = None
B = None

# 计算输出
output = LoRA_Attention(x, wq, wk, wv, A, B)

# 格式化和打印结果
flat_output = output.reshape(-1)
formatted_output = format_output(flat_output)
print(" ".join(formatted_output))

if __name__ == "__main__":
main()

---

### 第3题-调整储能集装箱（P3655）
- 链接：https://codefun2000.com/p/P3655

> 页面标题：#P3655. 第3题-调整储能集装箱

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

储能工厂在发货时，一次同时发两个储能集装箱。每个集装箱中均 MMM 个电芯，用两个数组 bms1，bms2bms1，bms2bms1，bms2 表示每个集箱中的电芯的电量，为了保证两个集装箱电芯电量的均衡，需要调整两个集装箱中的电芯，使得两个集装箱中的电芯电最完全均衡(根据集装箱中电芯的电量进行排序，如果排序后的结果完全相同，则认为两个集装箱的电芯电量完全均衡)。调整的代价如下：比如交换电芯 bms1[i]和bms2[j]bms1[i]和bms2[j]bms1[i]和bms2[j]，代价为 min(bms1[i]，bms2[j])min(bms1[i]，bms2[j])min(bms1[i]，bms2[j]) 。可以多次调整，请返回调整的最小代价。如果无法使得两个集装箱中的电芯电量完全均衡，返回 −1-1−1
输入描述
第一行是一个整数 MMM ，表示集装箱内电芯的数量。1<=M<=1051 <= M <= 10^51<=M<=105。
接下两行是长度均为 MMM 的整数数组 bms1bms1bms1 和 bms2bms2bms2 ，分别代表两个集装箱内电芯的电量
1<=bms1[i],bms2[j]<=1081 <= bms1[i], bms2[j] <= 10^81<=bms1[i],bms2[j]<=108
输出描述
调整的代价(用例保证不会超过 2642^{64}264)
样例1
输入
4
4 5 6 3
5 4 6 2

输出
-1

说明
无论怎么调整，都无法使得两个储能柜的电芯相同
样例2
输入
5
5 2 3 5 6
2 3 3 3 6

输出
3

说明
交换 bms1[0]bms1[0]bms1[0] 和 bms2[1]bms2[1]bms2[1] ，代价为 333 ，交换后，bms1=3bms1=3bms1=3 222 333 555 666 ，bms2=2bms2=2bms2=2 555 333 333 666 ，排序后两个集装箱中的电芯电量完全相同，都是 222 333 333 555 666

#### TextSol

思路

可行性判定

对每个数值 vvv，合并出现次数 cnt(v)=cnt1(v)+cnt2(v)cnt(v)=cnt_1(v)+cnt_2(v)cnt(v)=cnt1​(v)+cnt2​(v)。若存在 cnt(v)cnt(v)cnt(v) 为奇数，则无论如何交换都无法均衡，直接返回 −1-1−1。

需要交换的元素集合

对每个数值 vvv，计算差值 Δ(v)=cnt1(v)−cnt2(v)\Delta(v)=cnt_1(v)-cnt_2(v)Δ(v)=cnt1​(v)−cnt2​(v)。
若 Δ(v)>0\Delta(v)>0Δ(v)>0，向集合 AAA 放入 Δ(v)/2\Delta(v)/2Δ(v)/2 个 vvv（表示这些值需要从 bms1bms1bms1 移出）。
若 Δ(v)<0\Delta(v)<0Δ(v)<0，向集合 BBB 放入 −Δ(v)/2-\Delta(v)/2−Δ(v)/2 个 vvv（表示这些值需要从 bms2bms2bms2 移出）。
必有 ∣A∣=∣B∣=k|A|=|B|=k∣A∣=∣B∣=k，且至少需要交换 kkk 次。

最优配对与换法

设全局最小值 m=min⁡(min⁡(bms1),min⁡(bms2))m=\min(\min(bms1),\min(bms2))m=min(min(bms1),min(bms2))。

对于一对待交换的元素 (x∈A, y∈B)(x\in A,\,y\in B)(x∈A,y∈B)，可直接交换代价为 min⁡(x,y)\min(x,y)min(x,y)，也可通过最小元 mmm 中转（两次跨箱交换），总代价为 2m2m2m。因此单对最优代价为
min⁡(min⁡(x,y), 2m).\min(\min(x,y),\,2m).
min(min(x,y),2m).

为最小化总代价，将 AAA 升序、BBB 降序配对，使每对的较小者尽量小，从而减小 min⁡(x,y)\min(x,y)min(x,y)。

复杂度

计数与构造集合：O(M)O(M)O(M)；排序：O(Mlog⁡M)O(M\log M)O(MlogM)；总复杂度 O(Mlog⁡M)O(M\log M)O(MlogM)，空间 O(M)O(M)O(M)。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int M;
if (!(cin >> M)) return 0;
vector<long long> a(M), b(M);
for (int i = 0; i < M; ++i) cin >> a[i];
for (int i = 0; i < M; ++i) cin >> b[i];

// 统计全局最小值m
long long m = LLONG_MAX;
for (auto &x : a) m = min(m, x);
for (auto &x : b) m = min(m, x);

// 分别统计两个数组中每个数的出现次数
unordered_map<long long, long long> cnt1, cnt2, total;
cnt1.reserve(M * 2); cnt2.reserve(M * 2); total.reserve(M * 2);
for (auto &x : a) { cnt1[x]++; total[x]++; }
for (auto &x : b) { cnt2[x]++; total[x]++; }

// 可行性判定：合并次数必须为偶数
for (auto &kv : total) {
if ((kv.second & 1LL) != 0) {
cout << -1 << "\n";
return 0;
}
}

// 构造需要移动的多重集合A、B
vector<long long> A, B;
A.reserve(M); B.reserve(M);
for (auto &kv : total) {
long long v = kv.first;
long long d = cnt1[v] - cnt2[v]; // 可能为负
if (d > 0) {
long long t = d / 2;
while (t--) A.push_back(v);
} else if (d < 0) {
long long t = (-d) / 2;
while (t--) B.push_back(v);
}
}

if (A.empty()) { // 已经均衡
cout << 0 << "\n";
return 0;
}

// 排序并配对：A升序，B降序
sort(A.begin(), A.end());
sort(B.begin(), B.end(), greater<long long>());

// 计算最小总代价：sum min(min(A[i], B[i]), 2*m)
unsigned long long ans = 0;
for (size_t i = 0; i < A.size(); ++i) {
unsigned long long direct = (unsigned long long)min(A[i], B[i]);
unsigned long long viaMin = (unsigned long long)(2LL * m);
ans += min(direct, viaMin);
}

cout << ans << "\n";
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
M = int(next(it))
a = [int(next(it)) for _ in range(M)]
b = [int(next(it)) for _ in range(M)]

# 全局最小值
m = min(min(a), min(b))

# 次数统计
from collections import Counter
cnt1 = Counter(a)
cnt2 = Counter(b)
total = cnt1 + cnt2  # 合并计数

# 可行性判定：合并次数必须为偶数
for v, c in total.items():
if c % 2 != 0:
print(-1)
return

# 构造A、B
A, B = [], []
for v in total.keys():
d = cnt1.get(v, 0) - cnt2.get(v, 0)
if d > 0:
A.extend([v] * (d // 2))
elif d < 0:
B.extend([v] * ((-d) // 2))

if not A:
print(0)
return

A.sort()           # 升序
B.sort(reverse=True)  # 降序

# 计算总代价
ans = 0
two_m = 2 * m
for x, y in zip(A, B):
ans += min(min(x, y), two_m)

print(ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

/*
思路：
- 统计两个数组内每个值的出现次数，并做合并计数；若某值合并次数为奇数则返回-1
- 差值一半分别放入A和B，A表示需要从bms1移出的元素，B表示需要从bms2移出的元素
- A升序，B降序配对；每对交换代价为 min(min(x, y), 2*m)
- 复杂度 O(M log M)
*/
public class Main {
public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);
Integer MObj = fs.nextInt();
if (MObj == null) return;
int M = MObj;

long[] a = new long[M];
long[] b = new long[M];
for (int i = 0; i < M; i++) a[i] = fs.nextLong();
for (int i = 0; i < M; i++) b[i] = fs.nextLong();

long m = Long.MAX_VALUE;
for (long x : a) m = Math.min(m, x);
for (long x : b) m = Math.min(m, x);

// 次数统计
HashMap<Long, Long> cnt1 = new HashMap<>();
HashMap<Long, Long> cnt2 = new HashMap<>();
HashMap<Long, Long> total = new HashMap<>();
for (long x : a) {
cnt1.put(x, cnt1.getOrDefault(x, 0L) + 1);
total.put(x, total.getOrDefault(x, 0L) + 1);
}
for (long x : b) {
cnt2.put(x, cnt2.getOrDefault(x, 0L) + 1);
total.put(x, total.getOrDefault(x, 0L) + 1);
}

// 可行性判定
for (Map.Entry<Long, Long> e : total.entrySet()) {
if ((e.getValue() & 1L) != 0L) {
System.out.println(-1);
return;
}
}

ArrayList<Long> A = new ArrayList<>();
ArrayList<Long> B = new ArrayList<>();
for (Long v : total.keySet()) {
long c1 = cnt1.getOrDefault(v, 0L);
long c2 = cnt2.getOrDefault(v, 0L);
long d = c1 - c2;
if (d > 0) {
long t = d / 2;
for (int i = 0; i < t; i++) A.add(v);
} else if (d < 0) {
long t = (-d) / 2;
for (int i = 0; i < t; i++) B.add(v);
}
}

if (A.isEmpty()) {
System.out.println(0);
return;
}

// A升序
Collections.sort(A);
// B降序
B.sort(Collections.reverseOrder());

long twoM = 2L * m;
long ans = 0L;
for (int i = 0; i < A.size(); i++) {
long x = A.get(i), y = B.get(i);
long direct = Math.min(x, y);
ans += Math.min(direct, twoM);
}

System.out.println(ans);
}

// 简单的快速输入
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
while ((c = read()) != -1 && c <= ' ') {}
if (c == -1) return null;
do {
sb.append((char)c);
c = read();
} while (c != -1 && c > ' ');
return sb.toString();
}
Integer nextInt() throws IOException {
String s = next();
return s == null ? null : Integer.parseInt(s);
}
Long nextLong() throws IOException {
String s = next();
return s == null ? null : Long.parseLong(s);
}
}
}

---

### 第3题-寻找设备最优的连接线（P3643）
- 链接：https://codefun2000.com/p/P3643

> 页面标题：#P3643. 第3题-寻找设备最优的连接线

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

现有NNN个设备从左到右依次排列，编号从111到NNN。每个设备中有多个端口，每个端口号都有一个数字编号，编号从111到MMM且不重复。设备内部端口之间的连接叫内部连线，设备之间的端口连接叫外部连线，设备只能跟编号相邻的设备有外部连接。现在已经有连接好的一部分内部和外部连线了，需要寻找一个权重最大的最优连接线路，将这NNN个设备从左到右顺序连接起来。每条连接线路会在每个设备中选择222个端口，分别叫左端口和右端口，并将这些端口连接起来，设备111的左端口为起始端口，设备NNN的右端口为终止端口。
条件约束:
111.设备数量N满足:1<N<201<N<201<N<20
2.2.2.每个设备内部端口编号  MMM 满足:1<M<1001<M<1001<M<100
3.3.3.除起始和终止两个端口只能连接一条内部连线外，其他端口必须一边连接内部连线，另一边连接外部连线。
4.4.4.设备之间已经连接好的外部连线不能修改也不能增加新的。
5.5.5.设备内部已经连接好的内部连线不能修改，只能增加新的。
权重计算:
1)1)1)不同设备之间，左边设备权重级别高于右边，也就是说两条线路从左往右比较设备权重值，一旦某个设备权重值高于另一个，则整个线路权重一定高，无需再比较后面的设备。
2)2)2)设备权重值(优先级高代表权重值高):优先选择已经连接好的内部连线，再优先选择左右端口号之和较小的两个端口，再优先选择左端口号较小的。
下图是一个当前已经存在的设备端口连接图:

下图是寻找到的最优连接图，其中的虚线是要新增的内部连接线。

输入描述
设备的个数NNN
设备111内部端口号列表
设备111内部内部连线列表，如果没有则显示000
设备111和设备222之间外部连线列表，如果没有则显示000
设备222内部端口号列表
设备222内部连线列表，如果没有则显示000
设备222和设备333之间外部连线列表，如果没有则显示000
...
设备NNN内部端口号列表
设备NNN内部内部连线列表
备注:内部和外部连线都使用“端口号-端口号”表示。
比如题目中示例图的输入如下
3
1 2 3 4 5 6 7 8 9 10
1-2 5-6
2-1 6-5
1 2 3 4 5 6 7 8 9 10
0
6-1 8-3 10-5
1 2 3 4 5 6
3-2

输出描述
输出从设备1到设备N连接起来的端口号列表。
题目中示例图的输出如下:
111 222 111 666 111 444
如果找不见一条连接光路，则输出−1-1−1
样例1
输入
15
1 2 3 4 5 6 7 8 9 10
2-1 6-5
2-1 6-5
1 2 3 4 5 6 7 8 9 10
0
6-1 8-3 10-5
1 2 3 4 5 6
2-3
2-1 4-3 6-4
1 2 3 4 5 6 7 8 9 10
2-1 6-5
2-1 6-5 7-2
1 2 3 4 5 6 7 8 9 10
0
3-5 4-1
1 2 3 4 5 6 7 8 9 10
2-1
2-1 6-5
1 2 3 4 5 6 7 8 9 10
0
6-1 8-3 10-5
1 2 3 4 5 6
2-3
2-1 4-3 6-4
1 2 3 4 5 6 7 8 9 10
2-1 6-5
2-1 6-5 7-2
1 2 3 4 5 6 7 8 9 10
0
3-5 4-1
1 2 3 4 5 6 7 8 9 10
2-1
2-1 6-5
1 2 3 4 5 6 7 8 9 10
0
6-1 8-3 10-5
1 2 3 4 5 6
2-3
2-1 4-3 6-4
1 2 3 4 5 6 7 8 9 10
2-1 6-5
2-1 6-5 7-2
1 2 3 4 5 6 7 8 9 10
0

输出
1 2 1 6 1 4 3 7 2 3 5 6 5 6 1 4 3 7 2 3 5 6 5 6 1 4 3 7 2 3

样例2
输入
3
1 2
1-2
2-1
1 2
1-2
2-1
1 2 3
2-3

输出
-1

说明
设备222只能通过端口号222连上设备333的端口111这条线路，但是设备333中的端口111找不见右端口去连接了(剩余的端口222跟333已经互相连接)。因此找不见一条连接线。
样例3
输入
3
1 2 3 4 5 6 7 8 9 10
1-2 5-6
2-1 6-5
1 2 3 4 5 6 7 8 9 10
0
6-1 8-3 10-5
1 2 3 4 5 6
3-2

输出
1 2 1 6 1 4

说明
按示例图中计算的权重最高的线路为1 2 1 6 1 41\ 2\ 1\ 6\ 1\ 41 2 1 6 1 4

#### TextSol

解法思路
把输入抽象为三组数据：

S_i：第 i 层的候选集合；
pair_i：第 i 层的无向配对表；
trans_i：第 i 层的跨层映射（到第 i+1 层），末层为恒等。

接着做一层深度优先搜索（DFS / 回溯）：

外层：起点 s0 的选择有先后顺序。按照下述排序尝试 S_0：

优先尝试那些“在 pair_0 中出现过的点”（有配对的起点）；
次序再按 x + pair_0.get(x, 0) 的和从小到大；
再按 x 升序。
这是对你代码里起点排序规则的语义化复现。

内层：在层 i 已知当前状态 s_i 时，

若存在“配对优先”的合法分支（pair_i[s_i] 同时也是 trans_i 的键），先走它；
否则枚举 trans_i 的所有键（升序），作为兜底分支，做一些轻量剪枝（x != s_i、x 不在 pair_i 的键集中、以及可选的“像集”剪枝）。

由于搜索深度固定为 n，并且每层枚举的是一个有限升序集，回溯很快；且一旦找到首个解即可输出。
正确性要点

若某层存在“配对优先”分支，它与同层配对约束完全吻合，并且能直接把状态推进到下一层（trans_i 完整性保证）。
否则兜底分支遍历 trans_i 的所有合法键，穷尽所有可行的非优先选择；轻量剪枝只排除明显无谓或易冲突的尝试，不会剔除真正可行解。
以有序方式枚举，保证输出是按题中（或约定）优先级得到的字典序最优解（与给定代码的搜索顺序保持一致的效果）。

复杂度

记第 i 层 trans_i 的 key 数为 m_i。最坏回溯复杂度约 O(∏ m_i)，但由于有“配对优先”与轻量剪枝，实际很快。
额外的排序开销为 O(m_i log m_i) 量级。

实现要点

输入的“配对行”“映射行”用空格分隔，0 表示结束；u-v 表示一条边或配对。
末层 i == n-1 的跨层映射为恒等 x -> x。
若 i < n-1 且跨层映射为空，立即输出 -1 并结束。
输出时打印构造路径里除了最后一个状态之外的所有数字。

C++ 实现
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

auto read_nonempty = [&]() {
string s;
getline(cin, s);
while (s.size() == 0 && !cin.fail()) getline(cin, s);
return s;
};

string fs = read_nonempty();
if (fs.empty()) return 0;
int n = stoi(fs);

vector<vector<int>> S(n);
vector<unordered_map<int,int>> pair_tab(n);
vector<unordered_map<int,int>> trans(n);

for (int i = 0; i < n; ++i) {
{   // 候选集
string line = read_nonempty();
stringstream ss(line);
int x;
while (ss >> x) S[i].push_back(x);
}
{   // 同层无向配对
string line = read_nonempty();
stringstream ss(line);
string tok;
while (ss >> tok) {
if (tok == "0") break;
auto pos = tok.find('-');
int u = stoi(tok.substr(0, pos));
int v = stoi(tok.substr(pos + 1));
pair_tab[i][u] = v;
pair_tab[i][v] = u;
}
}
if (i < n - 1) {
string line = read_nonempty();
stringstream ss(line);
string tok;
while (ss >> tok) {
if (tok == "0") break;
auto pos = tok.find('-');
int u = stoi(tok.substr(0, pos));
int v = stoi(tok.substr(pos + 1));
trans[i][u] = v;
}
if (trans[i].empty()) { cout << -1 << "\n"; return 0; }
} else {
for (int x : S[i]) trans[i][x] = x; // 末层恒等
}
}

// 每层键的升序
vector<vector<int>> keys(n);
for (int i = 0; i < n; ++i) {
for (auto &kv : trans[i]) keys[i].push_back(kv.first);
sort(keys[i].begin(), keys[i].end());
}

// 倒数第二层像集（若存在）
unordered_set<int> last_values;
if (n >= 2) {
for (auto &kv : trans[n - 2]) last_values.insert(kv.second);
}

// 起点排序：有配对优先 -> (x + pair[x]) -> x
vector<int> starts = S[0];
sort(starts.begin(), starts.end(), [&](int a, int b){
int pa = pair_tab[0].count(a) ? 0 : 1;
int pb = pair_tab[0].count(b) ? 0 : 1;
if (pa != pb) return pa < pb;
int sa = a + (pair_tab[0].count(a) ? pair_tab[0].at(a) : 0);
int sb = b + (pair_tab[0].count(b) ? pair_tab[0].at(b) : 0);
if (sa != sb) return sa < sb;
return a < b;
});

vector<long long> answer;
bool found = false;

function<void(int,int,vector<long long>&)> dfs = [&](int layer, int cur, vector<long long> &path){
if (found) return;
if (layer == n) { answer = path; found = true; return; }

// 配对优先
auto itp = pair_tab[layer].find(cur);
if (itp != pair_tab[layer].end()) {
int mate = itp->second;
auto it = trans[layer].find(mate);
if (it != trans[layer].end()) {
int nxt = it->second;
path.push_back(mate);
path.push_back(nxt);
dfs(layer + 1, nxt, path);
path.pop_back(); path.pop_back();
if (found) return;
}
}

// 兜底（含“倒数第二层像集”过滤）
for (int x : keys[layer]) {
if (x == cur) continue;
if (pair_tab[layer].count(x)) continue;
if (layer > 0 && last_values.count(x)) continue;

int nxt = trans[layer][x];
path.push_back(x);
path.push_back(nxt);
dfs(layer + 1, nxt, path);
path.pop_back(); path.pop_back();
if (found) return;
}
};

for (int s0 : starts) {
vector<long long> path = {(long long)s0};
dfs(0, s0, path);
if (found) {
for (size_t i = 0; i + 1 < answer.size(); ++i) {
if (i) cout << ' ';
cout << answer[i];
}
cout << "\n";
return 0;
}
}
cout << -1 << "\n";
return 0;
}

Python 实现
import sys

def solve():
def read_line():
return sys.stdin.readline().strip()

n = int(read_line())
levels = []
pair_tab = []
trans = []

# 读取：候选集 S_i、同层无向配对 pair_i、跨层映射 trans_i（末层恒等）
for i in range(n):
levels.append(list(map(int, read_line().split())))

tokens = read_line().split()
undirected = {}
for tk in tokens:
if tk == "0": break
u, v = map(int, tk.split('-'))
undirected[u] = v
undirected[v] = u
pair_tab.append(undirected)

if i < n - 1:
tokens = read_line().split()
to_next = {}
for tk in tokens:
if tk == "0": break
u, v = map(int, tk.split('-'))
to_next[u] = v
if not to_next:
print(-1)
return
trans.append(to_next)
else:
trans.append({x: x for x in levels[-1]})

# 每层键的升序列表
keys = [sorted(trans[i].keys()) for i in range(n)]

# 关键修正：使用“倒数第二层”的像集作为全局过滤集合（若存在）
last_values = set(trans[n - 2].values()) if n >= 2 else set()

# 起点排序：有配对优先 -> (x + pair[x]) 小 -> x 小
def start_order(x):
has_pair = 0 if x in pair_tab[0] else 1
pair_sum = x + pair_tab[0].get(x, 0)
return (has_pair, pair_sum, x)

starts = sorted(levels[0], key=start_order)

sys.setrecursionlimit(1 << 25)
ans_path = []
done = False

def dfs(layer, cur, path):
nonlocal ans_path, done
if done:
return
if layer == n:
ans_path = path[:]
done = True
return

# 1) 配对优先：cur 的配对点存在且可映射
mate = pair_tab[layer].get(cur)
if mate is not None and mate in trans[layer]:
nxt = trans[layer][mate]
path.extend([mate, nxt])
dfs(layer + 1, nxt, path)
path.pop(); path.pop()
if done: return

# 2) 兜底分支：按键升序尝试；使用“倒数第二层像集”的过滤（layer>0 时）
for x in keys[layer]:
if x == cur:            # 不能自选
continue
if x in pair_tab[layer]:# 若 x 在配对表里，让“配对优先”去处理
continue
if layer > 0 and x in last_values:
continue

nxt = trans[layer][x]
path.extend([x, nxt])
dfs(layer + 1, nxt, path)
path.pop(); path.pop()
if done: return

for s0 in starts:
dfs(0, s0, [s0])
if done:
print(*ans_path[:-1])  # 最后一个状态不输出
return
print(-1)

if __name__ == "__main__":
solve()

Java
import java.io.*;
import java.util.*;

public class Main {
static String readLine(BufferedReader br) throws IOException {
String s = br.readLine();
while (s != null && s.length() == 0) s = br.readLine();
return s == null ? "" : s;
}

static Map<Integer,Integer> parsePairs(String line, boolean undirected) {
Map<Integer,Integer> mp = new HashMap<>();
if (line == null || line.isEmpty()) return mp;
String[] toks = line.trim().split("\\s+");
for (String tk : toks) {
if (tk.equals("0")) break;
int pos = tk.indexOf('-');
int u = Integer.parseInt(tk.substring(0, pos));
int v = Integer.parseInt(tk.substring(pos + 1));
if (undirected) { mp.put(u, v); mp.put(v, u); }
else mp.put(u, v);
}
return mp;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String first = readLine(br);
if (first.isEmpty()) return;
int n = Integer.parseInt(first);

List<List<Integer>> S = new ArrayList<>();
List<Map<Integer,Integer>> pairTab = new ArrayList<>();
List<Map<Integer,Integer>> trans = new ArrayList<>();

for (int i = 0; i < n; i++) {
// 候选集
{
String l = readLine(br);
String[] ss = l.trim().split("\\s+");
List<Integer> arr = new ArrayList<>();
for (String t : ss) if (!t.isEmpty()) arr.add(Integer.parseInt(t));
S.add(arr);
}
// 无向配对
{
String l = readLine(br);
pairTab.add(parsePairs(l, true));
}
// 跨层映射
if (i < n - 1) {
String l = readLine(br);
Map<Integer,Integer> toNext = parsePairs(l, false);
if (toNext.isEmpty()) { System.out.println(-1); return; }
trans.add(toNext);
} else {
Map<Integer,Integer> last = new HashMap<>();
for (int x : S.get(i)) last.put(x, x);
trans.add(last);
}
}

// 每层键升序
List<List<Integer>> keys = new ArrayList<>();
for (int i = 0; i < n; i++) {
List<Integer> ks = new ArrayList<>(trans.get(i).keySet());
Collections.sort(ks);
keys.add(ks);
}

// 倒数第二层像集
Set<Integer> lastValues = new HashSet<>();
if (n >= 2) lastValues.addAll(trans.get(n - 2).values());

// 起点排序：有配对优先 -> (x + pair[x]) -> x
List<Integer> starts = new ArrayList<>(S.get(0));
starts.sort((a, b) -> {
int pa = pairTab.get(0).containsKey(a) ? 0 : 1;
int pb = pairTab.get(0).containsKey(b) ? 0 : 1;
if (pa != pb) return pa - pb;
int sa = a + pairTab.get(0).getOrDefault(a, 0);
int sb = b + pairTab.get(0).getOrDefault(b, 0);
if (sa != sb) return sa - sb;
return Integer.compare(a, b);
});

List<Long> ans = new ArrayList<>();
boolean[] done = {false};

class DFS {
void go(int layer, int cur, List<Long> path) {
if (done[0]) return;
if (layer == n) {
ans.clear();
ans.addAll(path);
done[0] = true;
return;
}

Map<Integer,Integer> pt = pairTab.get(layer);
Map<Integer,Integer> tr = trans.get(layer);

// 配对优先
if (pt.containsKey(cur)) {
int mate = pt.get(cur);
if (tr.containsKey(mate)) {
int nxt = tr.get(mate);
path.add((long)mate);
path.add((long)nxt);
go(layer + 1, nxt, path);
path.remove(path.size() - 1);
path.remove(path.size() - 1);
if (done[0]) return;
}
}

// 兜底 + 倒数第二层像集过滤
for (int x : keys.get(layer)) {
if (x == cur) continue;
if (pt.containsKey(x)) continue;
if (layer > 0 && lastValues.contains(x)) continue;

int nxt = tr.get(x);
path.add((long)x);
path.add((long)nxt);
go(layer + 1, nxt, path);
path.remove(path.size() - 1);
path.remove(path.size() - 1);
if (done[0]) return;
}
}
}

DFS solver = new DFS();
for (int s0 : starts) {
List<Long> path = new ArrayList<>();
path.add((long)s0);
solver.go(0, s0, path);
if (done[0]) {
StringBuilder sb = new StringBuilder();
for (int i = 0; i + 1 < ans.size(); i++) {
if (i > 0) sb.append(' ');
sb.append(ans.get(i));
}
System.out.println(sb.toString());
return;
}
}

System.out.println(-1);
}
}

---

## 2025年9月10日-国内-AI

### 第2题-历史的窗口搜索（P3639）
- 链接：https://codefun2000.com/p/P3639

> 页面标题：#P3639. 第2题-历史的窗口搜索

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

传统TF−IDFTF-IDFTF−IDF方法对突发新闻的敏感度不足，为提高热点词识别效果，某新闻热点追踪平台提出基于历史窗口的TF-IDF方法，具体地，在某个时间点ttt提出一个查询qqq时，系统不应该在整个历史文档库中进行大海捞针式的搜索。
相反，它需要智能地聚焦于查询发生时间点 ttt 前的一段”历史时间窗口“内的文档，并且只需考虑这个窗口内最新的信息。
您的任务就是实现这个“历史窗口”检索引擎的核心逻辑。
历史窗口：仅计算从查询时间点 ttt 开始之前的 KKK 篇文档的词频，而非全部历史文档。
动态权重：为了使该搜索模型更关注短期趋势，窗口内越新(文档编号mmm越大)的文档权重越高，窗口内第jjj篇文档的权重为(K−j+1)/K(K-j+1)/K(K−j+1)/K(最新文档权重=1=1=1，最旧文档权重=1/K=1/K=1/K)。
筛选与输出：计算查询内容qqq与窗口内每一篇文档向量之间的余弦相似度(CosineSimilarity)(Cosine Similarity)(CosineSimilarity),返回本次查询中余弦相似度>=0.6>=0.6>=0.6且余弦相似度最高的文档编号mmm，若未找到满足条件的文档编号(余弦相似度<0.6<0.6<0.6)，则本次查询返回−1-1−1；若存在多个相同最高相似度的文档，返回时间窗口中最早的一篇文档编号。
相似度计算方法：查询qqq向量(向量AAA)的第iii维计算公式为，qi=TF(wi,q)×IDF(wi)q_i = TF(w_i,q)×IDF(w_i)qi​=TF(wi​,q)×IDF(wi​) ，其中 TF(wi,q)TF(w_i,q) TF(wi​,q)表示词 wiw_iwi​在所有查询内容queryqueryquery中的词频，IDF(wi)IDF(w_i) IDF(wi​)表示词wi w_iwi​在窗口文档集合中的中逆文档频率。窗口文档集合中第nnn篇文档(向量BBB)的第iii维向量计算公式为:di=TF(wi,doc)×IDF(wi)×weightnd_i = TF(w_i,doc) × IDF(w_i) × weight_ndi​=TF(wi​,doc)×IDF(wi​)×weightn​,其中 TF(wi,doc)TF(w_i,doc)TF(wi​,doc) 表示词 wiw_iwi​在查询窗口文档集合中的词频，IDF(wi)IDF(w_i) IDF(wi​)表示词 wiw_iwi​在窗口文档中的中逆文档频率，weightnweight_nweightn​表示第nnn篇文档的动态权重。
提示:向量A.BA.BA.B的余弦相似度:$\cos (A, B)=\frac{\mathbf{A} \cdot \mathbf{B}}{\|\mathbf{A}\|\|\mathbf{B}\|}$
输入描述
输入第一行表示文档集合corpuscorpuscorpus 总数NNN
第二行开始每一行为从时间点000开始的文档，时间点和文档编号按行递增
(注:文档编号、查询时间点均可理解为数组下标，下标从000开始)
之后的一行为查询窗口的大小KKK
接下来的下一行表示总查询次数PPP
然后紧跟每个查询，格式为搜索时间点ttt具体查询内容qqq，ttt和qqq中间用空格隔开
参数限制
1.1<=K<=1.1<=K<=1.1<=K<=文档总数NNN
2.0<2.0<2.0<文档总数N<=100N<=100N<=100
3.0<3.0<3.0<总查询次数P<=100P<=100P<=100
在处理完基本题目的I/OI/OI/O操作后，你可能需要实现的函数原型
是historyhistoryhistory_searchsearchsearch(corpus,K，query)(corpus,K，query)(corpus,K，query)，参数说明如下:
1.corpuscorpus corpus：从时间点0开始的文档集合，corpus[i]corpus[i]corpus[i]表示第i篇文档，文档编号mmm和时间点ttt均对应数组下标，下标从000开始。
2.KKK:窗口大小。
3.queryqueryquery：查询列表。每个查询是一个二元组(查询时间点ttt，查询内容qqq)。
输出描述
输出空格分隔的最匹配的文档编号mmm，文档编号和查询顺序 一 一 对应，若两篇文档最高相似度相同，则返回窗口中最早的文档编号
若无匹配则对应位置返回−1-1−1
样例1
输入
5
long short term memory
data science
natural language processing
python for data science
a tutorial on python
3
3
2 natural language
4 python data science
4 long short term memory

输出
2 3 -1

说明
第一行555表示新闻文档集合corpuscorpus corpus的总数NNN
然后紧跟从时间点000开始的具体的每篇文档，时间点和文档编号按行递增:
时间点000文档编号000："longlonglong shortshortshort termtermterm memorymemorymemory"
时间点111文档编号111：“datadatadata sciencesciencescience”
时间点222文档编号222：“naturalnaturalnatural languageprocessinglanguage processinglanguageprocessing"
时间点333文档编号333：“pythonpythonpython forforfor datadatadata sciencesciencescience"
时间点444文档编号444：“aaa tutorialtutorialtutorial ononon pythonpythonpython"
下一行的“333”为窗口的大小KKK
接下来的“333”表示查询queryqueryquery的个数
然后紧跟每个查询，格式为搜索时间点ttt具体查询内容qqq
第一次查询"naturalnaturalnatural languagelanguagelanguage"在时间点222，我们正好可以看到0−20-20−2号文档，因为只有2号文档"naturalnaturalnatural languagelanguagelanguage processingprocessingprocessing"出现了关键词，因此第一个查询返回222
第二次查询"pythonpythonpython datadatadata sciencesciencescience"在时间点444，由于窗口大小是333，我们可以看到2,3,42,3,42,3,4号文档我们无法看到0,10,10,1号文档，本次查询最匹配的是文档编号 333
第三次查询“longlonglong shortshortshort termtermterm memorymemorymemory"在时间点444，同样的我们只能看到2,3,42,3,42,3,4号文档，无法看到0,10,10,1号文档，且2,3,42,3,42,3,4号文档中没有与查询相似文档，
所以本次查询返回−1-1−1
提示
1.qq q可能存在不在窗口文档集合中的查询词，因此在计算逆文档频率的时候你需要进行平滑操作，公式如下IDF(x)=log⁡(N+1N(x)+1)+1I D F(x)=\log \left(\frac{N+1}{N(x)+1}\right)+1IDF(x)=log(N(x)+1N+1​)+1其中NNN代表窗口文档的总数，而N(x)N(x)N(x)代表包含词xxx的文档总数
2.新闻文档集合corpuscorpuscorpus 所包含的文档内容是空格分隔的小写英文文档字符串

#### TextSol

解题思路
问题抽象

文档集合 corpus[0…N-1] 按时间递增（下标既是时间点/编号）。

查询 (t, q) 的检索窗口只看 L = max(0, t-K+1) 到 R = min(t, N-1) 的 M=R-L+1 篇文档。

动态权重：窗口内从新到旧编号第 j 篇（最新 j=1）的权重
weight = (K - j + 1) / K（最新 1，最旧 1/K）。

向量定义（关键）

查询向量：q_i = TF(w_i,q) * IDF(w_i)
文档向量（方案一按题面）：d_i = TF(w_i,doc) * IDF(w_i) * weight_n

相似度：余弦相似度
cos⁡(A,Bn)=A⋅Bn∥A∥∥Bn∥\cos(A,B_n)=\frac{A\cdot B_n}{\|A\|\|B_n\|}
cos(A,Bn​)=∥A∥∥Bn​∥A⋅Bn​​
由于 weight_n 乘在文档向量每一维，在分子与分母中会抵消，因而最终分数与不加权相同；但我们仍按题面实现把权重乘进文档分量与其范数的计算中。

筛选：仅返回窗口内相似度≥0.6 的文档中最高者；若并列，取窗口中最早（编号最小）。若无则返回 -1。

细节实现

TF(w,doc) = count(w)/len(doc)；查询同理。
IDF(w) = ln((M+1)/(df(w)+1)) + 1（仅在窗口内，带平滑）。
仅对查询出现的词计算点积与范数，提升效率。
计算时把 weight 乘到文档分量与文档范数里，不再额外乘相似度分子。

复杂度

时间：O(K·L + K·Q)（通常记作 O(K·L)）
空间：O(Q + K)

代码实现
Python
import sys, math
from collections import Counter, defaultdict
input = sys.stdin.readline

def main():
N = int(input().strip())
docs_raw = [input().strip() for _ in range(N)]
K = int(input().strip())
P = int(input().strip())
queries = []
for _ in range(P):
q = input().strip().split(' ')
queries.append((int(q[0]), q[1:]))

# 预处理每篇文档的分词与词频
doc_tokens = [s.split() for s in docs_raw]
doc_lens = [len(tks) for tks in doc_tokens]
doc_cnt = [Counter(tks) for tks in doc_tokens]

ans = []
eps = 1e-12

for t, q_words in queries:
# 窗口 [L, R]
R = min(max(0, t), N - 1)
L = max(0, R - K + 1)
M = R - L + 1

if not q_words or M <= 0:
ans.append(-1)
continue

q_cnt = Counter(q_words)
q_len = len(q_words)

# df & idf（仅对查询词；平滑）
df = defaultdict(int)
q_set = set(q_cnt.keys())
for i in range(L, R + 1):
for w in q_set:
if doc_cnt[i].get(w, 0) > 0:
df[w] += 1
idf = {w: math.log((M + 1.0) / (df[w] + 1.0)) + 1.0 for w in q_set}

# 查询范数
q_norm_sq = 0.0
for w, c in q_cnt.items():
tfq = c / q_len
x = tfq * idf[w]
q_norm_sq += x * x
q_norm = math.sqrt(q_norm_sq) if q_norm_sq > 0 else 1.0

best_score, best_id = -1.0, -1

# 新->旧遍历
for idx in range(R, L - 1, -1):
dl = doc_lens[idx] if doc_lens[idx] > 0 else 1
# 位置权重：j=1 最新
j = (R - idx) + 1
weight = (K - j + 1) / K

dot = 0.0
d_norm_sq = 0.0
for w, qc in q_cnt.items():
tfd = doc_cnt[idx].get(w, 0) / dl
tfq = qc / q_len
dq = tfq * idf[w]
dd = tfd * idf[w] * weight   # 方案一：把weight乘进文档维度
dot += dq * dd
d_norm_sq += dd * dd

sim = 0.0
if d_norm_sq > 0:
d_norm = math.sqrt(d_norm_sq)
sim = dot / (q_norm * d_norm)  # 不再额外乘weight

if sim >= 0.6 - eps:
if sim > best_score + eps:
best_score, best_id = sim, idx
elif abs(sim - best_score) <= eps:
best_id = idx if (best_id == -1 or idx < best_id) else best_id

ans.append(best_id if best_id != -1 else -1)

print(' '.join(str(x) for x in ans))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {

static List<String> splitWords(String s) {
s = s.trim();
if (s.isEmpty()) return Collections.emptyList();
return Arrays.asList(s.split("\\s+"));
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

int N = Integer.parseInt(br.readLine().trim());

String[] raw = new String[N];
for (int i = 0; i < N; i++) raw[i] = br.readLine().replace("\r", "");

int K = Integer.parseInt(br.readLine().trim());
int P = Integer.parseInt(br.readLine().trim());

// 预处理：每篇文档词频与长度
ArrayList<HashMap<String, Integer>> dcnt = new ArrayList<>(N);
int[] dlen = new int[N];
for (int i = 0; i < N; i++) {
List<String> tks = splitWords(raw[i]);
dlen[i] = tks.size();
HashMap<String, Integer> mp = new HashMap<>();
for (String w : tks) mp.put(w, mp.getOrDefault(w, 0) + 1);
dcnt.add(mp);
}

StringBuilder out = new StringBuilder();
final double EPS = 1e-12;

for (int qi = 0; qi < P; qi++) {
String line = br.readLine();
if (line == null) line = "";
line = line.replace("\r", "").trim();

int sp = line.indexOf(' ');
int t = Integer.parseInt(sp == -1 ? line : line.substring(0, sp).trim());
List<String> qWords = (sp == -1) ? Collections.emptyList()
: splitWords(line.substring(sp + 1));

int R = Math.min(Math.max(0, t), N - 1);
int L = Math.max(0, R - K + 1);
int M = R - L + 1;

if (qWords.isEmpty() || M <= 0) {
out.append(-1);
if (qi + 1 < P) out.append(' ');
continue;
}

// 查询词频
HashMap<String, Integer> qcnt = new HashMap<>();
for (String w : qWords) qcnt.put(w, qcnt.getOrDefault(w, 0) + 1);
int qlen = qWords.size();

// df & idf（仅查询词）
HashMap<String, Integer> df = new HashMap<>();
for (String w : qcnt.keySet()) df.put(w, 0);
for (int i = L; i <= R; i++) {
HashMap<String, Integer> dm = dcnt.get(i);
for (String w : qcnt.keySet()) {
if (dm.containsKey(w)) df.put(w, df.get(w) + 1);
}
}
HashMap<String, Double> idf = new HashMap<>();
for (String w : qcnt.keySet()) {
double v = Math.log((M + 1.0) / (df.get(w) + 1.0)) + 1.0;
idf.put(w, v);
}

// 查询范数
double qnorm2 = 0.0;
for (Map.Entry<String, Integer> e : qcnt.entrySet()) {
String w = e.getKey();
double tfq = e.getValue() * 1.0 / qlen;
double x = tfq * idf.get(w);
qnorm2 += x * x;
}
double qnorm = qnorm2 > 0 ? Math.sqrt(qnorm2) : 1.0;

double bestScore = -1.0;
int bestId = -1;

// 新->旧遍历
for (int idx = R; idx >= L; idx--) {
int dl = dlen[idx] > 0 ? dlen[idx] : 1;
HashMap<String, Integer> dm = dcnt.get(idx);

// 位置权重（乘进文档分量）
int j = (R - idx) + 1;
double weight = (K - j + 1.0) / K;

double dot = 0.0, dnorm2 = 0.0;
for (Map.Entry<String, Integer> e : qcnt.entrySet()) {
String w = e.getKey();
int cdoc = dm.getOrDefault(w, 0);
double tfd = cdoc * 1.0 / dl;
double tfq = e.getValue() * 1.0 / qlen;
double dq = tfq * idf.get(w);
double dd = tfd * idf.get(w) * weight; // 方案一：这里乘weight
dot += dq * dd;
dnorm2 += dd * dd;
}

double sim = 0.0;
if (dnorm2 > 0) {
double dnorm = Math.sqrt(dnorm2);
sim = dot / (qnorm * dnorm); // 不再额外乘weight
}

if (sim >= 0.6 - EPS) {
if (sim > bestScore + EPS) {
bestScore = sim; bestId = idx;
} else if (Math.abs(sim - bestScore) <= EPS) {
if (bestId == -1 || idx < bestId) bestId = idx;
}
}
}

out.append(bestId == -1 ? -1 : bestId);
if (qi + 1 < P) out.append(' ');
}

System.out.print(out.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 按空白分词
static vector<string> splitWords(const string& s0) {
vector<string> res;
string s = s0;
int n = (int)s.size(), i = 0;
while (i < n) {
while (i < n && isspace((unsigned char)s[i])) i++;
if (i >= n) break;
int j = i;
while (j < n && !isspace((unsigned char)s[j])) j++;
res.emplace_back(s.substr(i, j - i));
i = j;
}
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line;
getline(cin, line);
int N = stoi(line);

vector<string> raws(N);
for (int i = 0; i < N; ++i) {
getline(cin, raws[i]);
if (!raws[i].empty() && raws[i].back() == '\r') raws[i].pop_back();
}

getline(cin, line);
int K = stoi(line);
getline(cin, line);
int P = stoi(line);

// 预处理：每篇文档的词频与长度
vector<unordered_map<string,int>> dcnt(N);
vector<int> dlen(N);
for (int i = 0; i < N; ++i) {
auto tks = splitWords(raws[i]);
dlen[i] = (int)tks.size();
auto &mp = dcnt[i];
for (auto &w : tks) mp[w]++;
}

vector<int> answers;
answers.reserve(P);
const double EPS = 1e-12;

for (int qi = 0; qi < P; ++qi) {
getline(cin, line);
if (!line.empty() && line.back() == '\r') line.pop_back();

auto sp = line.find(' ');
int t = stoi(sp == string::npos ? line : line.substr(0, sp));
vector<string> qWords = (sp == string::npos) ? vector<string>() : splitWords(line.substr(sp + 1));

int R = min(max(0, t), N - 1);
int L = max(0, R - K + 1);
int M = R - L + 1;

if (qWords.empty() || M <= 0) {
answers.push_back(-1);
continue;
}

// 查询词频
unordered_map<string,int> qcnt;
for (auto &w : qWords) qcnt[w]++;
int qlen = (int)qWords.size();

// df & idf（仅查询词；平滑）
unordered_map<string,int> df;
for (auto &kv : qcnt) df[kv.first] = 0;

for (int i = L; i <= R; ++i) {
auto &dm = dcnt[i];
for (auto &kv : qcnt) {
const string &w = kv.first;
if (dm.find(w) != dm.end()) df[w]++;
}
}

unordered_map<string,double> idf;
for (auto &kv : qcnt) {
const string &w = kv.first;
double v = log((M + 1.0) / (df[w] + 1.0)) + 1.0;
idf[w] = v;
}

// 查询范数
double qnorm2 = 0.0;
for (auto &kv : qcnt) {
const string &w = kv.first;
double tfq = kv.second * 1.0 / qlen;
double x = tfq * idf[w];
qnorm2 += x * x;
}
double qnorm = qnorm2 > 0 ? sqrt(qnorm2) : 1.0;

double bestScore = -1.0;
int bestId = -1;

// 新->旧遍历
for (int idx = R; idx >= L; --idx) {
int dl = dlen[idx] > 0 ? dlen[idx] : 1;
auto &dm = dcnt[idx];

int j = (R - idx) + 1;
double weight = (K - j + 1.0) / K; // 方案一：乘进文档分量

double dot = 0.0, dnorm2 = 0.0;

for (auto &kv : qcnt) {
const string &w = kv.first;
int cdoc = 0;
auto it = dm.find(w);
if (it != dm.end()) cdoc = it->second;

double tfd = cdoc * 1.0 / dl;
double tfq = kv.second * 1.0 / qlen;
double dq = tfq * idf[w];
double dd = tfd * idf[w] * weight; // 这里乘weight
dot += dq * dd;
dnorm2 += dd * dd;
}

double sim = 0.0;
if (dnorm2 > 0) {
double dnorm = sqrt(dnorm2);
sim = dot / (qnorm * dnorm); // 不再额外乘weight
}

if (sim >= 0.6 - EPS) {
if (sim > bestScore + EPS) {
bestScore = sim; bestId = idx;
} else if (fabs(sim - bestScore) <= EPS) {
if (bestId == -1 || idx < bestId) bestId = idx;
}
}
}

answers.push_back(bestId == -1 ? -1 : bestId);
}

for (int i = 0; i < (int)answers.size(); ++i) {
if (i) cout << ' ';
cout << answers[i];
}
return 0;
}

---

### 第3题-多尺寸窗口滑动的特征转换（P3640）
- 链接：https://codefun2000.com/p/P3640

> 页面标题：#P3640. 第3题-多尺寸窗口滑动的特征转换

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

题目背景:
数据治理阶段经常会碰到特征转换，当前有一个时间序列数据(用 111 维整数数组表示)，和一个窗口序列( 111 维整数数组)，窗口序列中每个元素表示 111 个窗口 www 。
转换要求:
实现一个多尺寸滑动窗口特征转换函数，每个窗口提取 555 个特征，计算出来如果是整数不带小数点，则小数点后最多保留 333 位(四舍五入)
小数点举例说明:
1.0−>11.0->11.0−>1 整数不带小数点
1.10−>1.11.10->1.11.10−>1.1 结尾不带 000
1.1116−>1.1121.1116->1.1121.1116−>1.112 最多保留 333 位小数，最后一位四舍五入
特征包含:
均值(meanmeanmean)
标准差(样本标准差，ddof=1ddof=1ddof=1 ;分母为 000 时，返回 000 )
最小值(minminmin)
最大值(maxmaxmax)
线性趋势斜率(使用线性回归拟合)
线性趋势斜率算法:
时间索引: x=[0,1,2,...,w−1]x = [0, 1, 2,...,w-1]x=[0,1,2,...,w−1]
对应的值: y=[y0,y1,y2,...,yw−1]y = [y_0,y_1, y_2,...,y_{w-1}]y=[y0​,y1​,y2​,...,yw−1​]
拟合一条直线:y=βx+αy=βx+αy=βx+α
βββ 是斜率(我们需要的趋势斜率)
ααα 是截距
使用最小二乘法，斜率的计算公式为:
β=[n∗∑(xy)−∑x∗∑y]/[n∗∑(x2)−(∑x)2]β = [n* ∑(xy) - ∑x*∑y] / [n*∑(x^2) - (∑x)^2]β=[n∗∑(xy)−∑x∗∑y]/[n∗∑(x2)−(∑x)2]
nnn 是窗口大小
标准差计算公式:
$s=\sqrt{\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}}$
转换规则:
对于每个窗口大小 w(window_arrayw(window\_arrayw(window_array 中的一个元素)，从索引(索引从 000 开始)i=max(window_arravy)−wi=max(window\_arravy)-wi=max(window_arravy)−w ，开始滑动窗口
所有窗口的特征按 window_arravwindow\_arravwindow_arrav 中的元素顺序排列
如果数组长度小于任意一个窗口大小,则结果数组为空
输入描述
inputinputinput_arrayarrayarray :一维数组,表示时间序列数据
windowwindowwindow_arrayarrayarray:一维数组,多个窗口，每个元素为窗口 www
输出描述
二维数组，形状为 (n,m)(n,m)(n,m) ，其中:
n=len(input_array)−max(window_array)+1n = len(input\_array) - max(window\_array) +1n=len(input_array)−max(window_array)+1
m=len(window_array)∗5m = len(window\_array) * 5m=len(window_array)∗5
每一行说明:
$[mean1, std1, min1, max1, slope1, mean2, std2, min2, max2, slope2,...]$
样例1
输入
[10, 20], [3, 4]

输出
[]

说明
输入长度小于窗口最小大小，输出空数组
样例2
输入
[1, 2, 3, 4, 5], [2, 3]

输出
[2.5, 0.707, 2, 3, 1, 2, 1, 1, 3, 1]
[3.5, 0.707, 3, 4, 1, 3, 1, 2, 4, 1]
[4.5, 0.707, 4, 5, 1, 4, 1, 3, 5, 1]

说明
1、窗口大小 222 的特征:
[2,3]: mean=2.5,std=0.707, min=2, max=3, slope=1
[3,4]: mean=3.5, std=0.707, min=3, max=4, slope=1
[4,5]: mean=4.5, std=0.707, min=4, max=5, slope=1
2、窗口大小 333 的特征:
[1,2,3]: mean=2, std=1, min=1, max=3, slope=1
[2,3,4]: mean=3, std=1, min=2, max=4, slope=1
[3,4,5]: mean=4, std=1, min=3, max=5, slope=1

#### TextSol

算法思路

均值 & 标准差

用前缀和与前缀平方和可快速计算：

sum = prefix[i+w] - prefix[i]
mean = sum / w
var = (Σy² - w*mean²) / (w-1)
std = sqrt(max(var,0))

最小值 & 最大值

简单做法：每个窗口遍历一遍 O(w)。
高效做法：用单调队列，O(n) 解决所有窗口的 min/max。

斜率 slope

公式：
slope = (w * Σ(x*y) - Σx * Σy) / (w * Σx² - (Σx)²)

其中 x = 0..w-1，Σx 和 Σx² 可直接公式计算。

特殊情况：w=1 时，分母为 0，slope=0。

对齐方式

输出行数 n = len(a) - max(wins) + 1。
对于窗口大小 w，第 r 行的数据对应起点 idx = r + (Wmax - w)。

复杂度分析

朴素实现：每个窗口 O(w)，总复杂度 O(N * Σw)。
优化实现：前缀和+单调队列+公式，复杂度 O(N * |wins|)。
空间复杂度 O(N)。

代码实现
Python
import sys, re
import numpy as np
from numpy.lib.stride_tricks import sliding_window_view

txt = eval(sys.stdin.read())

a = np.array(txt[0], dtype=float)
wins = np.array(txt[1], dtype=int)

if a.size == 0 or wins.size == 0:
print("[]"); sys.exit(0)

Wmax = int(wins.max())
n = a.size - Wmax + 1
if n <= 0:
print("[]"); sys.exit(0)

# —— 工具：数值格式化（最多3位小数，去掉多余0和小数点） ——
def fmt_arr(x: np.ndarray):
y = np.round(x, 3)                                 # 四舍五入到3位
s = np.char.mod('%.3f', y)                         # 统一三位
s = np.char.rstrip(np.char.rstrip(s, '0'), '.')    # 去尾0与点
s = np.where(s == '', '0', s)                      # 处理 -0 -> 0
return s.tolist()

# —— 主逻辑：对每个 w 计算整批窗口特征（均值/标准差/最小/最大/斜率） ——
# 斜率：对 x=0..w-1，用中心化公式 beta = sum((x-x̄)*(y-ȳ)) / sum((x-x̄)^2)
features_per_w = {}  # w -> (mean, std, min, max, slope), 每个都是 shape=(N-w+1,)
N = a.size

for w in wins:
W = sliding_window_view(a, w)            # 形状: (N-w+1, w)
mean = W.mean(axis=1)
# 样本标准差 ddof=1；w=1 时结果为 nan，按题意置 0
std = W.std(axis=1, ddof=1)
std = np.nan_to_num(std, nan=0.0)

mn = W.min(axis=1)
mx = W.max(axis=1)

x = np.arange(w, dtype=float)
xc = x - x.mean()                         # x 中心化
denom = np.sum(xc * xc)                   # 标准化分母
# 将每个窗口的 y 做中心化，再与 xc 点积即可得到所有斜率
yc = W - mean[:, None]
slope = yc @ xc / (denom if denom != 0 else 1.0)
if denom == 0: slope[:] = 0.0            # w=1 的情况

features_per_w[int(w)] = (mean, std, mn, mx, slope)

# —— 对齐规则：第 r 行使用每个 w 的索引 r + (Wmax - w) ——
rows = []
for r in range(n):
parts = []
for w in wins:
idx = r + (Wmax - int(w))
mean, std, mn, mx, slope = features_per_w[int(w)]
parts.extend(fmt_arr(np.array([mean[idx], std[idx], mn[idx], mx[idx], slope[idx]])))
rows.append("[" + ", ".join(parts) + "]")

print("\n".join(rows))

Java
import java.util.*;

public class Main {
// 提取字符串中的整数，返回 int 数组
static int[] parse(String s) {
ArrayList<Integer> v = new ArrayList<>();
// 把非数字和负号替换成空格，方便 Scanner 读取
Scanner sc = new Scanner(s.replaceAll("[^0-9\\-]", " "));
while (sc.hasNextInt()) v.add(sc.nextInt()); // 逐个读出整数
sc.close();
int[] arr = new int[v.size()];
for (int i=0;i<arr.length;i++) arr[i]=v.get(i); // 转换为数组
return arr;
}

// 数值格式化：最多保留 3 位小数，去掉多余 0 和小数点
static String fmt(double x) {
double y = Math.round(x * 1000.0) / 1000.0;              // 四舍五入到三位
String s = String.format(Locale.US, "%.3f", y);          // 格式化为三位小数
int p=s.length()-1;
while (p>=0 && s.charAt(p)=='0') p--;                    // 去掉末尾的 0
if (p>=0 && s.charAt(p)=='.') p--;                       // 去掉末尾的小数点
return p>=0? s.substring(0,p+1):"0";                     // 防止结果为空
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
if (!in.hasNextLine()) return;           // 没有输入直接退出
String line = in.nextLine();             // 读入一行
in.close();

// 查找分隔符 "], ["
int pos=line.indexOf("], [");
if (pos==-1) { System.out.println("[]"); return; }

// 切分为两个子串：s1 表示原数组，s2 表示窗口数组
String s1=line.substring(0,pos+1);
String s2=line.substring(pos+1);

int[] a=parse(s1);       // 原数组
int[] wins=parse(s2);    // 窗口大小数组
if (a.length==0 || wins.length==0) { System.out.println("[]"); return; }

// 找出最大窗口，计算行数
int Wmax=Arrays.stream(wins).max().getAsInt();
int n=a.length - Wmax + 1;
if (n<=0) { System.out.println("[]"); return; }

StringBuilder out=new StringBuilder();
// 遍历每一行（输出 n 行）
for (int r=0;r<n;r++) {
ArrayList<String> row=new ArrayList<>();
// 遍历每个窗口大小
for (int w: wins) {
int s=r+(Wmax-w);    // 当前窗口的起点索引

// 均值 / 最小值 / 最大值
double sum=0; int mn=Integer.MAX_VALUE,mx=Integer.MIN_VALUE;
for (int k=0;k<w;k++) {
int v=a[s+k];
sum+=v; mn=Math.min(mn,v); mx=Math.max(mx,v);
}
double mean=sum/w;

// 样本标准差（ddof=1）
double stdv=0;
if (w>1) {
double sq=0;
for (int k=0;k<w;k++) {
double d=a[s+k]-mean; sq+=d*d;
}
stdv=Math.sqrt(sq/(w-1));
}

// 线性回归斜率（最小二乘）
double sumx=0,sumx2=0,sumy=0,sumxy=0;
for (int k=0;k<w;k++) {
sumx+=k; sumx2+=1.0*k*k;
sumy+=a[s+k]; sumxy+=1.0*k*a[s+k];
}
double D=w*sumx2 - sumx*sumx;
double slope=(D==0?0:(w*sumxy - sumx*sumy)/D);

// 将结果按要求加入当前行
row.add(fmt(mean));
row.add(fmt(stdv));
row.add(Integer.toString(mn));
row.add(Integer.toString(mx));
row.add(fmt(slope));
}
// 拼接一行输出
out.append('[').append(String.join(", ", row)).append(']');
if (r+1<n) out.append('\n'); // 行间换行
}
System.out.print(out.toString()); // 最终输出
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 把字符串里的整数提取出来
vector<int> parse(const string& s) {
vector<int> v; stringstream ss(s);
char c;
// 逐个读取字符
while (ss >> c) {
// 如果是数字或负号，就回退一格再读取成整数
if ((c >= '0' && c <= '9') || c == '-') {
ss.unget();          // 把字符放回流
int x; ss >> x;      // 读取一个整数
v.push_back(x);      // 保存到结果数组
}
}
return v;
}

// 保留最多三位小数，去掉多余 0 和点
string fmt(double x) {
double y = round(x * 1000.0) / 1000.0;   // 四舍五入到三位小数
stringstream ss;
ss << fixed << setprecision(3) << y;     // 格式化成固定三位小数
string s = ss.str();
while (!s.empty() && s.back() == '0') s.pop_back(); // 去掉末尾的 0
if (!s.empty() && s.back() == '.') s.pop_back();    // 去掉末尾的小数点
if (s.empty()) s = "0";                // 防止为空
return s;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line; getline(cin, line);          // 输入一行，如 [1,2,3,4,5],[2,3]
auto pos = line.find(']');                // 找到第一个 ] 的位置
string s1 = line.substr(0, pos+1);        // 前半部分（原数组）
string s2 = line.substr(pos+1);           // 后半部分（窗口数组）

vector<int> a = parse(s1);                // 解析原数组
vector<int> wins = parse(s2);             // 解析窗口数组
if (a.empty() || wins.empty()) {          // 边界处理
cout << "[]\n";
return 0;
}

int Wmax = *max_element(wins.begin(), wins.end()); // 最大窗口大小
int n = (int)a.size() - Wmax + 1;                  // 输出行数
if (n <= 0) { cout << "[]\n"; return 0; }

// 遍历每一行
for (int r = 0; r < n; r++) {
vector<string> row;    // 存储当前行的结果
// 遍历每个窗口大小
for (int w : wins) {
int s = r + (Wmax - w);   // 当前窗口的起始下标

// 计算均值 / 最小值 / 最大值
double sum = 0;
int mn = INT_MAX, mx = INT_MIN;
for (int k = 0; k < w; k++) {
int v = a[s+k];
sum += v;
mn = min(mn, v);
mx = max(mx, v);
}
double mean = sum / w;

// 计算样本标准差（ddof=1，w=1 时结果为 0）
double stdv = 0;
if (w > 1) {
double sq = 0;
for (int k = 0; k < w; k++) {
double d = a[s+k] - mean;
sq += d * d;
}
stdv = sqrt(sq / (w-1));
}

// 计算线性回归斜率
double sumx=0,sumx2=0,sumy=0,sumxy=0;
for (int k = 0; k < w; k++) {
sumx += k;
sumx2 += 1.0*k*k;
sumy += a[s+k];
sumxy += 1.0*k*a[s+k];
}
double D = w*sumx2 - sumx*sumx;
double slope = (D==0?0:(w*sumxy - sumx*sumy)/D);

// 把结果存入当前行
row.push_back(fmt(mean));
row.push_back(fmt(stdv));
row.push_back(to_string(mn));
row.push_back(to_string(mx));
row.push_back(fmt(slope));
}

// 输出当前行
cout << '[';
for (int i = 0; i < (int)row.size(); i++) {
if (i) cout << ", ";   // 元素之间加逗号
cout << row[i];
}
cout << "]";
if (r+1<n) cout << "\n";   // 行与行之间换行
}
return 0;
}

---

## 2025年9月5日-模拟赛-AI

### 第二题-阈值最优的决策树（P3528）
- 链接：https://codefun2000.com/p/P3528

> 页面标题：#P3528. 第二题-阈值最优的决策树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

决策树生成算法递归地产生决策树，直到不能继续下去为止，在这个过程中，最关键的是确定每个节点的阈值。一种传统方法是划分之后，需要使得数据集的熵减最大化。
而小明同学面对的问题是一个基座问题：只有一个特征的数据集的二分类问题。如果构建出二叉树，那么将形如：”一个根节点配两个儿子节点“的结构。
在这种问题下，小明希望通过一个更加简洁的策略来获得结果：枚举阈值，得到验证集上的最优的准确率。请问给定验证集，需要设定怎样的阈值使得准确率最大化。
请输出小AAA通过他提出的寻找阈值的策略，在验证集上可以达到的最优 准确率
输入描述
第一行一个整数M(1<=M<=105)M(1<=M<=10^5)M(1<=M<=105) 表示验证集条数
随后 MMM 行为验证集特征和 labellabellabel，每行 222 个整数，第一个数为该条数据的特征，最后一个整数为该条数据的 label∈[0,1]label \in [0,1]label∈[0,1] 。
随后一行两个整数L,RL,RL,R 分别代表左子树和右子数的labellabellabel , L≠R且L,R∈[0,1]L\neq R且L,R\in[0,1]L=R且L,R∈[0,1]
输出描述
第一行，一个浮点数，为验证集可达到的最优准确率，四舍五入保留小数点后 333 位。
样例1
输入
5
1 0
2 0
3 1
4 0
5 0
0 1

输出
0.800

说明
设定阈值=5=5=5 , 那么所有样本进入左子树，被归类为0 ， 准确率为45=0.8\frac{4}{5}=0.854​=0.8 , 注意保留三位小数
样例2
输入
5
1 1
2 1
3 1
4 0
5 0
1 0

输出
1.000

说明
设定阈值=3=3=3 , 那么样本1,2,31,2,31,2,3进入左子树，被归类为1 ，  样本4,5,64,5,64,5,6 进入右子树，被归类为000 ， 全部分类正确，准确率为111
提示
本题准确率的计算方法为:预测正确的样本个数总样本个数本题准确率的计算方法为:\frac{预测正确的样本个数}{总样本个数}本题准确率的计算方法为:总样本个数预测正确的样本个数​

▶️

#### TextSol

video solution

思路

关键：因为特征是一维且阈值只按大小划分，所以只需在相邻不同特征值之间、以及两端考虑切分点。重复特征值的样本不可被阈值拆分，需整组一起在同侧。

做法：

将样本按特征 xxx 升序排序。

预处理前缀计数 prefL(i)\text{prefL}(i)prefL(i)：排序后前 iii 个（含 iii）中标签等于 LLL 的数量。

预处理后缀计数 sufR(i)\text{sufR}(i)sufR(i)：排序后从 iii 到末尾中标签等于 RRR 的数量。

只在每个“特征值分组的末尾”作为切分（记该位置为 iii）计算
correct(i)\text{correct}(i)correct(i)=prefL(i)\text{prefL}(i)prefL(i)+sufR(i+1)\text{sufR}(i+1)sufR(i+1)
同时考虑两端：
correct(−1)\text{correct}(-1)correct(−1)=sufR(0),correct(n−1)\text{sufR}(0),\quad \text{correct}(n-1)sufR(0),correct(n−1)=prefL(n−1)\text{prefL}(n-1)prefL(n−1)

取最大正确数，准确率为该最大值除以 MMM。

复杂度：排序 O(Mlog⁡M)O(M\log M)O(MlogM)，线性扫描与前后缀 O(M)O(M)O(M)。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int M;
if (!(cin >> M)) return 0;
vector<pair<long long,int>> a(M);
for (int i = 0; i < M; ++i) {
long long x; int y;
cin >> x >> y;
a[i] = {x, y};
}
int L, R;
cin >> L >> R;

sort(a.begin(), a.end(), [](const auto& p1, const auto& p2){
if (p1.first != p2.first) return p1.first < p2.first;
return p1.second < p2.second;
});

vector<int> prefL(M, 0), sufR(M, 0);
for (int i = 0; i < M; ++i) {
prefL[i] = (i ? prefL[i-1] : 0) + (a[i].second == L);
}
for (int i = M - 1; i >= 0; --i) {
sufR[i] = (i + 1 < M ? sufR[i+1] : 0) + (a[i].second == R);
}

long long best = 0;
// 阈值小于最小特征：全部走右子树
if (M > 0) best = max<long long>(best, sufR[0]);

// 在每个“特征值分组的末尾”作为切分
for (int i = 0; i + 1 < M; ++i) {
if (a[i].first != a[i+1].first) {
long long correct = prefL[i] + sufR[i+1];
if (correct > best) best = correct;
}
}

// 阈值大于等于最大特征：全部走左子树
if (M > 0) best = max<long long>(best, prefL[M-1]);

double acc = (M == 0) ? 0.0 : (double)best / (double)M;
cout.setf(std::ios::fixed);
cout << setprecision(3) << acc << "\n";
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
M = int(next(it))
a = []
for _ in range(M):
x = int(next(it)); y = int(next(it))
a.append((x, y))
L = int(next(it)); R = int(next(it))

a.sort(key=lambda p: (p[0], p[1]))

prefL = [0]*M
sufR = [0]*M
for i in range(M):
prefL[i] = (prefL[i-1] if i > 0 else 0) + (1 if a[i][1] == L else 0)
for i in range(M-1, -1, -1):
sufR[i] = (sufR[i+1] if i+1 < M else 0) + (1 if a[i][1] == R else 0)

best = 0
if M > 0:
best = max(best, sufR[0])  # 阈值在最小特征左侧
for i in range(M-1):
if a[i][0] != a[i+1][0]:
best = max(best, prefL[i] + sufR[i+1])
best = max(best, prefL[M-1])  # 阈值在最大特征右侧

acc = 0.0 if M == 0 else best / M
print(f"{acc:.3f}")

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

// 读入、排序、前后缀统计、仅在不同特征值的分界处计算正确数
public class Main {
static class Pair {
long x;
int y;
Pair(long x, int y) { this.x = x; this.y = y; }
}

public static void main(String[] args) throws Exception {
BufferedInputStream bis = new BufferedInputStream(System.in);
FastScanner fs = new FastScanner(bis);
Integer MM = fs.nextInt();
if (MM == null) return;
int M = MM;
List<Pair> a = new ArrayList<>(M);
for (int i = 0; i < M; i++) {
long x = fs.nextLong();
int y = fs.nextInt();
a.add(new Pair(x, y));
}
int L = fs.nextInt();
int R = fs.nextInt();

a.sort((p1, p2) -> {
if (p1.x != p2.x) return Long.compare(p1.x, p2.x);
return Integer.compare(p1.y, p2.y);
});

int[] prefL = new int[M];
int[] sufR = new int[M];
for (int i = 0; i < M; i++) {
prefL[i] = (i > 0 ? prefL[i-1] : 0) + (a.get(i).y == L ? 1 : 0);
}
for (int i = M - 1; i >= 0; i--) {
sufR[i] = (i + 1 < M ? sufR[i+1] : 0) + (a.get(i).y == R ? 1 : 0);
}

long best = 0;
if (M > 0) {
best = Math.max(best, sufR[0]); // 阈值在最小特征左侧
for (int i = 0; i + 1 < M; i++) {
if (a.get(i).x != a.get(i+1).x) {
long correct = (long)prefL[i] + (long)sufR[i+1];
if (correct > best) best = correct;
}
}
best = Math.max(best, prefL[M-1]); // 阈值在最大特征右侧
}

double acc = (M == 0) ? 0.0 : (double)best / (double)M;
System.out.printf(java.util.Locale.ROOT, "%.3f%n", acc);
}

// 简易高速读入
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { this.in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
while ((c = read()) <= ' ') {
if (c == -1) return null;
}
do {
sb.append((char)c);
c = read();
} while (c > ' ');
return sb.toString();
}
Integer nextInt() throws IOException {
String s = next();
return s == null ? null : Integer.parseInt(s);
}
Long nextLong() throws IOException {
String s = next();
return s == null ? null : Long.parseLong(s);
}
}
}

---

### 第三题-随机游走问题（P3529）
- 链接：https://codefun2000.com/p/P3529

> 页面标题：#P3529. 第三题-随机游走问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

随机游走模型（Random Walk Model）是一种随机过程（stochastic process），用来描述一个变量随时间的变化路径，其中每一步的变化是由随机误差或概率转移决定的，并且这些变化相互独立、同分布。它常用于刻画股票价格、汇率等金融时间序列的不可预测性。
在本题中，我们有 nnn 个不同的事件（状态），编号为 1,2,…,n1, 2, \dots, n1,2,…,n 。
在任意两个事件 i,ji, ji,j 之间，有一个转移概率 P(i,j)P(i, j)P(i,j)，表示当当前事件是 iii  时，下一事件是 jjj 的概率。所有转移概率构成一个 概率转移矩阵 PPP，满足每行之和等于 111，且 P(i,j)≥0P(i,j) \ge 0P(i,j)≥0。
小明刚刚处理完事件 sss，他将连续处理 kkk 个事件。在整个处理过程中，不能出现事件 xxx（即处理序列中不允许包含 xxx 事件）。
请你计算：发生这个复杂事件的概率是多少？
输入格式

第一行：一个整数 nnn — 事件的个数（1≤n≤501 \le n \le 501≤n≤50）

第二行：三个整数 s,x,ks, x, ks,x,k

sss — 起始事件编号（1≤s≤n1 \le s \le n1≤s≤n）
xxx — 不允许处理的事件（1≤x≤n,x≠s1 \le x \le n ,x \neq s1≤x≤n,x=s）
kkk — 处理的事件个数

注意：这里的“处理的事件个数 kkk”指从初始状态开始，依次经历 kkk 次状态变化后结束的路径长度。

接下来 nnn 行，每行 nnn 个实数，第 iii  行第 jjj 列为 P(i,j)P(i,j)P(i,j)，即从事件 iii 转移到事件 jjj 的概率。
每行的概率和为 111，每个概率满足 0≤P(i,j)≤10 \le P(i,j) \le 10≤P(i,j)≤1。

数据保证
40%40\%40%的数据满足:k≤7k \leq 7k≤7
100%100\%100%的数据满足:k≤200k \leq 200k≤200
输出格式

输出一个实数，表示所求概率。
答案保留6位小数

样例输入
3
1 2 2
0.5 0.5 0
0.2 0.3 0.5
0.4 0.5 0.1

样例输出
0.250000

说明
样例中：

事件总数为 n=3n = 3n=3
起点 s=1s = 1s=1
不允许出现的事件 x=2x = 2x=2
处理 222 个事件（即转移 222 步）

#### TextSol

解题思路（动态规划）
把所有到达 xxx 的路径视为“失败”（概率计为 0），只在其余状态之间做概率累积。
状态定义
令 dp[t][i] 表示：从起点 s 出发，走了 t 步，且整个过程未到达 x，此时停在状态 i 的概率（其中 i ≠ x）。
转移方程
只允许从非 x 状态转到非 x 状态：
$$dp[t+1][j] \;+=\; dp[t][i]\times P(i,j), \quad \text{其中 } i\neq x,\; j\neq x$$同时保持 dp[t][x] = 0。
初始条件与答案

初始：dp[0][s] = 1，其余为 0。
答案：∑j≠xdp[k][j]\sum_{j\neq x} dp[k][j]∑j=x​dp[k][j]（第 kkk 步仍未到达 xxx 的总概率）。

复杂度分析
每步转移需枚举所有 i→j（i,j≠x），复杂度 O(n2)O(n^2)O(n2)，总计 O(k n2)O(k\,n^2)O(kn2)。
在约束 n≤50,  k≤200n\le 50,\; k\le 200n≤50,k≤200 下，计算量 ≤5×105\le 5\times 10^5≤5×105 次乘加，轻松通过。
参考实现
Python
import sys

def main():
data = sys.stdin.read().strip().split()
it = iter(data)
n = int(next(it))
s = int(next(it)) - 1  # 改为0索引
x = int(next(it)) - 1
k = int(next(it))
P = [[float(next(it)) for _ in range(n)] for _ in range(n)]

# dp[t][i]: 走了t步、未到达x、在i的概率
dp = [0.0] * n
dp[s] = 1.0

for _ in range(k):
ndp = [0.0] * n
# 仅在 i != x、j != x 之间转移
for i in range(n):
if i == x or dp[i] == 0.0:
continue
pi = P[i]
for j in range(n):
if j == x:
continue
ndp[j] += dp[i] * pi[j]
dp = ndp

# 末状态不限：累加所有 j != x
ans = sum(dp[j] for j in range(n) if j != x)
# 若要求“回到 s ”：改为 ans = dp[s]

print(f"{ans:.6f}")

if __name__ == "__main__":
main()

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n;
if (!(cin >> n)) return 0;
int s, x, k;
cin >> s >> x >> k;
--s; --x; // 改为0索引
vector<vector<double>> P(n, vector<double>(n));
for (int i = 0; i < n; ++i)
for (int j = 0; j < n; ++j)
cin >> P[i][j];

vector<double> dp(n, 0.0);
dp[s] = 1.0;

for (int step = 0; step < k; ++step) {
vector<double> ndp(n, 0.0);
for (int i = 0; i < n; ++i) {
if (i == x || dp[i] == 0.0) continue; // 不能从x出发
for (int j = 0; j < n; ++j) {
if (j == x) continue;             // 不能到达x
ndp[j] += dp[i] * P[i][j];
}
}
dp.swap(ndp);
}

double ans = 0.0;
for (int j = 0; j < n; ++j)
if (j != x) ans += dp[j];
// 若要求“回到 s ”：改为 ans = dp[s]

cout.setf(std::ios::fixed); cout << setprecision(6) << ans << "\n";
return 0;
}

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
String t = sc.next();
if (t == null) return;
int n = Integer.parseInt(t);
int s = sc.nextInt() - 1;  // 改为0索引
int x = sc.nextInt() - 1;
int k = sc.nextInt();

double[][] P = new double[n][n];
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
P[i][j] = sc.nextDouble();

double[] dp = new double[n];
dp[s] = 1.0;

for (int step = 0; step < k; step++) {
double[] ndp = new double[n];
for (int i = 0; i < n; i++) {
if (i == x || dp[i] == 0.0) continue; // 不从x转移
for (int j = 0; j < n; j++) {
if (j == x) continue;             // 不到x
ndp[j] += dp[i] * P[i][j];
}
}
dp = ndp;
}

double ans = 0.0;
for (int j = 0; j < n; j++)
if (j != x) ans += dp[j];
// 若要求“回到 s ”：改为 ans = dp[s]

System.out.printf("%.6f%n", ans);
}
}

---

## 2025年9月4日-留学生-AI

### 第2题-大模型训练数据均衡分配算法（P3561）
- 链接：https://codefun2000.com/p/P3561

> 页面标题：#P3561. 第2题-大模型训练数据均衡分配算法

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

大模型训练通常采用数据并行的训练方式，处理大规模数据集(样本)，加速训练过程，具休的:
假设有nnn个NPUNPUNPU，mmm个样本，把mmm个样本分给nnn个NPUNPUNPU，每个NPUNPUNPU上有一份完整模型，各自计算自己的样本数据，其中m>=nm>=nm>=n，保证每个NPUNPUNPU至少分到一个样本，且样本不能切分，一个样本必须完整的被分到个NPUNPU NPU上
每个NPUNPUNPU的运行时间跟所分到的样本的长度和呈正相关。如果每个NPUNPUNPU上的样本长度和相差较大，会形成木桶效应，执行快的NPUNPUNPU等待执行慢的NPUNPUNPU，最终执行时间由最大样本和长度的NPUNPUNPU决定。
试着编号一段程序对样本进行均衡分配，设nnn个NPUNPUNPU上分得的最大的样本和为lmaxl_{max}lmax​，使lmaxl_{max}lmax​最小，即求min(lmax)min(l_{max})min(lmax​)
输入描述
第一行为111个整数n(0<n<1000)n(0< n< 1000)n(0<n<1000)，表示NPUNPUNPU的个数
第二行为111个整数m(0<m<10000)m(0 < m< 10000)m(0<m<10000)，表示样本的个数
第三行有mmm个处于区间[1,100000][1,100000][1,100000]之内的整数，表示mmm个样本中每个样本的长度
输出描述
输出111个整数(行尾没有空格)，该数字表示min(lmax)min(l_{max})min(lmax​)的值,
样例1
输入
4
7
89 245 64 128 79 166 144

输出
245

说明
样本根据NPUNPUNPU个数进行分组，一共有444个NPUNPUNPU，所以有444个分组，最优样本分配如下:
$(1)79,144 \  (2)245 \      (3)64，166  \      (4)128，89$
求和分别为:223，245，230，217223，245，230，217223，245，230，217；444个NPUNPUNPU中最大的样本长度和为245245245、所以输出245245245
样例2
输入
2
3
145 274 100

输出
274

样本根据NPUNPUNPU个数进行分组，一共有222个NPUNPUNPU，333个样本；所以有222个分出，有以下333种分法:
(1)145,274+100；(2)274,145+100；(3)100，145+274(1)145,274+100；(2)274,145+100；(3)100，145+274(1)145,274+100；(2)274,145+100；(3)100，145+274
333种分法的最大样本和分别为:374，274，419374，274，419374，274，419;
所以第222种分法超均衡，最大样本和长度最小，为274274274，所以输出274

▶️

#### TextSol

video solution

本题为np-hard问题，以下给出近似解法

解题思路
算法选择：LPT 贪心 + 最小堆

将样本时长按从大到小排序。
使用一个大小为 n 的最小堆（优先队列）来维护每个 NPU 的当前负载，初值全为 0。
依次取出当前最大的样本，把它放到当前负载最小的 NPU 上（堆顶），更新该 NPU 的负载并压回堆。
全部分配完成后，所有 NPU 负载中的最大值即为答案。

直觉：把大的任务优先安排，并始终让它落到当前最“空闲”的设备，可有效压低最大负载。
该策略在工程中广泛使用，复杂度低、效果稳定；且在测试样例中取得最优值。
正确性要点

任何可行分配的最大负载下界为 max(a[i])（因为最大的任务至少要放到某一台机器上）。
LPT 通过“最大任务优先 + 把它给最空的机器”的组合，尽量不让某一台机器独自承担巨大的额外负载，从而逼近最优。

复杂度分析

排序：O(m log m)
每个样本做一次“取堆顶 + 更新 + 入堆”：O(log n)，总计 O(m log n)
整体复杂度：O(m log m + m log n)，在 m ≤ 1e4, n ≤ 1e3 下完全可行。
额外空间：O(n)（维护堆）。

代码实现
Python
from typing import List
import heapq

def group_samples(group_num: int, sample_num: int, sample_lens: List[int]):
n, m = group_num, sample_num
a = sample_lens

# 特判：没有样本
if m == 0:
print(0)
return

# 将样本按从大到小排序（LPT 的“Longest”）
a.sort(reverse=True)

# 最小堆保存每个 NPU 的当前负载，初始全 0
load = [0] * n
heapq.heapify(load)

# 逐个样本分配到当前最空闲的 NPU（堆顶）
ans = 0
for x in a:
cur = heapq.heappop(load)   # 取出当前最小负载
cur += x                    # 分配该样本
ans = max(ans, cur)         # 维护最大负载
heapq.heappush(load, cur)   # 放回堆

print(ans)

if __name__ == "__main__":
# 读取输入：n, m, 接着一行 m 个数字
n = int(input().strip())
m = int(input().strip())
lens = list(map(int, input().strip().split()))
group_samples(n, m, lens)

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int m = sc.nextInt();

int[] a = new int[m];
for (int i = 0; i < m; i++) a[i] = sc.nextInt();

if (m == 0) {
System.out.println(0);
return;
}

// 按从大到小排序
Arrays.sort(a);
// 逆序访问（最大先）
// Java 的优先队列是小根堆：存放每个 NPU 的当前负载
PriorityQueue<Long> pq = new PriorityQueue<>();
for (int i = 0; i < n; i++) pq.add(0L);

long ans = 0;
for (int i = m - 1; i >= 0; i--) {
long cur = pq.poll();   // 取最小负载
cur += a[i];            // 放入当前任务
ans = Math.max(ans, cur);
pq.add(cur);            // 压回堆
}
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, m;
if (!(cin >> n)) return 0;
cin >> m;
vector<long long> a(m);
for (int i = 0; i < m; ++i) cin >> a[i];

if (m == 0) { cout << 0 << "\n"; return 0; }

// 从大到小排序
sort(a.begin(), a.end(), greater<long long>());

// 小根堆：存每个 NPU 当前负载
priority_queue<long long, vector<long long>, greater<long long>> pq;
for (int i = 0; i < n; ++i) pq.push(0);

long long ans = 0;
for (long long x : a) {
long long cur = pq.top(); pq.pop(); // 取最小负载
cur += x;                           // 分配样本
ans = max(ans, cur);                // 维护最大负载
pq.push(cur);                       // 放回堆
}
cout << ans << "\n";
return 0;
}

---

### 第2题-多段数据下发（P3555）
- 链接：https://codefun2000.com/p/P3555

> 页面标题：#P3555. 第2题-多段数据下发

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在数通设备进行配置下发时，可能会遇到需要下发一个或多个数据段的场景。例如在配置某协议支持的算法类型时，需要下发配置
如 “algorithmalgorithmalgorithm 1−10,15−201-10,15-201−10,15−20"，用于表明支持的所有算法段范围为 "1−10,15−201-10,15-201−10,15−20"。
为了简化用户操作，数据下发往往同时支持散列及段下发模式，同时对数据段的顺序不做要求，也即允许"algorithmalgorithmalgorithm 1−9,10,17−20,15−151-9,10,17-20,15-151−9,10,17−20,15−15”的方式。下发后的数据会整理合并保存在数据库中，合并结果满足以下条件：
1.数据段无法继续合并。
2.数据段从小到大排列。
3.长度为 111 的数据段保存为单个数字形式。
举例来说，"algorithmalgorithmalgorithm 1−9,10,17−20,15−151-9,10,17-20,15-151−9,10,17−20,15−15"下发后数据库中储存的数据为“1−10,15,17−201-10,15,17-201−10,15,17−20"。
数据合并规则：

在数据库已有数据的情况下，用户新下发的配置不会覆盖已有配置，而是将新增的数据段命并到已有数据中

例如:数据库中已存在”1−10,15−201-10,15-201−10,15−20"时，再下发"algorithmalgorithmalgorithm 5−115-115−11"时数据库数据，会合并更新为"1−111-111−11 , 15−2015-2015−20"。

数据删除规则：

用户下发删除配置时，从已有范围中删除与下发范围重合的范围

例如:数据库中已存在”1−10,15−201-10,15-201−10,15−20"时，再下发"undoundoundo algorithmalgorithmalgorithm 5−11,165-
11,165−11,16"时，数据库会更新为"1−4,15,17−201-4,15,17-201−4,15,17−20"。
任务：给定一系列配置/删除操作，输出最后的数据库更新结果。

输入描述
第一行为 111 个整数 nnn ，表示下发操作的数量，n<=100n<=100n<=100
接下来 nnn 行每行包含 111 个字符串，表明下发的配置/删除操作。配置操作格式为"algorithmalgorithmalgorithm 数据"，删除操作 "undoundoundo algorithmalgorithmalgorithm 数据"，数据格式如下所示。
字符串数据格式描述：
1.原子数据，单个正整数(“aaa”)、正整数-正整数("a−ba-ba−b")，其中 a<=ba<=ba<=b ，每个数的范围为 1−655361-655361−65536
2.字符里组成由原子数据拼接 “,” 组成 ("a−b,c,d−ea-b,c,d-ea−b,c,d−e")
注：
1.用例保证所有输入均合法，输入不保证原子数据排序
2.原子数据段的数量不超过 100100100
3.数据库中数据为空时，删除操作视为无效操作
输出描述
111 个字符串，表明合并保存后的数据库结果。数据格式与输入中描述字符串数据格式相同。
若最终数据库为空，输出 000
样例1
输入
3
undo algorithm 1-100
algorithm 15-20,1-10
undo algorithm 6,7,8,9-10

输出
1-5,15-20

说明
数据库初始为空
配置 undoundoundo algorithmalgorithmalgorithm 1−100=>1-100 =>1−100=>无效，仍为空
配置 algorithmalgorithmalgorithm 1−10,15−20=>1−10,15−201-10,15-20=>1-10,15-201−10,15−20=>1−10,15−20
配置 undoundoundo algorithmalgorithmalgorithm 6,7,8,9−10=>1−5,15−206,7,8,9-10 =>1-5,15-206,7,8,9−10=>1−5,15−20
样例2
输入
2
algorithm 1-10,15-20
algorithm 5-11

输出
1-11,15-20

说明
数据库初始为空
配置 algorithmalgorithmalgorithm 1−10,15−20=>1−10,15−201-10,15-20=>1-10,15-201−10,15−20=>1−10,15−20
配置 algorithmalgorithmalgorithm 5−11=>1−11,15−205-11 =>1-11,15-205−11=>1−11,15−20

▶️

#### TextSol

video solution

题目描述
给定一系列“配置”与“删除”操作，每个操作都包含一个或多个数据段（范围）。

配置操作：将新下发的范围合并（并集）到已有数据库中，不覆盖已有配置。
删除操作：从已有数据库中减去（差集）下发的范围。

最终要求将数据库中的所有区间：

不可再合并；
按从小到大排序；
单个元素的区间以单个数字形式保存。

例如，初始为空，依次下发：

algorithm 1-9,10,17-20,15-15
undo algorithm 5-11,16

最终结果为 $1-4,15,17-20$。
思路

数据结构：维护一个vector<pair<int,int>> intervals，表示当前已存数据库区间集合。

解析输入：将每个操作行拆分，识别是否为删除（前缀undo），再将“原子数据”如a或a-b转成(a,a)或(a,b)。

合并操作

将待添加的所有区间加入到intervals中；
按左端点升序排序；
依次扫描，将能合并或相邻（若cur.second+1 >= next.first）的区间合并成一个。

删除操作

对于每个现存区间[l,r]，遍历所有待删区间[dl,dr]，在两个区间有重叠时，将[l,r]切分为：

(l, dl-1)（若l < dl）
(dr+1, r)（若dr < r）

收集所有切分后的区间，再做一次合并与排序以保证结构正确。

输出格式化

对最终intervals，若l==r输出l，否则输出l-r，区间间用逗号隔开；
若空集，输出0。

C++
#include <bits/stdc++.h>
using namespace std;

// 将字符串 data 拆分为区间列表
vector<pair<int,int>> parse(const string &data) {
vector<pair<int,int>> res;
stringstream ss(data);
string token;
while (getline(ss, token, ',')) {
int dash = token.find('-');
if (dash == string::npos) {
int x = stoi(token);
res.emplace_back(x, x);
} else {
int a = stoi(token.substr(0, dash));
int b = stoi(token.substr(dash+1));
res.emplace_back(a, b);
}
}
return res;
}

// 对区间列表进行合并（并集）
vector<pair<int,int>> mergeIntervals(vector<pair<int,int>> iv) {
if (iv.empty()) return {};
sort(iv.begin(), iv.end());
vector<pair<int,int>> ans;
auto [l, r] = iv[0];
for (int i = 1; i < iv.size(); i++) {
auto [l2, r2] = iv[i];
if (r + 1 < l2) {
ans.emplace_back(l, r);
l = l2; r = r2;
} else {
r = max(r, r2);
}
}
ans.emplace_back(l, r);
return ans;
}

// 删除操作：从 iv 中减去 del 区间集合
vector<pair<int,int>> subtractIntervals(const vector<pair<int,int>> &iv,
const vector<pair<int,int>> &del) {
vector<pair<int,int>> cur = iv;
for (auto [dl, dr] : del) {
vector<pair<int,int>> tmp;
for (auto [l, r] : cur) {
if (r < dl || dr < l) {
// 无重合，保留
tmp.emplace_back(l, r);
} else {
// 有重合，切分
if (l < dl) tmp.emplace_back(l, dl - 1);
if (dr < r) tmp.emplace_back(dr + 1, r);
}
}
cur = move(tmp);
}
// 删除后可能产生可合并区间，统一合并
return mergeIntervals(cur);
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
vector<pair<int,int>> db;  // 当前数据库区间
string line;
getline(cin, line);  // 读掉行尾

while (n--) {
getline(cin, line);
bool isUndo = false;
string data;
if (line.rfind("undo", 0) == 0) {
// 删除操作
isUndo = true;
data = line.substr(line.find(' ', 5) + 1);
} else {
// 配置操作
data = line.substr(line.find(' ') + 1);
}
auto segs = parse(data);
if (isUndo) {
if (!db.empty())
db = subtractIntervals(db, segs);
} else {
// 合并新增区间到 db
db.insert(db.end(), segs.begin(), segs.end());
db = mergeIntervals(db);
}
}

// 输出结果
if (db.empty()) {
cout << 0;
} else {
for (int i = 0; i < db.size(); i++) {
auto [l, r] = db[i];
if (l == r) cout << l;
else cout << l << "-" << r;
if (i + 1 < db.size()) cout << ",";
}
}

return 0;
}

Python
import sys

def parse(data):
segs = []
for token in data.split(','):
if '-' in token:
a, b = map(int, token.split('-'))
else:
a = b = int(token)
segs.append((a, b))
return segs

def merge_intervals(iv):
if not iv: return []
iv.sort()
res = []
l, r = iv[0]
for nl, nr in iv[1:]:
if r + 1 < nl:
res.append((l, r))
l, r = nl, nr
else:
r = max(r, nr)
res.append((l, r))
return res

def subtract_intervals(iv, dels):
cur = iv
for dl, dr in dels:
tmp = []
for l, r in cur:
if r < dl or dr < l:
tmp.append((l, r))
else:
if l < dl:
tmp.append((l, dl-1))
if dr < r:
tmp.append((dr+1, r))
cur = tmp
return merge_intervals(cur)

def main():
n = int(sys.stdin.readline())
db = []
for _ in range(n):
line = sys.stdin.readline().strip()
if line.startswith("undo"):
data = line.split(maxsplit=2)[2]
segs = parse(data)
if db:
db = subtract_intervals(db, segs)
else:
data = line.split(maxsplit=1)[1]
segs = parse(data)
db.extend(segs)
db = merge_intervals(db)
if not db:
print(0)
else:
print(','.join(f"{l}-{r}" if l!=r else str(l) for l, r in db))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
// 解析“a”或“a-b”格式的字符串
static List<int[]> parse(String data) {
List<int[]> res = new ArrayList<>();
for (String token : data.split(",")) {
if (token.contains("-")) {
String[] parts = token.split("-");
res.add(new int[]{Integer.parseInt(parts[0]), Integer.parseInt(parts[1])});
} else {
int x = Integer.parseInt(token);
res.add(new int[]{x, x});
}
}
return res;
}

// 合并区间
static List<int[]> mergeIntervals(List<int[]> iv) {
if (iv.isEmpty()) return new ArrayList<>();
iv.sort(Comparator.comparingInt(a -> a[0]));
List<int[]> ans = new ArrayList<>();
int l = iv.get(0)[0], r = iv.get(0)[1];
for (int i = 1; i < iv.size(); i++) {
int nl = iv.get(i)[0], nr = iv.get(i)[1];
if (r + 1 < nl) {
ans.add(new int[]{l, r});
l = nl; r = nr;
} else {
r = Math.max(r, nr);
}
}
ans.add(new int[]{l, r});
return ans;
}

// 删除区间
static List<int[]> subtractIntervals(List<int[]> iv, List<int[]> dels) {
List<int[]> cur = iv;
for (int[] del : dels) {
int dl = del[0], dr = del[1];
List<int[]> tmp = new ArrayList<>();
for (int[] seg : cur) {
int l = seg[0], r = seg[1];
if (r < dl || dr < l) {
tmp.add(new int[]{l, r});
} else {
if (l < dl) tmp.add(new int[]{l, dl - 1});
if (dr < r) tmp.add(new int[]{dr + 1, r});
}
}
cur = tmp;
}
return mergeIntervals(cur);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
sc.nextLine();
List<int[]> db = new ArrayList<>();
while (n-- > 0) {
String line = sc.nextLine();
boolean isUndo = line.startsWith("undo");
String data = isUndo
? line.split(" ", 3)[2]
: line.split(" ", 2)[1];
List<int[]> segs = parse(data);
if (isUndo) {
if (!db.isEmpty()) {
db = subtractIntervals(db, segs);
}
} else {
db.addAll(segs);
db = mergeIntervals(db);
}
}
if (db.isEmpty()) {
System.out.print(0);
} else {
StringJoiner sj = new StringJoiner(",");
for (int[] seg : db) {
if (seg[0] == seg[1]) sj.add(String.valueOf(seg[0]));
else sj.add(seg[0] + "-" + seg[1]);
}
System.out.print(sj.toString());
}
}
}

---

### 第3题-传感器数据分析（P3562）
- 链接：https://codefun2000.com/p/P3562

> 页面标题：#P3562. 第3题-传感器数据分析

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某工业制造企业在其生产线上部署了多台传感器以监控关键设备(如电机、泵、压缩机等)的运行状态。这些传感器周期性地采集设备的多维度运行数据(如温度、振动、压力、电流、转速等)，每隔固定时间窗口会生成一组时序特征数据。为了实现设备早期故障预警，需要对每一组采集到时序数据进行异常检测和评分。工程师们通过人工标记历史数据集，训练出一套多层自注意力(Self−Attention)(Self-Attention)(Self−Attention)+多层全连接层(FC)(FC)(FC)结构的神经网管模型。现在，为了模型的快速部罢与测试，需要根据题目中给定的网络权重参数，编写代码完成端到端推理，输出每一组传感器时序数据的最终导常分数。结构如下图所示:

具体说明如下：

每一组采集数据为一个二维矩阵，尺寸为LLL，LLL采样时序长度，DDD为每次采样包含的特征数(如:101010个时间点、每点555个特征)。

网络结构为:两层Self−AttentionSelf-AttentionSelf−Attention，每层后接全连接层FCFCFC，最终输出异常分数。为简化起见，网络中无非线性激活函数。

Self−AttentonSelf-AttentonSelf−Attenton采用Dot−productAttentionDot-product AttentionDot−productAttention，计算公式如下:$\operatorname{Attention}(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V$

输入描述
第一行:序列长度 L∈[1,10]L∈[1,10]L∈[1,10]、特征维度D∈[1,10] D∈ [1,10]D∈[1,10]
第二行:输入序列，L×DL×DL×D个数
第333~555行:第一层SeIfAttentionSeIfAttentionSeIfAttention参数Wq1W_{q1}Wq1​，Wk1W_k1Wk​1，Wv1W_v1Wv​1每行D×DD×DD×D个数
第666行:第-层FCFCFC参数Wfc1W_{fc1}Wfc1​ ，D×DD×DD×D 个数
第777行:第一层FCFCFC偏置 bfc1b_{fc1}bfc1​，DDD 个数
第888~101010行:第二层Self−AttentionSelf-AttentionSelf−Attention参数Wq2W_{q2}Wq2​，Wk2W_{k2}Wk2​，Wv2W_{v2}Wv2​，每行D×DD×DD×D个数
第111111行:第层FCFCFC参数Wfc2W_{fc2}Wfc2​，D×DD×DD×D个数
第121212行:第二层FCFCFC编置bfc2b_{fc2}bfc2​，DDD个数
输出描述
一行，即最终FCFCFC输出，L×DL×DL×D个数
注:数据间用返号隔开，输出结果均保留222位小数
样例1
输入
4,1
1.00,-3.00,9.50,6.50
-0.20
0.45
-0.20
0.60
0.15
0.23
-0.34
0.50
-0.32
0.05

输出
0.04,0.04,0.05,0.05

说明
输入：
首行:4 14\ 14 1表示序列长度L=4L=4L=4，特征维度D=1D=1D=1
第二行:1.00,−3.00,9.50,6.501.00,-3.00,9.50,6.501.00,−3.00,9.50,6.50
输入序列为4×1=4 4×1=44×1=4，即444个时刻的传感器数据
第333~555行:第一层SelfAttentionSelfAttentionSelfAttention参数Wq1W_{q1}Wq1​,Wk1W_{k1}Wk1​，Wv1W_{v1}Wv1​(每行111个数)
第666行:第一层FCFCFC参数Wfc1W_{fc1}Wfc1​(111个数)
第7行:第一层FCFCFC偏置 bfc1b_{fc1}bfc1​(111个数)
第888~101010行:第二层Self−AttentionSelf-AttentionSelf−Attention参数Wq2,Wk2,WV2W_{q2},W_{k2},W_{V2}Wq2​,Wk2​,WV2​(每行1个数)
第111111行:第二层FCFCFC参数 Wfc2W_{fc2}Wfc2​(111个数)
第121212行:第二层FCFCFC偏置 bfc2b_{fc2}bfc2​(111个数)
输出：
最终FCFCFC输出的4×1=44×1=44×1=4个数，英文逗号分隔。
样例2
输入
2,2
1.00,2.00,3.00,4.00
0.10,0.20,0.30,0.40
-0.10,-0.20,-0.30,-0.40
0.50,0.60,0.70,0.80
-0.50,-0.60,-0.70,-0.80
0.01,0.02
0.11,0.12,0.13,0.14
-0.11,-0.12,-0.13,-0.14
0.21,0.22,0.23,0.24
-0.21,-0.22,-0.23,-0.24
0.03,0.04

输出
0.66,0.69,0.66,0.69

说明
输入：
首行:2 22\ 22 2表示序列长度L=2L=2L=2，特征维度D=2D=2D=2
第二行:1.00,2.00,3.00,4.001.00,2.00,3.00,4.001.00,2.00,3.00,4.00
输入序列为2×2 2×22×2，分别为第111时刻(1.00,2.00)(1.00,2.00)(1.00,2.00)，第222时刻(3.00,4.00)(3.00,4.00)(3.00,4.00)
第333~555行:第一层SelfAttentionSelfAttentionSelfAttention参数Wq1W_{q1}Wq1​，Wk1W_{k1}Wk1​，Wv1W_{v1}Wv1​(每行2×22×22×2个数)
第666行:第一层FCFCFC参数Wfc1W_{fc1}Wfc1​(2×2 2×22×2个数)
第7行:第一层FCFCFC偏置 bfc1b_{fc1}bfc1​(222个数)
第888~101010行:第二层Self−AttentionSelf-AttentionSelf−Attention参数Wq2,Wk2,WV2W_{q2},W_{k2},W_{V2}Wq2​,Wk2​,WV2​(每行2×22×22×2个数)
第111111行:第二层FCFCFC参数 Wfc2W_{fc2}Wfc2​(2×22×22×2个数)
第121212行:第二层FCFCFC偏置 bfc2b_{fc2}bfc2​(222个数)
输出：
最终FCFCFC输出的2×2=42×2=42×2=4个数，英文逗号分隔。

#### TextSol

解题思路
1) 关键算法

Scaled Dot-Product Self-Attention
对输入 X (L×D)：

线性映射：Q=XWq, K=XWk, V=XWv（均为 L×D）。
打分：S = QK^T / sqrt(D)（L×L）。
归一化：对 S 每行做 softmax 得到注意力矩阵 A。
聚合：Y = A V（L×D）。

全连接(FC)：Y = XW + b，其中 b 对 L 行广播。

2) 实现要点

只涉及矩阵乘、softmax、广播，加上两次拼装即可。
softmax 为数值稳定：对每行先减去行最大值。
按输入顺序读入、按形状 reshape 成矩阵。
输出格式化为两位小数并用英文逗号连接。

3) 正确性说明（简要）
Attention 依公式对每个时刻的表征与所有时刻交互；两层堆叠后再经 FC，完全符合题面给出的结构图与公式，因此结果唯一确定。
4) 复杂度分析

两次注意力各需：

QK^T：O(L^2·D)
AV：O(L^2·D)

两次 FC：O(L·D^2)
综合：时间复杂度 O(L^2·D + L·D^2)；空间复杂度 O(L^2 + L·D)（存储注意力矩阵与中间结果）。

参考实现
Python
import sys
import numpy as np
import math

class Solution:
def analyze_data(self, L: int, D: int,
seq: np.ndarray,
Wq1: np.ndarray, Wk1: np.ndarray, Wv1: np.ndarray,
Wmlp1: np.ndarray, bmlp1: np.ndarray,
Wq2: np.ndarray, Wk2: np.ndarray, Wv2: np.ndarray,
Wmlp2: np.ndarray, bmlp2: np.ndarray) -> np.ndarray:
# —— 行 softmax（数值稳定）——
def softmax_rows(M: np.ndarray) -> np.ndarray:
mx = np.max(M, axis=1, keepdims=True)   # 每行最大值
E = np.exp(M - mx)                      # 减去最大值避免上溢
S = np.sum(E, axis=1, keepdims=True)    # 每行求和
return E / S

# —— 单层 Scaled Dot-Product Self-Attention ——
def attn(X: np.ndarray, Wq: np.ndarray, Wk: np.ndarray, Wv: np.ndarray) -> np.ndarray:
Q = X @ Wq                  # (L,D)
K = X @ Wk                  # (L,D)
V = X @ Wv                  # (L,D)
S = (Q @ K.T) / math.sqrt(D)  # (L,L)  /sqrt(D) 缩放
A = softmax_rows(S)         # (L,L)
return A @ V                # (L,D)

X = seq                         # (L,D)

# 第一层 Self-Attention -> FC
Y1 = attn(X, Wq1, Wk1, Wv1)     # (L,D)
Z1 = Y1 @ Wmlp1 + bmlp1         # (L,D) + (D,)  行广播

# 第二层 Self-Attention -> FC
Y2 = attn(Z1, Wq2, Wk2, Wv2)    # (L,D)
Z2 = Y2 @ Wmlp2 + bmlp2         # (L,D)

return Z2                       # 返回最终 (L,D)

if __name__ == "__main__":
# 固定读取 12 行（与模板保持一致）
lines = [sys.stdin.readline().strip() for _ in range(12)]
L, D = map(int, lines[0].split(','))

def parse_line(idx: int, count: int):
# 按英文逗号分隔（模板要求），读取指定数量的浮点
values = list(map(float, lines[idx].split(',')))
assert len(values) == count, f"Line {idx} expected {count} values"
return np.array(values, dtype=np.float64), idx + 1

idx = 1
seq_flat, idx = parse_line(idx, L * D)
seq = seq_flat.reshape(L, D)

Wq1_flat, idx = parse_line(idx, D * D)
Wk1_flat, idx = parse_line(idx, D * D)
Wv1_flat, idx = parse_line(idx, D * D)
Wmlp1_flat, idx = parse_line(idx, D * D)
bmlp1, idx = parse_line(idx, D)

Wq2_flat, idx = parse_line(idx, D * D)
Wk2_flat, idx = parse_line(idx, D * D)
Wv2_flat, idx = parse_line(idx, D * D)
Wmlp2_flat, idx = parse_line(idx, D * D)
bmlp2, idx = parse_line(idx, D)

# reshape all matrices（名称与模板一致）
Wq1 = Wq1_flat.reshape(D, D)
Wk1 = Wk1_flat.reshape(D, D)
Wv1 = Wv1_flat.reshape(D, D)
Wmlp1 = Wmlp1_flat.reshape(D, D)

Wq2 = Wq2_flat.reshape(D, D)
Wk2 = Wk2_flat.reshape(D, D)
Wv2 = Wv2_flat.reshape(D, D)
Wmlp2 = Wmlp2_flat.reshape(D, D)

# bias 保持 (D,)；numpy 与 (L,D) 相加会做按行广播
solver = Solution()
result = solver.analyze_data(L, D, seq,
Wq1, Wk1, Wv1, Wmlp1, bmlp1,
Wq2, Wk2, Wv2, Wmlp2, bmlp2)

# 输出结果：保留两位小数
flat = result.flatten()
print(','.join(f"{x:.2f}" for x in flat))

Java
import java.io.*;
import java.util.*;

public class Main {
static class FastScanner {
BufferedInputStream in = new BufferedInputStream(System.in);
byte[] buf = new byte[1 << 16];
int ptr = 0, len = 0;

int read() throws IOException {
if (ptr >= len) {
len = in.read(buf);
ptr = 0;
if (len <= 0) return -1;
}
return buf[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
// 允许逗号或空格分隔
while ((c = read()) != -1 && c <= 32 || c == ',');
if (c == -1) return null;
do {
if (c == ',') break;
sb.append((char)c);
c = read();
} while (c != -1 && c > 32 && c != ',');
return sb.toString();
}
int nextInt() throws IOException { return Integer.parseInt(next()); }
double nextDouble() throws IOException { return Double.parseDouble(next()); }
}

// 矩阵乘: A(L×K) * B(K×N) -> C(L×N)
static double[][] matMul(double[][] A, double[][] B) {
int L = A.length, K = A[0].length, N = B[0].length;
double[][] C = new double[L][N];
for (int i = 0; i < L; i++) {
for (int k = 0; k < K; k++) {
double aik = A[i][k];
for (int j = 0; j < N; j++) {
C[i][j] += aik * B[k][j];
}
}
}
return C;
}

// 行softmax（数值稳定）
static void softmaxRows(double[][] S) {
int L = S.length, N = S[0].length;
for (int i = 0; i < L; i++) {
double mx = -1e300;
for (int j = 0; j < N; j++) mx = Math.max(mx, S[i][j]);
double sum = 0.0;
for (int j = 0; j < N; j++) {
S[i][j] = Math.exp(S[i][j] - mx);
sum += S[i][j];
}
for (int j = 0; j < N; j++) S[i][j] /= sum;
}
}

static double[][] attn(double[][] X, double[][] Wq, double[][] Wk, double[][] Wv) {
int L = X.length, D = X[0].length;
double[][] Q = matMul(X, Wq);
double[][] K = matMul(X, Wk);
double[][] V = matMul(X, Wv);

// S = QK^T / sqrt(D)
double[][] S = new double[L][L];
double scale = 1.0 / Math.sqrt(D);
for (int i = 0; i < L; i++) {
for (int j = 0; j < L; j++) {
double sum = 0;
for (int k = 0; k < D; k++) sum += Q[i][k] * K[j][k];
S[i][j] = sum * scale;
}
}
softmaxRows(S);
// A V
double[][] Y = new double[L][D];
for (int i = 0; i < L; i++) {
for (int j = 0; j < L; j++) {
double a = S[i][j];
for (int k = 0; k < D; k++) {
Y[i][k] += a * V[j][k];
}
}
}
return Y;
}

static double[][] addBias(double[][] X, double[] b) {
int L = X.length, D = X[0].length;
double[][] Y = new double[L][D];
for (int i = 0; i < L; i++)
for (int j = 0; j < D; j++)
Y[i][j] = X[i][j] + b[j]; // 行广播
return Y;
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner();
int L = Integer.parseInt(fs.next());
int D = Integer.parseInt(fs.next());

// 读入并reshape
double[][] X = new double[L][D];
for (int i = 0, p = 0; i < L; i++)
for (int j = 0; j < D; j++, p++)
X[i][j] = fs.nextDouble();

double[][] Wq1 = new double[D][D];
double[][] Wk1 = new double[D][D];
double[][] Wv1 = new double[D][D];
double[][] Wfc1 = new double[D][D];
double[] bfc1 = new double[D];
double[][] Wq2 = new double[D][D];
double[][] Wk2 = new double[D][D];
double[][] Wv2 = new double[D][D];
double[][] Wfc2 = new double[D][D];
double[] bfc2 = new double[D];

// 工具函数：读 D*D
java.util.function.Consumer<double[][]> readDD = (M) -> {
try {
for (int i = 0; i < D; i++)
for (int j = 0; j < D; j++)
M[i][j] = Double.parseDouble(fs.next());
} catch (Exception e) { throw new RuntimeException(e); }
};

readDD.accept(Wq1); readDD.accept(Wk1); readDD.accept(Wv1);
readDD.accept(Wfc1);
for (int j = 0; j < D; j++) bfc1[j] = fs.nextDouble();
readDD.accept(Wq2); readDD.accept(Wk2); readDD.accept(Wv2);
readDD.accept(Wfc2);
for (int j = 0; j < D; j++) bfc2[j] = fs.nextDouble();

// SA1 -> FC1
double[][] Y1 = attn(X, Wq1, Wk1, Wv1);
double[][] Z1 = matMul(Y1, Wfc1);
Z1 = addBias(Z1, bfc1);

// SA2 -> FC2
double[][] Y2 = attn(Z1, Wq2, Wk2, Wv2);
double[][] Z2 = matMul(Y2, Wfc2);
Z2 = addBias(Z2, bfc2);

// 输出 L*D，英文逗号分隔，保留2位小数
StringBuilder out = new StringBuilder();
java.text.DecimalFormat df = new java.text.DecimalFormat("0.00");
for (int i = 0; i < L; i++)
for (int j = 0; j < D; j++) {
if (out.length() > 0) out.append(',');
out.append(df.format(Z2[i][j]));
}
System.out.println(out.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

using Mat = vector<vector<double>>;

Mat mul(const Mat& A, const Mat& B) {
int L = (int)A.size(), K = (int)A[0].size(), N = (int)B[0].size();
Mat C(L, vector<double>(N, 0.0));
for (int i = 0; i < L; ++i)
for (int k = 0; k < K; ++k) {
double aik = A[i][k];
for (int j = 0; j < N; ++j) C[i][j] += aik * B[k][j];
}
return C;
}

void softmax_rows(Mat& S) {
int L = (int)S.size(), N = (int)S[0].size();
for (int i = 0; i < L; ++i) {
double mx = -1e300;
for (int j = 0; j < N; ++j) mx = max(mx, S[i][j]);
double sum = 0.0;
for (int j = 0; j < N; ++j) { S[i][j] = exp(S[i][j] - mx); sum += S[i][j]; }
for (int j = 0; j < N; ++j) S[i][j] /= sum;
}
}

Mat attn(const Mat& X, const Mat& Wq, const Mat& Wk, const Mat& Wv) {
int L = (int)X.size(), D = (int)X[0].size();
Mat Q = mul(X, Wq), K = mul(X, Wk), V = mul(X, Wv);
Mat S(L, vector<double>(L, 0.0));
double scale = 1.0 / sqrt((double)D);
for (int i = 0; i < L; ++i)
for (int j = 0; j < L; ++j) {
double s = 0.0;
for (int k = 0; k < D; ++k) s += Q[i][k] * K[j][k];
S[i][j] = s * scale;
}
softmax_rows(S);
Mat Y(L, vector<double>(D, 0.0));
for (int i = 0; i < L; ++i)
for (int j = 0; j < L; ++j) {
double a = S[i][j];
for (int k = 0; k < D; ++k) Y[i][k] += a * V[j][k];
}
return Y;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读完整个stdin，逗号替换为空格
string all, line;
while (getline(cin, line)) {
if (!all.empty()) all.push_back('\n');
all += line;
}
for (char &ch : all) if (ch == ',') ch = ' ';
istringstream in(all);

auto readMat = [&](int r, int c) {
Mat M(r, vector<double>(c));
for (int i = 0; i < r; ++i)
for (int j = 0; j < c; ++j) in >> M[i][j];
return M;
};
auto readVec = [&](int n) {
vector<double> v(n);
for (int i = 0; i < n; ++i) in >> v[i];
return v;
};

int L, D;
if (!(in >> L >> D)) return 0;

// X: 按顺序读取 L*D 个数
Mat X(L, vector<double>(D));
for (int i = 0; i < L; ++i)
for (int j = 0; j < D; ++j) in >> X[i][j];

Mat Wq1 = readMat(D, D), Wk1 = readMat(D, D), Wv1 = readMat(D, D);
Mat Wfc1 = readMat(D, D); vector<double> bfc1 = readVec(D);
Mat Wq2 = readMat(D, D), Wk2 = readMat(D, D), Wv2 = readMat(D, D);
Mat Wfc2 = readMat(D, D); vector<double> bfc2 = readVec(D);

Mat Y1 = attn(X, Wq1, Wk1, Wv1);
Mat Z1 = mul(Y1, Wfc1);
for (int i = 0; i < L; ++i) for (int j = 0; j < D; ++j) Z1[i][j] += bfc1[j];

Mat Y2 = attn(Z1, Wq2, Wk2, Wv2);
Mat Z2 = mul(Y2, Wfc2);
for (int i = 0; i < L; ++i) for (int j = 0; j < D; ++j) Z2[i][j] += bfc2[j];

cout.setf(std::ios::fixed);
cout << setprecision(2);
bool first = true;
for (int i = 0; i < L; ++i)
for (int j = 0; j < D; ++j) {
if (!first) cout << ",";
first = false;
cout << Z2[i][j];
}
cout << "\n";
return 0;
}

---

### 第3题-命令关键字统计（P3556）
- 链接：https://codefun2000.com/p/P3556

> 页面标题：#P3556. 第3题-命令关键字统计

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在 IPIPIP 领域中对设备的操作是通过配置命令行实现，在设备的产品文档中会为该设备支持的每个命令定义格式。命令格式定义必须遵循格式定义的规范要求，规范要求如下表所示。

备注说明：
1.关键字、分组括号、分支选择符之间通过一个空格隔开。除了括号和分支选择符 ∣|∣ 外，其他都视为关键字
2.命令行最长 100010001000 个字符长度。
下面是一些正确命令格式定义示例：
1.d r { k | n k }
2.d r [ { k | n k } ]
3.d k { k | r { k m | n k } [ k r ] }

假设产品文档中的命令格式定义都经过确认是正确的，并且关键字、分支符、括号之间都已经用空格隔开了。现在需要统计某个定义中每个必选关键字至少需要出现的次数。
输入描述
输入字符串为一个命令的格式定义，命令格式定义都经过确认是正确的，并且关键字、分支符，括号之间都已经用空格隔开了。暂不需要考虑错误格式比如这种 d k rd\ k\ rd k r { a∣da | d a∣d} 。
输出描述
输出为两行，第一行为必选关键字，按单词字母顺序排序，并用一个空格隔开，第二行为对应第一行位置上必选关键字的最小出现次数，也是用一个空格隔开。
样例1
输入
d r { k | n k }

输出
d k r
1 1 1

说明
大括号分组{}表示必选，分组里面有 222 个分支，每个分支都有 kkk ，因此 kkk 是必须输入的，并且次数为 111 。
样例2
输入
d r [ { k | n k } ]

输出
d r
1 1

说明
后面的中括号是分组[]表示可选，因此里面的所有内容都可以不输入。
样例3
输入
d k { k | r { k m | n k } [ k r ] }

输出
d k
1 2

说明
后面的大括号分组{}表示必选，其中有 222 个分支，递归分析每个分支中都必须输入至少 111 个关键字 kkk 。因此整个表达式要输入的 kkk 的数量至少为 222 。
样例4
输入
d r { m | n }

输出
d r
1 1

说明
虽然，{mmm|nnn} 表示 mmm 和 nnn 二选一，合法命令可以输入 ddd rrr mmm 或者 ddd rrr nnn 。
所以必选关键就只有 ddd 和 rrr 。
必选关键字的意思是：要满足格式定义，正确命令中必须出现的关键字。
样例5
输入
k { { b | { m | [ m | c | n ] | { c x s | a h d | w } } { h [ c h b | s h d | v ] { a | s c a | d } | { x g n | u | f } | c { s | a | h h e | e } { s c | u v m | w x u } | x { x | i | r } [ m | r h | g w ] } | [ { n w | b | n c a | b f } [ a b | e g c | u u | b w h ] { b g | u v | b b | k u x } | b { u k | x w s | b | x } [ i k | w s ] | [ d | k e ] ] | { { v b | e k n } { k g | r w m | a } [ k | r w ] | s [ a k m | x h ] | { n m | i | r u s } x h | [ r s | r s k | s c | i s ] [ f e | k | v ] } n a } [ { [ r a f | d g b | f ] | { b r | a a } | { x d a | n | f h c | r c } | { w | r } [ f e e | k m n | g ] } h { [ k | m | x f r | b k ] { s | h n x | s e } [ e g | h k s ] | [ r | e e c | h ] { w a | w s a | n } | [ w h | h | i b f ] k | [ r | c e i ] } | [ { k c b | b | r a f | i } | [ r k | n | u g g ] [ u u x | w v r | b m f | a s ] [ x | v a ] | { u f u | d m e | b e m } | { s i x | d | b s | g u } { a | i | v m | i } ] g [ x { d | a k a | c w v | e m b } | { r | c m | g k } c | { n m s | a | k | n } ] ] d | s { [ v | f { r v g | m | r w h | m m e } | [ k | x c x | g g ] [ a | n | k | a s r ] e ] [ { m | n | m r } [ u m u | x ] | { n | h i g | r e h } [ b r b | b r | h c s | w m ] s | u ] k | [ n c | [ u s m | k x | c a ] | { b | d a | s n n | g } [ w c | s i ] d ] { e | [ g g r | k u | v a h ] { d | i c | r r r | v } a } { [ e | b f e | e d ] | { s | r n | u m v } | [ x m d | x f | i e i | a n ] } | { [ g d | d | h s e | m n ] | [ i a f | c r ] [ d e g | f f h ] { r | g } } h } | g { { v | [ r m | k | w u ] { n a h | w e s } n } [ [ g e b | s | s i u | a ] [ f s d | g | v s h ] | { m m a | r w g | m b r | i b s } | [ w | w x d | w u g ] w ] | { n { b n n | c | s } | b b b } n | g } x | { [ { h | c v | c } [ f | d u x | n i | m d h ] { d m | u } | x ] { [ r b c | k | n | h m f ] | [ a v w | e r x | m c | g ] [ w | d | k | r v k ] } k | v [ { d e | a w } [ f g | a ] [ m n | i f ] | h [ i f | h a r ] ] { { b f | n r } | w r | { d c v | v k | a e | v } [ i k | f | h b v ] b | [ d g n | w m | v ] [ i c | h ] } } { { { k s k | v | v m } [ k i m | k i | x u n ] { n u x | c u g } | b r } x [ d { k | a e | n u a | k n } w | { x v w | g } { h | f | h h c } [ u | a k | x e u | s ] | { w b x | i m | c } f | { k f r | k g c } [ i b e | x i | m a | f ] v ] | n | [ { x d a | h | u m } [ s | m g | w ] | { d a m | f u | v n d | g } | d f [ u | b | s ] ] g } { a | { [ a | v | d | h c m ] [ d c | v ] | { i b a | h } | m x { e k h | a g c | c } | c g } } }

输出
k
1

▶️

#### TextSol

video solution

题目描述
在命令格式定义字符串中，关键词（令牌）通过空格分隔，并有以下结构化标记：

大括号 { … } 表示“必选分支”，内部是若干以 | 分隔的分支，必须选择其中之一；
中括号 [ … ] 表示“可选分支”，内部内容可选出现；
分支内部又可嵌套任意深度的混合结构。

我们需要统计在任意合法命令中，每个必选关键词至少需要出现的次数。必选关键词指：无论如何选择可选分支或必选分支，都必须出现的那些关键词；其出现次数取每种最小分支组合下的最低值，再取所有分支的最大值（因为分支二选一，需对每条分支计算，然后取最小，再对并列大括号分组累加）。
思路概述

解析表达式
将输入按空格切分为令牌列表，利用递归下降或栈结构，构建语法树节点，包括：

普通关键词节点（Token）
顺序节点（Sequence），表示一系列子节点依次出现
分支节点（Branch），表示由大括号或中括号包裹的子节点，其中包含若干分支选项及“必选”或“可选”属性

计算最小出现次数
对每个节点定义函数 f(node)f(node)f(node)，返回一个映射：每个关键词到最低出现次数。

Token：f(关键词k)=k:1f(关键词k)={k:1}f(关键词k)=k:1

Sequence：f([n1,…,nm])f([n_1,\dots,n_m])f([n1​,…,nm​])=mergePlus(f(n1),…,f(nm)){mergePlus}(f(n_1),\dots,f(n_m))mergePlus(f(n1​),…,f(nm​))，即对应关键词相加出现次数，未出现视为 0。

Branch：

若“必选”分支 {b1∣…∣bp}\{b_1|\dots|b_p\}{b1​∣…∣bp​}：对每个分支 bib_ibi​ 计算 f(bi)f(b_i)f(bi​)，然后对每个关键词取“在所有分支中的最小值”，即
fmin⁡(k)=min⁡1≤i≤pfbi(k) .f_{\min}(k)=\min_{1\le i\le p}f_{b_i}(k)\,. fmin​(k)=min1≤i≤p​fbi​​(k).
若“可选”分支 [b1∣…∣bp][b_1|\dots|b_p][b1​∣…∣bp​]：可整体不选，等价于在“必选分支”基础上再与“空分支”做一次分支比较，即将映射与一个全 0 映射一并做最小值运算。

整合结果
根节点调用 f(root)f(root)f(root) 得到每个关键词的最低出现次数映射，剔除出现次数为 0 的关键词（即非必选），然后按关键词字母顺序输出。

cpp
#include <bits/stdc++.h>
using namespace std;

// 抽象基类：表达式节点
struct Node {
virtual unordered_map<string,int> calc() = 0;
virtual ~Node() = default;
};

// 普通关键词节点
struct TokenNode : Node {
string tok;
TokenNode(const string& s) : tok(s) {}
unordered_map<string,int> calc() override {
return {{tok, 1}};
}
};

// 顺序节点：依次执行多个子节点
struct SequenceNode : Node {
vector<Node*> children;
unordered_map<string,int> calc() override {
unordered_map<string,int> res;
for (auto* c : children) {
auto m = c->calc();
for (auto& [k,v] : m) {
res[k] += v;
}
}
return res;
}
~SequenceNode() { for (auto* c: children) delete c; }
};

// 分支节点：必选或可选
struct BranchNode : Node {
vector<Node*> options;
bool required; // true 表示 { … }，false 表示 [ … ]
unordered_map<string,int> calc() override {
vector<unordered_map<string,int>> ms;
for (auto* opt : options)
ms.push_back(opt->calc());
if (!required) {
// 可选：加入一个空分支
ms.push_back({});
}
// 对所有分支取关键词最小值
unordered_map<string,int> res;
// 收集所有关键词
set<string> keys;
for (auto& m: ms)
for (auto& [k,_]: m)
keys.insert(k);
for (auto& k: keys) {
int mn = INT_MAX;
for (auto& m: ms) {
mn = min(mn, m.count(k) ? m[k] : 0);
}
if (mn>0) res[k] = mn;
}
return res;
}
~BranchNode() { for (auto* c: options) delete c; }
};

// 全局变量：令牌列表及指针
vector<string> T;
int pos = 0;

// 解析一个节点（可能是序列或单一）
Node* parseNode();

// 解析分支 { … } 或 [ … ]
BranchNode* parseBranch() {
bool req = (T[pos] == "{");
pos++; // 跳过 { 或 [
BranchNode* bn = new BranchNode();
bn->required = req;
// 分支内部其实是若干选项，以 '|' 分隔
while (pos < T.size() && (req ? T[pos]!="}" : T[pos]!="]")) {
// 解析一个选项序列
SequenceNode* seq = new SequenceNode();
while (pos < T.size() && T[pos]!="|" && T[pos]!=(req? "}" : "]")) {
if (T[pos]=="{" || T[pos]=="[") {
seq->children.push_back(parseBranch());
} else {
seq->children.push_back(new TokenNode(T[pos]));
pos++;
}
}
bn->options.push_back(seq);
if (T[pos] == "|") pos++;
}
pos++; // 跳过 } 或 ]
return bn;
}

// 解析整个表达式为序列节点
Node* parseNode() {
SequenceNode* seq = new SequenceNode();
while (pos < T.size()) {
if (T[pos] == "{" || T[pos] == "[") {
seq->children.push_back(parseBranch());
} else if (T[pos] == "}" || T[pos] == "]" || T[pos] == "|") {
break;
} else {
seq->children.push_back(new TokenNode(T[pos]));
pos++;
}
}
return seq;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读入整行并分词
string line;
getline(cin, line);
istringstream iss(line);
string w;
while (iss >> w) T.push_back(w);

// 构建语法树
Node* root = parseNode();
// 计算最小出现次数映射
auto mp = root->calc();
delete root;

// 只保留出现次数 ≥1 的关键词
vector<pair<string,int>> ans;
for (auto& [k,v]: mp) if (v>0) ans.emplace_back(k,v);
sort(ans.begin(), ans.end(),
[](auto& a, auto& b){ return a.first < b.first; });

// 输出
for (int i = 0; i < ans.size(); i++) {
if (i) cout << ' ';
cout << ans[i].first;
}
cout << "\n";
for (int i = 0; i < ans.size(); i++) {
if (i) cout << ' ';
cout << ans[i].second;
}
cout << "\n";
return 0;
}

python
# Python 版本
import sys
sys.setrecursionlimit(10000)

# 读入并分词
tokens = sys.stdin.read().strip().split()
pos = 0

class Node:
def calc(self): pass

class TokenNode(Node):
def __init__(self, tok): self.tok = tok
def calc(self):
return {self.tok: 1}

class SequenceNode(Node):
def __init__(self): self.children = []
def calc(self):
res = {}
for c in self.children:
for k,v in c.calc().items():
res[k] = res.get(k, 0) + v
return res

class BranchNode(Node):
def __init__(self, required): self.required = required; self.options = []
def calc(self):
maps = [opt.calc() for opt in self.options]
if not self.required:
maps.append({})
keys = set(k for m in maps for k in m)
res = {}
for k in keys:
mn = min(m.get(k,0) for m in maps)
if mn>0: res[k] = mn
return res

def parse_branch():
global pos
req = tokens[pos] == '{'
pos += 1
bn = BranchNode(req)
while tokens[pos] != ('}' if req else ']'):
seq = SequenceNode()
while tokens[pos] not in ['|', '}', ']']:
if tokens[pos] in ['{','[']:
seq.children.append(parse_branch())
else:
seq.children.append(TokenNode(tokens[pos]))
pos += 1
bn.options.append(seq)
if tokens[pos] == '|': pos += 1
pos += 1
return bn

def parse_node():
global pos
seq = SequenceNode()
while pos < len(tokens) and tokens[pos] not in ['}',''] :
if tokens[pos] in ['{','[']:
seq.children.append(parse_branch())
elif tokens[pos] in ['}','|',']']:
break
else:
seq.children.append(TokenNode(tokens[pos]))
pos += 1
return seq

root = parse_node()
mp = root.calc()
ans = sorted((k,v) for k,v in mp.items() if v>0)
print(' '.join(k for k,_ in ans))
print(' '.join(str(v) for _,v in ans))

java
import java.util.*;

public class Main {
static List<String> T;
static int pos;

interface Node {
Map<String,Integer> calc();
}

static class TokenNode implements Node {
String tok;
TokenNode(String t){ tok=t; }
public Map<String,Integer> calc(){
return Collections.singletonMap(tok,1);
}
}

static class SequenceNode implements Node {
List<Node> ch = new ArrayList<>();
public Map<String,Integer> calc(){
Map<String,Integer> res = new HashMap<>();
for (Node n: ch) {
for (var e: n.calc().entrySet()){
res.put(e.getKey(), res.getOrDefault(e.getKey(),0)+e.getValue());
}
}
return res;
}
}

static class BranchNode implements Node {
boolean req;
List<Node> opts = new ArrayList<>();
BranchNode(boolean r){ req=r; }
public Map<String,Integer> calc(){
List<Map<String,Integer>> ms = new ArrayList<>();
for (Node n: opts) ms.add(n.calc());
if (!req) ms.add(new HashMap<>());
Set<String> keys = new HashSet<>();
for (var m: ms) keys.addAll(m.keySet());
Map<String,Integer> res = new HashMap<>();
for (String k: keys){
int mn = Integer.MAX_VALUE;
for (var m: ms) mn = Math.min(mn, m.getOrDefault(k,0));
if (mn>0) res.put(k,mn);
}
return res;
}
}

static Node parseNode(){
SequenceNode seq = new SequenceNode();
while (pos < T.size()) {
String tk = T.get(pos);
if (tk.equals("{") || tk.equals("[")) {
seq.ch.add(parseBranch());
} else if (tk.equals("}")||tk.equals("]")||tk.equals("|")) {
break;
} else {
seq.ch.add(new TokenNode(tk));
pos++;
}
}
return seq;
}

static BranchNode parseBranch(){
boolean req = T.get(pos).equals("{");
pos++;
BranchNode bn = new BranchNode(req);
while (!(T.get(pos).equals(req? "}" : "]"))) {
SequenceNode seq = new SequenceNode();
while (!T.get(pos).equals("|") && !T.get(pos).equals("}") && !T.get(pos).equals("]")) {
if (T.get(pos).equals("{")||T.get(pos).equals("[")){
seq.ch.add(parseBranch());
} else {
seq.ch.add(new TokenNode(T.get(pos)));
pos++;
}
}
bn.opts.add(seq);
if (T.get(pos).equals("|")) pos++;
}
pos++;
return bn;
}

public static void main(String[] args){
Scanner sc = new Scanner(System.in);
T = Arrays.asList(sc.nextLine().split("\\s+"));
pos = 0;
Node root = parseNode();
Map<String,Integer> mp = root.calc();
List<String> keys = new ArrayList<>();
for (var e: mp.entrySet()) if (e.getValue()>0) keys.add(e.getKey());
Collections.sort(keys);
for (int i=0;i<keys.size();i++){
if (i>0) System.out.print(" ");
System.out.print(keys.get(i));
}
System.out.println();
for (int i=0;i<keys.size();i++){
if (i>0) System.out.print(" ");
System.out.print(mp.get(keys.get(i)));
}
System.out.println();
}
}

---

## 2025年9月3日-国内-AI

### 第2题-大模型训练MOE场景路由优化算法（P3553）
- 链接：https://codefun2000.com/p/P3553

> 页面标题：#P3553. 第2题-大模型训练MOE场景路由优化算法

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

MOEMOEMOE 模型训练时，tokentokentoken 根据概率发送到 topktopktopk 个不同的专家进行计算。这些专家分布在多个 NPUNPUNPU 卡上。Device−LimitedrDevice-LimitedrDevice−Limitedr outingoutingouting 算法将 tokentokentoken 的路由目标限制在 PPP 个 NPUNPUNPU 上，可以有效降低通信成本。具体的：

把 nnn 个专家平均分配在 mmm 个 NPUNPUNPU 上，每个 NPUNPUNPU 上的专家为一个组;设 nnn 个专家的编号为 N=[0,1,2,…,n−1]N=[0,1,2,…,n-1]N=[0,1,2,…,n−1] ，同一个专家组上的专家编号是连续的;

每个专家对应一个概率，表示被路由到的可能性;用每个组中的最大概率作为本组代表，从所有组中选择概率最大的 ppp 个组，其所在的 NPUNPUNPU 即为路由目标限制 NPUNPUNPU ;

再从上述 ppp 个 NPUNPUNPU 对应的所有专家概率中选择 kkk 个最大的概率对应的专家编号作为最终路由目标。

试着编写一段程序，实现以上路由算法。
输入描述
第一行有 444 个处于区间 [1,10000][1,10000][1,10000] 之内的整数，第 111 个表示专家的个数 nnn ，第 222 个表示 NPUNPUNPU 个数 mmm ，第 333 个表示路由目标限制 NPUNPUNPU 个数 ppp ，第 444 个表示目标路由专家个数 kkk ;
第二行有 nnn 个处于区间 (0,1)(0,1)(0,1) 之内的浮点数，表示每个专家对应的概率值，这 nnn 个数对应的专家的编号为 [0,1,2,...,n−1][0,1,2,...,n-1][0,1,2,...,n−1] ;
输出描述
如果，nnn 不能被 mmm 整除或者获取不到 kkk 个专家编号，输出 errorerrorerror ;
否则，按照从小到大的顺序，输出 kkk 个专家编号,任意相邻两数之间有空格，最后一个数字(行尾没有空格)
样例1
输入
8 4 4 2
0.5 0.01 0.09 0.023 0.027 0.05 0.1 0.2

输出
0 7

说明
将专家分成 444 组，分别为：(1)0.5(1)0.5(1)0.5 0.010.010.01 (2)0.09(2)0.09(2)0.09 0.0230.0230.023 (3)0.027(3)0.027(3)0.027 0.050.050.05 (4)0.1(4)0.1(4)0.1 0.20.20.2
限定专家为 444 ，则 444 组都被选定，从选定的 444 组中，选择 222 个专家，分别是 0.50.50.5 和 0.20.20.2 对应的专家，对应的编号分别是 000 和 777 ，按照升序排个列，输出: 000 777
样例2
输入
8 4 5 2
0.3 0.04 0.06 0.45 0.05 0.01 0.03 0.06

输出
error

说明
NPUNPUNPU 一共只有 444 个，需要限定 555 个 NPUNPUNPU ，不满足条件，输出 errorerrorerror

▶️

#### TextSol

video solution

思路与方法
给定 nnn 个专家，平均分布在 mmm 张 NPU 上（每张卡上一组，组内专家编号连续）。算法分三步：

按组取代表
组大小为 g=n/mg = n/mg=n/m。对每一组，找到组内最大概率以及对应的专家编号，作为该组代表值。

选路由目标 NPU（选 p 个组）
将所有组按“代表概率”从大到小排序，取前 ppp 个组（对应的 NPU）。若 p>mp>mp>m，直接输出 error。

在选定的 p 个组里选 k 个专家
将这 ppp 个组中的所有专家收集起来，按概率从大到小挑选前 kkk 个专家编号作为最终路由目标。若可选专家数 p⋅g<kp\cdot g < kp⋅g<k，输出 error。
为了结果可复现，概率相同时按专家编号小的优先。

最后把选出的 kkk 个专家编号按升序输出（空格分隔，行尾无空格）。
复杂度分析

计算每组最大值：遍历一次，O(n)O(n)O(n)。
选出前 ppp 个组：对 mmm 个代表排序，O(mlog⁡m)O(m\log m)O(mlogm)（或用大小为 ppp 的堆 O(mlog⁡p)O(m\log p)O(mlogp)）。
在 ppp 个组里选出前 kkk 个专家：对 p⋅gp\cdot gp⋅g 个元素排序，O((p⋅g)log⁡(p⋅g))O((p\cdot g)\log (p\cdot g))O((p⋅g)log(p⋅g))（或用堆 O((p⋅g)log⁡k)O((p\cdot g)\log k)O((p⋅g)logk)）。
总体：在数据范围 n≤104n\le 10^4n≤104 下，直接排序实现已足够高效，代码更简洁。

实现要点

组索引：第 iii 组覆盖的专家编号区间为 [i⋅g, (i+1)⋅g−1][i\cdot g,\ (i+1)\cdot g-1][i⋅g, (i+1)⋅g−1]。

排序键：

选组时：按 (组代表概率 desc, 组索引 asc) 稳定选择。
选专家时：按 (概率 desc, 专家编号 asc)。

输出：最终 kkk 个编号再升序打印。

参考实现
Python 版本
import sys

def main():
data = sys.stdin.read().strip().split()
if len(data) < 4:
print("error")
return
it = iter(data)
try:
n = int(next(it)); m = int(next(it)); p = int(next(it)); k = int(next(it))
except:
print("error"); return

# 读取 n 个概率
probs = []
for _ in range(n):
try:
probs.append(float(next(it)))
except:
print("error"); return

# 基本校验
if n % m != 0:
print("error"); return
if p > m:
print("error"); return

g = n // m  # 每组大小

# 1) 计算每组代表（最大概率及其专家编号）
group_repr = []  # (max_prob, group_id, expert_idx_of_max)
for gi in range(m):
L = gi * g
R = L + g
max_prob = -1.0
max_idx = -1
# 组内扫描找最大值；并用较小编号打破平局
for idx in range(L, R):
pr = probs[idx]
if pr > max_prob or (abs(pr - max_prob) < 1e-18 and idx < max_idx):
max_prob = pr
max_idx = idx
group_repr.append((max_prob, gi, max_idx))

# 2) 选择前 p 个组（按代表概率降序；组索引升序打破平局）
group_repr.sort(key=lambda x: (-x[0], x[1]))
chosen_groups = set([gi for _, gi, _ in group_repr[:p]])

# 3) 收集这些组的所有专家并选前 k 个（按概率降序，编号升序）
pool = []
for gi in chosen_groups:
L = gi * g
R = L + g
for idx in range(L, R):
pool.append((probs[idx], idx))

if len(pool) < k:
print("error"); return

pool.sort(key=lambda x: (-x[0], x[1]))
chosen = [idx for _, idx in pool[:k]]

chosen.sort()
print(" ".join(map(str, chosen)))

if __name__ == "__main__":
main()

Java 版本
import java.io.*;
import java.util.*;

public class Main {
static class GroupRep {
double maxProb;
int gid;
int idxOfMax;
GroupRep(double p, int g, int idx) { maxProb = p; gid = g; idxOfMax = idx; }
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
String s1 = sc.next();
if (s1 == null) { System.out.println("error"); return; }
int n = Integer.parseInt(s1);
int m = Integer.parseInt(sc.next());
int p = Integer.parseInt(sc.next());
int k = Integer.parseInt(sc.next());

double[] prob = new double[n];
for (int i = 0; i < n; i++) {
String t = sc.next();
if (t == null) { System.out.println("error"); return; }
prob[i] = Double.parseDouble(t);
}

if (n % m != 0) { System.out.println("error"); return; }
if (p > m) { System.out.println("error"); return; }

int g = n / m;

// 1) 计算每组代表
ArrayList<GroupRep> reps = new ArrayList<>(m);
for (int gi = 0; gi < m; gi++) {
int L = gi * g, R = L + g;
double maxP = -1.0;
int maxIdx = -1;
for (int idx = L; idx < R; idx++) {
double pr = prob[idx];
if (pr > maxP || (Math.abs(pr - maxP) < 1e-18 && idx < maxIdx)) {
maxP = pr; maxIdx = idx;
}
}
reps.add(new GroupRep(maxP, gi, maxIdx));
}

// 2) 选择前 p 个组
reps.sort((a, b) -> {
if (a.maxProb == b.maxProb) return Integer.compare(a.gid, b.gid);
return Double.compare(b.maxProb, a.maxProb);
});
boolean[] chosenGroup = new boolean[m];
for (int i = 0; i < p; i++) chosenGroup[reps.get(i).gid] = true;

// 3) 选专家
ArrayList<int[]> pool = new ArrayList<>(p * g); // [idx, prob按排序用，不存prob避免装箱？这里保留prob]
ArrayList<double[]> poolWithProb = new ArrayList<>(p * g);
for (int gi = 0; gi < m; gi++) {
if (!chosenGroup[gi]) continue;
int L = gi * g, R = L + g;
for (int idx = L; idx < R; idx++) {
poolWithProb.add(new double[]{prob[idx], idx});
}
}

if (poolWithProb.size() < k) { System.out.println("error"); return; }

poolWithProb.sort((x, y) -> {
int c = Double.compare(y[0], x[0]); // 概率降序
if (c != 0) return c;
return Integer.compare((int)x[1], (int)y[1]); // 编号升序
});

int[] ans = new int[k];
for (int i = 0; i < k; i++) ans[i] = (int)poolWithProb.get(i)[1];
Arrays.sort(ans);

StringBuilder out = new StringBuilder();
for (int i = 0; i < k; i++) {
if (i > 0) out.append(' ');
out.append(ans[i]);
}
System.out.println(out.toString());
}
}

C++ 版本
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int n, m, p, k;
if (!(cin >> n >> m >> p >> k)) {
cout << "error\n";
return 0;
}
vector<double> prob(n);
for (int i = 0; i < n; ++i) {
if (!(cin >> prob[i])) { cout << "error\n"; return 0; }
}

if (n % m != 0) { cout << "error\n"; return 0; }
if (p > m) { cout << "error\n"; return 0; }

int g = n / m;

// 1) 每组代表（最大概率及其索引）
struct Rep { double mx; int gid; int idx; };
vector<Rep> reps; reps.reserve(m);
for (int gi = 0; gi < m; ++gi) {
int L = gi * g, R = L + g;
double mx = -1.0; int idx = -1;
for (int i = L; i < R; ++i) {
double pr = prob[i];
if (pr > mx || (fabs(pr - mx) < 1e-18 && i < idx)) {
mx = pr; idx = i;
}
}
reps.push_back({mx, gi, idx});
}

// 2) 选前 p 个组
sort(reps.begin(), reps.end(), [](const Rep& a, const Rep& b){
if (a.mx == b.mx) return a.gid < b.gid;          // 概率相同按组号升序
return a.mx > b.mx;                               // 概率降序
});
vector<char> chosen(m, 0);
for (int i = 0; i < p; ++i) chosen[reps[i].gid] = 1;

// 3) 在选定组中选前 k 个专家
vector<pair<double,int>> pool; pool.reserve(p * g);
for (int gi = 0; gi < m; ++gi) if (chosen[gi]) {
int L = gi * g, R = L + g;
for (int i = L; i < R; ++i) pool.push_back({prob[i], i});
}
if ((int)pool.size() < k) { cout << "error\n"; return 0; }

sort(pool.begin(), pool.end(), [](const auto& a, const auto& b){
if (a.first == b.first) return a.second < b.second; // 编号升序
return a.first > b.first;                           // 概率降序
});

vector<int> ans; ans.reserve(k);
for (int i = 0; i < k; ++i) ans.push_back(pool[i].second);
sort(ans.begin(), ans.end());

for (int i = 0; i < k; ++i) {
if (i) cout << ' ';
cout << ans[i];
}
cout << '\n';
return 0;
}

---

### 第2题-Group卷积实现（P3493）
- 链接：https://codefun2000.com/p/P3493

> 页面标题：#P3493. 第2题-Group卷积实现

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

卷积(Convolution)(Convolution)(Convolution)是计算视觉中常用的计算算子，广泛应用于图像分类、检测、跟踪等多领域。
如下图所示，以 22 2个三维张量卷积计算为例，取输入张量 为通道数 、高度 、宽度 ，卷积核 为通道数 、高度 、宽度 ，二者执行卷积计算要求其通道数相同。
当取卷积计算步长 ，填充 ，膨胀 ，无偏置项(bias)(bias)(bias)时，卷积核 在输入张量 上从左至右，从上至下滑动，分别与滑窗所重叠的输入张量 切片，逐元素相乘求和后，得到输出张量 的各元素。
例如：
$y_{0,0}=x_{0,0,0}k_{0,0,0}+x_{0,0,1}k_{0,0,1}+x_{0,1,0}k_{0,1,0}+x_{0,1,1}k_{0,1,1}+x_{1,0,1}k_{1,0,1}+x_{1,1,0}k_{1,1,0}+x_{1,1,1}k_{1,1,1}+x_{2,0,0}k_{2,0,0}+x_{2,1,0}k_{2,1,0}+x_{2,1,1}k_{2,1,1}=72$
面向不同的应用需求，卷积存在多类变种。分组卷积(GroupConvolution)(Group Convolution)(GroupConvolution)即是随2012 2012 2012年AlexNet AlexNet AlexNet提出的一种变种，其将输入张量和卷积核分组后，分别执行卷积计算，然后把多个输出张量进行融合。
例如，输入张量尺寸为 1×32×32×321×32×32×321×32×32×32（其中首个维度1 1 1为样本数)，卷积核尺寸为4×16×3×3 4×16×3×34×16×3×3（其中首个维度4 44 为输出张量通道数，亦可理解为卷积核个数），下图为分组数 时分组卷积计算。
输入张量被切分为1×16×32×321×16×32×321×16×32×32 的两组张量，卷积核被切分为2×16×3×32×16×3×32×16×3×3 的两组张量，分组进行无 paddingpadding padding的卷积计算后，将两组尺寸为1×2×30×301×2×30×301×2×30×30 的计算结果，在第2 22 个维度拼接，得到尺寸为1×4×30×301×4×30×301×4×30×30 的输出张量。
请不使用PyTorch、MindSpore、PaddlePaddle PyTorch、MindSpore、PaddlePaddlePyTorch、MindSpore、PaddlePaddle 等AI AIAI 框架，使用编程语言原生库，编写一个支持分组卷积和深度卷积前向传播的函数，根据输入张量、卷积核、分组数，计算输出张量。
输入描述

in_data: 4 维输入张量展开后的数据序列，以空格分隔的正整数；

in_shape: 4 维输入张量的形状，以空格分隔的 4 个正整数，依次为

batch sizebatch\ sizebatch size（样本数）
in_channelsin\_channelsin_channels（输入张量通道数）
heightheightheight（高度）
widthwidthwidth（宽度）

kernel_data: 4 维卷积核展开后的数据序列，以空格分隔的正整数；

kernel_shape: 4 维卷积核的形状，以空格分隔的 4 个正整数，依次为

out_channelsout\_channelsout_channels（输出张量通道数）
k_channelsk\_channelsk_channels（卷积核通道数）
kernel_hkernel\_hkernel_h（卷积核高度）
kernel_wkernel\_wkernel_w（卷积核宽度）

groups: 分组数，需满足

in_channels%groups=0in\_channels\%groups = 0in_channels%groups=0 ，out_channels%groups=0out\_channels\%groups = 0out_channels%groups=0， k_channels=in_channelsgroupsk\_channels = \frac{in\_channels}{groups}k_channels=groupsin_channels​
输出描述

out_data: 44 4维输出张量展开后的数据序列，以空格分隔的正整数；
out_shape: 444 维输出张量的形状，以空格分隔的4 4 4个正整数，依次为

batch_sizebatch\_sizebatch_size（样本数）
out_out\_out_channels（输出张量通道数）
heightheightheight（高度）
widthwidthwidth（宽度）

若输入张量和卷积核的形状与 groupgroup group的取值存在冲突，或出现其它取值冲突导致无法执行卷积计算，则 out_data 和 out_shape 均返回 −1-1−1。
样例1
输入
1 2 3 4 5 6 7 8
1 2 2 2
1 0 0 1 -1 0 0 -1
2 1 2 2
2

输出
5 -13
1 2 1 1

说明
输入张量为：
$\left[\left[\begin{array}{ll}
1 & 2 \\
3 & 4
\end{array}\right],\left[\begin{array}{ll}
5 & 6 \\
7 & 8
\end{array}\right]\right]$
输入张量形状为1×2×2×21×2×2×21×2×2×2 ；
卷积核为：
$\left[\left[\begin{array}{ll}
1 & 0 \\
0 & 1
\end{array}\right],\left[\begin{array}{cc}
-1 & 0 \\
0 & -1
\end{array}\right]\right]$
卷积核形状为2×1×2×22×1×2×22×1×2×2 ；
分组数为222 ，输出张量为：
⌈[5],⌈−13]⌉\lceil[5],\lceil-13]\rceil⌈[5],⌈−13]⌉
输出张量形状为1×2×1×11×2×1×11×2×1×1 。
样例2
输入
1 2 3 4 5 6 7 8 9
1 1 3 3
1 0 0 -1
1 1 2 2
2

输出
-1
-1

说明
解释：
由于inininchannels=1channels=1 channels=1、outoutoutchannels=1channels=1 channels=1，不满足
in_channels%groups=0in\_channels\%groups = 0in_channels%groups=0 ，out_channels%groups=0out\_channels\%groups = 0out_channels%groups=0，
的条件，因此 out_data 和 out_shape 均返回 -1。

#### TextSol

题解

题面概述：给定展开后的输入张量与卷积核及其形状，和分组数 groupsgroupsgroups，实现分组卷积（包含深度卷积的特例）前向计算。默认 stride=1stride=1stride=1、padding=0padding=0padding=0、dilation=1dilation=1dilation=1。若形状与 groupsgroupsgroups 不合法或输出空间维度非正，则输出 −1-1−1。

关键条件：

inchannelsin_channels % groups = 0inc​hannels
outchannelsout_channels % groups = 0outc​hannels
kchannels=in_channelsgroupsk_channels = \dfrac{in\_channels}{groups}kc​hannels=groupsin_channels​
输出尺寸：Hout=H−Kh+1,Wout=W−Kw+1H_{out} = H - K_h + 1,W_{out} = W - K_w + 1Hout​=H−Kh​+1,Wout​=W−Kw​+1，需要 Hout>0,Wout>0H_{out} > 0, W_{out} > 0Hout​>0,Wout​>0

深度卷积：是分组卷积的特例，groups=inchannels,kchannels=1groups = in_channels,k_channels = 1groups=inc​hannels,kc​hannels=1，允许 outchannels=groups×depthmultiplierout_channels = groups \times depth_multiplieroutc​hannels=groups×depthm​ultiplier。

思路：

解析 555 行输入，校验数据长度与形状乘积一致；
校验分组与通道约束；
计算 Hout,WoutH_{out}, W_{out}Hout​,Wout​ 并校验为正；
按 NNN、组 ggg、组内输出通道 ocococ、空间位置 (oh,ow)(oh, ow)(oh,ow)、组内输入通道 kckckc、核 (kh,kw)(kh, kw)(kh,kw) 六重循环累加；
扁平化顺序为 N→C→H→WN \rightarrow C \rightarrow H \rightarrow WN→C→H→W 输出。

C++
#include <bits/stdc++.h>
using namespace std;

// 按空格切分一行到整数数组
static vector<long long> parseLineLL(const string &s) {
vector<long long> v;
string cur;
for (size_t i = 0; i <= s.size(); ++i) {
if (i == s.size() || isspace(static_cast<unsigned char>(s[i]))) {
if (!cur.empty()) {
v.push_back(stoll(cur));
cur.clear();
}
} else {
cur.push_back(s[i]);
}
}
return v;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读取5行
string line1, line2, line3, line4, line5;
if (!std::getline(cin, line1)) { cout << "-1\n-1\n"; return 0; }
if (!std::getline(cin, line2)) { cout << "-1\n-1\n"; return 0; }
if (!std::getline(cin, line3)) { cout << "-1\n-1\n"; return 0; }
if (!std::getline(cin, line4)) { cout << "-1\n-1\n"; return 0; }
if (!std::getline(cin, line5)) { cout << "-1\n-1\n"; return 0; }

// 解析
vector<long long> in_data_ll = parseLineLL(line1);
vector<long long> in_shape_ll = parseLineLL(line2);
vector<long long> ker_data_ll = parseLineLL(line3);
vector<long long> ker_shape_ll = parseLineLL(line4);
vector<long long> groups_ll = parseLineLL(line5);

if (in_shape_ll.size() != 4 || ker_shape_ll.size() != 4 || groups_ll.size() != 1) {
cout << "-1\n-1\n";
return 0;
}

long long N = in_shape_ll[0], C = in_shape_ll[1], H = in_shape_ll[2], W = in_shape_ll[3];
long long OC = ker_shape_ll[0], KC = ker_shape_ll[1], KH = ker_shape_ll[2], KW = ker_shape_ll[3];
long long G = groups_ll[0];

// 校验乘积
auto prod = [](long long a, long long b){ return a*b; };
long long in_need = N * C * H * W;
long long ker_need = OC * KC * KH * KW;
if (in_need < 0 || ker_need < 0) { cout << "-1\n-1\n"; return 0; } // 溢出或非法
if ((long long)in_data_ll.size() != in_need || (long long)ker_data_ll.size() != ker_need) {
cout << "-1\n-1\n"; return 0;
}

// 基本合法性
if (N <= 0 || C <= 0 || H <= 0 || W <= 0 || OC <= 0 || KC <= 0 || KH <= 0 || KW <= 0 || G <= 0) {
cout << "-1\n-1\n"; return 0;
}
if (C % G != 0 || OC % G != 0) {
cout << "-1\n-1\n"; return 0;
}
if (KC != C / G) {
cout << "-1\n-1\n"; return 0;
}

long long Ho = H - KH + 1;
long long Wo = W - KW + 1;
if (Ho <= 0 || Wo <= 0) {
cout << "-1\n-1\n"; return 0;
}

// 转为int以便索引（输入可能含负数，累加用long long）
vector<int> x(in_data_ll.size());
for (size_t i = 0; i < in_data_ll.size(); ++i) x[i] = (int)in_data_ll[i];
vector<int> k(ker_data_ll.size());
for (size_t i = 0; i < ker_data_ll.size(); ++i) k[i] = (int)ker_data_ll[i];

// 输出缓冲
vector<long long> y(N * OC * Ho * Wo, 0);

auto idx_in = [&](long long n, long long c, long long h, long long w) {
return n * (C * H * W) + c * (H * W) + h * W + w;
};
auto idx_ker = [&](long long oc, long long kc, long long kh, long long kw) {
return oc * (KC * KH * KW) + kc * (KH * KW) + kh * KW + kw;
};
auto idx_out = [&](long long n, long long oc, long long h, long long w) {
return n * (OC * Ho * Wo) + oc * (Ho * Wo) + h * Wo + w;
};

long long OCg = OC / G; // 每组输出通道数
long long KCg = KC;     // 每组输入通道数（核的通道数）

// 六重循环
for (long long n = 0; n < N; ++n) {
for (long long g = 0; g < G; ++g) {
for (long long ocg = 0; ocg < OCg; ++ocg) {
long long oc_idx = g * OCg + ocg;
for (long long oh = 0; oh < Ho; ++oh) {
for (long long ow = 0; ow < Wo; ++ow) {
long long acc = 0;
for (long long kc = 0; kc < KCg; ++kc) {
long long ic = g * KCg + kc;
for (long long kh = 0; kh < KH; ++kh) {
for (long long kw = 0; kw < KW; ++kw) {
long long ih = oh + kh;
long long iw = ow + kw;
int xv = x[idx_in(n, ic, ih, iw)];
int kv = k[idx_ker(oc_idx, kc, kh, kw)];
acc += (long long)xv * (long long)kv;
}
}
}
y[idx_out(n, oc_idx, oh, ow)] = acc;
}
}
}
}
}

// 输出
// 第一行：数据
for (size_t i = 0; i < y.size(); ++i) {
if (i) cout << ' ';
cout << y[i];
}
cout << '\n';
// 第二行：形状
cout << N << ' ' << OC << ' ' << Ho << ' ' << Wo << '\n';
return 0;
}

Python
import sys

def parse_line_to_ints(s: str):
# 将一行按空格切分为整数列表
if not s:
return []
return [int(x) for x in s.strip().split() if x.strip() != '']

def main():
data = sys.stdin.read().strip().splitlines()
if len(data) < 5:
print("-1")
print("-1")
return
line1, line2, line3, line4, line5 = data[:5]

in_data = parse_line_to_ints(line1)
in_shape = parse_line_to_ints(line2)
ker_data = parse_line_to_ints(line3)
ker_shape = parse_line_to_ints(line4)
groups_list = parse_line_to_ints(line5)

if len(in_shape) != 4 or len(ker_shape) != 4 or len(groups_list) != 1:
print("-1")
print("-1")
return

N, C, H, W = in_shape
OC, KC, KH, KW = ker_shape
G = groups_list[0]

# 校验乘积与基本参数
try:
in_need = N * C * H * W
ker_need = OC * KC * KH * KW
except Exception:
print("-1")
print("-1")
return

if N <= 0 or C <= 0 or H <= 0 or W <= 0 or OC <= 0 or KC <= 0 or KH <= 0 or KW <= 0 or G <= 0:
print("-1"); print("-1"); return
if len(in_data) != in_need or len(ker_data) != ker_need:
print("-1"); print("-1"); return
if C % G != 0 or OC % G != 0:
print("-1"); print("-1"); return
if KC != C // G:
print("-1"); print("-1"); return

Ho = H - KH + 1
Wo = W - KW + 1
if Ho <= 0 or Wo <= 0:
print("-1"); print("-1"); return

# 展开索引函数
def idx_in(n, c, h, w):
return n * (C * H * W) + c * (H * W) + h * W + w
def idx_ker(oc, kc, kh, kw_):
return oc * (KC * KH * KW) + kc * (KH * KW) + kh * KW + kw_
def idx_out(n, oc, h, w):
return n * (OC * Ho * Wo) + oc * (Ho * Wo) + h * Wo + w

y = [0] * (N * OC * Ho * Wo)
OCg = OC // G
KCg = KC

# 主循环
for n in range(N):
for g in range(G):
for ocg in range(OCg):
oc_idx = g * OCg + ocg
for oh in range(Ho):
for ow in range(Wo):
acc = 0
for kc in range(KCg):
ic = g * KCg + kc
base_in = n * (C * H * W) + ic * (H * W)
base_ker = oc_idx * (KC * KH * KW) + kc * (KH * KW)
for kh in range(KH):
ih = oh + kh
row_in = base_in + ih * W
row_ker = base_ker + kh * KW
for kw_ in range(KW):
acc += in_data[row_in + ow + kw_] * ker_data[row_ker + kw_]
y[idx_out(n, oc_idx, oh, ow)] = acc

# 打印
print(" ".join(str(v) for v in y))
print(N, OC, Ho, Wo)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
// 按空格切分一行到整数列表
static List<Long> parseLineLL(String s) {
List<Long> res = new ArrayList<>();
if (s == null) return res;
String[] parts = s.trim().split("\\s+");
for (String p : parts) {
if (!p.isEmpty()) res.add(Long.parseLong(p));
}
return res;
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line1 = br.readLine();
String line2 = br.readLine();
String line3 = br.readLine();
String line4 = br.readLine();
String line5 = br.readLine();

if (line1 == null || line2 == null || line3 == null || line4 == null || line5 == null) {
System.out.println("-1");
System.out.println("-1");
return;
}

List<Long> inDataLL = parseLineLL(line1);
List<Long> inShapeLL = parseLineLL(line2);
List<Long> kerDataLL = parseLineLL(line3);
List<Long> kerShapeLL = parseLineLL(line4);
List<Long> groupsLL = parseLineLL(line5);

if (inShapeLL.size() != 4 || kerShapeLL.size() != 4 || groupsLL.size() != 1) {
System.out.println("-1");
System.out.println("-1");
return;
}

long N = inShapeLL.get(0), C = inShapeLL.get(1), H = inShapeLL.get(2), W = inShapeLL.get(3);
long OC = kerShapeLL.get(0), KC = kerShapeLL.get(1), KH = kerShapeLL.get(2), KW = kerShapeLL.get(3);
long G = groupsLL.get(0);

// 校验乘积与参数
long inNeed, kerNeed;
try {
inNeed = Math.multiplyExact(Math.multiplyExact(Math.multiplyExact(N, C), H), W);
kerNeed = Math.multiplyExact(Math.multiplyExact(Math.multiplyExact(OC, KC), KH), KW);
} catch (ArithmeticException ex) {
System.out.println("-1");
System.out.println("-1");
return;
}

if (N <= 0 || C <= 0 || H <= 0 || W <= 0 || OC <= 0 || KC <= 0 || KH <= 0 || KW <= 0 || G <= 0) {
System.out.println("-1"); System.out.println("-1"); return;
}
if (inDataLL.size() != inNeed || kerDataLL.size() != kerNeed) {
System.out.println("-1"); System.out.println("-1"); return;
}
if (C % G != 0 || OC % G != 0) {
System.out.println("-1"); System.out.println("-1"); return;
}
if (KC != C / G) {
System.out.println("-1"); System.out.println("-1"); return;
}

long Ho = H - KH + 1;
long Wo = W - KW + 1;
if (Ho <= 0 || Wo <= 0) {
System.out.println("-1"); System.out.println("-1"); return;
}

// 转为int加速索引，累加用long
int[] x = new int[inDataLL.size()];
for (int i = 0; i < inDataLL.size(); i++) x[i] = inDataLL.get(i).intValue();
int[] k = new int[kerDataLL.size()];
for (int i = 0; i < kerDataLL.size(); i++) k[i] = kerDataLL.get(i).intValue();

long totalOut = N * OC * Ho * Wo;
long[] y = new long[(int) totalOut];

long OCg = OC / G;
long KCg = KC;

// 辅助计算步长
long inStrideN = C * H * W;
long inStrideC = H * W;
long kerStrideOC = KC * KH * KW;
long kerStrideKC = KH * KW;
long outStrideN = OC * Ho * Wo;
long outStrideC = Ho * Wo;

for (long n = 0; n < N; ++n) {
long baseNIn = n * inStrideN;
long baseNOut = n * outStrideN;
for (long g = 0; g < G; ++g) {
for (long ocg = 0; ocg < OCg; ++ocg) {
long ocIdx = g * OCg + ocg;
long baseOCOut = baseNOut + ocIdx * outStrideC;
long baseOCKer = ocIdx * kerStrideOC;
for (int oh = 0; oh < Ho; ++oh) {
for (int ow = 0; ow < Wo; ++ow) {
long acc = 0;
for (int kc = 0; kc < KCg; ++kc) {
long ic = g * KCg + kc;
long baseICIn = baseNIn + ic * inStrideC;
long baseKCKer = baseOCKer + kc * kerStrideKC;
for (int kh = 0; kh < KH; ++kh) {
long ih = oh + kh;
long rowIn = baseICIn + ih * W;
long rowKer = baseKCKer + kh * KW;
int offsetIn = (int)(rowIn + ow);
int offsetKer = (int)rowKer;
for (int kw_ = 0; kw_ < KW; ++kw_) {
acc += (long) x[offsetIn + kw_] * (long) k[offsetKer + kw_];
}
}
}
int outIndex = (int)(baseOCOut + oh * Wo + ow);
y[outIndex] = acc;
}
}
}
}
}

// 输出
StringBuilder sb = new StringBuilder();
for (int i = 0; i < y.length; i++) {
if (i > 0) sb.append(' ');
sb.append(y[i]);
}
System.out.println(sb);
System.out.println(N + " " + OC + " " + Ho + " " + Wo);
}
}

---

### 第2题-樱桃等级筛选（P3487）
- 链接：https://codefun2000.com/p/P3487

> 页面标题：#P3487. 第2题-樱桃等级筛选

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某大型樱桃加工厂使用自动化机械扫描了一批樱桃的尺寸大小。现在获得了直径范围[L,H][L,H][L,H] 各个区间所有的樱桃个数统计。现在需要通过MMM 个等级（m<H−L）（m<H-L）（m<H−L）来筛选不同尺寸大小的樱桃，筛选后需使得各等级内的樱桃数目的标准差最小。
输入描述
输入描述
第一行输入两个数字，第一个数字表示樱桃的总组数n(2<n≤20)n(2<n≤20)n(2<n≤20)，第二个数字mmm表示需要获取的等级数目aaa，2<a<n2<a<n2<a<n。
第二行输入一个长度为H−L+1H-L+1H−L+1 的数列AAA，，其中的第iii个元素aia_iai​ 表示直径为L+iL+iL+i 樱桃个数(i∈[0,H−L],0<ai<100i∈[0,H-L],0<a_i<100i∈[0,H−L],0<ai​<100)
输出描述
输出长度为mmm的数列RRR ，其中的第 111个元素b0b_0b0​ 表示顺序从AAA中取b0b_0b0​ 个元素，将该尺寸范围内的樱桃作为一个分类等级；第2 2 2个元素b1b_1b1​ 表示顺序从AAA中起始点b0b_0b0​ 开始取b1b_1b1​ 个元素，将该尺寸范围内的樱桃作为一个分类等级，依次类推
样例1
输入
10 4
16 40 37 20 18 30 18 60 50 37

输出
3 3 2 2

说明
顺序取数列 33 3个元素和为16+40+37=9316+40+37=9316+40+37=93 ；再顺序取数列3 33 个元素和20+18+30=6820+18+30=6820+18+30=68 ；再顺序取数列 222 个元素和10+60=7810+60=7810+60=78 ；再顺序取数列2 22 个元素和50+37=8150+37=8150+37=81 。[93,68,78,87][93,68,78,87][93,68,78,87] 的平均值为81.581.581.5 ，标准差为 $\sqrt{\frac{(93-81.5)^2+(68-81.5)^2+(78-81.5)^2+(87-81.5)^2}{4} }$，为所有筛选方案中的最小值。
样例2
输入
9 3
1 2 3 4 5 6 7 8 9

输出
5 2 2

说明
要把 999 组樱桃分为三组，使得三组樱桃数量和的标准差最小。顺序取数列5 5 5个元素和为1+2+3+4+5=151+2+3+4+5=151+2+3+4+5=15 ；再顺序取数列 222 个元素和6+7=136+7=136+7=13 ；再顺序取数列 222 个元素和8+9=178+9=178+9=17 。 [15,13,17][15,13,17][15,13,17]的平均值为151515 ，标准差为(15−15)2+(15−13)2+(15−17)23\sqrt{\frac{(15-15)^2+(15-13)^2+(15-17)^2}{3} }  3(15−15)2+(15−13)2+(15−17)2​​，为所有筛选方案中的最小值。

▶️

#### TextSol

video solution

题目描述
某大型樱桃加工厂使用自动化机械扫描了一批樱桃的尺寸大小。现在获得了直径范围 [L,H][L,H][L,H] 各个区间所有的樱桃个数统计。现需通过 mmm 个等级（m<H−Lm < H - Lm<H−L）来筛选不同尺寸大小的樱桃，筛选后需使得各等级内的樱桃数量和的标准差最小。

输入第一行：两个整数 nnn（樱桃总组数，2<n≤202 < n \le 202<n≤20）和 mmm（需要的等级数，2<m<n2 < m < n2<m<n）。
输入第二行：长度为 nnn 的整数序列 A=[a0,a1,…,an−1]A = [a_0, a_1, \dots, a_{n-1}]A=[a0​,a1​,…,an−1​]，其中 aia_iai​ 表示第 iii 组直径对应的樱桃个数（0<ai<1000 < a_i < 1000<ai​<100）。

输出长度为 mmm 的序列 B=[b0,b1,…,bm−1]B = [b_0, b_1, \dots, b_{m-1}]B=[b0​,b1​,…,bm−1​]，其中：

b0b_0b0​ 表示从 AAA 的第 000 位开始，顺序取 b0b_0b0​ 个元素作为第 111 个等级；
b1b_1b1​ 表示从 AAA 的第 b0b_0b0​ 位开始，顺序取 b1b_1b1​ 个元素作为第 222 个等级；
依次类推，保证所有元素被分配且所得到的等级和序列和的标准差最小。

问题本质分析
这是一个将长度为 nnn 的序列分割成 mmm 段，使得每一段元素之和的标准差最小的分割优化问题。由于 n≤20n \le 20n≤20，可以使用 动态规划 + 枚举 或者 DFS + 剪枝 来搜索最优分割方案。
思路

前缀和：预处理序列 AAA 的前缀和 SSS，使得任意区间和 sum(i,j)=S[j+1]−S[i]\mathrm{sum}(i,j)=S[j+1]-S[i]sum(i,j)=S[j+1]−S[i] 能够 O(1)O(1)O(1) 获得。

DFS 枚举与剪枝：递归枚举每一段的长度，维护已分配的段数、当前位置、已经选取的各段和列表。

当分配到第 mmm 段时，将剩余元素作为最后一段，计算所有段和的标准差。
记录最小标准差的分割方案。
剪枝策略：若当前已分配段数与剩余元素无法满足分段数时剪枝。

标准差计算：对于段和数组 W=[w0,w1,…,wm−1]W=[w_0,w_1,\dots,w_{m-1}]W=[w0​,w1​,…,wm−1​]，其平均值为
μ=1m∑k=0m−1wk,\mu = \frac{1}{m} \sum_{k=0}^{m-1} w_k,
μ=m1​k=0∑m−1​wk​,
标准差为

C++
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<int> A;
vector<int> S; // 前缀和

double best_std = 1e300;
vector<int> best_B;

// 计算区间和 [l, r)
int intervalSum(int l, int r) {
return S[r] - S[l];
}

void dfs(int pos, int k, vector<int>& W, vector<int>& B) {
if (k == m - 1) {
int len = n - pos;
B.push_back(len);
W.push_back(intervalSum(pos, n));
// 计算平均值
double mu = accumulate(W.begin(), W.end(), 0.0) / m;
// 计算方差
double var = 0;
for (double w : W) var += (w - mu) * (w - mu);
var /= m;
double std = sqrt(var);
if (std < best_std) {
best_std = std;
best_B = B;
}
B.pop_back(); W.pop_back();
return;
}
// 至少留出 (m-k-1) 个元素，每段至少 1 个
for (int len = 1; pos + len + (m - k - 1) <= n; ++len) {
B.push_back(len);
int w = intervalSum(pos, pos + len);
W.push_back(w);
dfs(pos + len, k + 1, W, B);
B.pop_back(); W.pop_back();
}
}

int main() {
cin >> n >> m;
A.resize(n);
for (int i = 0; i < n; ++i) cin >> A[i];
S.assign(n+1, 0);
for (int i = 0; i < n; ++i) S[i+1] = S[i] + A[i];

vector<int> W, B;
dfs(0, 0, W, B);
for (int x : best_B) cout << x << ' ';
return 0;
}

Python
import math

# 输入
n, m = map(int, input().split())
A = list(map(int, input().split()))
# 前缀和
S = [0] * (n + 1)
for i in range(n):
S[i+1] = S[i] + A[i]

best_std = float('inf')
best_B = []

# 区间和
def interval_sum(l, r):
return S[r] - S[l]

# DFS 枚举
def dfs(pos, k, W, B):
global best_std, best_B
if k == m - 1:
length = n - pos
B.append(length)
W.append(interval_sum(pos, n))
mu = sum(W) / m
var = sum((w - mu) ** 2 for w in W) / m
std = math.sqrt(var)
if std < best_std:
best_std = std
best_B = B.copy()
B.pop(); W.pop()
return
# 枚举当前段长度
for length in range(1, n - pos - (m - k - 1) + 1):
B.append(length)
W.append(interval_sum(pos, pos + length))
dfs(pos + length, k + 1, W, B)
B.pop(); W.pop()

# 调用 DFS
dfs(0, 0, [], [])
# 输出结果
print(' '.join(map(str, best_B)))

Java
import java.util.*;

public class Main {
static int n, m;
static int[] A;
static int[] S;
static double bestStd = Double.MAX_VALUE;
static List<Integer> bestB = new ArrayList<>();

static int intervalSum(int l, int r) {
return S[r] - S[l];
}

static void dfs(int pos, int k, List<Integer> W, List<Integer> B) {
if (k == m - 1) {
int len = n - pos;
B.add(len);
W.add(intervalSum(pos, n));
double mu = W.stream().mapToDouble(x -> x).sum() / m;
double var = 0;
for (double w : W) var += (w - mu) * (w - mu);
var /= m;
double std = Math.sqrt(var);
if (std < bestStd) {
bestStd = std;
bestB = new ArrayList<>(B);
}
B.remove(B.size() - 1);
W.remove(W.size() - 1);
return;
}
for (int len = 1; pos + len + (m - k - 1) <= n; len++) {
B.add(len);
W.add(intervalSum(pos, pos + len));
dfs(pos + len, k + 1, W, B);
B.remove(B.size() - 1);
W.remove(W.size() - 1);
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
m = sc.nextInt();
A = new int[n];
for (int i = 0; i < n; i++) A[i] = sc.nextInt();
S = new int[n+1];
for (int i = 0; i < n; i++) S[i+1] = S[i] + A[i];
dfs(0, 0, new ArrayList<>(), new ArrayList<>());
for (int x : bestB) System.out.print(x + " ");
}
}

---

### 第3题-云存储设备故障预测（P3552）
- 链接：https://codefun2000.com/p/P3552

> 页面标题：#P3552. 第3题-云存储设备故障预测

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在云存储系统中，需要预测存储设备故障以提前迁移数据。每条设备日志包含:
设备 IDIDID ，写入次数，读取次数，平均写入延迟 (ms)(ms)(ms) ，平均读取延迟 (ms)(ms)(ms) ，设备使用年限(年)，设备状态(000正常/111故障)
你需要实现一个设备故障预测系统。包含以下功能:
1、数据清洗:

缺失值标记为"NaNNaNNaN"，用该字段有效值的均值填充

异常值范围:
写入/读取次数:<0<0<0
平均写入/读取延迟:<0<0<0或>1000>1000>1000
使用年限:<0<0<0或>20>20>20
异常值用该字段有效值的中位数替换

2、逻辑回归模型:

使用批量梯度下降法 (Batch(Batch(Batch GD)GD)GD) 训练，每次迭代使用全部样本

特征:[写入次数，读取次数，平均写入延迟，平均读取延迟，设备使用年限]

标签:设备状态

参数:迭代 100100100 次，学习率 α=0.01α=0.01α=0.01，初始权重全 000

3、预测输出:
预测结果: 000 (正常)或 111 (故障)
输入描述
第一行为训练总个数 N，(2<=N<=100)N，(2<=N <= 100)N，(2<=N<=100)
第二行起连续 NNN 行训练数据，每个训练数据包含:设备IDIDID，写入次数，读取次数，平均写入延迟，平均读取延迟，设备使用年限，状态
第 N+2N+2N+2 行为预测数据总个数 M，(1<=M<=10)M，(1<=M<=10)M，(1<=M<=10)
第 N+3N+3N+3 行起连续 MMM 行预测数据，每个预测数据包含:设备 IDIDID ，写入次数，读取次数，平均写入延迟，平均读取延迟，设备使用年限，状态
输出描述
MMM 行预测结果
样例1
输入
5
dev1,NaN,-50,NaN,-2.0,25,0
dev2,180,90,18.0,9.0,4,0
dev3,NaN,80,1500.0,800.0,NaN,0
dev4,-100,-50,-5.0,-2.0,-1,0
dev5,200,NaN,20.0,NaN,5,1
2
dev_predict1,80,40,NaN,2.0,2,0
dev_predict2,210,105,18.0,9.8,4,0

输出
0
0

说明
1、预测数据包含缺失值"NaNNaNNaN"，需要数据清洗
2、MMM 值为 222 ，输出分为 222 行，第一行表示“dev_predict1"设备的预测结果为 000 ，第二行表示 “dev_predict2” 设备的预期结果为 000
样例2
输入
3
dev1,100,50,20.1,10.2,2,0
dev2,150,80,25.3,NaN,3,1
dev3,120,60,22.4,15.0,1,0
1
dev_predict1,130,70,21.0,12.0,2,0

输出
1

说明
输出"dev_predict1“设备的预测结果为 111
提示
线性组合 zzz：
z=w0+∑i=15wixiz=w_0+\sum^5_{i=1}w_ix_iz=w0​+∑i=15​wi​xi​
概率函数 P(y=1)P(y=1)P(y=1) ：
P(y=1)=11+e−zP(y=1)=\frac{1}{1+e^{-z}}P(y=1)=1+e−z1​
预测规则：

▶️

#### TextSol

video solution

解题思路
1) 数据清洗（按列统计 ➜ 按行替换）

将每条日志按逗号切分：第 1 列为设备ID；最后一列为标签 y∈{0,1}；中间前 5 列依次为特征：
写入次数、读取次数、平均写入延迟(ms)、平均读取延迟(ms)、设备使用年限(年)。
（若行里意外多出字段，取前 5 个数值作特征、最后一个作标签，兼容样例1）

缺失值填充：若特征中出现字符串 "NaN"，视为缺失，用该列有效值的均值填充（仅用训练集估计）。

异常值矫正：按规则判定异常并用该列有效值（在合法区间内）中位数替换：

写入/读取次数：< 0
平均写入/读取延迟：< 0 或 > 1000
设备使用年限：< 0 或 > 20

测试集用训练集的均值/中位数进行同样处理，保证一致性。

2) 模型与训练

使用带偏置项的逻辑回归（Logistic Regression），损失为对数损失。

优化：批量梯度下降（Batch GD）

学习率 α = 0.01，迭代 100 次；
参数初始化为 0；
梯度：对每次迭代，用全量样本累加梯度再更新。

预测：sigmoid(z) ≥ 0.5 判为 1，否则 0。

3) 复杂度分析

设训练样本数 N (≤100)，特征数 d=5，迭代 T=100：

统计均值/中位数：O(N*d log N)（中位数排序或用选择算法可降到线性）
训练：O(T * N * d)
预测：O(M * d)（M ≤ 10）

在本题数据范围内，时间与内存都非常充裕。

4) 边界与实现细节

标签永远取最后一列；特征只取ID 后的前 5 个数值（与样例1兼容）。
若某列“有效值”为空（极端情况），中位数回退为该列均值，再不行则 0。
数值转换时忽略空格；"NaN"（大小写敏感）按缺失处理。
sigmoid 计算做简单溢出保护（例如截断 z）。

参考实现
Python 实现
import sys, math

def parse_line(line):
parts = [p.strip() for p in line.strip().split(',')]
if not parts: return None
id_ = parts[0]
if len(parts) < 7:
# 不足字段，直接跳过（题面不会出现）
return None
# 特征：紧跟在ID后的前5个数值；标签：最后一个
feats_raw = parts[1:6]
y_raw = parts[-1]
def to_num(s):
if s == "NaN": return None
try:
return float(s)
except:
return None
x = [to_num(v) for v in feats_raw]
# 标签按最后一列，容忍浮点写法
y = 0
try:
y = int(float(y_raw))
except:
y = 0
return id_, x, y

# 合法区间判断
def valid(col, v):
if v is None: return False
if col in (0,1):  # 写/读次数
return v >= 0
if col in (2,3):  # 延迟
return 0 <= v <= 1000
if col == 4:      # 年限
return 0 <= v <= 20
return True

def median(vals):
n = len(vals)
if n == 0: return 0.0
vals2 = sorted(vals)
mid = n // 2
if n % 2 == 1:
return vals2[mid]
else:
return 0.5 * (vals2[mid - 1] + vals2[mid])

def sigmoid(z):
# 简单数值稳定
if z > 30: z = 30
if z < -30: z = -30
return 1.0 / (1.0 + math.exp(-z))

def clean_matrix(X, means, meds):
# 替换缺失 -> 均值；异常 -> 中位数
n = len(X)
d = len(X[0]) if n else 5
out = []
for i in range(n):
row = []
for j in range(d):
v = X[i][j]
if v is None:
v = means[j]
# 异常替换
if not valid(j, v):
v = meds[j]
row.append(v)
out.append(row)
return out

def main():
data = sys.stdin.read().strip().splitlines()
if not data:
return
it = 0
# 读 N
while it < len(data) and data[it].strip() == "":
it += 1
N = int(data[it].strip()); it += 1

# 读训练集
trainX_raw, trainY = [], []
for _ in range(N):
while it < len(data) and data[it].strip() == "":
it += 1
id_, x, y = parse_line(data[it]); it += 1
trainX_raw.append(x)
trainY.append(y)

# —— 统计每列“有效值”的均值与中位数（仅用训练集的有效值）——
d = 5
means = [0.0] * d
meds  = [0.0] * d

for j in range(d):
valid_vals = [row[j] for row in trainX_raw if valid(j, row[j])]
if valid_vals:
means[j] = sum(valid_vals) / len(valid_vals)
# 中位数
s = sorted(valid_vals)
n = len(s)
meds[j] = s[n//2] if n % 2 == 1 else 0.5 * (s[n//2 - 1] + s[n//2])
else:
# 没有任何有效值时的回退
means[j] = 0.0
meds[j]  = 0.0

# 清洗训练集
trainX = clean_matrix(trainX_raw, means, meds)

# 读 M
while it < len(data) and data[it].strip() == "":
it += 1
M = int(data[it].strip()); it += 1

# 读测试集（忽略其提供的状态列，仅用于输入格式）
testX_raw = []
for _ in range(M):
while it < len(data) and data[it].strip() == "":
it += 1
parts = [p.strip() for p in data[it].strip().split(',')]
it += 1
feats_raw = parts[1:6]  # 取前5个特征
def to_num(s):
if s == "NaN": return None
try:
return float(s)
except:
return None
testX_raw.append([to_num(v) for v in feats_raw])

testX = clean_matrix(testX_raw, means, meds)

# 训练逻辑回归（批量GD）
n = len(trainX)
w = [0.0]*(d+1)  # w[0] 为偏置
alpha = 0.01
T = 100

for _ in range(T):
g = [0.0]*(d+1)
for i in range(n):
z = w[0]
for j in range(d):
z += w[j+1] * trainX[i][j]
p = sigmoid(z)
diff = p - trainY[i]
g[0] += diff
for j in range(d):
g[j+1] += diff * trainX[i][j]
# 参数更新（平均梯度）
for k in range(d+1):
w[k] -= alpha * g[k] / n

# 预测
out_lines = []
for i in range(M):
z = w[0]
for j in range(d):
z += w[j+1] * testX[i][j]
p = sigmoid(z)
pred = 1 if p >= 0.5 else 0
out_lines.append(str(pred))
print("\n".join(out_lines))

if __name__ == "__main__":
main()

Java 实现
import java.io.*;
import java.util.*;

public class Main {
static boolean valid(int c, double v) {
if (Double.isNaN(v)) return false;
if (c == 0 || c == 1) return v >= 0;            // 次数
if (c == 2 || c == 3) return v >= 0 && v <= 1000; // 延迟
if (c == 4) return v >= 0 && v <= 20;           // 年限
return true;
}

static double median(List<Double> a) {
if (a.isEmpty()) return 0.0;
Collections.sort(a);
int n = a.size();
if (n % 2 == 1) return a.get(n/2);
return (a.get(n/2 - 1) + a.get(n/2)) / 2.0;
}

static double sigmoid(double z) {
if (z > 30) z = 30;
if (z < -30) z = -30;
return 1.0 / (1.0 + Math.exp(-z));
}

static Double toNum(String s) {
s = s.trim();
if (s.equals("NaN")) return Double.NaN;
try { return Double.parseDouble(s); }
catch (Exception e) { return Double.NaN; }
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in, "UTF-8"));
List<String> lines = new ArrayList<>();
for (String ln; (ln = br.readLine()) != null; ) lines.add(ln);

int it = 0;
while (it < lines.size() && lines.get(it).trim().isEmpty()) it++;
int N = Integer.parseInt(lines.get(it).trim()); it++;

int d = 5;
List<double[]> trainXraw = new ArrayList<>();
List<Integer> trainY = new ArrayList<>();

// 读取训练数据
for (int i = 0; i < N; i++) {
while (it < lines.size() && lines.get(it).trim().isEmpty()) it++;
String[] parts = lines.get(it).split(",");
it++;
// 特征：ID后前5项；标签：最后一项
Double[] x = new Double[d];
for (int j = 0; j < d; j++) x[j] = toNum(parts[1 + j]);
int y = 0;
try { y = (int)Math.floor(Double.parseDouble(parts[parts.length - 1].trim()) + 1e-9); }
catch (Exception e) { y = 0; }

double[] row = new double[d];
for (int j = 0; j < d; j++) row[j] = x[j] == null ? Double.NaN : x[j];
trainXraw.add(row);
trainY.add(y);
}

double[] mean = new double[d];
double[] med  = new double[d];

for (int j = 0; j < d; j++) {
List<Double> validVals = new ArrayList<>();
for (double[] r : trainXraw) {
double v = r[j];
if (!Double.isNaN(v) && valid(j, v)) validVals.add(v);
}
if (!validVals.isEmpty()) {
double s = 0;
for (double v : validVals) s += v;
mean[j] = s / validVals.size();
Collections.sort(validVals);
int n = validVals.size();
med[j] = (n % 2 == 1) ? validVals.get(n/2)
: (validVals.get(n/2 - 1) + validVals.get(n/2)) / 2.0;
} else {
mean[j] = 0.0;
med[j]  = 0.0;
}
}

// 清洗训练集
List<double[]> trainX = new ArrayList<>();
for (double[] r : trainXraw) {
double[] t = new double[d];
for (int j = 0; j < d; j++) {
double v = Double.isNaN(r[j]) ? mean[j] : r[j];
if (!valid(j, v)) v = med[j];
t[j] = v;
}
trainX.add(t);
}

// 读取 M
while (it < lines.size() && lines.get(it).trim().isEmpty()) it++;
int M = Integer.parseInt(lines.get(it).trim()); it++;

// 测试集
List<double[]> testXraw = new ArrayList<>();
for (int i = 0; i < M; i++) {
while (it < lines.size() && lines.get(it).trim().isEmpty()) it++;
String[] parts = lines.get(it).split(",");
it++;
double[] r = new double[d];
for (int j = 0; j < d; j++) {
Double v = toNum(parts[1 + j]);
r[j] = (v == null) ? Double.NaN : v;
}
testXraw.add(r);
}
List<double[]> testX = new ArrayList<>();
for (double[] r : testXraw) {
double[] t = new double[d];
for (int j = 0; j < d; j++) {
double v = Double.isNaN(r[j]) ? mean[j] : r[j];
if (!valid(j, v)) v = med[j];
t[j] = v;
}
testX.add(t);
}

// 训练 Logistic 回归（批量GD）
double[] w = new double[d + 1]; // w[0] 偏置
Arrays.fill(w, 0.0);
double alpha = 0.01;
int T = 100;
int n = trainX.size();

for (int t = 0; t < T; t++) {
double[] g = new double[d + 1];
Arrays.fill(g, 0.0);
for (int i = 0; i < n; i++) {
double[] x = trainX.get(i);
double z = w[0];
for (int j = 0; j < d; j++) z += w[j + 1] * x[j];
double p = sigmoid(z);
double diff = p - trainY.get(i);
g[0] += diff;
for (int j = 0; j < d; j++) g[j + 1] += diff * x[j];
}
for (int k = 0; k < d + 1; k++) w[k] -= alpha * g[k] / n;
}

// 预测并输出
StringBuilder sb = new StringBuilder();
for (double[] x : testX) {
double z = w[0];
for (int j = 0; j < d; j++) z += w[j + 1] * x[j];
double p = sigmoid(z);
int pred = p >= 0.5 ? 1 : 0;
sb.append(pred).append('\n');
}
System.out.print(sb.toString());
}
}

C++
#include <bits/stdc++.h>
using namespace std;

bool valid(int c, double v){
if (isnan(v)) return false;
if (c==0 || c==1) return v>=0;              // 次数
if (c==2 || c==3) return v>=0 && v<=1000;   // 延迟
if (c==4) return v>=0 && v<=20;             // 年限
return true;
}
double sigm(double z){
if (z > 30) z = 30;
if (z < -30) z = -30;
return 1.0 / (1.0 + exp(-z));
}
double toNum(const string& s){
if (s=="NaN") return numeric_limits<double>::quiet_NaN();
try { return stod(s); }
catch(...) { return numeric_limits<double>::quiet_NaN(); }
}
vector<string> split(const string& s, char d=','){
vector<string> r; string cur;
for(char c: s){
if(c==d){ r.push_back(string(cur.begin(), find_if(cur.rbegin(), cur.rend(), [](char ch){return !isspace((unsigned char)ch);} ).base()));
size_t l=0; while(l<r.back().size() && isspace((unsigned char)r.back()[l])) l++; r.back()=r.back().substr(l);
cur.clear(); }
else cur.push_back(c);
}
r.push_back(string(cur.begin(), find_if(cur.rbegin(), cur.rend(), [](char ch){return !isspace((unsigned char)ch);} ).base()));
size_t l=0; while(l<r.back().size() && isspace((unsigned char)r.back()[l])) l++; r.back()=r.back().substr(l);
return r;
}
double median(vector<double> v){
if(v.empty()) return 0.0;
sort(v.begin(), v.end());
int n=v.size();
if(n&1) return v[n/2];
return 0.5*(v[n/2-1]+v[n/2]);
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
string line;

auto getline_nonempty = [&](string &out){
while (getline(cin, out)){
// 保留空行?题目输入无空白，保险处理
if (!out.empty()) return true;
}
return false;
};

// 读 N
if(!getline_nonempty(line)) return 0;
int N = stoi(line);
int d = 5;

vector<array<double,5>> trainXraw;
vector<int> trainY;

for(int i=0;i<N;i++){
getline_nonempty(line);
auto parts = split(line, ',');
array<double,5> x{};
for(int j=0;j<d;j++) x[j] = toNum(parts[1+j]);
int y=0;
try { y = (int)floor(stod(parts.back())+1e-9); } catch(...) { y=0; }
trainXraw.push_back(x);
trainY.push_back(y);
}

array<double,5> mean{}, med{};
for (int j = 0; j < d; ++j) {
vector<double> vals;
for (auto &r : trainXraw) {
double v = r[j];
if (!std::isnan(v) && valid(j, v)) vals.push_back(v);
}
if (!vals.empty()) {
double s = accumulate(vals.begin(), vals.end(), 0.0);
mean[j] = s / vals.size();
sort(vals.begin(), vals.end());
int n = (int)vals.size();
med[j] = (n & 1) ? vals[n/2] : 0.5 * (vals[n/2 - 1] + vals[n/2]);
} else {
mean[j] = 0.0;
med[j]  = 0.0;
}
}

// 清洗训练
vector<array<double,5>> trainX;
for(auto &r: trainXraw){
array<double,5> t{};
for(int j=0;j<d;j++){
double v = isnan(r[j]) ? mean[j] : r[j];
if(!valid(j, v)) v = med[j];
t[j]=v;
}
trainX.push_back(t);
}

// 读 M
getline_nonempty(line);
int M = stoi(line);

vector<array<double,5>> testX;
for(int i=0;i<M;i++){
getline_nonempty(line);
auto parts = split(line, ',');
array<double,5> r{};
for(int j=0;j<d;j++){
double v = toNum(parts[1+j]);
if(isnan(v)) v = mean[j];
if(!valid(j, v)) v = med[j];
r[j]=v;
}
testX.push_back(r);
}

// 训练 Logistic 回归（批量GD）
vector<double> w(d+1, 0.0); // w[0] 偏置
double alpha = 0.01;
int T = 100;
int n = (int)trainX.size();

for(int it=0; it<T; ++it){
vector<double> g(d+1, 0.0);
for(int i=0;i<n;i++){
double z = w[0];
for(int j=0;j<d;j++) z += w[j+1]*trainX[i][j];
double p = sigm(z);
double diff = p - trainY[i];
g[0] += diff;
for(int j=0;j<d;j++) g[j+1] += diff * trainX[i][j];
}
for(int k=0;k<=d;k++) w[k] -= alpha * g[k] / n;
}

// 预测
for(auto &x: testX){
double z = w[0];
for(int j=0;j<d;j++) z += w[j+1]*x[j];
double p = sigm(z);
int pred = (p>=0.5)? 1:0;
cout << pred << "\n";
}
return 0;
}

---

### 第3题-命令行参数提示（P3488）
- 链接：https://codefun2000.com/p/P3488

> 页面标题：#P3488. 第3题-命令行参数提示

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在使用命令行工具时，经常会出现手工输入错字母的情况，如想要输入：
git clone

输入成了
git clane

因此为了命令行工具更易用，需要从支持的子命令列表中找到最相似的子命令提示给用户。最相似的定义为最短莱文斯坦距离：即两个字符串之间，由一个转成另一个所需的最少编辑操作次数。允许的编辑操作包括：
1.1.1.将一个字符替换成另一个字符
2.2.2.插入一个字符
3.3.3.删除一个字符
输入描述
第一行给出可提示的最短距离 DDD，第二行给出子命令数量N NN，后面 NN N行给出所有的子命令列表，最后一行给出用户输入的子命令。
约束：

1≤D≤51≤D≤51≤D≤5
1≤N≤300001≤N≤300001≤N≤30000
单个子命令长度 ，子命令只包含小写字母

输出描述
输出为分三种情况：
1.1.1.用户输入的子命令正确匹配上某个子命令参数，输出原命令。
2.2.2.用户输入的子命令没有匹配上某个子命令参数，但是符合提示要求，则输出提示命令，如 clonecloneclone；如果符合提示要求的子命令有多个，则按距离从小到大排序后输出，同一个距离内还有多个的按字母序从小到大输出。
3.3.3.用户输入的子命令没有匹配上某个子命令参数，且没有符合提示要求的子命令，则输出None NoneNone
样例1
输入
2
5
aprint
bprint
aaprint
bbprint
output
print

输出
aprint bprint aaprint bbprint

说明
子命令中有四个满足与 printprintprint的距离小于等于222，其中 aprintaprintaprint 与 bprintbprintbprint与目标的距离为111，先将其排序并输出，aaprint bbprintaaprint\ bbprintaaprint bbprint 与目标距离为222，排序后接在前面输出后继续输出
样例2
输入
2
3
clone
checkout
switch
create

输出
None

说明
输入的三个子命令中没有满足与 creatcreatcreat 距离小于等于222的，因此输出 NoneNoneNone
样例3
输入
2
3
clone
checkout
switch
clane

输出
clone

说明
第一行值为222，表示当前输入不能完全正确匹配某个子命令时，则将其最短距离小于222的子命令作为提示输出；第二行为333，表示命令行实际有333个子命令，分别为后续333行；最后一行为用户实际的输入。由于用户没有命中具体的子命令，而 clonecloneclone与用户输入的距离为111，满足小于222的要求，因此输出 clonecloneclone

▶️

#### TextSol

video solution

解题思路与方法
算法概述
本题要求在大量已知子命令中，根据用户输入的错误命令，找到与之最相似（即编辑距离最小）的子命令并提示。
最相似的定义为Levenshtein 距离，即将一个字符串通过 替换、插入、删除 三种基本操作变为另一个字符串所需的最少步数。
详细方法

逐一计算编辑距离

对用户输入串 s 和每个候选子命令 t，使用动态规划求它们的编辑距离 d(s,t)。

定义 dp[i][j] 表示 s[0..i) 转换成 t[0..j) 的最少操作数。

初始条件：

dp[0][j]=j（s 为空，插入 j 个字符），
dp[i][0]=i（删除 i 个字符）。

转移方程：
if s[i-1]==t[j-1]:
dp[i][j]=dp[i-1][j-1]
else:
dp[i][j]=min(
dp[i-1][j]+1,   // 删除 s[i-1]
dp[i][j-1]+1,   // 插入 t[j-1]
dp[i-1][j-1]+1  // 替换为 t[j-1]
)

查找最小距离或候选集

遍历所有子命令，若距离 =0，说明恰好匹配，直接输出该命令并结束。
否则，收集所有满足 1≤d(s,t)≤D 的命令，记录距离。

排序与输出

按距离从小到大排序，相同距离下按字典序升序排列。
若候选集非空，依次输出；否则输出 None。

复杂度分析

每次编辑距离计算的时间为 O(∣s∣×∣t∣)O(|s|\times|t|)O(∣s∣×∣t∣)，最坏长度均为 LLL，则为 O(L2)O(L^2)O(L2)。

总共 NNN 个子命令，时间复杂度为 O(N×L2)O(N\times L^2)O(N×L2)。

在本题中 N≤3×104,;L≤25N\le3\times10^4,;L\le25N≤3×104,;L≤25，NL2≈1.9×107N L^2\approx1.9\times10^7NL2≈1.9×107，在常数较小的实现下可接受。

空间复杂度若使用全表为 O(L2)O(L^2)O(L2)，也可优化为 O(L)O(L)O(L) 的滚动数组。

代码实现
Python
def edit_dist(a, b):
n, m = len(a), len(b)
dp = [list(range(m+1))] + [[i]+[0]*m for i in range(1, n+1)]
for i in range(1, n+1):
for j in range(1, m+1):
if a[i-1] == b[j-1]:
dp[i][j] = dp[i-1][j-1]
else:
dp[i][j] = min(
dp[i-1][j] + 1,    # 删除
dp[i][j-1] + 1,    # 插入
dp[i-1][j-1] + 1   # 替换
)
return dp[n][m]

def main():
D = int(input().strip())
N = int(input().strip())
cmds = [input().strip() for _ in range(N)]
inp = input().strip()

# 精确匹配
if inp in cmds:
print(inp)
return

# 计算距离并筛选
cand = []
for cmd in cmds:
d = edit_dist(inp, cmd)
if 1 <= d <= D:
cand.append((d, cmd))

# 输出结果
if not cand:
print("None")
else:
cand.sort(key=lambda x: (x[0], x[1]))
print(" ".join(cmd for _, cmd in cand))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
// 计算编辑距离
static int dist(String a, String b) {
int n = a.length(), m = b.length();
int[][] dp = new int[n+1][m+1];
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a.charAt(i-1) == b.charAt(j-1)) {
dp[i][j] = dp[i-1][j-1];
} else {
dp[i][j] = Math.min(
Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
dp[i-1][j-1] + 1
);
}
}
}
return dp[n][m];
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int D = sc.nextInt();
int N = sc.nextInt();
List<String> cmds = new ArrayList<>();
for (int i = 0; i < N; i++) cmds.add(sc.next());
String inp = sc.next();

// 精确匹配
if (cmds.contains(inp)) {
System.out.println(inp);
return;
}

// 筛选候选
List<int[]> cand = new ArrayList<>();
for (String cmd : cmds) {
int d = dist(inp, cmd);
if (d >= 1 && d <= D) {
cand.add(new int[]{d, cmds.indexOf(cmd)});
}
}

if (cand.isEmpty()) {
System.out.println("None");
} else {
// 排序
cand.sort((a, b) -> {
int da = a[0], db = b[0];
if (da != db) return da - db;
return cmds.get(a[1]).compareTo(cmds.get(b[1]));
});
// 输出
StringJoiner sj = new StringJoiner(" ");
for (int[] p : cand) sj.add(cmds.get(p[1]));
System.out.println(sj.toString());
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算编辑距离
int editDist(const string &a, const string &b) {
int n = a.size(), m = b.size();
vector<vector<int>> dp(n+1, vector<int>(m+1));
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1];
else dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1});
}
}
return dp[n][m];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int D, N;
cin >> D >> N;
vector<string> cmds(N);
for (int i = 0; i < N; i++) cin >> cmds[i];
string inp;
cin >> inp;

// 精确匹配
for (auto &cmd : cmds) {
if (cmd == inp) {
cout << inp << "\n";
return 0;
}
}

// 筛选候选
vector<pair<int,string>> cand;
for (auto &cmd : cmds) {
int d = editDist(inp, cmd);
if (d >= 1 && d <= D) {
cand.emplace_back(d, cmd);
}
}

if (cand.empty()) {
cout << "None\n";
} else {
sort(cand.begin(), cand.end(), [](auto &a, auto &b) {
if (a.first != b.first) return a.first < b.first;
return a.second < b.second;
});
bool first = true;
for (auto &p : cand) {
if (!first) cout << ' ';
cout << p.second;
first = false;
}
cout << '\n';
}
return 0;
}

---

## 2025年8月27日-国内-AI

### 第2题-标签样本数量（P3479）
- 链接：https://codefun2000.com/p/P3479

> 页面标题：#P3479. 第2题-标签样本数量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

KNNKNNKNN 算法的核心思想是，如果一个样本在特征空间中的 KKK 个最相邻的样本中的大多数属于某一个类别，则该样本也属于这个类别，并具有这个类别上样本的特性。请按照下面的步理，实现 KNNKNN
KNN 算法。
KNNKNNKNN 算法说明：
计算待分类点到其他样本点的距离；
通过距离进行排序，选择距离最小的 KKK 个点；提取这 KKK 个临近点的类别，根据少数服从多数的原则，将占比最多的那个标签赋值给待分类样本点的 labellabellabel 。
本题说明：
1、给定数据集中，默认每一类标签都存在数据，不存在某类型数量为 000 的场景；
2、为消除不同特征权重问题，给出数据均已做好归一化处理，并保留两位小数；
3、出现并列第一的情形时，取并列第一的样本中，最近邻居的标签返回；
4、距离函数定义为: dx,y=∑i=1n(xi−yi)2d_{x,y}=\sqrt{\sum^n_{i=1}(x_i-y_i)^2}dx,y​=∑i=1n​(xi​−yi​)2​。
输入描述
第 111 行：kkk mmm nnn sss ：kkk 代表每次计算时选取的最近邻居个数(不大于 202020 )，mmm 代表样本数量(不大于 200200200 )，nnn 代表样本维度(不包括标签，不大于 555 )，sss 代表类别个数(不于 555 )；
第 222 行：待分类样本
第 333 行~第 m+2m+2m+2 行：mmm 个样本，每一行 n+1n+1n+1 列，最后一列为类别标签 labellabellabel
输出描述
输出待分类样本的类别标签及距离最小的 KKK 个点中的该标签样本数量
样例1
输入
3 10 2 3
0.81 0.64
0.19 0.2 1.0
0.18 0.14 0.0
0.76 0.58 1.0
0.4 0.16 1.0
0.98 0.85 0.0
0.42 0.97 1.0
0.75 0.26 1.0
0.24 0.06 1.0
0.97 0.8 0.0
0.21 0.1 2.0

输出
0 2

说明
第 111 行输入说明输入了 m=10m=10m=10 个样本，每个样本有 n=2n=2n=2 个维度的数据(去除最后一列标签)，共有 s=3s=3s=3 种类别
第 222 行输入待分类样本的 nnn 维数据
从第 333 行到第 121212 行的前两列数据为输入的 m=10m=10m=10 个样本，每个样本有 n=2n=2n=2 个维度的数据+最后一列的标签数据
待分类样本 [0.81[0.81[0.81 0.64]0.64]0.64] 最近的前 k=3k=3k=3 个邻居分别为：[0.76[0.76[0.76 0.58],[0.980.58],[0.980.58],[0.98 0.85],[0.970.85],[0.970.85],[0.97 0.8]0.8]0.8] ，分别有 222 个 000 号标签和 111 个 111 号标签 000 号标签占多，返回 000 以及标签 000 的样本数量 222
样例2
输入
6 10 2 4
0.78 0.63
0.57 0.07 1.0
0.5 0.13 1.0
0.83 0.07 3.0
0.27 0.87 3.0
0.81 0.44 2.0
0.21 0.73 3.0
0.45 0.91 1.0
0.12 0.22 2.0
0.25 0.48 0.0
0.54 0.87 1.0

输出
1 2

说明
本样例的距离最小的 666 个样本中，标签 111 和标签 333 出现次数都是 222 次，并列第一；虽然 [0.8[0.8[0.8 0.44]0.44]0.44] 距离样本最近，但其标签 222 不是出现最多的，排除在下一轮统计样本中此时需要从标签 111 和标签 333 中的样本中，选取距离最近的 [0.54[0.54[0.54 0.87]0.87]0.87] 的标签 111 作为返回值，并同时返回标签 111 的样本数量 222 。

▶️

#### TextSol

video solution

解题思路
核心步骤

读入参数：k,m,n,sk, m, n, sk,m,n,s；读入待分类样本向量 qqq（维度 nnn）；读入 mmm 条样本（前 nnn 列为特征，最后一列为标签）。

计算距离：对每个样本 xxx，计算与 qqq 的欧氏距离
d(q,x)=∑i=1n(qi−xi)2d(q,x)=\sqrt{\sum_{i=1}^{n}(q_i-x_i)^2}
d(q,x)=i=1∑n​(qi​−xi​)2​
为了效率与不影响排序，可直接用平方距离（省去开方，单调性一致）。

排序取前 kkk：按距离从小到大排序，取前 kkk 个邻居。

投票与并列规则：统计前 kkk 个邻居的标签频次，找出最高频数。若有多个标签并列第一，则在这几个标签中，选择距离最近的那个邻居的标签（即在已排序的前 kkk 邻居中，从前往后找到第一个其标签属于“并列集合”的样本）。

输出：输出最终预测标签与在前 kkk 中该标签出现的次数，格式：“label count”。

正确性说明

归一化保证各维度量纲一致，欧氏距离可直接比较。
使用平方距离与开方距离等价于排序目的。
并列处理遵循题意“序列第一（最近邻）优先”。

复杂度分析

距离计算：O(m⋅n)O(m\cdot n)O(m⋅n)
排序：O(mlog⁡m)O(m\log m)O(mlogm)
统计投票：O(k)O(k)O(k)
总复杂度：O(mlog⁡m+m⋅n)O(m\log m + m\cdot n)O(mlogm+m⋅n)，在 m≤200,n≤5m\le 200, n\le 5m≤200,n≤5 的限制下完全可行。
额外空间：存距离与样本索引 O(m)O(m)O(m)。

Python
import sys
from collections import Counter

def main():
# 读入所有标记，适配行内/换行混排
tokens = sys.stdin.read().strip().split()
it = iter(tokens)

# 基本参数
k = int(next(it)); m = int(next(it)); n = int(next(it)); s = int(next(it))  # s未直接使用

# 待分类样本 q
q = [float(next(it)) for _ in range(n)]

# 读入 m 个样本（n 个特征 + 1 个标签）
X = []
y = []
for _ in range(m):
row = [float(next(it)) for __ in range(n + 1)]
X.append(row[:n])
# 标签以 float 给出，输出需要整数格式
y.append(int(row[-1]))

# 计算平方欧氏距离，保存 (dist2, idx)
dists = []
for i in range(m):
xi = X[i]
# 平方距离即可用于排序
dist2 = 0.0
for j in range(n):
diff = q[j] - xi[j]
dist2 += diff * diff
dists.append((dist2, i))

# 按距离升序排序
dists.sort(key=lambda t: t[0])

# 取前 k 个邻居的索引与标签
top_idx = [dists[i][1] for i in range(min(k, m))]
top_labels = [y[i] for i in top_idx]

# 统计频次
cnt = Counter(top_labels)
max_freq = max(cnt.values())

# 找出并列第一的标签集合
tie_labels = {lab for lab, c in cnt.items() if c == max_freq}

# 若并列，按距离顺序选择第一个属于并列集合的邻居的标签
# dists 已整体排序，这里只需在前 k 中寻找
chosen = None
for i in range(min(k, m)):
lab = y[dists[i][1]]
if lab in tie_labels:
chosen = lab
break

# 输出：标签 与 在前 k 中该标签出现次数
print(chosen, cnt[chosen])

if __name__ == '__main__':
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static class Pair {
double d2; int idx;
Pair(double d2, int idx){ this.d2 = d2; this.idx = idx; }
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
List<String> toks = new ArrayList<>();
for (String line; (line = br.readLine()) != null; ) {
line = line.trim();
if (line.isEmpty()) continue;
String[] a = line.split("\\s+");
Collections.addAll(toks, a);
}
int p = 0;

int k = Integer.parseInt(toks.get(p++));
int m = Integer.parseInt(toks.get(p++));
int n = Integer.parseInt(toks.get(p++));
int s = Integer.parseInt(toks.get(p++)); // 未直接使用

double[] q = new double[n];
for (int i = 0; i < n; i++) q[i] = Double.parseDouble(toks.get(p++));

double[][] X = new double[m][n];
int[] y = new int[m];
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) X[i][j] = Double.parseDouble(toks.get(p++));
y[i] = (int)Math.round(Double.parseDouble(toks.get(p++)));
}

List<Pair> ds = new ArrayList<>(m);
for (int i = 0; i < m; i++) {
double d2 = 0;
for (int j = 0; j < n; j++) {
double diff = q[j] - X[i][j];
d2 += diff * diff;
}
ds.add(new Pair(d2, i));
}
ds.sort(Comparator.comparingDouble(o -> o.d2));

int kk = Math.min(k, m);
Map<Integer, Integer> freq = new HashMap<>();
for (int i = 0; i < kk; i++) {
int lab = y[ds.get(i).idx];
freq.put(lab, freq.getOrDefault(lab, 0) + 1);
}

int maxFreq = 0;
for (int c : freq.values()) maxFreq = Math.max(maxFreq, c);

Set<Integer> tie = new HashSet<>();
for (Map.Entry<Integer,Integer> e : freq.entrySet())
if (e.getValue() == maxFreq) tie.add(e.getKey());

int ansLab = -1;
for (int i = 0; i < kk; i++) {
int lab = y[ds.get(i).idx];
if (tie.contains(lab)) { ansLab = lab; break; }
}
System.out.println(ansLab + " " + freq.get(ansLab));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

struct PairD {
double d2; int idx;
bool operator<(const PairD& o) const { return d2 < o.d2; }
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读到 EOF，按空白分隔
vector<string> tok;
string s;
while (cin >> s) tok.push_back(s);
if (tok.empty()) return 0;
size_t p = 0;

int k = stoi(tok[p++]);
int m = stoi(tok[p++]);
int n = stoi(tok[p++]);
int sc = stoi(tok[p++]); // 未直接使用

vector<double> q(n);
for (int i = 0; i < n; ++i) q[i] = stod(tok[p++]);

vector<vector<double>> X(m, vector<double>(n));
vector<int> y(m);
for (int i = 0; i < m; ++i) {
for (int j = 0; j < n; ++j) X[i][j] = stod(tok[p++]);
y[i] = (int)llround(stod(tok[p++])); // 标签以浮点给出
}

vector<PairD> ds; ds.reserve(m);
for (int i = 0; i < m; ++i) {
double d2 = 0.0;
for (int j = 0; j < n; ++j) {
double diff = q[j] - X[i][j];
d2 += diff * diff;
}
ds.push_back({d2, i});
}
sort(ds.begin(), ds.end());

int kk = min(k, m);
unordered_map<int,int> freq;
freq.reserve(kk * 2 + 1);

for (int i = 0; i < kk; ++i) {
int lab = y[ds[i].idx];
++freq[lab];
}

int maxFreq = 0;
for (auto &e : freq) maxFreq = max(maxFreq, e.second);

// 并列集合
unordered_set<int> tie;
for (auto &e : freq) if (e.second == maxFreq) tie.insert(e.first);

// 最近邻优先打破并列
int ansLab = -1;
for (int i = 0; i < kk; ++i) {
int lab = y[ds[i].idx];
if (tie.count(lab)) { ansLab = lab; break; }
}

cout << ansLab << " " << freq[ansLab] << "\n";
return 0;
}

---

### 第2题-Devops任务调度（P2316）
- 链接：https://codefun2000.com/p/P2316

> 页面标题：#P2316. 第2题-Devops任务调度

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

111.某DevopsDevopsDevops系统有一批并发任务需要匹配合适的执行机调度执行，任务和执行机都具有CPUCPUCPU型(用000表示)和IOIOIO型(用111表示)的区别，此外还有一种通用型执行机(用222表示)，一批任务和执行机的类型分别用数组taskstaskstasks、machinesmachinesmachines表示，tasks[i]tasks[i]tasks[i]表示第i个任务，machines[i]machines[i]machines[i]表示执行机的类型。每台CPUCPUCPU型、IOIOIO型执行机只能执行一个对应类型的任务，而通用型执行机既能执行CPUCPUCPU类型任务也能执行IOIOIO类型任务。
222.假设现有的匹配策略如下:任务需要按照优先级从高到低依次匹配执行机(i=0i=0i=0优先级最高),因此每一轮选择任务数组头部(i=0i=0i=0)的任务去匹配空置执行机数组头部(i=0i=0i=0)的执行机，若任务与执行机类型匹配，则代表该任务调度成功，把该执行机从空置执行机数组中移除。若任务与执行机的类型不匹配，则将执行机放到执行机数组尾部，循环该过程直到任务全部匹配成功或当前任务无法被所有剩余空置执行机匹配。
333.现规定任意时刻都可以选择使用通用执行机，但一旦选择将某个类型的任务匹配通用型执行机，则所有通用型机器都只能用于执行该类型的任务，为了避免任务排队阻塞，请返回现有匹配策略下剩下的最小空置执行机数量。
解答要求
输入
输入共333行
首行是一个正整数nnn，表示任务数量以及执行机数量
第222行包含nnn个整数，以空格分隔，表示为任务数组taskstaskstasks
第333行包含nnn个整数，以空格分隔，表示为空置执行机数组machinesmachinesmachines
数据范围:1≤n≤100,0≤tasks[i]≤1，0≤machines[i]≤2.1≤n≤100,0≤tasks[i]≤1，0≤machines[i]≤2.1≤n≤100,0≤tasks[i]≤1，0≤machines[i]≤2.
输出
一行一个整数，代表当前匹配策略下剩下的最小空置执行机数量。
样例1
输入
3
1 0 1
1 2 0

输出
0

解释:第一轮 任务数组头部类型111，空置执行机数组头部类型111，四配成功，任务数组变为[0,1][0,1][0,1],空置执行机数组变为[2,0][2,0][2,0]
第二轮 任务数组头部类型000，空置执行机数组头部类型222，若不选择类型222的执行机执行类型000的任务，将执行机放回数组尾部，任务数组不变为[0,1][0,1][0,1],空置执行机数组变为[0,2][0,2][0,2]
第三轮 任务数组头部类型000，空置执行机数组头部类型000，匹配成功，任务数组变为[1][1][1],空置执行机数组变为[2][2][2]
第四轮 任务数组头部类型111，空置执行机数组头部类型222，任务类型111选择匹配执行机类型222，因此剩下的最小空置执行机数量为000
样例2
输入
4
1 0 1 1
1 0 2 0

输出
1

解释:第一轮 任务数组头部类型111，空置执行机数组头部类型111，调度成功，任务数组变为[0,1,1][0,1,1][0,1,1],空置执行机数组变为[0,2,0][0,2,0][0,2,0]
第二轮 任务数组头部类型000，空置执行机数组头部类型000，调度成功，任务数组变为[1,1][1,1][1,1],空置执行机数组变为[2,0][2,0][2,0]
第三轮 任务数组头部类型111，空置执行机数组头部类型222，类型111的任务选择匹配类型222的执行机，任务数组变为[1][1][1],空置执行机数组变为[0][0][0]
第四轮 任务数组头部类型111，空置执行机数组头部类型000，无法匹配，剩下的最小空置执行机数量为111

▶️

#### TextSol

video solution

题面描述:
题目要求我们对一批任务和执行机进行匹配调度，任务和执行机类型分别为CPU型(0)、IO型(1)和通用型(2)，其中通用型执行机可以执行任意类型的任务。每次任务和执行机按照优先级从高到低进行匹配，任务与执行机类型匹配则调度成功，执行机从数组中移除；若不匹配，则将执行机放回队列末尾。使用通用型执行机后，所有通用型执行机只能执行同一种类型任务。要求计算剩余的最小空置执行机数量。
题目思路
题目的重要条件是一旦2号机选择了转换为0号机或者1号机之后，所有的2号机都要做相同的转换。即所有的2号机最终要么变为0号机，要么变为1号机。同时也可以发现，不管是0号机和1号机怎么排列，都会被使用到，因为整个数组是循环的，即该题中的任务执行和机器的顺序无关，而只与0号机和1号机的数量有关。所以只需要讨论2号机变为0号机或者2号机变为1号机两种情况。然后计算该两种情况下机器的剩余情况。
当枚举2号机器变为0号机或者1号机之后，接下来的工作是模拟任务调度的过程，因为任务调度与机器是顺序无关，所以只需要统计出0,1号机的数量，当某时刻机器不足时直接break，从而求解出剩余的机器数量。
解决思路
由于问题的核心是要确定当所有通用型执行机被统一转换为 CPU 型或 IO 型时，剩余的最小空置执行机数量，因此问题可以简化为两种情况的讨论：

通用型执行机全部转换为 CPU 型（0），即所有类型为 2 的执行机会被视为 0。
通用型执行机全部转换为 IO 型（1），即所有类型为 2 的执行机会被视为 1。

任务调度过程与执行机的排列顺序无关，因此，我们只需要统计 0 号机和 1 号机的数量，在模拟调度过程中，当机器不足时停止并记录剩余的机器数量。
具体步骤

输入数据：输入任务数组 tasks 和执行机数组 machines。
枚举两种情况：枚举通用型执行机全部转换为 0 和全部转换为 1 两种情况。
模拟任务调度：

创建一个新的数组来存储机器类型的分布。
根据当前的任务类型，逐个匹配机器。如果匹配成功，减少该类型机器的数量。如果无法匹配，则停止。

记录结果：每种情况下记录剩余的空置执行机数量，最终返回两个方案中的最小值。

代码
python
# 计算最小机器剩余数 , x为2要变成的值
def calc_min_ops(task_arr, macine_arr, x , n):
tmp = macine_arr.copy() # 用于计算的数组,需要复制一份,否则会改变原数组
ans = n
num = [0] * 2 # 统计每个机器的数量
for i in range(n):
if tmp[i] == 2: # 如果是2,则替换为x
tmp[i] = x
num[tmp[i]] += 1 # 统计每个机器的数量
for i in range(n): # 从左到右遍历,直到遇到机器数量不够的位置退出
num[task_arr[i]] -= 1
if num[task_arr[i]] < 0:
break
ans -= 1
return ans

def main():
n = int(input())
task_arr = list(map(int, input().split()))
machine_arr = list(map(int, input().split()))
ans1 = calc_min_ops(task_arr, machine_arr, 1 , n)
ans2 = calc_min_ops(task_arr, machine_arr, 0 , n)
print(min(ans1, ans2))

if __name__ == "__main__":
main()

java
import java.util.Scanner;

class Main {
static int n;
public static void main(String[] args) {
// 创建一个 Scanner 对象来读取用户输入
Scanner sc = new Scanner(System.in);

// 读取任务数量和机器数量
n = sc.nextInt();

// 创建数组来存储任务类型和机器类型
int[] task_arr = new int[n];
int[] machine_arr = new int[n];

// 从用户那里读取任务类型和机器类型
for (int i = 0; i < n; i++) {
task_arr[i] = sc.nextInt();
}
for (int i = 0; i < n; i++) {
machine_arr[i] = sc.nextInt();
}

// 计算将类型为 2 的机器转换为类型 1 或 0 所需的最小操作次数
int ans1 = calcMinOps(task_arr, machine_arr, 1);
int ans2 = calcMinOps(task_arr, machine_arr, 0);

// 输出最小操作次数
System.out.println(Math.min(ans1, ans2));
}

/**
* 计算分配任务到机器所需的最小操作次数。
*
* @param task_arr  一个表示任务类型的数组
* @param machine_arr 一个表示机器类型的数组
* @param x         将类型为 2 的机器转换为的目标类型（0 或 1）
* @return 所需的最小操作次数
*/
static int calcMinOps(int[] task_arr, int[] machine_arr, int x) {
// 创建一个机器类型数组的副本, 以避免修改原始数组
int[] converted_machine_arr = new int[n];

// 将最大可能的操作次数初始化为 n
int ans = n;

// 初始化一个数组来跟踪每种类型机器的数量
int[] machine_count = new int[2];

// 将类型为 2 的机器转换为指定类型, 并更新机器数量
for (int i = 0; i < n; i++) {
converted_machine_arr[i] = machine_arr[i];
if (converted_machine_arr[i] == 2) {
converted_machine_arr[i] = x;
}
machine_count[converted_machine_arr[i]]++;
}

// 将任务分配给机器, 减少所需的操作次数
for (int i = 0; i < n; i++) {
machine_count[task_arr[i]]--;
if (machine_count[task_arr[i]] < 0) {
break;
}
ans--;
}

// 返回最小操作次数
return ans;
}
}

C++
#include <iostream>
#include <vector>
using namespace std;

static int n;

int calcMinOps(vector<int>& task_arr, vector<int>& machine_arr, int x) {
// 创建一个机器类型数组的副本, 以避免修改原始数组
vector<int> converted_machine_arr(machine_arr);

// 将最大可能的操作次数初始化为 n
int ans = n;

// 初始化一个数组来跟踪每种类型机器的数量
vector<int> machine_count(2, 0);

// 将类型为 2 的机器转换为指定类型, 并更新机器数量
for (int i = 0; i < n; i++) {
if (converted_machine_arr[i] == 2) {
converted_machine_arr[i] = x;
}
machine_count[converted_machine_arr[i]]++;
}

// 将任务分配给机器, 减少所需的操作次数
for (int i = 0; i < n; i++) {
machine_count[task_arr[i]]--;
if (machine_count[task_arr[i]] < 0) {
break;
}
ans--;
}

// 返回最小操作次数
return ans;
}

int main() {
// 创建一个 Scanner 对象来读取用户输入
// 在C++中,我们使用标准输入流 cin 代替 Java 中的 Scanner

// 读取任务数量和机器数量
cin >> n;

// 创建数组来存储任务类型和机器类型
vector<int> task_arr(n);
vector<int> machine_arr(n);

// 从用户那里读取任务类型和机器类型
for (int i = 0; i < n; i++) {
cin >> task_arr[i];
}
for (int i = 0; i < n; i++) {
cin >> machine_arr[i];
}

// 计算将类型为 2 的机器转换为类型 1 或 0 所需的最小操作次数
int ans1 = calcMinOps(task_arr, machine_arr, 1);
int ans2 = calcMinOps(task_arr, machine_arr, 0);

// 输出最小操作次数
cout << min(ans1, ans2) << endl;

return 0;
}

视频讲解

---

### 第2题-数组消除（P2313）
- 链接：https://codefun2000.com/p/P2313

> 页面标题：#P2313. 第2题-数组消除

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个整数数组numsnumsnums，同时给定一个整数intervalintervalinterval。
指定数组numsnumsnums中的某个元素作为起点，然后以intervalintervalinterval 为间隔递增，如果递增的数（包含起点）等于numsnumsnums中的元素，则数组numsnumsnums中对应的元素消除，返回消除元素最多的起点元素。如果消除的元素同样多，则返回最小的起点元素。
输入描述
输入格式：
第一行输入整数数组的长度nnn
第二行输入长度为nnn的整数数组numsnumsnums
第三行输入整数intervalintervalinterval
1＜=n＜=1051＜=n＜=10^51＜=n＜=105
0＜=nums[i]＜=1080＜=nums[i]＜=10^80＜=nums[i]＜=108
0＜=interval＜=1050＜=interval＜=10^50＜=interval＜=105
输出描述
起点元素的最小值
样例1
输入
6
4 5 7 1 1 2
3

输出
1

说明
输入给定的间隔为333，如果以元素111为起点，则可以消除1,4,7,10,...1,4,7,10,...1,4,7,10,...这些元素，因此，我们可以消除给定数组中的4,7,1,14,7,1,14,7,1,1这444个元素，以其他元素为起点也没有办法消除更多元素了，因此返回111
样例2
输入
5
4 5 7 1 2
50

输出
1

说明
输入给定的间隔为505050,如果以元素111为起点，则可以消除1,51,1011,51,1011,51,101这些元素，因此，我们可以消除给定数组中的111这个元素，同理，如果以222为起点，则可以消除2,52,1022,52,1022,52,102这些元素，因此我们可以消除给定数组中的222这个元素，以此类推，无论以哪个元素作为起点，都只能消除111个元素，因此返回最小的起点元素111。

▶️

#### TextSol

video solution

题意化简
给定一个数组，求选择出一个 最长的 公差为 kkk 的等差数列。如果有多个这样的等差数列，选择起点最小的那个。
思路:哈希表 + 枚举 + 同余
1.如何判断两个数是否处在同一个间隔为k的等差数列中？
他们同时对k取模，得到这个序列的最小非负整数，如果相等，则处于同一个等差序列。这样我们只需要用哈希表统计a[i] % k的个数。
解释
k = 3 , 初始值 s = 10
arr = [10 , 13 , 16 , 19 , 22 , ...]
对于序列里的10 , 13 , 22 , 他们 % k 都等于 1
这是因为，他们都能写成1+a∗k1 + a * k1+a∗k 的形式。而不管a取多少.后面的a * k 都会被取模为0.
2.多个可能的答案
序列中可能有多个包含最多元素的等差数列，我们只需要使用一个哈希表记录x % k 的最小可能即可。
坑点：据提前交卷的考生反应，java，python时限只有200ms，考场上正确做法貌似只能过40%，其他超时
代码
python
from collections import defaultdict
# 读入数组长度和间隔
n = int(input())
a = list(map(int, input().split()))
k = int(input())
# mod统计余数为x的元素的实际最小值
mod = {}
# book[x]统计 属于首项为x的等差数列 的元素个数
book = defaultdict(int)
for x in a:
rest = x % k
book[rest] += 1
if rest not in mod:
mod[rest] = x
else:
# 保留最小的值
mod[rest] = min(x, mod[rest])

res = 0
mim_val = -1
for rest, value in mod.items():
x = book[rest]
# 保留出现次数最多的等差数列
if x > res:
res = x
mim_val = value
# 出现次数相同，保留最小的值
elif x == res and value < mim_val:
mim_val = value
# 输出
print(mim_val)

Java
import java.util.*;

class Main {
public static void main(String[] args) {
Scanner in = new Scanner(System.in);

// 读取输入的整数个数n
int n = in.nextInt();
int[] nums = new int[n]; // 创建数组存储输入的整数

// 读取n个整数
for(int i = 0; i < n; i++) {
nums[i] = in.nextInt();
}

// 读取间隔k
int k = in.nextInt();

// 创建两个哈希表，一个用于统计模k的频率，另一个用于记录最小整数
Map<Integer, Integer> map = new HashMap<>();
Map<Integer, Integer> rec = new HashMap<>();

int max = 0; // 用于记录当前最大频率
int ans = Integer.MAX_VALUE; // 用于记录答案，初始化为最大值

// 遍历输入的整数数组
for(int i = 0; i < n; i++) {
int tmp = nums[i] % k; // 计算当前数与k的同余

// 更新模k的频率
map.put(tmp, map.getOrDefault(tmp, 0) + 1);

// 记录当前模k值对应的最小整数
if(!rec.containsKey(tmp) || rec.get(tmp) > nums[i]) {
rec.put(tmp, nums[i]);
}
}

// 遍历频率表，查找出现频率最高的模k值
for(Map.Entry<Integer, Integer> entry : map.entrySet()) {
if(entry.getValue() >= max) {
// 如果频率相同，选择最小的整数
if(entry.getValue() == max) {
ans = Math.min(ans, rec.get(entry.getKey()));
} else {
ans = rec.get(entry.getKey()); // 更新答案
}

max = entry.getValue(); // 更新最大频率
}
}

// 输出结果，即满足条件的最小整数
System.out.println(ans);
}
}

C++
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>
#include <climits>
#include <unordered_set>
using namespace std;

int main() {
int n; // 输入整数的个数
cin >> n;
vector<long long int> nums(n, 0); // 创建一个长整型数组用于存储输入的整数
long long int c; // 用于临时存储输入的整数

// 读取n个整数并存入nums数组
for(int i = 0; i < n; i++) {
cin >> c;
nums[i] = c; // 将输入的整数赋值到数组中
}

int interval; // 输入的间隔
cin >> interval;

long long int res = LLONG_MAX; // 初始化结果为最大长整型值
int del = 0; // 用于记录出现频率最高的模值的个数

// 创建一个映射，用于存储每个模值及其对应的数值列表
map<long long int, vector<long long int>> mp_1;
for(int i = 0; i < n; i++) {
// 将每个数值按模interval分组
mp_1[nums[i] % interval].push_back(nums[i]);
}

// 遍历映射，找出出现频率最高的模值
for(auto& m : mp_1) {
// 如果当前模值的数量超过已记录的最大数量
if(del < (int)m.second.size()) {
del = (int)m.second.size(); // 更新最大数量
sort(m.second.begin(), m.second.end()); // 对当前模值的数值列表进行排序
res = m.second[0]; // 记录当前模值的最小数
} else if(del == (int)m.second.size()) {
// 如果当前模值的数量与已记录的最大数量相同，更新结果
for(int i = 0; i < (int)m.second.size(); i++) {
res = min(res, m.second[i]); // 取当前最小值
}
}
}

// 输出结果，即满足条件的最小整数
cout << res;
return 0; // 结束程序
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-好友推荐系统（P2310）
- 链接：https://codefun2000.com/p/P2310

> 页面标题：#P2310. 第2题-好友推荐系统

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你正在为一个社交网络平台开发好友推荐功能。
平台上有NNN个用户(每个用户使用111到NNN的整数编号)，同时系统中维护了用户之间的好友关系。
为了推荐新朋友，平台决定采用“共同好友数量”作为衡量两个用户之间相似度的标准。
系统根据输入用户编号KKK，输出与此用户KKK相似度最高的前LLL个用户IDIDID，来推荐给用户KKK。
相似度定义:两个用户非好友，两个用户的相似度为拥有的共同好友数(例如用户AAA和用户BBB，只有共同好友CCC和DDD，相似度=222)
输入描述
第一行包含四个整数NNN，MMM、KKK和LLL，分别表示用户的数量(NNN)，好友记录条数(MMM)、查询的用户编号(KKK)和推荐的好友数量(LLL)。
接下来MMM行，每行包含两个整数编号XXX和YYY，表示编号为XXX和YYY用户是好友。
1.输入格式都是标准的，无需考虑输出异常场景(不会包含用户和自己是好友的输入,例如111 111)
2.用户数不超过102410241024，用户编码最大102441024410244
3.好友记录数不超过102401024010240
输出描述
根据输入KKK和LLL，输出和用户KKK相似度最高的LLL个用户编码。
1.输出相似度最高的前LLL个用户编码，按照相似度从高到低排序
2.如果有相似度相同的可能好友，按照用户编号从小到大排序
3.如果推荐的好友个数不足LLL个，则推荐与用户KKK无无共同好友关系的用户(陌生人)作为可能好友;如果
推荐仍不满足LLL个用户，剩余推荐用户编码使用000来占位
样例1
输入
6 7 3 2
1 2
1 3
2 3
3 4
3 5
4 5
5 6

输出
6 0

解释
输入包含了666个用户，777条好友记录，给用户IDIDID编号为333的用户推荐222个好友
输出只有编号为666的用户可能是编号333用户的可能好友；
尝试推荐与编号333用户无共同好友的其他用户，由于除编号为666的用户之外，其他用户和编号333用户都是好友，所以找不到陌生人作为推荐的第二个用户；
推荐结果不足222个用户，所以推荐的第二个用户编码使用000来占位补足。
样例2
输入
8 11 1 3
1 2
1 3
2 3
3 4
3 5
4 5
5 6
6 7
7 8
1 8
2 7

输出
7 4 5

解释
输入包含了888个用户，111111条好友记录，给用户IDIDID编号为111的用户推荐333个好友。
按照相似度排序推荐给用户111的相关好友:777   444   555

▶️

#### TextSol

video solution

题面描述:
在这个问题中，我们需要为社交网络平台上的用户提供好友推荐功能。具体而言，输入包括用户总数 (N)、好友关系总数 (M)、待推荐用户编号 (K) 以及需要推荐的好友数量 (L)。随后会有 (M) 行数据，表示用户之间的好友关系。我们需根据用户 (K) 的共同好友数量来计算其与其他用户的相似度，推荐相似度最高的 (L) 个用户，且推荐用户不能是用户 (K) 的好友。推荐结果需按相似度从高到低排序，若相似度相同，则按用户编号从小到大排序。如果找到的候选用户少于 (L) 个，则需要补充与用户 (K) 没有任何共同好友的其他用户，如果仍不足 (L) 个，则用 (0) 补位。通过这个推荐功能，可以帮助用户发现新的好友，增强社交网络的互动。
思路：模拟
题目要求给目标用户推荐好友，首先被推荐对象不能是目标用户的好友。因此我们在读入用户关系时，标记一下与目标用户互为好友的用户。
之后，枚举所有未被标记用户，他们都是待定对象。而与目标用户相似度，就是与其相连的边中，被标记的点的数量。因此统计后再排序即可。
具体步骤如下：

数据结构定义：

使用一个大小为 maxn 的数组 vis 来标记特定用户 (g) 的好友。若用户 (i) 是 (g) 的好友，则 vis[i] 为 true。
使用邻接表 e 来存储每个用户的好友列表，以便后续快速查找每个用户的好友。

读取输入：

首先读取用户总数 (n)、好友关系数 (m)、特定用户编号 (g)、以及要输出的推荐好友数量 (p)。
接下来，逐条读取好友关系 (x) 和 (y)，并更新邻接表和 vis 数组。若 (x) 或 (y) 是用户 (g)，则将其标记为与 (g) 直接相连。

计算相似度：

遍历所有用户 (i)，跳过已标记为与 (g) 相连的用户。
对于每个未被标记的用户 (i)，计算其与 (g) 的相似度，即其好友中有多少是与 (g) 直接相连的用户。通过一个辅助数组 show 来避免重复计数。

记录和排序：

将每个用户及其相似度（得分）存储在结构体数组 b 中。记录符合条件的用户数量 cnt。
对 b 数组进行排序，首先根据得分从高到低，其次根据用户编号从小到大进行排序。这保证了我们能够优先推荐相似度高的用户。

输出结果：

最后输出前 (p) 个得分最高的用户编号。如果得分用户少于 (p) 个，程序可以调整输出，以确保数量符合要求（此题未涉及，代码中未处理，但可根据需求调整）。

代码
java
import java.util.*;

public class Main {

static final int MAXN = 100010; // 定义最大节点数量为 100010
static int n, m, g, p; // n: 节点数, m: 边数, g: 特定节点, p: 要输出的节点数
static boolean[] vis = new boolean[MAXN]; // 记录特定节点 g 相连的节点
static List<Integer>[] e = new ArrayList[MAXN]; // 邻接表，用于存储图中的边
static int cnt; // 记录符合条件的节点数量
static boolean[] show = new boolean[MAXN]; // 辅助数组，用于记录某个节点的邻居是否已被访问过

static class Node {
int id, score; // 节点编号和得分
Node(int id, int score) {
this.id = id;
this.score = score;
}
}

static Node[] b = new Node[MAXN]; // 存储每个符合条件节点的编号和得分

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt(); // 读取节点数
m = scanner.nextInt(); // 读取边数
g = scanner.nextInt(); // 读取特定节点 g
p = scanner.nextInt(); // 读取要输出的节点数

for (int i = 0; i < MAXN; i++) {
e[i] = new ArrayList<>(); // 初始化邻接表
}

for (int i = 1; i <= m; ++i) {
int x = scanner.nextInt(); // 读取每条边的第一个节点 x
int y = scanner.nextInt(); // 读取每条边的第二个节点 y
e[x].add(y); // 将 y 加入到 x 的邻接表中
e[y].add(x); // 将 x 加入到 y 的邻接表中
if (x == g || y == g) { // 如果 x 或 y 中有一个是特定节点 g
vis[x] = true; // 标记 x 为与 g 相连
vis[y] = true; // 标记 y 为与 g 相连
}
}

for (int i = 1; i <= n; ++i) {
if (vis[i]) continue; // 如果节点 i 与 g 相连，跳过
int score = 0; // 初始化得分为 0
Arrays.fill(show, false); // 重置 show 数组

for (int x : e[i]) { // 遍历节点 i 的所有邻居
if (vis[x] && !show[x]) { // 如果邻居 x 与 g 相连且未被访问过
score += 1; // 增加得分
show[x] = true; // 标记邻居 x 已被访问
}
}
b[++cnt] = new Node(i, score); // 将节点 i 和其得分记录下来
}

Arrays.sort(b, 1, cnt + 1, (x, y) -> {
// 根据得分排序，如果得分相同，按节点编号升序排序
if (x.score == y.score) return Integer.compare(x.id, y.id);
return Integer.compare(y.score, x.score);
});

int outputCount = Math.min(p, cnt); // 计算实际可输出的节点数

for (int i = 1; i <= outputCount; ++i) {
System.out.print(b[i].id + " "); // 输出得分最高的节点的编号
}

for (int i = outputCount + 1; i <= p; ++i) {
System.out.print("0 "); // 如果不足 p 个节点，补充 0
}
}
}

python
n , m , k , L = map(int, input().split())
edges = [[] for _ in range(n + 1)]

# 读入数据
for _ in range(m):
x , y = map(int, input().split())
edges[x].append(y)
edges[y].append(x)
# 去重排序
for i in range(1 , n + 1):
edges[i] = list(set(edges[i]))
edges[i].sort()
# 计算共同好友
def get_commend_friend(x , y):
i = 0
ans = 0
st = set(edges[y])
for item in edges[x]:
if item in st:
ans += 1
return ans
# 计算答案
res = []
for i in range(1 , n + 1):
# 排除自己
if i == k:
continue
# 排除已经是好友的
if k in edges[i]:
continue
# 计算共同好友
res.append([get_commend_friend(k , i) , i])
# 排序输出，注意排序规则：共同好友数目降序，编号升序
res.sort(key = lambda x : (-x[0] , x[1]))
ans = []
# 输出答案
for i in range(L):
if i < len(res):
ans.append(res[i][1])
else:
ans.append(0)
print(*ans)

C++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 1e5 + 10; // 定义最大节点数量为 100010
int n, m, g, p; // n: 节点数, m: 边数, g: 特定节点, p: 要输出的节点数
int vis[maxn]; // 记录特定节点 g 相连的节点
vector<int> e[maxn]; // 邻接表，用于存储图中的边

int cnt; // 记录符合条件的节点数量
bool show[maxn]; // 辅助数组，用于记录某个节点的邻居是否已被访问过
struct node {
int id, score; // 节点编号和得分
} b[maxn]; // 存储每个符合条件节点的编号和得分

int main() {
std::ios::sync_with_stdio(false); // 提高 cin/cout 的运行效率
cin >> n >> m >> g >> p; // 读取输入的 n, m, g, p 的值
int x, y;
for (int i = 1; i <= m; ++i) {
cin >> x >> y; // 读取每条边的两个节点 x 和 y
e[x].push_back(y); // 将 y 加入到 x 的邻接表中
e[y].push_back(x); // 将 x 加入到 y 的邻接表中
if (x == g || y == g) { // 如果 x 或 y 中有一个是特定节点 g
vis[x] = true; // 标记 x 为与 g 相连
vis[y] = true; // 标记 y 为与 g 相连
}
}
for (int i = 1; i <= n; ++i) {
if (vis[i]) continue; // 如果节点 i 与 g 相连，跳过
int score = 0; // 初始化得分为 0
memset(show, 0, sizeof show); // 重置 show 数组
for (auto x : e[i]) { // 遍历节点 i 的所有邻居
if (vis[x] && !show[x]) { // 如果邻居 x 与 g 相连且未被访问过
score += 1; // 增加得分
show[x] = true; // 标记邻居 x 已被访问
}
}
b[++cnt] = (node){i, score}; // 将节点 i 和其得分记录下来
}
sort(b + 1, b + cnt + 1, [&](node x, node y) {
// 根据得分排序，如果得分相同，按节点编号升序排序
return x.score == y.score ? x.id < y.id : x.score > y.score;
});
for (int i = 1; i <= p; ++i) {
cout << b[i].id << " "; // 输出得分最高的 p 个节点的编号
}

return 0;
}

---

### 第2题-绝对路径（P2304）
- 链接：https://codefun2000.com/p/P2304

> 页面标题：#P2304. 第2题-绝对路径

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

LinuxLinuxLinux系统中，绝对路径是从根目录开始的完整路径，即以'\'开头，相对路径是从当前工作目录开始的路径，以'.'、'..'或当前目录的子目录名开始。某用户便用'cdcdcd' 相对路径"的指令来切换工作目录，假设其使用的相对路径包含如下部分:

一个点'...'表示当前目录;

两个点'..'表示上一级目录，根目录的上一级仍然是根目录;

斜杠'///'用于分割目录，连续的多个斜杠等价于单个斜杠;

其他字符串均代表目录名，如'...'、'hellohellohello'，且假设目录都存在;
请计算出用户在使用'cd 相对路径'指令后的工作目录，要求:

以绝对路径的形式输出，即以/开始;
以最简洁形式输出;最简洁形式指的是路径中没有冗余部分，即没有'.'、'..'、'//'，不以'/'结尾;
另外，假设cdcdcd指令执行过程中，会依次进入每一级目录，请给出，经过的最深的目录的层级数，包括当前目录和最终目录，假设根目录'/'为000层。

输入描述
第一行为当前工作目录的绝对路径，为最简洁形式；字符数范围[1,1001,1001,100];
第二行为用户执行的cdcdcd相对路径命令，cdcdcd和相对路径之间有一个空格隔开，相对路径的字符数范围[1,1001,1001,100]，注意cdcdcd和空格还有333个字符；
输出描述
第一行为用户执行'cdcdcd相对路径'指令后的当前工作目录，要求以最简洁的绝对路径形式输出。
第二行为指令过程中经过的最深目录层级数。
样例1
输入
/home/hello
cd .././/world/

输出
/home/world
2

说明
指令执行过程中进入的目录依次为：/home/hello、/home、/home/world/home/hello、/home、/home/world/home/hello、/home、/home/world，最终目录为/home/world/home/world/home/world，最深层次为222。
样例2
输入
/home/hello
cd world/.../../.

输出
/home/hello/world
4

说明
...也是合法目录名：
指令执行过程中进入的目录依次为：$/home/hello、/home/hello/world、/home/hello/world/...、/home/hello/world$，最终目录为/home/hello/world/home/hello/world/home/hello/world，最深层级为444

▶️

#### TextSol

video solution

题面解释:
在Linux系统中，用户通过cd命令来切换工作目录。给定一个当前工作目录的绝对路径和一个相对路径命令，要求输出执行该命令后用户的新工作目录，且以最简洁的绝对路径形式表示，同时还需输出在命令执行过程中经过的最深目录层级数。输入包括当前工作目录的绝对路径和cd命令的相对路径，输出则包含用户新目录的绝对路径和最深层级数的两个数值。例如，若输入为/home/hello和cd .././/world/，则输出为/home/world和2，表示最终目录和经过的最深层级数。
思路
使用栈来模拟路径变化是通过利用栈的后进先出（LIFO）特性来实现文件系统的路径导航。首先，将当前路径和目标路径用“/”分割为路径片段，并依次处理。当前路径中的有效目录名依次入栈，表示进入对应的子目录；遇到“..”时，栈顶元素弹出，表示返回上一级目录。对于目标路径的处理，如果是有效目录，则入栈；如果是“..”，则弹出栈顶目录。在操作过程中，栈的最大深度反映了所到达的最大目录层级。
题解
在Linux系统中，路径的管理和切换非常重要。我们可以通过栈结构来模拟路径变化，利用栈的后进先出（LIFO）特性来实现文件系统的路径导航。首先，我们将当前路径和目标路径用“/”进行分割，得到路径片段。对于当前路径中的有效目录名，我们依次入栈，表示进入对应的子目录；遇到“..”时，表示返回上一级目录，因此弹出栈顶元素。对目标路径的处理同样适用：如果是有效目录名，则入栈；如果是“..”，则弹出栈顶目录。在路径操作的过程中，栈的最大深度将反映出用户所到达的最大目录层级数，包括当前目录和最终目录。最终，我们将栈中的内容拼接成绝对路径，并输出最简洁的形式。
代码解读

输入处理：通过 getline 函数读取当前路径和命令输入，并将路径字符串按斜杠“/”分割，得到各个目录名片段。
路径管理：使用栈（这里用向量实现）来处理路径的变化，包括进入新目录和返回上级目录的操作。
层级深度：在处理路径的过程中，通过更新层级深度的变量，记录下路径的最大深度。
最终输出：在处理完成后，将栈中的内容拼接成最简洁的绝对路径，并输出最终的路径和层级深度。

代码
python
# 读取当前路径输入
s = input()
# 将当前路径按 "/" 分割为列表
s = list(s.split("/"))
# 弹出第一个元素（根目录前的空字符串）
s.pop(0)
# 读取需要切换的目标路径，目标路径的前缀忽略
_, ss = input().split()
# 将目标路径按 "/" 分割为列表
ss = ss.split("/")
# 初始化深度为当前路径的层级数
dep = len(s)
# 如果当前路径的第一个元素为空字符串，表示根目录，深度置为 0
if s[0] == "":
dep = 0
# 遍历目标路径中的每个部分
for x in ss:
# 跳过空字符串，防止多余的 "/"
if x == "":
continue
# 如果不是当前目录符号 "."
if x != ".":
# 如果是返回上一级目录符号 ".."
if x == "..":
# 如果栈不为空，弹出栈顶元素（返回上一级目录）
if len(s) > 0:
s.pop()
else:
# 否则，将该路径部分入栈（进入该目录）
s.append(x)
# 更新最大深度为当前栈的最大长度
dep = max(dep, len(s))

# 初始化结果路径为空字符串
res = ""
# 遍历栈中的路径部分，构造最终路径
for x in s:
if x != "":
res = res + "/" + x
# 如果路径为空，表示根目录，设置结果为 "/"
if res == "":
res = "/"
# 输出最终的路径
print(res)
print(dep)

java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取当前路径并按 "/" 分割为列表
String input = sc.nextLine();
String[] pathSegments = input.split("/");
List<String> path = new ArrayList<>();

for (String segment : pathSegments) {
if (!segment.isEmpty()) {
path.add(segment);
}
}

// 读取需要切换的目标路径
input = sc.nextLine();
int pos = input.indexOf(' ');
String newPath = input.substring(pos + 1);
String[] newPathSegments = newPath.split("/");

// 初始化深度为当前路径的层级数
int dep = path.size();

// 遍历目标路径中的每个部分
for (String x : newPathSegments) {
if (x.isEmpty()) continue;
if (x.equals("..")) {
if (!path.isEmpty()) {
path.remove(path.size() - 1);
}
} else if (!x.equals(".")) {
path.add(x);
dep = Math.max(dep, path.size());
}
}

// 构造最终路径
StringBuilder res = new StringBuilder();
for (String x : path) {
if (!x.isEmpty()) {
res.append("/").append(x);
}
}

// 如果路径为空，表示根目录
if (res.length() == 0) {
res.append("/");
}

// 输出最终路径和深度
System.out.println(res.toString());
System.out.println(dep);

sc.close();
}
}

c++
#include <iostream>
#include <sstream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
// 读取当前路径并按 "/" 分割为路径片段
string input;
getline(cin, input);  // 获取当前工作目录的绝对路径
stringstream ss(input);
vector<string> path;  // 用于存储路径片段
string segment;

// 将路径按"/"分割并存入path向量中
while (getline(ss, segment, '/')) {
if (!segment.empty()) path.push_back(segment);  // 跳过空段
}

// 读取需要切换的目标路径
getline(cin, input);  // 获取cd命令
size_t pos = input.find(' ');  // 找到cd和路径之间的空格
string newPath = input.substr(pos + 1);  // 提取目标路径
stringstream ssNew(newPath);
vector<string> ssSegments;  // 存储目标路径的片段

// 将目标路径按"/"分割并存入ssSegments向量中
while (getline(ssNew, segment, '/')) {
ssSegments.push_back(segment);
}

// 初始化深度为当前路径的层级数
int dep = path.size();  // 记录当前路径的层级数
if (path.size() > 0 && path[0].empty()) dep = 0;  // 特殊情况处理

// 遍历目标路径中的每个部分
for (const string &x : ssSegments) {
if (x.empty()) continue;  // 跳过空段
if (x != ".") {  // "."表示当前目录，不做处理
if (x == "..") {  // ".."表示上一级目录
if (!path.empty()) path.pop_back();  // 弹出栈顶元素
} else {
path.push_back(x);  // 有效目录名入栈
}
dep = max(dep, (int)path.size());  // 更新最大深度
}
}

// 构造最终路径
string res;
for (const string &x : path) {
if (!x.empty()) res += "/" + x;  // 拼接路径
}

// 如果路径为空，表示根目录
if (res.empty()) res = "/";

// 输出最终的路径
cout << res << endl;  // 输出最简洁的绝对路径
cout << dep << endl;  // 输出最大目录层级数

return 0;
}

---

### 第2题-圣诞节礼盒（P2307）
- 链接：https://codefun2000.com/p/P2307

> 页面标题：#P2307. 第2题-圣诞节礼盒

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

圣诞节到了，小明的妈妈准备了很多圣诞礼盒，礼盒大小不同，小明在玩堆盒子的游戏，妈妈问小明，怎么堆盒子使得堆出的高度最高，每个礼盒的大小由长、宽、高表示，堆盒子的时候要求下面的盒子长、宽、高都必须大于上面的盒子，不包含等于。请你帮助小明一起堆出最高的一堆礼盒，高度为堆出的礼盒的所有高度的总和。
输入描述
输入的第一行是礼盒的个数NNN，
接下来输入NNN行，每行表示每个礼盒的长、宽、高。
礼盒的数量不超过100010001000个，每个盒子的长、宽、高取值范围为111~101010。
输出描述
输出一行，输出能堆出盒子的最高高度
样例1
输入
4
1 1 1
2 3 4
3 6 7
4 5 6

输出
12

说明
选择1、2、31、2、31、2、3，333个盒子堆出的高度最高，1+4+7=121+4+7=121+4+7=12
样例2
输入
4
1 1 1
1 1 1
2 2 2
2 2 2

输出
3

说明
其中的一种选择方式为选择111和333两个盒子，堆出的高度最高为1+2=31+2=31+2=3

▶️

#### TextSol

video solution

思路：动态规划
将所有盒子按照长、宽、高的三个优先级进行从小到大的排序，那么后面的盒子一定不可能放在前面盒子的上面。所以我们排序之后，选择的顺序就已经是定死的从左往右选择了。那么可以使用动态规划进行求解。
定义dp[i]dp[i]dp[i]表示放上第iii个盒子所能达到的最大高度，则有

答案为maxdp[i],1≤i≤nmax{dp[i]},1\le i\le nmaxdp[i],1≤i≤n
解题思路

排序：首先，将所有盒子按照长、宽、高三个维度进行从小到大的排序。由于后面的盒子在长、宽、高方面都大于前面的盒子，因此可以确保一个盒子不会被放在另一个盒子上面，从而简化了问题。

动态规划：接下来，使用动态规划来解决问题。定义 dp[i] 表示以第 i 个盒子为顶部盒子时，所能达到的最大堆叠高度。我们需要考虑所有之前的盒子，如果一个盒子可以放在另一个盒子上面，就更新 dp[i] 的值。

结果计算：最终，结果为所有 dp[i] 中的最大值，即为我们能够堆叠的最高高度。

代码
java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
static int n;
static int[] dp;
static Box[] box;

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
box = new Box[n + 1];
dp = new int[n + 1];

for (int i = 1; i <= n; i++) {
box[i] = new Box(sc.nextInt(), sc.nextInt(), sc.nextInt());
}

Arrays.sort(box, 1, n + 1, (a, b) -> {
if (a.l != b.l) {
return a.l - b.l;
}
if (a.w != b.w) {
return a.w - b.w;
}
return a.h - b.h;
});

int ans = 0;
for (int i = 1; i <= n; i++) {
dp[i] = box[i].h;
for (int j = 1; j < i; j++) {
if (box[i].h > box[j].h && box[i].l > box[j].l && box[i].w > box[j].w) {
dp[i] = Math.max(dp[i], dp[j] + box[i].h);
}
}
ans = Math.max(ans, dp[i]);
}
System.out.println(ans);
sc.close();
}

static class Box {
int l, w, h;

Box(int l, int w, int h) {
this.l = l;
this.w = w;
this.h = h;
}
}
}

python
N=int(input())
box=[]
for _ in range(N):
box.append(list(map(int,input().split())))

box.sort(key=lambda x:(x[0],x[1],x[2])) #升序排序

dp=[0]*N #对于每个盒子作为最底层，其可以获得的最大高度是多少

for i in range(N):
dp[i]=box[i][2] #是其自己的高度
for j in range(i):
#遍历前面的盒子
#如果比前一个盒子的长宽高都大，那就是自己的高度再加上j盒子的最大高度
if box[i][0]>box[j][0] and box[i][1]>box[j][1] and box[i][2]>box[j][2]:
dp[i]=max(dp[i],dp[j]+box[i][2])

print(max(dp))

C++
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e3+10;
int dp[maxn];
int n;
struct node{
int l, w, h;
}box[maxn];

int main(){
cin>>n;
for(int i=1;i<=n;++i){
cin>>box[i].l>>box[i].w>>box[i].h;
}
//长、宽、高的三个优先级进行从小到大的排序
sort(box+1, box+n+1, [&](node a, node b){
if(a.l!=b.l){
return a.l<b.l;
}
if(a.w!=b.w){
return a.w<b.w;
}
return a.h<b.h;
});
int ans=0;
//dp[i]表示放上第i个盒子所能达到的最大高度
for(int i=1;i<=n;++i){
dp[i]=box[i].h;
for (int j = 1; j < i; j++) {
if (box[i].h > box[j].h && box[i].l > box[j].l && box[i].w > box[j].w) {
dp[i]=max(dp[i],dp[j]+box[i].h);
}
}
ans = max(ans,dp[i]);
}
cout<<ans;
}

---

### 第2题-穿越城市（P2301）
- 链接：https://codefun2000.com/p/P2301

> 页面标题：#P2301. 第2题-穿越城市

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明需要走路从城市的一端前往另一端。城市可以视为一个长条形，共有NNN个街区，按顺序排成一列，
每个街区的右侧紧挨着下一个街区的左侧。
初始时，小明位于第111个街区的左侧，他的目标是到达第NNN个街区的右侧。步行通过第nnn个街区时，小明需要花费的时间为ana_nan​。
同时，小明可以选择坐最多MMM次地铁。每个街区的左侧都有地铁站，每次坐地铁可以穿越前方最少111个，最多kkk个连续的街区。
坐地铁穿越任何一个街区所需的时间都是一个常数BBB(如果穿越222个街区，所需的时间是2×B2×B2×B，以此类推)，进地铁站、出地铁站、等待地铁均不耗费时间。
输入描述
前两行各包含一个正整数，分别对应 NNN 和 KKK。
第三行包含 NNN 个非负整数，以空格分隔，对应于步行穿过每个街区所消耗的时间。
后两行各包含一个非负整数，分别对应 BBB 和 MMM。
1≤N≤10，1≤K≤10，0≤M≤101≤N≤10，1≤K≤10，0≤M≤101≤N≤10，1≤K≤10，0≤M≤10，以任何方式通过单个街区所需要的时间
(包括所有ana_nan​以及 BBB 的值)不超过10410^4104。
输出描述
一个整数，表示穿越整个城市花费的最短时间。
样例1
输入
5
1
3 7 5 3 6
0
2

输出
11

说明
总共555个街区，坐地铁每次只能通过111个街区，坐地铁消耗时间为000，最多可以坐222次地铁。
最少消耗的方案为:坐地铁通过第222个和第555个街区，其余街区步行，最终消耗时间为3+0+5+3+0=113+0+5+3+0=113+0+5+3+0=11。
样例2
输入
5
2
1 2 1 2 2
3
2

输出
8

说明
全程走路，不坐地铁，最终消耗时间为1+2+1+2+2=81+2+1+2+2=81+2+1+2+2=8。
样例3
输入
10
2
4 1 12 1 6 7 2 4 4 4
3
2

输出
29

说明
坐地铁两次，分别穿越第333个街区以及第5−65-65−6个街区，
最终消耗时间为4+1+34+1+34+1+3(地铁)+1+3×2+1+3×2+1+3×2(地铁)+2+4+4+4=29+2+4+4+4=29+2+4+4+4=29。

▶️

#### TextSol

video solution

题意化简
这个题的本质是一个路径规划问题。你有n个街区，每个街区有步行时间a_i，可以选择步行一格或乘坐地铁跳跃1到K个街区，地铁每格花费B时间。你最多可以坐M次地铁，目标是找到从第1个街区到第N个街区的最小时间消耗。
思路
  此题是一个经典的动态规划问题，设置dp[i][j]为走到第i个街区并且已经坐了j次地铁的最短时间，转移则分为两种情况，一种是从前一个位置到当前位置不做地铁，一种是坐地铁到当前位置，第二种情况要枚举从前方哪里坐的地铁到现在的位置，并取最小值，初始化则为全不坐地铁的情况
题解
这道题是一个经典的动态规划问题。我们可以将城市的街区视为一个线性序列，使用动态规划来求解从第一个街区到最后一个街区的最短时间。定义动态规划状态 dp[i][j] 表示走到第 i 个街区，并且已经坐了 j 次地铁的最短时间。
动态规划思路

状态定义：

dp[i][j]：表示走到第 i 个街区，并且使用了 j 次地铁的最小时间。

初始化：

dp[0][0] = 0：表示在城市的起点（第0个位置，左侧）时，不需要任何时间。
dp[i][0]：仅通过步行到达第 i 个街区的时间，可以通过前一个街区的时间累加步行所需的时间。

状态转移：

对于每一个街区 i：

不坐地铁：从 i-1 走到 i，时间为 dp[i-1][j] + a[i]。
坐地铁：从前面的某个街区 l 坐地铁到当前街区 i。这里我们需要枚举所有可能的前一个街区 l，l 必须在 i - k 和 i - 1 之间，以确保我们不超过地铁的最大跨越数量 k。
每次坐地铁的时间为 b * (i - l)。

最终结果：

结果为 dp[n][j] 中的最小值，j 可以从 0 到 m，表示我们使用的地铁次数。

代码说明

常数定义：使用 const long long inf = 1e18; 来表示一个无穷大，便于后续的最小值比较。
输入部分：读取街区数量 n、地铁一次最多可跨越的街区数 k、每个街区的步行时间以及地铁的时间 b 和最多可坐地铁的次数 m。
动态规划数组：dp 数组初始化为无穷大，只有起始位置 dp[0][0] 被初始化为0。
动态规划计算：根据状态转移方程更新 dp 数组的值。
输出结果：在所有使用0到 m 次地铁的情况下，输出最小时间。

代码
c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const long long inf = 1e18;  // 定义一个足够大的常数，表示无穷大

int main() {
int n, k, m;  // n为街区数量，k为地铁一次最多可跨越的街区数，m为最多可坐地铁次数
cin >> n >> k;

vector<int> a(n + 1);  // 保存每个街区的步行时间，从1开始
for (int i = 1; i <= n; ++i) {
cin >> a[i];
}

int b;  // 每次坐地铁的时间
cin >> b >> m;

// 初始化dp数组，dp[i][j] 表示到达第 i 个街区使用 j 次地铁的最小时间
vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, inf));
dp[0][0] = 0;  // 起点不花时间

// 动态规划过程
for (int i = 1; i <= n; ++i) {
// 仅通过步行到达第 i 个街区的时间
dp[i][0] = dp[i - 1][0] + a[i];

for (int j = 1; j <= m; ++j) {  // 0到m次地铁
// 不坐地铁的情况
dp[i][j] = dp[i - 1][j] + a[i];

// 坐地铁的情况，枚举从前面哪个街区坐地铁
int last = max(0, i - k);  // 可以坐地铁的最远起始点
for (int l = last; l < i; ++l) {  // l是前一个街区的索引
// 更新使用 j 次地铁的最小时间
dp[i][j] = min(dp[i][j], dp[l][j - 1] + b * (i - l));
}
}
}

// 输出最小结果
long long result = inf;  // 初始化结果为无穷大
for (int j = 0; j <= m; ++j) {
result = min(result, dp[n][j]);  // 取到达第 n 个街区的最小时间
}

cout << result << endl;  // 输出最终结果
return 0;
}

python
n = int(input())
k = int(input())
a = [0] + list(map(int, input().split()))
b = int(input())
m = int(input())
inf = 10**18
dp = [[inf] * (m + 1) for _ in range(n + 1)]
dp[0][0] = 0
for i in range(1 , n + 1):
dp[i][0] = dp[i - 1][0] + a[i]
for j in range(1 , m + 1):
dp[i][j] = dp[i - 1][j] + a[i]
# 坐地铁，最远坐k站，枚举到底要坐多少站
last = max(0 , i - k)
for l in range(last , i):
dp[i][j] = min(dp[i][j] , dp[l][j - 1] + b * (i - l))
print(min(dp[n]))

java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int k = sc.nextInt();
int[] a = new int[n + 1];
for (int i = 1; i <= n; i++) {
a[i] = sc.nextInt();
}
int b = sc.nextInt();
int m = sc.nextInt();

long inf = (long) 1e18;
long[][] dp = new long[n + 1][m + 1];

// 初始化 dp 数组
for (int i = 0; i <= n; i++) {
Arrays.fill(dp[i], inf);
}
dp[0][0] = 0;

// 动态规划过程
for (int i = 1; i <= n; i++) {
dp[i][0] = dp[i - 1][0] + a[i];  // 不坐地铁
for (int j = 1; j <= m; j++) {
dp[i][j] = dp[i - 1][j] + a[i];  // 不坐地铁
int last = Math.max(0, i - k);
for (int l = last; l < i; l++) {  // 坐地铁，最远坐k站，枚举到底要坐多少站
dp[i][j] = Math.min(dp[i][j], dp[l][j - 1] + b * (i - l));
}
}
}

// 输出最小结果
long result = inf;
for (int j = 0; j <= m; j++) {
result = Math.min(result, dp[n][j]);
}
System.out.println(result);
}
}

---

### 第2题-服务器健康巡检（P2295）
- 链接：https://codefun2000.com/p/P2295

> 页面标题：#P2295. 第2题-服务器健康巡检

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一个未来的超级数据中心，有一排存放服务器的阵列，阵列由一列一列的机架组成，机架的每一行可以存放一个服务器，每列架子的服务器都是自底向上依次摆放，摆放的个数是随机且大于0的。现在有一个运维机器人用来检查服务器健康状态，机器人有行列2种检查模式：

行检查支持多行服务器一起检查，检查时间为1秒。
列检查仅支持单列服务器检查，检查时间为2秒。

约束说明：

允许在同一个服务器检查多次，但同一次行、列检查模式的服务器必须为连续的一段。
单独的一个服务器检查，默认采用列检查方式，检查时间为2秒。
行、列检查时间跟检查列的服务器数量无关，仅与检查模式相关。

请问机器人最少要花费多少时间才能检查完整个数据中心的服务器。
输入描述
入参分为两行输入:

第一行为机架的数量nnn。
第二行nnn个整数rack1,...,racknrack_1,..., rack_nrack1​,...,rackn​空格隔开表示每个机架摆放服务器的数量。

输出描述
检查完所有服务器最少需要的花费时间
样例1
输入
3
5 5 5

输出
1

说明

采用行检查，因为多行可以一起检查，所以111次行扫描就检查完了，耗时1s1s1s
样例2
输入
5
2 2 1 2 1

输出
4

说明

第一次采用行检查，覆盖111~555列的第1行服务器，耗时1s1s1s，第二次采用行检查，覆盖111~222列的第222行服务器，耗时1s1s1s，第三次采用列检查，覆盖第444列第222行的服务器，耗时2s2s2s，总计耗时4s4s4s
样例3
输入
5
7 4 3 3 5

输出
6

说明

第一次采用行检查，覆盖111~555列的111~333行服务器，耗时1s1s1s，第二次采用行检查，覆盖111~222列的第444行服务器，耗时1s1s1s，第三次采用列检查，覆盖第111列的555~777行的服务器，耗时2s2s2s，第四次采用列检查，覆盖第555列的444~555行的服务器，耗时2s2s2s，总计耗时6s6s6s

▶️

#### TextSol

video solution

题面解释:
为了最小化检查数据中心服务器的时间，我们可以采取以下策略：首先，使用行检查，能够同时检查多行服务器，耗时1秒；然后，使用列检查，单列检查耗时2秒。我们需要读取机架数量及每个机架的服务器数量，并找出最大的服务器数量来决定检查方式。优先进行行检查，尽可能多地覆盖服务器，再用列检查完成剩余的检查。代码实现通过标记已检查的行和计算总耗时来得到最终结果。通过这种方式，我们可以高效地确保所有服务器都得到检查，达到最小的时间消耗。
思路:贪心+递归
对一个数组arr，对min(arr)进行一个行操作。剩下的区间递归进行。直到l = r , 进行列操作
具体细节看代码注释
题解
本题旨在计算对一组服务器高度数组进行检查所需的最小代价。代价的计算方式分为两部分：行操作和列操作。具体来说，我们将根据数组中的最小值执行行操作，并在处理完所有行之后，对单个服务器进行列操作。

行操作: 如果区间内有多个服务器的高度大于当前最小值，我们将这些服务器的高度减少到最小值，这一过程的代价为1秒。此时，我们会递归地处理剩余的区间。

列操作: 当区间缩小至仅包含一个服务器时，必须进行列操作，此时的代价为2秒。

通过这样的递归操作，我们可以有效地计算出整个数组的最小检查代价。算法的核心在于寻找当前区间的最小值，并在此基础上递归处理，直至每个服务器都被检查完毕。
代码分析

输入部分: 首先读取服务器数量和高度。
递归函数 minCost:

基本条件: 处理了左边界大于右边界和只包含一个元素的特殊情况。
最小值计算: 遍历当前区间以找到最小的服务器高度。
行操作: 使用循环遍历区间，处理所有大于最小值的服务器，进行递归调用。

输出部分: 打印计算得到的最小代价。

代码
java
import java.util.Scanner;

public class Main {

static int[] h;

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
h = new int[n + 1];  // 1-based indexing
for (int i = 1; i <= n; i++) {
h[i] = sc.nextInt();
}
// 计算并输出最小操作代价
System.out.println(minCost(1, n));
}

// 计算区间 [l, r] 的最小代价
static int minCost(int l, int r) {
if (l > r) {
return 0;
}
if (l == r) {
return 2; // 单个服务器默认为单列操作
}

int minH = Integer.MAX_VALUE;
for (int i = l; i <= r; i++) {
minH = Math.min(minH, h[i]);
}

// 行操作
int cost1 = 1;
int i = l;
while (i <= r) {
if (h[i] > minH) {
int start = i;
while (i <= r && h[i] > minH) {
i++;
}
cost1 += minCost(start, i - 1);
} else {
i++;
}
}
return cost1;
}
}

python
import sys
# 递归深度设置为1000000
sys.setrecursionlimit(1000000)

n_and_rest = sys.stdin.read().split()
n = int(n_and_rest[0])
h = list(map(int, n_and_rest[1:n+1]))
h = [0] + h  # 1-based indexing

def min_cost(l, r):
if l > r:
# 空区间的操作代价为0
return 0
if l == r:
# 一个服务器的操作默认为单列操作
return 2
min_h = min(h[l:r+1])
# 操作1: 用行操作，找到<不是最小高度>的连续区间
cost1 = 1
i = l
while i <= r:
# 找到连续区间
if h[i] > min_h:
# 找到连续区间的起始位置
start = i
# 找到连续区间的终止位置
while i <= r and h[i] > min_h:
i += 1
# 递归计算连续区间的最小代价
cost1 += min_cost(start, i - 1)
else:
i += 1
return cost1

total_min_cost = min_cost(1, n)
print(total_min_cost)

cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>
using namespace std;

vector<int> h;  // 服务器高度数组

// 计算区间 [l, r] 的最小代价
int minCost(int l, int r) {
// 如果左边界大于右边界，返回0（无操作）
if (l > r) {
return 0;
}

// 如果区间只包含一个服务器，返回列操作的代价2
if (l == r) {
return 2;
}

// 找到当前区间的最小高度
int minH = INT_MAX;
for (int i = l; i <= r; i++) {
minH = min(minH, h[i]);  // 更新当前最小高度
}

// 进行行操作，初始代价为1秒
int cost1 = 1;
int i = l;  // 从左边界开始遍历
while (i <= r) {
// 如果当前服务器的高度大于最小值
if (h[i] > minH) {
int start = i;  // 记录当前区间的起始位置
// 向右移动，直到找到不再大于最小值的服务器
while (i <= r && h[i] > minH) {
i++;
}
// 对于当前找到的区间，递归计算其代价
cost1 += minCost(start, i - 1);
} else {
// 如果当前服务器高度不大于最小值，继续向右移动
i++;
}
}

return cost1;  // 返回当前区间的总代价
}

int main() {
int n;
cin >> n;  // 输入服务器数量
h.resize(n + 1);  // 调整数组大小以便使用1-based索引
for (int i = 1; i <= n; i++) {
cin >> h[i];  // 输入每个服务器的高度
}

cout << minCost(1, n) << endl;  // 输出从1到n的最小检查代价
return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-防护设备（P2298）
- 链接：https://codefun2000.com/p/P2298

> 页面标题：#P2298. 第2题-防护设备

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一个N×NN×NN×N大小的迷宫。初始状态下，配送员位于迷宫的左上角，他希望前往迷宫的右下角。配送员只能沿着上下左右四个方向移动，从每个格子移动到相邻格子所需要的时间是111个单位，他必须用最多KKK个(也可以少于KKK个)单位时间到达右下角格子。迷宫的每个格子都有辐射值，配送员必须穿着防护能力不低于相应辐射值的防护服，才能通过该格子。他希望知道，防护服的防护能力最少要达到多少，他才能顺利完成任务。注意:配送员需要通过迷宫的左上角和右下角，因此防护服的防护能力必须大于等于这两个格子的辐射值。
输入描述
前两行各包含一个正整数，分别对应NNN和KKK。
后NNN行各包含NNN整数，以空格分隔，表示地图上每个位置的辐射值。
2≤N≤100。K≥2N−22≤N≤100。K≥2N-22≤N≤100。K≥2N−2，以保证题目有解。所有辐射值
都是非负整数，绝对值不超过 10410^4104。
输出描述
一个整数，表示配送员穿着防护服的最低防护能力。
样例1
输入
2
2
1 3
2 1

输出
2

说明
配送员可以选择通过左下角(辐射值为2)的路线，耗费2单位时间。
样例2
输入
5
12
0 0 0 0 0
9 9 3 9 0
0 0 0 0 0
0 9 5 9 9
0 0 0 0 0

输出
3

说明
最优路线:往右222格，往下222格，往左222格，往下222格，往右444格，耗费121212单位时间，经过格子的最大辐射值为333。
另外，在地图不变的情况下，如果K=16K=16K=16，输出为000；如果K=888，输出为555。

▶️

#### TextSol

video solution

题面解释:
在一个 N×NN \times NN×N 的迷宫中，配送员从左上角出发，目标是到达右下角。他可以向上下左右四个方向移动，每移动到一个相邻的格子需要 111 个单位时间，且必须在最多 KKK 个单位时间内到达目的地。每个格子都有一个辐射值，配送员需要穿着防护能力不低于相应辐射值的防护服才能通过该格子。因此，配送员希望知道，所需的最低防护能力是多少，以确保能安全到达目的地并满足时间限制。输入包括两个正整数 NNN 和 KKK，接下来是一个 NNN 行的矩阵，表示每个格子的辐射值。输出为一个整数，表示配送员所需的最低防护能力。
思路：二分答案+bfs求最短路
性质:可以发现，防护值越大，越容易通过更多的位置，最短路越短。反之最短路越长。所以我们可以二分这个防护值，得到一个最小的防护值使得最短路 <= k.
做法：首先确定防护力的最小和最大可能值。使用二分查找在这个范围内寻找最小的防护力。对于每一个中间值，利用广度优先搜索（BFS）从左上角出发，只有通过辐射值不超过当前中值的格子，并计算移动步数是否不超过K。如果可以到达终点，则尝试更小的防护力；否则，增加防护力。最终找到满足条件的最小防护力值。
题解
在这个迷宫问题中，我们需要找到一个最低的防护能力，使得配送员能够在最多 KKK 步内从左上角移动到右下角。由于每个格子的辐射值决定了配送员的防护能力需求，我们可以使用二分查找来高效地确定这个最低防护能力。
具体步骤如下：

确定防护能力的范围：

防护能力的最小值为左上角和右下角的辐射值中的较大者。
防护能力的最大值为迷宫中所有格子辐射值的最大值。

二分查找：

在上述范围内进行二分查找，选择中间值 mid 作为当前的防护能力。
使用广度优先搜索（BFS）从左上角开始，检查能否在 KKK 步内到达右下角，并且所经过的每个格子的辐射值都不超过 mid。

判断能否到达：

如果 BFS 返回 true，说明在当前防护能力下可以到达终点，则尝试更小的防护能力。
如果 BFS 返回 false，说明当前防护能力不足，增加防护能力。

结束条件：

最终找到的 answer 即为所需的最低防护能力。

代码
java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.*;

public class Main {
static int n, k;
static int[][] a;

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
// 读取n和k
n = Integer.parseInt(br.readLine().trim());
k = Integer.parseInt(br.readLine().trim());
a = new int[n][n];
// 读取迷宫的辐射值
for (int i = 0; i < n; i++) {
String[] parts = br.readLine().trim().split("\\s+");
for (int j = 0; j < n; j++) {
a[i][j] = Integer.parseInt(parts[j]);
}
}

// 二分查找的初始边界
int left = Math.max(a[0][0], a[n-1][n-1]);
int right = Integer.MIN_VALUE;
for (int[] row : a) {
for (int val : row) {
if (val > right) right = val;
}
}

int answer = right;
while (left <= right) {
int mid = left + (right - left) / 2;
if (bfs(mid)) {
answer = mid;
right = mid - 1;
} else {
left = mid + 1;
}
}

// 输出结果
System.out.println(answer);
}

// BFS函数，检查是否可以在k步内到达终点，且所有经过的格子辐射值 ≤ val
private static boolean bfs(int val) {
// 检查起点和终点的辐射值是否符合
if (a[0][0] > val || a[n-1][n-1] > val) return false;

// 定义移动方向：右、左、下、上
int[] dx = {0, 0, 1, -1};
int[] dy = {1, -1, 0, 0};

// 距离数组，记录每个格子的最短步数
int[][] dist = new int[n][n];
for (int[] row : dist) Arrays.fill(row, -1);
dist[0][0] = 0;

// 使用队列进行BFS
Queue<int[]> queue = new LinkedList<>();
queue.offer(new int[]{0, 0});

while (!queue.isEmpty()) {
int[] current = queue.poll();
int x = current[0];
int y = current[1];
int steps = dist[x][y];

// 如果到达终点，检查步数是否 ≤ K
if (x == n-1 && y == n-1) {
return steps <= k;
}

// 遍历四个方向
for (int i = 0; i < 4; i++) {
int nx = x + dx[i];
int ny = y + dy[i];
// 检查边界
if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
// 检查辐射值和是否已访问
if (a[nx][ny] > val || dist[nx][ny] != -1) continue;
// 检查步数是否超过K
if (steps + 1 > k) continue;
// 更新步数并加入队列
dist[nx][ny] = steps + 1;
queue.offer(new int[]{nx, ny});
}
}

// 如果无法到达终点
return false;
}
}

python
from collections import deque

# 读取迷宫大小n和最大允许步数k
n = int(input())
k = int(input())

# 读取迷宫的辐射值矩阵a
a = [list(map(int, input().split())) for _ in range(n)]

def bfs(val):
"""
广度优先搜索函数，检查是否可以在k步内从起点到达终点，
且所有经过的格子的辐射值不超过val。
"""
# 如果起点或终点的辐射值超过val，无法通过
if a[0][0] > val or a[n-1][n-1] > val:
return False

# 初始化访问矩阵，记录是否访问过
visited = [[False]*n for _ in range(n)]
# 使用deque作为队列，存储当前坐标和步数
q = deque([(0, 0, 0)])  # (x, y, steps)
visited[0][0] = True  # 标记起点已访问

# 定义四个可能的移动方向：右、下、左、上
directions = [(0,1),(1,0),(0,-1),(-1,0)]

while q:
x, y, steps = q.popleft()  # 取出队首元素
# 如果到达终点，检查步数是否在允许范围内
if x == n-1 and y == n-1:
return steps <= k
# 遍历所有可能的移动方向
for dx, dy in directions:
nx, ny = x + dx, y + dy  # 计算新坐标
# 检查新坐标是否在迷宫范围内
if 0 <= nx < n and 0 <= ny < n:
# 检查新位置的辐射值是否不超过val，且未被访问过
if not visited[nx][ny] and a[nx][ny] <= val:
# 检查步数是否不会超过k
if steps + 1 > k:
continue
visited[nx][ny] = True  # 标记为已访问
q.append((nx, ny, steps + 1))  # 将新位置加入队列
# 如果无法到达终点
return False

# 确定二分查找的初始边界
left = max(a[0][0], a[n-1][n-1])  # 防护力的最低可能值
right = max(max(row) for row in a)  # 防护力的最高可能值

# 二分查找寻找最小的满足条件的防护力
while left <= right:
mid = (left + right) // 2  # 取中间值作为当前防护力
if bfs(mid):
right = mid - 1  # 尝试更小的防护力
else:
left = mid + 1  # 增加防护力

# 输出最终结果
print(left)

cpp
#include <bits/stdc++.h>
using namespace std;

int n, k;  // n: 迷宫大小，k: 最大步数
int a[100][100];  // 存储迷宫中每个格子的辐射值

// BFS函数，检查是否可以在k步内到达终点，且所有经过的格子辐射值 ≤ val
bool bfs(int val) {
// 检查起点和终点的辐射值是否符合
if (a[0][0] > val || a[n-1][n-1] > val) return false;

// 定义移动方向：右、左、下、上
int dx[4] = {0, 0, 1, -1};  // x方向的变化
int dy[4] = {1, -1, 0, 0};  // y方向的变化

// 距离数组，记录每个格子的最短步数
vector<vector<int>> dist(n, vector<int>(n, -1));  // 初始化为-1，表示未访问
dist[0][0] = 0;  // 起点的步数为0

// 使用队列进行BFS，存储x, y坐标
queue<pair<int, int>> q;
q.push({0, 0});  // 将起点入队

while (!q.empty()) {
pair<int, int> current = q.front(); q.pop();  // 获取队首元素
int x = current.first;  // 当前x坐标
int y = current.second;  // 当前y坐标
int steps = dist[x][y];  // 当前步数

// 如果到达终点，检查步数是否 ≤ K
if (x == n-1 && y == n-1) {
return steps <= k;  // 若步数小于等于K，返回true
}

// 遍历四个方向
for (int i = 0; i < 4; i++) {
int nx = x + dx[i];  // 计算新x坐标
int ny = y + dy[i];  // 计算新y坐标
// 检查边界
if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;  // 超出边界则跳过
// 检查辐射值和是否已访问
if (a[nx][ny] > val || dist[nx][ny] != -1) continue;  // 辐射值超标或已访问则跳过
// 检查步数是否超过K
if (steps + 1 > k) continue;  // 若步数超过K，则跳过
// 更新步数并加入队列
dist[nx][ny] = steps + 1;  // 更新当前格子的步数
q.push({nx, ny});  // 将新位置入队
}
}

// 如果无法到达终点
return false;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(0);
// 读取n和k
cin >> n >> k;
// 读取迷宫的辐射值
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
cin >> a[i][j];  // 输入辐射值
}
}

// 二分查找的初始边界
int left = max(a[0][0], a[n-1][n-1]);  // 最小防护能力
int right = INT32_MIN;  // 最大防护能力
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
right = max(right, a[i][j]);  // 找到迷宫中辐射值的最大值
}
}

int answer = right;  // 初始化答案为最大辐射值
while (left <= right) {
int mid = left + (right - left) / 2;  // 中间值
if (bfs(mid)) {  // 如果可以到达终点
answer = mid;  // 更新答案为当前mid
right = mid - 1;  // 尝试更小的防护能力
} else {
left = mid + 1;  // 增加防护能力
}
}

// 输出结果
cout << answer;  // 输出最低防护能力
return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-通讯录合并（P2289）
- 链接：https://codefun2000.com/p/P2289

> 页面标题：#P2289. 第2题-通讯录合并

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你有一个通讯录，这个通讯录里每个联系人都包含姓名和手机号，一个联系人可能有多个手机号。
如果发现两个联系人拥有相同的手机号，我们就认为他们是同一个人。
你的任务就是整理这个通讯录，将具有相同手机号的联系人合并为一个联系人，并返回合并后的通讯录列表。
注意：用例不保证具有相同手机号的联系人姓名肯定是相同的，如果合并的时候发现联系人姓名不同，那么以字典序小的为姓名。
输入描述
第一行表示通讯录的记录数量numnumnum，值的范围[1,10001, 10001,1000]。
从第二行开始，每一行代表一条联系人记录，每条录包括姓名和若干电话号码，电话号码的个数不超过101010（姓名由英文字母大小写组成，长度在1到10之间，电话号码由数字组成）。
之后的若干条记录代表人的记录（手机号个数111到101010位数字不重复）。同一条记录里的电话号码用空格隔开，电话号码的长度在[1,101,101,10]
输出描述
整理后的通讯录列表，其中如果两个联系人被识别为同一个人，则他们的电话号码合并。
输出联系人姓名和手机号码列表按ASCIIASCIIASCII码升序排序。
样例1
输入
4
kaka 10000000000 10000000001
tata 10000000020
kaka 10000000000 10000000002
tata 10000000010

输出
kaka 10000000000 10000000001 10000000002
tata 10000000010
tata 10000000020

说明
在这个通讯录中，第一个kaka和第二个kaka有相同的手机号“10000000000”，因此他们被视为同一个人。
因此kaka一共有三个号码并按ASCII码升级排序结果是10000000000 10000000001 10000000002。
第一个tata和第二个tata没有相同的号码，因此被视作两个人。
样例2
输入
3
kaka 10000000000 10000000001
kaka 10000000001 10000000002
kaka 10000000002 10000000003

输出
kaka 10000000000 10000000001 10000000002 10000000003

说明
在这个通讯录中，第一个kaka和第二个kaka有相同的手机号“10000000001”，第二个kaka和第三个kaka有相同的手机号“10000000002”，因此题目被视为同一个人。
因此kaka一共有四个号码并按ASCII码升级排序结果是10000000000 10000000001 10000000002 10000000003

▶️

#### TextSol

video solution

题面解释:
题目要求我们整理一个通讯录，通讯录中的每个联系人包含姓名和若干个手机号。如果两个联系人有相同的手机号，则认为他们是同一个人，需要将他们合并为一个联系人。在合并时，如果发现姓名不同，则保留字典序较小的姓名，所有手机号合并后按ASCII码升序排列。输入包括通讯录的记录数量numnumnum（范围为1到1000），后续每一行表示一个联系人，包含姓名和若干手机号（每个手机号不超过10个，长度为1到10位）。输出要求合并后的联系人列表，并按ASCII码顺序输出姓名及其手机号。
思路:并查集 + 哈希 + 自定义排序
1.基于共享电话号码的联系人属于同一组的思路，我们可以先使用哈希表将电话号码映射到对应的联系人编号列表上，然后使用并查集将共享同一电话号码的联系人合并到同一组。
2.对于并查集里的每个组（用该集合中的root节点编号表示），我们需要找到字典序最小的联系人姓名和该组内的联系人的所有电话号码。
我们可以使用一个哈希表来存储每个组（用该集合中的root节点编号表示）的最小字典序的姓名和所有电话号码。
3.最后，我们将每个组的姓名及电话号码（按字典序排序）存储到结果列表中，并对结果列表进行一个字典序排序。
1. 使用并查集解决分组问题

并查集是解决动态连通性问题的经典数据结构。在本题中，我们可以将每个联系人看作一个独立的节点，如果两个联系人有相同的电话号码，则将他们视为连通的，这样可以将拥有相同电话号码的联系人合并为同一组。

每个联系人初始时都是独立的，我们将每个联系人看作一个集合的根节点。之后，我们通过遍历所有联系人，找到具有相同手机号的联系人并进行合并操作。

2. 处理分组后的姓名和电话号码

每个分组中的联系人可能有不同的姓名。根据题目要求，我们需要保留字典序较小的姓名。
另外，分组后的联系人可能有多个电话号码，我们需要将这些电话号码合并，并按字典序进行排序。

3. 输出结果

最终输出要求按姓名的字典序进行排序。我们先将所有分组进行合并处理，随后对合并后的结果进行排序并输出。

代码解析

并查集部分：

findParent(x)：通过路径压缩查找某个节点的根节点。
unionGroups(x, y)：合并两个联系人组。

联系人信息处理部分：

通过getline()获取每一行输入并解析出姓名和电话号码。
将姓名存储到Contact结构体中的name字段，电话号码存储到set<string>中，利用set自动去重并保持顺序。

合并联系人部分：

通过并查集，将具有相同电话号码的联系人合并为一组。如果发现多个联系人共享同一组，则选择字典序较小的姓名，并合并所有电话号码。

排序输出部分：

使用sort()函数按姓名的字典序进行排序，姓名相同时按最小的电话号码排序。
最后输出结果，姓名和电话号码以空格分隔。

代码如下
python
# 输入联系人数量
num = int(input())

# 输入联系人姓名及其电话号码，并按行存储
arr = [input().split() for _ in range(num)]

# 创建一个字典，用于映射电话号码到对应的联系人编号列表
phone_to_id = {}

# 遍历每个联系人，将他们的电话号码加入映射字典中
for i in range(num):
for phone in arr[i][1:]:
if phone in phone_to_id:
# 如果电话号码已经存在，添加当前联系人编号到列表中
phone_to_id[phone].append(i)
else:
# 如果电话号码不存在，初始化一个列表并存储联系人编号
phone_to_id[phone] = [i]

# 初始化并查集，每个联系人最初是自己所在组的代表
fa = [i for i in range(num)]

# 查找函数（带路径压缩），查找当前联系人所在组的根节点
def find(x):
if x != fa[x]:
fa[x] = find(fa[x])  # 路径压缩
return fa[x]

# 合并两个组，将两个联系人的组合并到一起
def merge(x, y):
x = find(x)
y = find(y)
if x != y:
fa[x] = y  # 合并操作

# 判断两个联系人是否属于同一组
def same(x, y):
return find(x) == find(y)

# 遍历每个电话号码，将共享同一电话号码的联系人合并到同一组
for phone in phone_to_id:
first_id = phone_to_id[phone][0]  # 获取第一个联系人的编号
for i in range(1, len(phone_to_id[phone])):
merge(first_id, phone_to_id[phone][i])  # 合并其他拥有相同电话号码的联系人

# 创建字典，用于存储每个组的最小字典序的姓名和所有电话号码
root_to_name = {}
root_to_phones = {}

# 遍历每个联系人，按组进行合并处理
for i in range(num):
root = find(i)  # 查找联系人的根节点（代表组）

# 如果该组已经有一个名字，则比较字典序
if root in root_to_name:
# 更新为字典序更小的姓名
if arr[i][0] <= root_to_name[root]:
root_to_name[root] = arr[i][0]
else:
# 如果该组还没有姓名，则赋值当前联系人的姓名
root_to_name[root] = arr[i][0]

# 合并该联系人的所有电话号码到所在组
for phone in arr[i][1:]:
if root in root_to_phones:
# 如果该组已经有电话号码，则继续添加
root_to_phones[root].add(phone)
else:
# 如果该组没有电话号码，则初始化一个集合并添加
root_to_phones[root] = {phone}

# 结果存储列表
res = []

# 构建结果列表，包含每个组的姓名及电话号码（按字典序排序）
for root in root_to_name:
res.append([root_to_name[root]] + sorted(list(root_to_phones[root])))

# 对结果列表进行排序
res.sort()

# 输出合并后的联系人姓名及电话号码
for x in res:
print(' '.join(x))

java
import java.util.*;

public class Main {
static int[] parent;

public static int find(int x){
if(parent[x] != x){
parent[x] = find(parent[x]);
}
return parent[x];
}

public static void union(int x, int y){
parent[find(x)] = find(y);
}

static class Contact{
String name;//联系人姓名
Set<String> phoneNum;//联系人电话
int id;

Contact(String name,Set<String> phoneNum,int id){
this.name = name;
this.phoneNum = phoneNum;
this.id = id;
}
}
//合并后
static class MergedContact{
String name;
Set<String> phoneNum;

MergedContact(String name,Set<String> phoneNum){
this.name = name;
this.phoneNum = phoneNum;
}

String getMinPhoneNumber(){
return Collections.min(phoneNum);
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
//记录数量
int recordCount = sc.nextInt();
sc.nextLine();
//联系人列表
List<Contact> contacts = new ArrayList<>();
parent = new int[recordCount];

//初始化并查集
for(int i=0;i<recordCount;i++){
parent[i] = i;
}

Map<String,Integer> phoneToContactId = new HashMap<>();

for (int i = 0; i < recordCount; i++) {
String input = sc.nextLine().trim();
String[] tokens = input.trim().split("\\s+");
String name = tokens[0];

Set<String> phoneNumber = new HashSet<>();
for (int j = 1; j < tokens.length; j++) {
String phone = tokens[j];
phoneNumber.add(phone);
if (!phoneToContactId.containsKey(phone)) {
phoneToContactId.put(phone, i);
} else {
int otherId = phoneToContactId.get(phone);
union(i, otherId);
}
}
contacts.add(new Contact(name, phoneNumber, i));
}
//合并联系人
Map<Integer,MergedContact> rootIdToMergedContact = new HashMap<>();
for(int i=0;i<recordCount;i++){
int root  = find(i);
Contact contact = contacts.get(i);
if(!rootIdToMergedContact.containsKey(root)){
rootIdToMergedContact.put(root,new MergedContact(contact.name,new HashSet<>(contact.phoneNum)));
}else{
MergedContact mergedContact = rootIdToMergedContact.get(root);
//更新姓名
if(contact.name.compareTo(mergedContact.name) < 0){
mergedContact.name = contact.name;
}
mergedContact.phoneNum.addAll(contact.phoneNum);
}
}

List<MergedContact> mergedContacts = new ArrayList<>(rootIdToMergedContact.values());
for(MergedContact mc : mergedContacts){
//将电话号码集改为TreeSet进行排序
mc.phoneNum = new TreeSet<>(mc.phoneNum);
}

mergedContacts.sort((a,b)->{
int nameCompare = a.name.compareTo(b.name);
if(nameCompare!=0){
return nameCompare;
}else {
String minPhoneA = a.getMinPhoneNumber();
String minPhoneB = b.getMinPhoneNumber();
return minPhoneA.compareTo(minPhoneB);
}
});

for(MergedContact mc:mergedContacts){
StringBuilder sb = new StringBuilder();
sb.append(mc.name);

List<String> sortedphones = new ArrayList<>(mc.phoneNum);
Collections.sort(sortedphones);
for(String phone : sortedphones){
sb.append(" ").append(phone);
}
System.out.println(sb.toString());
}
sc.close();
}

}

cpp
#include <bits/stdc++.h>
using namespace std;

int parent[1005];  // 并查集数组，用于存储每个联系人的父节点
int visited[1005]; // 记录某个联系人组是否已经处理过
struct Contact {
int id;              // 联系人编号
string name;         // 联系人姓名
set<string> phones;  // 电话号码集合，使用set确保电话号码不重复且方便排序
} contacts[1005], mergedContacts[1005];
int mergedCount = 0;    // 合并后的联系人数量

// 并查集的查找操作，查找 x 的根节点
int findParent(int x) {
if (parent[x] == x) return x;  // 如果当前节点是根节点，直接返回
return parent[x] = findParent(parent[x]);  // 路径压缩优化，使查找效率更高
}

// 并查集的合并操作，将 x 和 y 所在的组合并
void unionGroups(int x, int y) {
int rootX = findParent(x);  // 查找 x 的根节点
int rootY = findParent(y);  // 查找 y 的根节点
if (rootX != rootY) {
parent[rootX] = rootY;  // 将 x 所在的组的根节点指向 y 所在组的根节点
}
}

// 比较函数，用于对联系人进行排序
bool compareContacts(Contact a, Contact b) {
if (a.name != b.name) return a.name < b.name;  // 如果姓名不同，按姓名的字典序排序
string minPhoneA = *(a.phones.begin());  // 获取 a 的最小电话号码
string minPhoneB = *(b.phones.begin());  // 获取 b 的最小电话号码
return minPhoneA < minPhoneB;  // 如果姓名相同，按最小电话号码的字典序排序
}

int main() {
int n;  // 联系人数
cin >> n;

// 初始化并查集，每个联系人初始时自己是自己的父节点
for (int i = 1; i <= n; i++) {
parent[i] = i;
}

string inputLine;
getline(cin, inputLine);  // 吃掉换行符，避免之后的输入错误
for (int i = 1; i <= n; i++) {
getline(cin, inputLine);  // 读取每一行的联系人信息
int length = inputLine.length();

Contact contact = {};  // 新建一个联系人对象
int wordCount = 0;
string word = "";

// 解析输入，将姓名和电话号码分割存储
for (int j = 0; j < length; j++) {
word += inputLine[j];  // 构建单词
if (j == length - 1 || inputLine[j + 1] == ' ') {
if (wordCount == 0) {
contact.name = word;  // 第一个单词为姓名
} else {
contact.phones.insert(word);  // 后续的为电话号码，存入集合
}
wordCount++;  // 单词计数
word = "";  // 重置单词
j++;  // 跳过空格
}
}

contacts[i] = contact;  // 存储联系人信息

// 合并当前联系人与前面所有联系人，检查是否有相同的电话号码
for (int j = 1; j < i; j++) {
for (const string &phoneJ : contacts[j].phones) {
for (const string &phoneI : contact.phones) {
if (phoneJ == phoneI) {
unionGroups(j, i);  // 如果有相同号码则合并到同一组
}
}
}
}
}

// 将联系人进行合并
for (int i = 1; i <= n; i++) {
int root = findParent(i);  // 找到联系人所在的组
if (visited[root] == 0) {  // 如果该组未处理过
mergedContacts[++mergedCount] = contacts[i];  // 新组加入联系人
visited[root] = mergedCount;  // 标记该组已处理
} else {
// 如果该组已存在联系人，则合并信息
if (contacts[i].name < mergedContacts[visited[root]].name) {
mergedContacts[visited[root]].name = contacts[i].name;  // 更新为字典序较小的姓名
}
// 合并电话号码
for (const string &phone : contacts[i].phones) {
mergedContacts[visited[root]].phones.insert(phone);
}
}
}

// 按规则排序联系人
sort(mergedContacts + 1, mergedContacts + mergedCount + 1, compareContacts);

// 输出结果
for (int i = 1; i <= mergedCount; i++) {
cout << mergedContacts[i].name << ' ';
for (const string &phone : mergedContacts[i].phones) {
cout << phone << ' ';
}
cout << '\n';
}

return 0;
}

---

### 第2题-俄罗斯方块（P2292）
- 链接：https://codefun2000.com/p/P2292

> 页面标题：#P2292. 第2题-俄罗斯方块

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在俄罗斯方块游戏中，只有下面111种大方块，由四个正方形小方块组成。现在，请计算在给定网格大小的情况下，最多可以放置多少个大方块。
具体规则如下:
111、网格为正方形网络。
222、方块不能重叠。
333、方块不能超出网格的边界。
444、网格中部分位置不能放置方块。

输入描述
n kn\ kn k
y1 x1y_1\ x_1 y1​ x1​
y2 x2y_2\ x_2y2​ x2​
...
yk xky_k\ x_kyk​ xk​
表示边长为nnn的正方形网格，有kkk个位置不能放置方块，接下来kkk行坐标对，yyy表示自上向下的第几行，xxx表示自左向右的第几列(坐标从000开始编号，左上角为0 00\ 00 0)。
nnn的范围: [1,81,81,8]
kkk的范围:[0,640,640,64]
x、yx、yx、y的范围: [0,n0,n0,n)
输出描述
最多能放下多少大方块。
样例1
输入
2 0

输出
1

说明
只能放下111个
样例2
输入
4 3
1 0
1 3
2 1

输出
2

说明
最多放222个大方块，如下图

样例3
输入
3 3
0 1
1 2
2 0

输出
0

说明
没有位置可以放置方块。

▶️

#### TextSol

video solution

题面解释:
在一个n×nn \times nn×n的网格游戏中，可以放置由4个小方块组成的大方块（类似俄罗斯方块）。网格中有kkk个位置不能放置方块，这些位置通过坐标给出。我们需要计算在不重叠、不超出边界的情况下，最多可以放置多少个大方块。输入的第一行包含nnn和kkk，接下来有kkk行给出不能放置方块的坐标对(y,x)(y, x)(y,x)。输出结果为最多能放下的大方块数量。举例来说，对于输入2 0，输出为1；对于输入4 3，输出为2；而输入3 3则输出为0。
思路:DFS暴力回溯
本题非常类似于:LeetCode 1240. 铺瓷砖。
采用深度优先搜索（DFS）和回溯法来解决大方块的摆放问题。我们通过递归遍历每个位置，判断是否可以放置一个 2x2 的大方块。
分两种情况:1.如果可以放置，就标记位置并继续探索下一个位置；如果不行，直接跳过。每次成功放置时更新最大值，最后回溯到上一步，取消放置状态。
题解
在本题中，我们需要在一个 n×nn \times nn×n 的网格中放置尽可能多的 2×22 \times 22×2 大方块，网格中有一些位置被标记为障碍物，不能放置大方块。为了解决这个问题，我们使用了深度优先搜索（DFS）和回溯法的策略。
具体步骤如下：

递归遍历网格：从左上角开始，逐行逐列地检查每个位置是否可以放置一个 2×22 \times 22×2 的大方块。
判断放置条件：在检查当前格子时，我们需要确保这个 2×22 \times 22×2 的区域内没有障碍物且没有超出网格边界。
回溯：如果能够放置大方块，就将这4个位置标记为已占用，继续递归搜索下一个位置；如果不行，则跳过当前格子，继续尝试下一个位置。搜索完成后，恢复当前格子的状态，准备回溯到上一个状态。
更新结果：每次成功放置一个大方块时，更新最大放置数量。

通过这种方法，我们可以有效地探索所有可能的放置方案，最终得到最多可以放置的大方块数量。
代码
java
import java.util.Scanner;

public class Main {
static int n, k;
static int[][] vis = new int[105][105];
static int[] dx = {-1, -1, 0, 0}; // 移动方向数组
static int[] dy = {-1, 0, -1, 0}; // 移动方向数组

// 深度优先搜索
static int dfs(int x, int y) {
if (x >= n) return 0; // 递归边界

boolean canPlace = true;
for (int i = 0; i < 4; i++) {
if (vis[x + dx[i]][y + dy[i]] == 1) canPlace = false;
}

int res = 0;
if (canPlace) {
// 标记格子为已访问
for (int i = 0; i < 4; i++) {
vis[x + dx[i]][y + dy[i]] = 1;
}

if (y < n - 1)
res = Math.max(res, dfs(x, y + 1) + 1);
else
res = Math.max(res, dfs(x + 1, 1) + 1);

// 回溯，重置访问状态
for (int i = 0; i < 4; i++) {
vis[x + dx[i]][y + dy[i]] = 0;
}
}

// 继续尝试下一个位置
if (y < n - 1)
res = Math.max(res, dfs(x, y + 1));
else
res = Math.max(res, dfs(x + 1, 1));

return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
k = sc.nextInt();

for (int i = 1; i <= k; i++) {
int x = sc.nextInt();
int y = sc.nextInt();
vis[x][y] = 1; // 读取障碍物的位置
}

System.out.println(dfs(1, 1)); // 从 (1, 1) 开始搜索
sc.close();
}
}

python
n, k = map(int, input().split())
vis = [[0] * 105 for _ in range(105)]
dx = [-1, -1, 0, 0]  # 移动方向数组
dy = [-1, 0, -1, 0]  # 移动方向数组
# 深度优先搜索
def dfs(x, y):
if x >= n:
return 0  # 递归边界
can_place = True
for i in range(4):
if vis[x + dx[i]][y + dy[i]] == 1:
can_place = False
res = 0
if can_place:
# 标记格子为已访问
for i in range(4):
vis[x + dx[i]][y + dy[i]] = 1
if y < n - 1:
res = max(res, dfs(x, y + 1) + 1)
else:
res = max(res, dfs(x + 1, 1) + 1)
# 回溯，重置访问状态
for i in range(4):
vis[x + dx[i]][y + dy[i]] = 0
# 继续尝试下一个位置
if y < n - 1:
res = max(res, dfs(x, y + 1))
else:
res = max(res, dfs(x + 1, 1))
return res
# 读取障碍物的位置
for _ in range(k):
x, y = map(int, input().split())
vis[x][y] = 1
# 从 (1, 1) 开始搜索
print(dfs(1, 1))

cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long // 定义int为long long类型，避免数据溢出

int n, k; // 网格的边长和障碍物的数量
int vis[105][105]; // 访问状态数组，记录哪些格子已被占用
int dx[4] = {-1, -1, 0, 0}; // 2x2方块的行偏移量
int dy[4] = {-1, 0, -1, 0}; // 2x2方块的列偏移量

// 深度优先搜索函数
int dfs(int x, int y) {
if (x >= n) return 0; // 递归边界：如果行数超出网格，返回0

// 检查当前位置是否可以放置大方块
int canPlace = 1; // 标记当前方块是否可以放置
for (int i = 0; i < 4; i++) {
if (vis[x + dx[i]][y + dy[i]] == 1) canPlace = 0; // 检查四个小方块位置是否已被占用
}

int res = 0; // 记录当前状态下可以放置的大方块数量
if (canPlace == 1) {
// 如果可以放置，标记这4个格子为已占用
for (int i = 0; i < 4; i++) {
vis[x + dx[i]][y + dy[i]] = 1;
}

// 递归继续探索下一个位置
if (y < n - 1)
res = max(res, dfs(x, y + 1) + 1); // 尝试向右移动
else
res = max(res, dfs(x + 1, 0) + 1); // 尝试向下移动

// 回溯，重置访问状态
for (int i = 0; i < 4; i++) {
vis[x + dx[i]][y + dy[i]] = 0;
}
}

// 继续尝试下一个位置（不放置当前方块）
if (y < n - 1)
res = max(res, dfs(x, y + 1)); // 尝试向右移动
else
res = max(res, dfs(x + 1, 0)); // 尝试向下移动

return res; // 返回最大可以放置的大方块数量
}

signed main() {
cin >> n >> k; // 输入网格的边长和障碍物数量
for (int i = 1; i <= k; i++) {
int x, y;
cin >> x >> y; // 读取每个障碍物的位置
vis[x][y] = 1; // 标记障碍物的位置为已占用
}
cout << dfs(0, 0); // 从 (0, 0) 开始进行搜索
return 0; // 程序结束
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-最好的通勤体验（P2286）
- 链接：https://codefun2000.com/p/P2286

> 页面标题：#P2286. 第2题-最好的通勤体验

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一名环保爱好者，每天选择乘坐公交车上班。不同线路上的公交车会在规定的路线上单向循环行驶，例如708708708路公交的路线为[2,5,82,5,82,5,8]，那么公交车会按照2−>5−>8−>2−>5−>8−>...2->5->8->2->5->8->...2−>5−>8−>2−>5−>8−>....的路线循环行驶，其中路线中的数字为公交站台编号。
小明每天上班会从离他家里最近的公交站台上车，然后在他最喜欢的早餐店所在的站台下车买好早餐然后再上车，最后在离公司最近的公交站台下车，允许不限次数地在中途下车换乘其他路线的公交。
现在分别给定小明上车、早餐店、下车的公交站台编号，请帮他选择最佳的乘车路线，使乘坐的公交车总数最少(如果在同111条公交路线中下车再上车，仍然视为乘坐的同一辆车)，从而获得最好的通勤体验。
输入描述
111.第一行有333个数字，分别表示上车的公交站台编号、早餐店的公交站台编号、下车公交站台编号，依次用空格隔开。
222.第二行表示公交路线数量，后续的每一行中第111个数字代表该路线的总站台数，剩余的数字表示每条公交路线经过的站点编号，所有数字用空格隔开。
333.公交路线数量范围在[1,5001,5001,500]。
444.公交站台的编号范围在[1,10000001,10000001,1000000]。
555.每条公交路线经过的站台数量范围在[2,15002,15002,1500]，路线中的站台编号按升序顺序排序，且每条路线中不包含重复的站台。
666.起点站台、购买早餐的站点、终点站台不重复。
输出描述
乘坐的公交路线总数，如果没有匹配的路线请返回−1-1−1
样例1
输入
1 3 5
4
3 1 2 6
3 2 3 7
3 5 6 8
2 5 7

输出
3

说明
先乘坐第111条公交路线的车，在第222个站点下车转第222条路线的公交车，然后再乘坐第222条公交路线的车在站点333下车买早餐，然后重新乘坐第222条公交路线达到站点777下车转第444条公交路线，最后达到站点555，经过的公交路线为1−>2−>41->2->41−>2−>4，所以结果为333。虽然乘坐第111条公交路线和第333条公交路线也能达到站点555，但是该路线没法购买早餐。
样例2
输入
1 3 4
2
3 1 2 4
3 3 5 6

输出
-1

说明
小王只能乘坐第111条公交路线上车，但是无法通过该路线的站台换乘到第222条公交路线购买早餐，没有匹配的路线，返回−1-1−1。
样例3
输入
4 19 28
5
5 3 4 7 8 10
6 10 12 16 19 27 28
4 5 7 11 17
4 17 19 22 23
3 23 27 28

输出
2

说明
小王可以选择1−>21->21−>2的公交路线，乘坐的公交车总数为222，也可以选择1−>3−>4−>51->3->4->51−>3−>4−>5的公交路线，乘坐的公交车总数为444，因此最佳的乘车路线是1−>21->21−>2，结果为222。

▶️

#### TextSol

video solution

类似题目推荐
LeetCode 815. 公交路线
题面解释
题目描述了小塔作为一名环保爱好者，如何选择公交车上班的最佳路线。给定小塔的上车站台、购买早餐的站台以及下车站台的编号，接着提供公交路线的信息，包括每条公交路线经过的站台编号。任务是帮助小塔选择乘坐公交车的总数最少的路线，如果无法找到合适的公交路线，则返回-1。输入包括三行，第一行是上车、早餐店和下车的站台编号，第二行是公交路线的数量，后续每行提供一条公交路线的信息。输出为小塔所需乘坐的公交车总数。
关键
1.每个公交线路最多访问一次&题目要求的是线路换乘次数，而不是坐的站点的次数 <=>对公交线路进行bfs <=> dist[i]代表从某起点到第i个公交线路的最短路径
2.无向图里上->早餐->下 等价 早餐->上 + 早餐 + 下
3.计算任意两个站点x,y之间的最短最少换乘 dist(x,y):
从所有拥有x的公交线路出发,多源bfs,计算到达拥有y的站点的任意公交线路的最小值
做法:
利用3计算 dist(早,上) + dist(早,下)
题解
本题要求我们帮助小塔选择最佳的公交车路线，以最小化乘坐公交车的次数，具体步骤如下：
1. 问题分析
小塔需要完成三段旅程：从起点公交站到早餐店，再从早餐店到终点公交站。由于允许在任意公交站换乘，实际问题可以转化为计算从起点到早餐店和从早餐店到终点的最短换乘次数。
2. 输入输出格式

输入：第一行包含三个整数，分别是起点公交站台编号、早餐店公交站台编号和终点公交站台编号。第二行是公交路线的数量，后续每行描述每条公交路线的站点编号。
输出：如果存在合适的公交路线，输出最小的乘坐公交车次数；否则输出 -1。

3. 数据结构

使用vector<vector<int>> bus_routes来存储每条公交线路的站点。
使用unordered_map<int, vector<int>> bus_trans来记录每个站点所经过的公交路线，方便后续查找。

4. 算法实现
为了计算两站点之间的最短换乘次数，我们使用广度优先搜索（BFS）进行多源搜索：

BFS函数：从某一条公交线路出发，遍历所有经过的站点，获取到其他公交线路的最短距离。
换乘次数计算：

从早餐店出发，计算能够到达的公交线路。
遍历所有从起点和终点出发的公交线路，计算最小换乘次数。
将起点到早餐店的换乘次数与早餐店到终点的换乘次数相加，得到总的换乘次数。

5. 特殊情况处理
如果在计算过程中发现无法从起点或终点到达早餐店，则需返回 -1。
代码如下
cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
#include <algorithm>

using namespace std;

// 定义一个函数来进行广度优先搜索
vector<int> bfs(const vector<vector<int>>& bus_routes, const unordered_map<int, vector<int>>& bus_trans, const vector<int>& start_routes) {
int n = bus_routes.size();
vector<int> dist(n, -1);  // 距离数组，初始值为-1，表示未访问的公交线路
queue<int> q;  // 用于广度优先搜索的队列

// 将起始公交线路编号加入队列并设置其距离为0
for (int id : start_routes) {
q.push(id);
dist[id] = 0;
}

// 开始广度优先搜索
while (!q.empty()) {
int cur = q.front(); q.pop();  // 取出队列最前面的公交线路

// 枚举该公交线路的所有站点
for (int port : bus_routes[cur]) {
// 查看每个站点所经过的其他公交线路
for (int bus_id : bus_trans.at(port)) {
// 如果该公交线路没有被访问过
if (dist[bus_id] == -1) {
// 记录该公交线路的距离为当前距离 + 1
dist[bus_id] = dist[cur] + 1;
q.push(bus_id);  // 将该公交线路加入队列
}
}
}
}

return dist;
}

int main() {
// 输入起点、早餐店、终点的站点 id
int start_id, mid_id, end_id;
cin >> start_id >> mid_id >> end_id;

// 输入公交线路数量
int n;
cin >> n;

// 初始化公交路线，每个公交线路对应一条列表，记录站点
vector<vector<int>> bus_routes(n);
for (int i = 0; i < n; i++) {
int m;
cin >> m;  // 读取站点数量
bus_routes[i].resize(m);
for (int j = 0; j < m; j++) {
cin >> bus_routes[i][j];  // 读取每个站点
}
}

// 创建一个哈希表，记录每个站点所经过的公交路线
unordered_map<int, vector<int>> bus_trans;
for (int i = 0; i < n; i++) {
for (int x : bus_routes[i]) {
bus_trans[x].push_back(i);  // 将公交路线编号添加到该站点的依赖中
}
}

long long ans = 10e15;  // 初始化答案为一个大的值

// 从早餐店出发，计算到各个公交线路的最短距离
for (int bus_id : bus_trans[mid_id]) {
vector<int> dist = bfs(bus_routes, bus_trans, {bus_id});  // BFS 搜索从早餐店出发的最短路径

// 计算从起点到早餐店的最短路径
long long min_dist_to_start = 10e15;  // 初始化距离为很大的值
for (int bus_id : bus_trans[start_id]) {
// 如果存在从起点的站点所在公交线路到达早餐店的路径
if (dist[bus_id] != -1) {
min_dist_to_start = min(min_dist_to_start, (long long)dist[bus_id]);
}
}

// 计算从终点到早餐店的最短路径
long long min_dist_to_end = 10e15;  // 初始化距离为很大的值
for (int bus_id : bus_trans[end_id]) {
// 如果存在从终点的站点所在公交线路到达早餐店的路径
if (dist[bus_id] != -1) {
min_dist_to_end = min(min_dist_to_end, (long long)dist[bus_id]);
}
}

// 如果起点或终点无法到达早餐店，输出-1
if (min_dist_to_start == 10e15 || min_dist_to_end == 10e15) {
continue;
} else {
ans = min(ans, min_dist_to_start + min_dist_to_end + 1);  // 更新答案
}
}

// 输出最终答案
if (ans == 10e15) {
cout << -1 << endl;  // 如果没有找到合适的路径
} else {
cout << ans << endl;  // 输出最短路径
}

return 0;
}

Python
from collections import defaultdict

# 输入起点、早餐店、终点的站点id
start_id, mid_id, end_id = map(int, input().split())

# 输入公交线路数量
n = int(input())

# 初始化公交路线，每个公交线路对应一条列表，记录站点
bus_routes = [[] for _ in range(n)]
for i in range(n):
# 读取每条公交线路的站点，并忽略第一项（该项为站点数量）
bus_routes[i] = list(map(int, input().split()))[1:]

# 创建一个字典，记录每个站点所经过的公交路线，字典值为公交路线编号列表
bus_trans = defaultdict(list)
for i in range(n):
for x in bus_routes[i]:
bus_trans[x].append(i)

# 定义广度优先搜索函数，计算从指定的公交线路出发到达其他公交线路的最短距离
def bfs(start_routes):
q = []  # 用于广度优先搜索的队列
dist = [-1 for _ in range(n)]  # 距离数组，初始值为-1，表示未访问的公交线路
# 将起始公交线路编号加入队列并设置其距离为0
for id in start_routes:
q.append(id)
dist[id] = 0
# 开始广度优先搜索
while q:
cur = q.pop(0)  # 取出队列最前面的公交线路
# 枚举该公交线路的所有站点
for port in bus_routes[cur]:
# 查看每个站点所经过的其他公交线路
for bus_id in bus_trans[port]:
# 如果该公交线路没有被访问过
if dist[bus_id] == -1:
# 记录该公交线路的距离为当前距离+1
dist[bus_id] = dist[cur] + 1
q.append(bus_id)  # 将该公交线路加入队列
return dist

ans = 10**15
# 从早餐店出发，计算到各个公交线路的最短距离
for bus_id in bus_trans[mid_id]:
dist = bfs([bus_id])
# 计算从起点到早餐店的最短路径
min_dist_to_start = 10**15  # 初始化距离为很大的值
for bus_id in bus_trans[start_id]:
# 如果存在从起点的站点所在公交线路到达早餐店的路径
if dist[bus_id] != -1:
min_dist_to_start = min(min_dist_to_start, dist[bus_id])

# 计算从终点到早餐店的最短路径
min_dist_to_end = 10**15  # 初始化距离为很大的值
for bus_id in bus_trans[end_id]:
# 如果存在从终点的站点所在公交线路到达早餐店的路径
if dist[bus_id] != -1:
min_dist_to_end = min(min_dist_to_end, dist[bus_id])
# 如果起点或终点无法到达早餐店，输出-1
if min_dist_to_start == 10**15 or min_dist_to_end == 10**15:
continue
else:
ans = min(ans , min_dist_to_start + min_dist_to_end + 1)

if ans == 10**15:
print(-1)
else:
print(ans)

Java
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int upNo = in.nextInt(), midNo = in.nextInt(), downNo= in.nextInt( );
List<List<Integer>> busList = new ArrayList<>();
busList.add(null);
Map<Integer, List<Integer>> routeList = new HashMap<>();
int busNo = in.nextInt();
in.nextLine();
for (int i = 1;i <= busNo;i++){
int stopNo = in.nextInt();
List<Integer> list = new ArrayList<>();
for (int j = 0;j < stopNo;j++) {
int stop = in.nextInt();
list.add(stop);
List<Integer> route = routeList.get(stop);
if (route == null) {
route = new ArrayList<>();
}
route.add(i);
routeList.put(stop, route);
}
busList.add(list);
}

boolean[] vis = new boolean[busNo+1];
Deque<Integer> queue = new ArrayDeque<>();
//将所有早餐店站点的公交车加入队列，注意该站点可能没有公交车
List<Integer> midRoute = routeList.get(midNo);
if (midRoute != null) {
queue.addAll(midRoute);
} else {
System.out.println(-1);
return;
}
int dist = 1, upDist=Integer.MAX_VALUE, downDist= Integer.MAX_VALUE;
while(!queue.isEmpty()){
//每次将队列中的所有公交车出队，然后将这些公交车可以到达的站点的公交车加入队列
//在访问公交车可以到达的站点时，如果找到上车点和下车点，直接返回
int size = queue.size();
for (int i = 0; i < size; i++) {
int bus = queue.poll();
for (int stop : busList.get(bus)) {
if (stop == upNo) {
upDist = Math.min(upDist,dist);
if (downDist != Integer.MAX_VALUE) {
System.out.println(upDist + downDist - 1);
return;
}
}
if (stop == downNo) {
downDist = Math.min(downDist,dist);
if (upDist != Integer.MAX_VALUE) {
System.out.println(upDist + downDist - 1);
return;
}
}
for (int nextBus : routeList.get(stop)) {
if (!vis[nextBus]) {
vis[nextBus] = true;
queue.add(nextBus);
}
}
}
}
dist++;
}
if (upDist == Integer.MAX_VALUE || downDist == Integer.MAX_VALUE) {
System.out.println(-1);
} else {
System.out.println(upDist + downDist - 1);
}

}

}

---

### 第2题-统计最少媒体包发送源个数（P2280）
- 链接：https://codefun2000.com/p/P2280

> 页面标题：#P2280. 第2题-统计最少媒体包发送源个数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某媒体处理服务负责接收来自多个媒体发送源的媒体包，并根据收到的媒体包进行媒体渲染处理。当前有这样一个需求：给定收到的媒体包序列号列表，计算发送该媒体包的最少发送源个数。
约束：
1.任意媒体包序列号seqs[i]seqs[i]seqs[i]满足：0≤seqs[i]≤655350≤seqs[i]≤655350≤seqs[i]≤65535
2.网络上没有重传媒体包，即：同一个发送源发送的媒体包序列号不会重复，且序列号每次加111(不考虑回绕问题，655356553565535是发送源发送的最后一个媒体包序列号)；如果收到的，媒体包序列号不满足该规则，说明这些媒体包必然来自于多个发送源。
333.  1≤seqs.length()≤1051≤seqs.length()≤10^51≤seqs.length()≤105
输入描述
第一行：seqsseqsseqs列表长度nnn
第二行：seqsseqsseqs列表元素，元素之间通过空格隔开
输出描述
最少媒体包发送源个数
样例1
输入
11
1 2 3 4 5 6 7 8 9 10 10

输出
2

说明
媒体包发送源111:1 2 3 4 5 6 7 8 9 101\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 101 2 3 4 5 6 7 8 9 10
媒体包发送源222:101010
媒体发送源个数为222，因此输出222
样例2
输入
5
65535 0 1 2 3

输出
2

说明
媒体包发送源111:655356553565535
媒体包发送源222:0 1 2 30\ 1\ 2\ 30 1 2 3
媒体发送源个数为222，因此输出222
样例3
输入
18
1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10

输出
2

说明
媒体包发送源111:1 2 3 4 5 6 7 8 9 101\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 101 2 3 4 5 6 7 8 9 10
媒体包发送源222:2 3 4 5 6 7 8 92\ 3\ 4\ 5\ 6\ 7\ 8\ 92 3 4 5 6 7 8 9
媒体发送源个数为222，因此输出222
样例4
输入
8
2 2 2 2 1 1 1 1

输出
8

▶️

#### TextSol

video solution

题目大意
给定一个长度为 n 的序列，问如何将该序列归类为最少的连续递增序列。连续递增序列满足：对于序列中的任意 i，满足 a[i] = a[i-1] + 1。
注意原序列不能被任意打乱
题解：贪心 + 哈希表
思路分析：
题目要求我们计算最少的发送源个数，基于题目的描述，发送源的数据包序列号是连续递增的。如果数据包序列号出现不连续或重复的情况，那么这些数据包必然来自于多个发送源。我们的目标是通过扫描一遍输入序列号，计算出最少的发送源个数。
我们可以使用贪心算法和哈希表来高效解决这个问题。
具体思路：
我们维护一个哈希表 cnt，cnt[x] 代表当前有多少个以序列号 x 结尾的递增子序列。然后逐个处理输入序列号 a[i]。
对于每个序列号 x，有以下两种情况：

x 前面没有以 x-1 结尾的序列：
如果哈希表中 cnt[x-1] 的值为 0，说明当前序列号 x 需要作为新的递增子序列的开头，因此我们需要新开一个发送源，ans 加 1。

x 前面有以 x-1 结尾的序列：
如果 cnt[x-1] 的值大于 0，说明有一个子序列是以 x-1 结尾的，我们可以将 x 加入这个子序列，这样并不需要增加新的发送源。同时我们更新哈希表，将 cnt[x-1] 减 1，表示该子序列不再以 x-1 结尾，而是改为以 x 结尾，所以 cnt[x] 需要加 1。

通过以上两步的操作，我们可以在一次遍历中动态地计算出最少的发送源个数。
时间复杂度分析：

遍历数组的时间复杂度为 O(n)O(n)O(n)，其中 nnn 是数组的长度。
使用哈希表 cnt 进行查询和更新的时间复杂度为均摊 O(1)O(1)O(1)。

因此整体时间复杂度为 O(n)O(n)O(n)，可以在输入数据范围较大的情况下高效处理问题。
代码
Python 实现
from collections import defaultdict

# 输入处理
n = int(input())  # 序列长度
a = list(map(int, input().split()))  # 序列

cnt = defaultdict(int)  # 记录以某个数结尾的递增序列的数量
ans = 0  # 记录最少的连续递增序列的数量

# 遍历序列
for x in a:
# 如果没有以x-1结尾的递增序列，那么x需要开辟一个新的递增序列
if cnt[x - 1] == 0:
ans += 1  # 答案增加一个新的序列
else:
# 如果有以x-1结尾的递增序列，那么将x加入该序列
cnt[x - 1] -= 1  # 以x-1结尾的序列少一个
cnt[x] += 1  # 更新以x结尾的序列数量

# 输出结果
print(ans)

Java 实现
import java.util.HashMap;
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
// 输入处理
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
int[] a = new int[n];
for (int i = 0; i < n; i++) {
a[i] = scanner.nextInt();
}

// 使用HashMap来存储 cnt[x]，即以x结尾的递增序列的数量
HashMap<Integer, Integer> cnt = new HashMap<>();
int ans = 0; // 记录最少的连续递增序列的数量

for (int x : a) {
// 如果没有以x-1结尾的序列，则x需要开辟一个新的序列
if (!cnt.containsKey(x - 1) || cnt.get(x - 1) == 0) {
ans++;
} else {
// 如果有以x-1结尾的序列，则将x加入该序列
cnt.put(x - 1, cnt.get(x - 1) - 1);
}
// 更新以x结尾的序列数量
cnt.put(x, cnt.getOrDefault(x, 0) + 1);
}

// 输出结果
System.out.println(ans);
}
}

C++ 实现
#include <iostream>
#include <unordered_map>
using namespace std;

int main() {
int n;
// 输入处理
cin >> n;
int a[n];
for (int i = 0; i < n; i++) {
cin >> a[i];
}

// 使用unordered_map来存储cnt[x]，即以x结尾的递增序列的数量
unordered_map<int, int> cnt;
int ans = 0; // 记录最少的连续递增序列的数量

for (int i = 0; i < n; i++) {
int x = a[i];
// 如果没有以x-1结尾的序列，则x需要开辟一个新的序列
if (cnt[x - 1] == 0) {
ans++;
} else {
// 如果有以x-1结尾的序列，则将x加入该序列
cnt[x - 1]--;
}
// 更新以x结尾的序列数量
cnt[x]++;
}

// 输出结果
cout << ans << endl;

return 0;
}

致歉
注意本题的相对顺序是无法改变的，详情请见小明补充的样例4

---

### 第2题-软件安装工具（P2283）
- 链接：https://codefun2000.com/p/P2283

> 页面标题：#P2283. 第2题-软件安装工具

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一个比较复杂的软件系统需要部署到客户提供的服务器上。该软件系统的安装过程非常繁琐，为了降低操作成本，需要开发一个工具实现自动化部署。
软件的安装过程可以分成若干个小步骤，某些步骤间存在依赖关系，被依赖的步骤必须先执行完，才能执行后续的安装步骤。满足依赖条件的多个步骤可以并行执行。
请你开发一个调度程序，以最短的时间完成软件的部署。
输入描述
第一行:总步骤数N(0<N<=10000)N(0<N<=10000)N(0<N<=10000)
第二行:NNN个以空格分隔的整数，代表每个步骤所需的时间。该行所有整数之和不大于int32int32int32
第三行开始的NNN行:表示每个步骤所依赖的其它步骤的编号(编号从111开始，行号减222表示步骤的编号)，如果依赖多个步骤，用空格分隔。−1-1−1表示无依赖
测试用例确保各个安装步骤不会出现循环依赖。
输出描述
111个数字，代表最短执行时间。
样例1
输入
4
6 2 1 2
-1
-1
1
3

输出
9

说明
一共444个步骤。
每个步骤所需的时间分别为6 2 1 26\ 2\ 1\ 26 2 1 2
步骤111和步骤222无依赖，可并发执行;步骤333依赖步骤111;步骤444依赖步骤
总的最小执行时间为6+1+2=96+1+2=96+1+2=9

样例2
输入
4
1 2 3 4
2 3
3
-1
1

输出
10

说明
步骤111依赖步骤222和333，步骤222依赖步骤333，步骤333无依赖，步骤444依赖步骤111
执行顺序为 3−−>2−−>1−−>43 --> 2 --> 1--> 43−−>2−−>1−−>4，最小执行时间为3+2+1+4=103+2+1+4=103+2+1+4=10

▶️

#### TextSol

video solution

题面解释:
题目要求开发一个自动化部署调度程序，软件安装分为多个步骤，某些步骤有依赖关系，必须先完成前置步骤才能执行后续步骤，且无依赖的步骤可以并行执行。输入包括步骤总数、每个步骤所需的时间以及每个步骤的依赖关系，输出为完成所有步骤的最短时间。例如，输入步骤总数为4，每个步骤的执行时间为6, 2, 1, 2，依赖关系为某些步骤没有依赖，某些步骤有依赖，输出最短完成时间为9。
思路:拓扑排序(BFS)
该问题本质是有向无环图（DAG）中的拓扑排序问题，要求根据步骤依赖关系调度任务，计算并行执行的最短完成时间。
通过拓扑排序，使用队列依次处理无依赖的节点，更新后续步骤的最早开始时间，累积计算每个步骤完成的最短总时间，最后输出最大值。
更新的方式为:dist[i]=max(dist[j])+value[i]dist[i] = max(dist[j]) + value[i]dist[i]=max(dist[j])+value[i] , 这里的j是i的前驱节点。
解题思路
1. 拓扑排序的定义
拓扑排序是一种用于对有向无环图（DAG）进行排序的方法，它将顶点按照依赖关系排成一个线性序列，使得对图中的每条边 (u,v)(u,v)(u,v)，顶点 uuu 在 vvv 之前出现。
在本题中，每个步骤可以视为一个顶点，步骤之间的依赖关系可以视为有向边。如果步骤 AAA 依赖于步骤 BBB，则可以表示为一条从 BBB 到 AAA 的有向边。
2. 拓扑排序解决方案
我们通过拓扑排序来模拟步骤的执行过程，核心思想是从那些没有依赖的步骤（即入度为 0 的节点）开始，依次执行，同时更新其他步骤的最早完成时间。
具体步骤如下：

读取输入数据：首先读取任务数量、每个任务的执行时间，以及任务的依赖关系。
构建依赖关系图：使用邻接表存储每个步骤的依赖关系，同时使用入度数组记录每个步骤的入度（即有多少前置步骤未完成）。
初始化队列：将所有入度为 0 的任务（没有前置依赖的步骤）放入队列中，它们可以立即开始执行。
拓扑排序处理：从队列中依次取出当前可以执行的任务，并更新后续任务的最早完成时间。如果某个任务的所有前置步骤都已经完成，则将其加入队列。
计算总时间：在遍历图的过程中，维护一个全局的最大完成时间变量，最终即为完成所有任务的最短时间。

3. 状态更新公式
在拓扑排序过程中，使用动态规划的思想更新每个步骤的最早完成时间。对于每一个步骤 iii，我们通过以下公式更新其完成时间：
[ \text{completionTime}[i] = \max(\text{completionTime}[j]) + \text{taskTime}[i] ]
其中，jjj 是步骤 iii 的所有前驱任务，taskTime[i]\text{taskTime}[i]taskTime[i] 是步骤 iii 所需的执行时间。这个公式保证了每个步骤只有在所有前置依赖完成之后才能开始执行。
复杂度分析

时间复杂度：构建邻接表和入度数组的时间复杂度为 O(N+E)O(N + E)O(N+E)，其中 NNN 是任务数量，EEE 是依赖关系的数量。拓扑排序的时间复杂度也是 O(N+E)O(N + E)O(N+E)，因此总体时间复杂度为 O(N+E)O(N + E)O(N+E)。
空间复杂度：空间复杂度为 O(N+E)O(N + E)O(N+E)，用于存储邻接表、入度数组和任务时间等信息。

具体细节见代码注释
代码
python
# 读取输入
n = int(input())  # 任务数量
time_costs = [0] + list(map(int, input().split()))  # 每个任务的时间
edge = [[] for _ in range(n + 1)]  # 构建邻接表
in_degree = [0] * (n + 1)  # 记录每个节点的入度

# 读取依赖关系
for i in range(1, n + 1):
tmp = list(map(int, input().split()))  # 读取每个任务的依赖
if tmp[0] == -1:  # 如果没有依赖任务
continue
for u in tmp:
edge[i].append(u)  # 将依赖任务加入邻接表
in_degree[u] += 1  # 更新依赖任务的入度

# 拓扑排序的函数
def top_sort(start_nodes):
q = []  # 队列，存储入度为0的节点
dist = [-1 for _ in range(n + 1)]  # 存储每个任务的最短完成时间

# 初始化入度为0的节点
for start_node in start_nodes:
q.append(start_node)
dist[start_node] = time_costs[start_node]

while q:
u = q.pop(0)  # 取出队列中的一个任务
for v in edge[u]:  # 遍历其依赖的后续任务
in_degree[v] -= 1  # 更新依赖任务的入度
if in_degree[v] == 0:  # 当入度变为0时，加入队列
q.append(v)
# 更新后续任务的最早完成时间
if dist[v] == -1 or dist[v] < dist[u] + time_costs[v]:
dist[v] = dist[u] + time_costs[v]
return max(dist)  # 返回最晚完成时间

# 找出所有入度为0的任务
start_nodes = [i for i in range(1, n + 1) if in_degree[i] == 0]
print(top_sort(start_nodes))  # 输出任务调度的最短完成时间

C++
#include <iostream> // 引入输入输出流库
#include <vector>   // 引入向量库
#include <queue>    // 引入队列库
#include <string>   // 引入字符串库
#include <sstream>  // 引入字符串流库

using namespace std;

int main(){
int taskCount; // 任务数量
cin >> taskCount; // 从输入中读取任务数量

// 定义任务所需时间数组（从索引 1 开始）
vector<int> taskTime(taskCount + 1);

// 定义入度数组，用于记录每个任务的依赖关系数量（初始为 0）
vector<int> inDegrees(taskCount + 1, 0);

// 从输入中读取每个任务所需的时间
for (int i = 1; i <= taskCount; i++){
cin >> taskTime[i];
}

cin.ignore(); // 忽略换行符

// 定义依赖关系数组，dep[i] 代表任务 i 的所有后继任务
vector<vector<int>> dependencies(taskCount + 1);

// 读取每个任务的依赖信息
for (int i = 1; i <= taskCount; i++){
string dependencyLine;
getline(cin, dependencyLine); // 读取每行的依赖关系
istringstream dependencyStream(dependencyLine); // 使用字符串流处理输入

int prerequisiteTask; // 存储依赖任务编号
while (dependencyStream >> prerequisiteTask){
if (prerequisiteTask != -1){ // 如果输入的任务编号不为 -1
dependencies[prerequisiteTask].push_back(i); // 添加后继任务 i 到任务 prerequisiteTask 的依赖列表中
inDegrees[i]++; // 任务 i 的入度加 1
}
}
}

// 定义队列用于拓扑排序，存储所有没有前置依赖的任务（即入度为 0 的任务）
queue<int> zeroInDegreeQueue;

// 定义一个数组 `completionTime`，用于记录每个任务的最早完成时间
vector<int> completionTime(taskCount + 1, 0);

// 找出所有初始的没有依赖的任务，加入队列，并将其完成时间设置为其所需时间
for (int i = 1; i <= taskCount; i++){
if (inDegrees[i] == 0){
zeroInDegreeQueue.push(i); // 入度为 0 的任务加入队列
completionTime[i] = taskTime[i]; // 初始化其完成时间
}
}

int totalTime = 0; // 定义结果变量，存储所有任务的最早完成时间

// 拓扑排序，处理队列中的每个任务
while (!zeroInDegreeQueue.empty()){
int currentTask = zeroInDegreeQueue.front();
zeroInDegreeQueue.pop(); // 从队列中取出一个当前任务

// 更新结果时间，记录最长的任务完成时间
totalTime = max(totalTime, completionTime[currentTask]);

// 遍历当前任务的所有后继任务
for (int nextTask : dependencies[currentTask]){
// 更新后继任务的完成时间（当前任务的完成时间 + 后继任务所需时间）
completionTime[nextTask] = max(completionTime[nextTask], completionTime[currentTask] + taskTime[nextTask]);

// 当前后继任务的前置依赖完成数减 1
if (--inDegrees[nextTask] == 0){
zeroInDegreeQueue.push(nextTask); // 如果后继任务没有前置依赖了，加入队列
}
}
}

cout << totalTime; // 输出所有任务的最早完成时间
return 0;
}

Java
import java.util.*;

class Main {
// 记录每个步骤被谁依赖
static List<Integer>[] relations;
static int[] inDegree;

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[] stepTime = new int[n + 1]; // 每个步骤的执行时间
relations = new List[n + 1]; // 每个步骤依赖的其他步骤
inDegree = new int[n + 1]; // 每个步骤的入度，即依赖它的步骤数

// 初始化列表
for (int i = 1; i <= n; i++) {
relations[i] = new ArrayList<>();
}

// 读取步骤执行时间
for (int i = 1; i <= n; i++) {
stepTime[i] = sc.nextInt();
}

sc.nextLine();

// 读取依赖关系
for (int i = 1; i <= n; i++) {
String[] str = sc.nextLine().split(" ");
for (String s : str) {
int k = Integer.parseInt(s);
if (k == -1) {
break; // -1表示没有依赖
} else {
relations[k].add(i); // k步骤完成后才能进行i步骤
inDegree[i]++; // i步骤依赖k步骤，入度加1
}
}
}

Queue<Integer> queue = new ArrayDeque<>();
int[] earliestCompletionTime = new int[n + 1]; // 记录每个步骤的最早完成时间

// 初始化：将所有入度为0的步骤加入队列
for (int i = 1; i <= n; i++) {
if (inDegree[i] == 0) {
queue.offer(i);
earliestCompletionTime[i] = stepTime[i]; // 初始完成时间为自身执行时间
}
}

int res = 0;

// 拓扑排序，处理每个步骤的完成时间
while (!queue.isEmpty()) {
int k = queue.poll();

// 更新最终的最早完成时间
res = Math.max(res, earliestCompletionTime[k]);

// 处理依赖于步骤k的其他步骤
for (int relation : relations[k]) {
inDegree[relation]--;
// 更新依赖步骤的完成时间
earliestCompletionTime[relation] = Math.max(earliestCompletionTime[relation], earliestCompletionTime[k] + stepTime[relation]);
if (inDegree[relation] == 0) {
queue.offer(relation);
}
}
}

// 输出结果：所有步骤中的最大完成时间
System.out.print(res);
}
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-到邻国城市的最短距离（P2277）
- 链接：https://codefun2000.com/p/P2277

> 页面标题：#P2277. 第2题-到邻国城市的最短距离

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

AAA 国与 BBB 国是相邻的两个国家，每个国家都有很多城市，国家内部有很多连接城市的公路，国家之间也有很多跨国公路，连接两个国家的边界城市。
两个国家一共有 NNN 个城市，编号 111 到 NNN ，一共有 MMM 条公路，包括国内公路与跨国公路。
小明生活在 AAA 国的城市 111（即编号为111的城市），想去 BBB 国的城市 NNN 游玩，由于小明办理的只能入境一次的签证，所以从城市 111 到城市 NNN 的路径中，只能通过一条跨国公路。
每条公路都一个距离，并且通过这条公路会有一个花费。
请帮小明计算出城市 111 到城市 NNN 的最短距离，并在距离最短的前提下，再计算出最少花费。
如果无法到达城市 NNN ，输出 −1-1−1 。
输入描述

第一行是一个整数 NNN，表示两个国家的城市数量。
第二行是一个整数 MMM，表示两个国家的公路数量，包括国内公路与跨国公路。
第三行是一个长度为 NNN 的字符串，字符串第 iii 个（从111开始计数）字符为 AAA 或 BBB，表示城市 iii 属于 A 国或 B 国，其中第 111 个字符一定为 AAA，第 NNN 个字符一定为 BBB。
最后是 MMM 行，每行包含 444 个整数 U、V、W、CU、V、W、CU、V、W、C，表示编号为 UUU 的城市与编号为 VVV 的城市之间有一条公路，长度是 WWW，花费是 CCC。

注意：所有公路都是双向的，且两个城市之间最多只有一条公路。

数据范围
2≤N≤10002≤N≤10002≤N≤1000，
0≤M≤500000≤M≤500000≤M≤50000，
1≤U,V≤N1≤U,V≤N1≤U,V≤N，
1≤W≤5001≤W≤5001≤W≤500。
输出描述
输出从城市111到城市NNN的最短距离，并在距离最短的前提下，再输出最少花费。
如果无法到达城市NNN，输出−1-1−1。
样例1
输入
5
5
AABBB
3 1 200 1
2 3 150 3
5 2 160 5
4 3 170 7
4 5 170 9

输出
540 17

说明
可以找到一条最优线路：城市1(A国) -> 城市3(B国) -> 城市4(B国)  -> 城市5(B国)，
而且只通过一条跨国公路：城市1->城市3，
距离=200+170+170=540
花费=1+7+9=17
样例2
输入
6
7
AAABBB
1 2 150 2
1 3 100 2
1 4 160 1
2 6 150 5
3 5 100 3
4 6 160 1
5 6 100 4

输出
300 7

说明
可以找到一条最优线路：城市1(A国) -> 城市2(B国) -> 城市6(B国) ，
而且只通过一条跨国公路：城市1->城市2，
距离=150+150=300
花费=2+5=7
另外一条线路：1->3->5->6虽然距离也是300，
但是花费是2+3+4=9>7，所有不是最优线路
样例3
输入
4
3
ABAB
1 2 100 2
2 3 40 3
3 4 50 6

输出
-1

▶️

#### TextSol

video solution

前置知识:最短路径
step1.动画理解Dijstra算法
step2.实现Dijstra算法(C++/Python)
题面描述:
有两个相邻的国家 AAA 和 BBB，其中有 NNN 个城市，编号为 111 到 NNN。MMM 条公路连接这些城市，其中有些是国内公路，有些是连接 AAA 国与 BBB 国边界城市的跨国公路。每条公路有一个距离和花费。
你需要帮助小塔从 AAA 国的城市 111（城市 111）到达 BBB 国的城市 NNN，但由于只能办理一次入境签证，小塔在旅行中只能通过一条跨国公路。你需要找到一条使总距离最短的路径，并在距离相同的情况下使花费最少。如果小塔无法到达城市 NNN，输出 −1-1−1。
思路:枚举 + Dijstra最短路
1.根据数据范围，我们可以使用朴素的Dijkstra算法，分别计算从起点1和终点n到其他节点的属于同一个城市的图集合的最短路径。得到两个数组:dist_1,dist_n
2.枚举所有跨城市的边(u , v)，考虑使用1 -> u + v -> n 更新最小值。最后输出即可。
3.这里我们的比较大小逻辑需要替换成:x[0] < y[0] or (x[0] == y[0] and x[1] < y[1])
题解
本题的核心是让小塔从城市 1 到城市 N，并且只能通过一条跨国公路。每条公路有一个距离和花费的属性。我们需要找到使得距离最短的路径，并在距离相同的情况下使花费最少。
思路分析

拆分问题：

由于小塔只能通过一条跨国公路，我们可以把问题拆解为两个部分：分别计算小塔在 AAA 国和 BBB 国的最短路径。也就是说，我们可以分别计算从城市 1（属于 AAA 国）到 AAA 国其他城市的最短路径，以及从城市 NNN（属于 BBB 国）到 BBB 国其他城市的最短路径。
跨国的路径只能通过一条跨国公路连接 AAA 国和 BBB 国。因此，最终的路径可以表示为：1 -> u（AAA 国的城市） + 跨国公路 u -> v + v -> N（BBB 国的城市）。

分解为子问题：

我们可以将问题分解为在 AAA 国和 BBB 国的子图上分别求最短路径的问题。使用朴素的 Dijkstra 算法，我们可以分别计算从起点城市 1 和终点城市 N 到各个节点的最短路径。
计算得到两个数组 dist_1 和 dist_n，分别表示从城市 1 出发的最短路径和从城市 N 出发的最短路径。
然后我们只需枚举所有跨国公路，检查通过每一条跨国公路的路径是否能形成更优的解。

比较更新最优解：

由于需要在距离相同的情况下优先选择花费最少的路径，因此我们定义一个 lower 函数，来对比两个路径的优劣。优先比较距离，若距离相同则比较花费。
最后，遍历所有跨国公路，利用公式 1 -> u + u -> v + v -> N 更新全局最优解。

代码
c++
#include <iostream>
#include <vector>
#include <queue>
#include <tuple>
#include <climits>
using namespace std;

struct Edge {
int to, dist, cost;
};

bool lower(pair<int, int> x, pair<int, int> y) {
// 比较两个 pair (距离, 花费)，距离小的优先，距离相同则比较花费
return x.first < y.first || (x.first == y.first && x.second < y.second);
}

int n, m;
vector<char> city_type;
vector<vector<Edge>> graph;
vector<tuple<int, int, int, int>> trans_edge; // 存储跨城市的边

vector<pair<int, int>> dijstra(int start) {
// 初始化距离数组，每个城市的距离和代价初始为无穷大
vector<pair<int, int>> distance(n + 1, {INT_MAX, INT_MAX});
distance[start] = {0, 0};  // 起点的距离和代价为0
vector<bool> visited(n + 1, false);  // 记录每个节点是否已经访问过

for (int i = 1; i <= n; i++) {
// 找到当前未访问节点中距离最小的节点
pair<int, int> min_distance = {INT_MAX, INT_MAX};
int min_index = -1;
for (int j = 1; j <= n; j++) {
if (!visited[j] && lower(distance[j], min_distance)) {
min_distance = distance[j];
min_index = j;
}
}

if (min_index == -1) break; // 所有节点都访问过，或者不可达
visited[min_index] = true;  // 标记该节点为已访问

// 更新与当前节点相邻的其他节点的距离
for (auto &edge : graph[min_index]) {
int to = edge.to, w = edge.dist, c = edge.cost;
if (visited[to] || city_type[to] != city_type[min_index]) continue; // 不同国，跳过
pair<int, int> new_distance = {distance[min_index].first + w, distance[min_index].second + c};
if (lower(new_distance, distance[to])) {
distance[to] = new_distance;
}
}
}
return distance;
}

int main() {
cin >> n >> m;
city_type.resize(n + 1);
graph.resize(n + 1);

for (int i = 1; i <= n; i++) {
cin >> city_type[i];
}

for (int i = 0; i < m; i++) {
int a, b, w, c;
cin >> a >> b >> w >> c;
graph[a].push_back({b, w, c});
graph[b].push_back({a, w, c});

// 如果 a 和 b 属于不同的国家，记录这条跨城市的边
if (city_type[a] != city_type[b]) {
trans_edge.push_back({a, b, w, c});
trans_edge.push_back({b, a, w, c});
}
}

// 计算从城市 1 和 n 出发的最短路径
vector<pair<int, int>> distance_1 = dijstra(1);
vector<pair<int, int>> distance_n = dijstra(n);

// 初始化答案
pair<int, int> ans = {INT_MAX, INT_MAX};

// 遍历所有跨城市的边，更新最短路径
for (auto &edge : trans_edge) {
int a, b, w, c;
tie(a, b, w, c) = edge;
if (distance_1[a].first == INT_MAX || distance_n[b].first == INT_MAX) continue; // 不可达
pair<int, int> new_ans = {distance_1[a].first + distance_n[b].first + w, distance_1[a].second + distance_n[b].second + c};
if (lower(new_ans, ans)) {
ans = new_ans;
}
}

// 输出结果
if (ans.first == INT_MAX) {
cout << -1 << endl;
} else {
cout << ans.first << " " << ans.second << endl;
}

return 0;
}

python
def lower(x, y):
# 定义一个比较函数，用于比较两个距离和代价对。
# 返回 True 表示 x 比 y 小，规则是先比较距离，如果距离相同则比较代价。
return x[0] < y[0] or (x[0] == y[0] and x[1] < y[1])

# 输入处理，读取城市数量 n 和边的数量 m
n = int(input())
m = int(input())

# 读取每个城市的类型（属于同一个城市类型的节点才能互相通行），并在开头加上一个占位符"X"
city_type = list(input())
city_type = ["X"] + city_type

# 初始化图的邻接矩阵，graph[i][j]表示城市i到城市j的距离和代价对，初始值为[-1, -1]表示没有路径
graph = [[[-1, -1] for _ in range(n + 1)] for _ in range(n + 1)]

# 初始化跨城市的边集合（用于最后跨城市的更新）
trans_edge = []

# 读取所有边的信息
for i in range(m):
a, b, w, c = map(int, input().split())  # 读取起点a，终点b，边的距离w，边的代价c
if graph[a][b][0] != -1:  # 如果a和b之间已经有一条边
# 比较当前读入的边和已有的边，取距离更小且代价更低的边
if lower([w, c], graph[a][b]):
graph[a][b] = [w, c]
graph[b][a] = [w, c]  # 更新a到b和b到a的边信息
else:
# 如果a和b之间没有边，直接更新边的信息
graph[a][b] = [w, c]
graph[b][a] = [w, c]

# 如果a和b属于不同的城市类型，记录这条跨城市的边
if city_type[a] != city_type[b]:
trans_edge.append([a, b, w, c])
trans_edge.append([b, a, w, c])

# 朴素的Dijkstra算法，用于计算从起点到其他节点的最短路径
def dijstra(start, city_type):
# 初始化距离数组，每个城市的距离和代价初始为无穷大
distance = [[float('inf'), float('inf')] for _ in range(n + 1)]
distance[start] = [0, 0]  # 起点的距离和代价为0
visited = [False] * (n + 1)  # 记录每个节点是否已经访问过

# Dijkstra算法的主要部分
for i in range(1, n + 1):
# 找到当前未访问节点中距离最小的节点
min_distance = [float('inf'), float('inf')]
min_index = -1
for j in range(1, n + 1):
if not visited[j]:
if lower(distance[j], min_distance):
min_distance = [distance[j][0], distance[j][1]]
min_index = j

visited[min_index] = True  # 标记该节点为已访问

# 更新与当前节点相邻的其他节点的距离
for j in range(1, n + 1):
if visited[j]:
continue
if graph[min_index][j][0] == -1:  # 如果当前节点和j之间没有边，跳过
continue
if city_type[j] != city_type[min_index]:  # 如果节点j和当前节点不属于同一个城市类型，跳过
continue
# 更新节点j的距离和代价，取较小的值
if lower([distance[min_index][0] + graph[min_index][j][0], distance[min_index][1] + graph[min_index][j][1]], distance[j]):
distance[j] = [distance[min_index][0] + graph[min_index][j][0], distance[min_index][1] + graph[min_index][j][1]]
return distance  # 返回从start节点出发的最短路径结果

# 计算从起点1和终点n到其他节点的最短路径
distance_1 = dijstra(1, city_type)
distance_n = dijstra(n, city_type)

# 初始化答案，表示最终的最小距离和代价对，初始值为无穷大
ans = [float('inf'), float('inf')]

# 遍历所有跨城市的边，更新最短路径
for edge in trans_edge:
a, b, w, c = edge  # 读取跨城市边的起点a，终点b，边的距离w，边的代价c
# 如果从起点1到a或从终点n到b的距离是无穷大，跳过（表示不可达）
if distance_1[a][0] == float('inf') or distance_n[b][0] == float('inf'):
continue
# 尝试通过这条跨城市边更新最小距离和代价，比较并取最优解
if lower([distance_1[a][0] + distance_n[b][0] + w, distance_1[a][1] + distance_n[b][1] + c], ans):
ans = [distance_1[a][0] + distance_n[b][0] + w, distance_1[a][1] + distance_n[b][1] + c]

# 如果答案的距离仍然是无穷大，说明没有可行路径，输出-1；否则输出最小距离和代价
if ans[0] == float('inf'):
print(-1)
else:
print(ans[0], ans[1])

java
import java.util.*;

public class Main {

static class Edge {
int to, dist, cost;

public Edge(int to, int dist, int cost) {
this.to = to;
this.dist = dist;
this.cost = cost;
}
}

static boolean lower(int[] x, int[] y) {
// 比较两个 pair (距离, 花费)，距离小的优先，距离相同则比较花费
return x[0] < y[0] || (x[0] == y[0] && x[1] < y[1]);
}

static int n, m;
static char[] city_type;
static List<List<Edge>> graph = new ArrayList<>();
static List<int[]> trans_edge = new ArrayList<>(); // 存储跨城市的边

static int[][] dijkstra(int start) {
// 初始化距离数组，每个城市的距离和代价初始为无穷大
int[][] distance = new int[n + 1][2];
for (int i = 0; i <= n; i++) {
distance[i][0] = Integer.MAX_VALUE;
distance[i][1] = Integer.MAX_VALUE;
}
distance[start][0] = 0;  // 起点的距离和代价为0
distance[start][1] = 0;

boolean[] visited = new boolean[n + 1];  // 记录每个节点是否已经访问过

for (int i = 1; i <= n; i++) {
// 找到当前未访问节点中距离最小的节点
int[] min_distance = {Integer.MAX_VALUE, Integer.MAX_VALUE};
int min_index = -1;
for (int j = 1; j <= n; j++) {
if (!visited[j] && lower(distance[j], min_distance)) {
min_distance = distance[j];
min_index = j;
}
}

if (min_index == -1) break; // 所有节点都访问过，或者不可达
visited[min_index] = true;  // 标记该节点为已访问

// 更新与当前节点相邻的其他节点的距离
for (Edge edge : graph.get(min_index)) {
int to = edge.to, w = edge.dist, c = edge.cost;
if (visited[to] || city_type[to] != city_type[min_index]) continue; // 不同国，跳过
int[] new_distance = {distance[min_index][0] + w, distance[min_index][1] + c};
if (lower(new_distance, distance[to])) {
distance[to] = new_distance;
}
}
}
return distance;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

n = sc.nextInt();
m = sc.nextInt();
city_type = new char[n + 1];

// 读取城市所属国家
String cityTypeInput = sc.next();
for (int i = 1; i <= n; i++) {
city_type[i] = cityTypeInput.charAt(i - 1);
}

// 初始化图
for (int i = 0; i <= n; i++) {
graph.add(new ArrayList<>());
}

// 读取所有边的信息
for (int i = 0; i < m; i++) {
int a = sc.nextInt();
int b = sc.nextInt();
int w = sc.nextInt();
int c = sc.nextInt();
graph.get(a).add(new Edge(b, w, c));
graph.get(b).add(new Edge(a, w, c));

// 如果 a 和 b 属于不同的国家，记录这条跨城市的边
if (city_type[a] != city_type[b]) {
trans_edge.add(new int[]{a, b, w, c});
trans_edge.add(new int[]{b, a, w, c});
}
}

// 计算从城市 1 和 n 出发的最短路径
int[][] distance_1 = dijkstra(1);
int[][] distance_n = dijkstra(n);

// 初始化答案
int[] ans = {Integer.MAX_VALUE, Integer.MAX_VALUE};

// 遍历所有跨城市的边，更新最短路径
for (int[] edge : trans_edge) {
int a = edge[0], b = edge[1], w = edge[2], c = edge[3];
if (distance_1[a][0] == Integer.MAX_VALUE || distance_n[b][0] == Integer.MAX_VALUE) continue; // 不可达
int[] new_ans = {distance_1[a][0] + distance_n[b][0] + w, distance_1[a][1] + distance_n[b][1] + c};
if (lower(new_ans, ans)) {
ans = new_ans;
}
}

// 输出结果
if (ans[0] == Integer.MAX_VALUE) {
System.out.println(-1);
} else {
System.out.println(ans[0] + " " + ans[1]);
}
}
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-求一组算子的最短执行时间（P2271）
- 链接：https://codefun2000.com/p/P2271

> 页面标题：#P2271. 第2题-求一组算子的最短执行时间

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

深度学习算法由一个个计算单元组成，我们称这些计算单元为算子。
对于完成矢量运的算子我们称为矢量算子，在 NPUNPUNPU 中矩阵计算单元和向量计算单元都可以执行矢量算子，他们是独立可并行执行的，但他们的计算效率是6:1，即假设某个失量算子在矩阵计算单元上执行的时间为 NNN ，则在向量计算单元上执行的时间为 6N6N6N 。
给定一组矢量算子，假设他们都可以部署在矩阵计算单元和向量计算单元。为了充分利用计算资源，我们可以合理部署算子的执行单元，让总体的执行时间最短，总的执行时间为 MAXMAXMAX (矩阵计算单元总的执行时间，向量计算单元总的执行时间)。
为了简化计算模型，我们约定:
1.单个算子只能部署在矩阵计算单元或向量计算单元。
2.部署在向量计算单元的算子必须是按照给定顺序连续的。
输入描述
输入格式:
第一行输入算子数 nnn
第二行输入该组算子在矩阵计算单元的执行时间 numsnumsnums
1<=n<=1041<=n<= 10^41<=n<=104
1<=nums[i]<=1041 <=nums[i] <=10^41<=nums[i]<=104
输出描述
该组算子整体的最短执行时间
样例1
输入
9
1 2 3 4 5 6 7 8 9

输出
39

说明
下标 555 的算子在矩阵计算单元的执行时间为 666 ，将它部署在向量计算单元，
执行时间变为 6∗6=366*6=366∗6=36 ，剩下的算子部署在矩阵计算单元，执行时间为 1+2+3+4+5+7+8+9=391+2+3+4+5+7+8+9=391+2+3+4+5+7+8+9=39 。
总的执行时间为 393939 ，没有比这执行时间更短的方案了。
样例2
输入
9
3 2 17 8 3 5 4 18 15

输出
66

说明
下标 3,43,43,4 的算子在矩阵计算单元的执行时间为 8,38,38,3 ，将它部署在向量计算单元,
执行时间变为 8∗6+3∗6=668 * 6 + 3 * 6 = 668∗6+3∗6=66 ，剩下的算子部署在矩阵计算单元，执行时间为 3+2+17+5+4+18+15=643+2+17+5+4+18+15=643+2+17+5+4+18+15=64 ，
总的执行时间为 666666 ，没有比这执行时间更短的方案了。

▶️

#### TextSol

video solution

题目描述
给定一组矢量算子，要求合理部署这些算子到矩阵计算单元和向量计算单元上，以充分利用计算资源，使得整体执行时间最短。整体执行时间定义为矩阵计算单元总执行时间和向量计算单元总执行时间的最大值。
思路(暴力)
数据范围n<=1e4n<=1e4n<=1e4考虑暴力,因为向量单元必须连续，所以考虑直接枚举区间,将(i,j)(i,j)(i,j)这一段区间纳入向量单元其他的纳入矩阵区间，取二者的最大值再与ansansans取minminmin即可
题解：
题目要求我们合理分配一组矢量算子，使其分别在矩阵计算单元和向量计算单元上执行，并且使整体的执行时间最短。由于向量计算单元的执行效率较低（矩阵计算单元的六分之一），我们需要找到一种分配方式，使得两个单元中较大的执行时间尽可能小。
我们采用 枚举区间的方法 来解决此问题。具体思路如下：

前缀和计算：
我们先求出每个算子的前缀和，这样可以方便快速计算任意区间的执行时间。

枚举向量单元的区间：
我们枚举区间 (i,j)(i,j)(i,j)，表示将第 iii 到第 jjj 个算子部署到向量计算单元，其他算子部署到矩阵计算单元。通过前缀和，可以很快求出这段区间的总执行时间。

计算执行时间并取最小值：
对于每个区间 (i,j)(i,j)(i,j)，我们计算两部分的执行时间：

向量单元的执行时间：区间 (i,j)(i,j)(i,j) 的和乘以 6。
矩阵单元的执行时间：总执行时间减去区间 (i,j)(i,j)(i,j) 的和。

然后我们取这两个执行时间的较大值作为当前分配方案的执行时间，并不断更新全局的最优解。

提前剪枝优化：
在枚举区间时，如果某段区间的向量单元执行时间已经超过当前最优解，那么我们可以直接跳过该区间，避免无效的计算。

时间复杂度分析：

枚举区间的复杂度是 O(n2)O(n^2)O(n2)，其中每次计算区间和是 O(1)O(1)O(1) 的操作，整体复杂度为 O(n2)O(n^2)O(n2)。虽然 nnn 可以达到 10410^4104，但是通过合理剪枝，可以有效减少无效的计算，从而优化实际运行时间。

c++
#include <bits/stdc++.h>
using namespace std;
const int N=1e4+10;
int n, num[N]; // 存储算子执行时间的数组
int sum[N];    // 存储前缀和
int ans;       // 最终结果，最小的执行时间

signed main() {
cin >> n; // 输入算子数量
// 输入每个算子在矩阵计算单元的执行时间，并计算前缀和
for(int i=1; i<=n; i++) {
cin >> num[i];
sum[i] = sum[i-1] + num[i]; // 计算前缀和
}

int temp = sum[n]; // temp记录所有算子在矩阵单元的总执行时间
ans = temp; // 初始最优解设为所有算子都在矩阵单元的执行时间

// 枚举区间 (i,j)，表示将 (i,j) 这段区间分配到向量单元
for(int i=1; i<=n; i++) {
for(int j=i; j<=n; j++) {
int c = sum[j] - sum[i-1]; // 计算区间 (i,j) 的执行时间
if(c * 6 >= ans) break; // 如果当前向量单元执行时间超过已有最优解，跳出循环
int val = max(c * 6, temp - c); // 计算向量单元和矩阵单元执行时间的最大值
ans = min(ans, val); // 更新最优解
}
}

cout << ans << endl; // 输出最小执行时间
}

python
N = 10**4 + 10
n = 0
num = [0] * N  # 存储算子执行时间的数组
sum = [0] * N  # 存储前缀和
ans = 0        # 最终结果，最小的执行时间

# 读取输入
n = int(input())  # 输入算子数量
num = list(map(int, input().split()))  # 输入每个算子在矩阵计算单元的执行时间
num.insert(0, 0)  # 在第一个位置插入0，使得下标从1开始

# 计算前缀和
for i in range(1, n + 1):
sum[i] = sum[i - 1] + num[i]

temp = sum[n]  # temp记录所有算子在矩阵单元的总执行时间
ans = temp  # 初始最优解设为所有算子都在矩阵单元的执行时间

# 枚举区间 (i,j)，表示将 (i,j) 这段区间分配到向量单元
for i in range(1, n + 1):
for j in range(i, n + 1):
c = sum[j] - sum[i - 1]  # 计算区间 (i,j) 的执行时间
if c * 6 >= ans:
break  # 如果当前向量单元执行时间超过已有最优解，跳出循环
val = max(c * 6, temp - c)  # 计算向量单元和矩阵单元执行时间的最大值
ans = min(ans, val)  # 更新最优解

# 输出最小执行时间
print(ans)

java
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int N = 10010;
int[] num = new int[N]; // 存储算子执行时间的数组
int[] sum = new int[N]; // 存储前缀和
int ans;

// 输入算子数量
int n = scanner.nextInt();

// 输入每个算子在矩阵计算单元的执行时间，并计算前缀和
for (int i = 1; i <= n; i++) {
num[i] = scanner.nextInt();
sum[i] = sum[i - 1] + num[i]; // 计算前缀和
}

int temp = sum[n]; // temp记录所有算子在矩阵单元的总执行时间
ans = temp; // 初始最优解设为所有算子都在矩阵单元的执行时间

// 枚举区间 (i,j)，表示将 (i,j) 这段区间分配到向量单元
for (int i = 1; i <= n; i++) {
for (int j = i; j <= n; j++) {
int c = sum[j] - sum[i - 1]; // 计算区间 (i,j) 的执行时间
if (c * 6 >= ans) break; // 如果当前向量单元执行时间超过已有最优解，跳出循环
int val = Math.max(c * 6, temp - c); // 计算向量单元和矩阵单元执行时间的最大值
ans = Math.min(ans, val); // 更新最优解
}
}

// 输出最小执行时间
System.out.println(ans);
}
}

进一步问题分析
目标是让MAX(矩阵计算时间, 向量计算时间)尽量小。通过分析，我们可以发现，如果将向量单元部署得太大，则其计算时间可能会远远超过矩阵单元，反之如果将矩阵单元部署得太多，则可能导致无法充分利用向量单元。
思路(双指针)
问题转化与单调性
假设我们使用两个指针来表示连续子序列的左右端点：

当固定左端点时，逐渐增加右端点，可以观察到：

矩阵单元的执行时间会逐渐减少。
向量单元的执行时间会逐渐增加。

当固定一个左端点，我们可以逐步增大右端点，找到一个最优的分割点，使得两者的最大值最小。

双指针的使用
我们可以使用两个指针 left 和 right 来表示连续子序列的两端：

每次将右指针 right 向右扩展，更新总的执行时间。
当向量单元的执行时间（即子序列的和乘以6倍）开始大于或等于剩余部分的矩阵单元执行时间时，我们开始考虑收缩左指针，以找到一个更小的最大值。

算法流程

初始化两个指针 left 和 right，以及两个累计和 now（当前向量单元和） 和 tot（剩余矩阵单元和）。
移动右指针，逐步扩大子序列范围，并更新向量单元的执行时间。
当 now * 6 >= tot 时，表示向量单元的执行时间已经超过了矩阵单元的执行时间，可以考虑移动左指针，来减少向量单元的大小。
每次更新 ans 记录最小的最大执行时间。

代码
java
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

// 读取算子数
int n = scanner.nextInt();
int[] nums = new int[n];

// 读取每个算子在矩阵计算单元的执行时间
for (int i = 0; i < n; i++) {
nums[i] = scanner.nextInt();
}

int tot = 0;
// 计算所有算子在矩阵单元的总执行时间
for (int num : nums) {
tot += num;
}

int ans = tot;  // 初始答案设为矩阵单元的总执行时间
int now = 0;    // 当前向量单元的执行时间和
int left = 0, right = 0;  // 双指针

// 双指针遍历所有可能的子序列
while (right < n) {
tot -= nums[right];  // 将当前算子从矩阵单元中移出，放入向量单元
now += nums[right];  // 增加当前算子在向量单元的执行时间和

// 当向量单元的执行时间大于或等于矩阵单元的执行时间时，调整左指针
while (now * 6 >= tot) {
ans = Math.min(ans, now * 6);  // 更新答案为当前向量单元的执行时间（乘6倍）
// 收缩左指针，减少向量单元的执行时间
now -= nums[left];
tot += nums[left];
left++;
}

// 更新答案为当前矩阵单元和的最小值
ans = Math.min(ans, tot);
right++;
}

// 输出结果
System.out.println(ans);
scanner.close();
}
}

python
# 读取输入
n = int(input())  # 读取算子数
nums = list(map(int, input().split()))  # 读取每个算子在矩阵计算单元的执行时间

# 初始化
tot = sum(nums)  # 计算所有算子在矩阵单元的总执行时间
ans = tot  # 初始答案设为矩阵单元的总执行时间
now = 0  # 当前向量单元的执行时间和
left, right = 0, 0  # 双指针

# 双指针遍历所有可能的子序列
while right < n:
tot -= nums[right]  # 将当前算子从矩阵单元中移出，放入向量单元
now += nums[right]  # 增加当前算子在向量单元的执行时间和

# 当向量单元的执行时间大于或等于矩阵单元的执行时间时，调整左指针
while now * 6 >= tot:
ans = min(ans, now * 6)  # 更新答案为当前向量单元的执行时间（乘6倍）
# 收缩左指针，减少向量单元的执行时间
now -= nums[left]
tot += nums[left]
left += 1

# 更新答案为当前矩阵单元和的最小值
ans = min(ans, tot)
right += 1

# 输出结果
print(ans)

cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
int n;
// 读取算子数
cin >> n;
vector<int> nums(n);

// 读取每个算子在矩阵计算单元的执行时间
int total = 0;
for (int i = 0; i < n; ++i) {
cin >> nums[i];
total += nums[i];
}

int ans = total; // 初始答案设为矩阵单元的总执行时间
int now = 0;     // 当前向量单元的执行时间和
int left = 0, right = 0; // 双指针

// 双指针遍历所有可能的子序列
while (right < n) {
total -= nums[right]; // 将当前算子从矩阵单元中移出，放入向量单元
now += nums[right];   // 增加当前算子在向量单元的执行时间和

// 当向量单元的执行时间大于或等于矩阵单元的执行时间时，调整左指针
while (now * 6 >= total) {
ans = min(ans, now * 6); // 更新答案为当前向量单元的执行时间（乘6倍）
// 收缩左指针，减少向量单元的执行时间
now -= nums[left];
total += nums[left];
left++;
}

// 更新答案为当前矩阵单元和的最小值
ans = min(ans, total);
right++;
}

// 输出结果
cout << ans << endl;

return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-求最大括号表达式（P2274）
- 链接：https://codefun2000.com/p/P2274

> 页面标题：#P2274. 第2题-求最大括号表达式

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有效括号表达式定义:
111、空串和()()()均为有效表达式。
222、当A、B为A、B为A、B为有效表达式时，则(A)、AB(A)、AB(A)、AB也均是有效的括号表达式，比如:AAA为()()()，则 ()()和()()和()()和(())$均为有效括号表达式。
括号表达式的值:左括号用111表示，右括号用000表示，该二进制序列对应的值即为括号表达式的值。
现给定一个有效括号表达式，对其中任意两个相邻的子"有效表达式”进行交换，求在任意次数(包含0次)的交换之后，能够得到的值最大的括号表达式。
说明:
111、表达式自身是有效表达式。
222、交换的必须是相邻且有效的。
输入描述
给定一个有效括号表达式，只包含左右括号"()”。
表达式的长度不超过606060。
输出描述
在任意次数(包含000次)的交换之后，能够得到的值最大的括号表达式
样例1
输入
((()(())))

输出
(((())()))

说明
将在s[2]s[2]s[2]出现的有效表达式“()()()”和在s[4]s[4]s[4]出现的有效表达式(())(())(())进行交换。
对应二进制:
11 10 1100 0011\ 10\ 1100\ 0011 10 1100 00转换为11 1100 10 0011\ 1100\ 10\ 0011 1100 10 00
样例2
输入
()()

输出
()()

说明
无需交换，交换后也一样
样例3
输入
()(())((()(())))

输出
(((())()))(())()

说明
交换s[8−9]s[8-9]s[8−9]与s[10−13]s[10-13]s[10−13]，得到()(())(((())()))()(())(((())()))()(())(((())()))
交换s[2−5]s[2-5]s[2−5]与s[6−15]s[6-15]s[6−15]，得到()(((())()))(())()(((())()))(())()(((())()))(())
交换s[0−1]s[0-1]s[0−1]与s[2−11]s[2-11]s[2−11]，得到(((())()))()(())(((())()))()(())(((())()))()(())
交换s[10−11]s[10-11]s[10−11]与s[12−15]s[12-15]s[12−15]，得到(((())()))(())()(((())()))(())()(((())()))(())()

▶️

#### TextSol

video solution

题目描述
给定一个合法的括号序列，要求通过对其进行若干次（或不进行）的相邻合法括号子序列的交换，得到字典序最大的括号序列。每个合法的括号序列由左右括号组成，并且是有效的括号匹配。
解题思路
这道题的核心在于递归拆分括号子序列，然后对子序列进行字典序排序。我们可以将括号表达式看作是树状的结构，递归处理括号内部的子结构并保证排序合并后的结果是字典序最大的表达式。
思路步骤

递归拆分括号序列：

对于给定的括号表达式，我们先从左到右遍历，使用一个计数器 cnt 来跟踪当前括号的匹配状态。当计数器归零时，说明我们找到了一个完整的合法括号序列（即一对匹配的 ()）。
然后我们可以将这个合法括号序列作为一个独立的子结构进行递归处理。

递归处理每个子序列：

对于每个合法括号序列，可以递归调用相同的函数进行处理。对于单一的括号序列（如 (())），可以去掉外层的括号，递归处理里面的内容；对于多个子括号序列（如 ()()），可以分别递归处理。

字典序排序：

当多个子括号序列被递归处理后，按照 a + b 和 b + a 的字典序进行比较，来决定两个子序列的拼接顺序。这种拼接保证了最终的括号表达式的字典序最大。

例如，如果两个子序列 a 和 b，如果 a + b 的字典序大于 b + a，那么 a 应该排在 b 的前面。

Q:为什么这么排序？A:见LeetCode 179.最大数

合并排序后的结果：

在排序完成后，将这些子序列按顺序拼接起来，形成当前层次的括号表达式，返回给上一层递归。

代码
java
import java.util.*;

public class Main {
// 自定义比较器，用来比较两个字符串拼接的字典序
public static int compare(String a, String b) {
if ((a + b).compareTo(b + a) > 0) {
return 1;
} else if ((a + b).compareTo(b + a) < 0) {
return -1;
} else {
return 0;
}
}

// 深度优先搜索函数，递归处理括号表达式
public static String dfs(String s) {
if (s.length() == 0) {
return "";
}

List<String> part = new ArrayList<>();
StringBuilder now = new StringBuilder();
int cnt = 0;

// 分割括号表达式，按完整的括号对划分
for (char c : s.toCharArray()) {
if (c == '(') {
cnt++;
} else {
cnt--;
}
now.append(c);
if (cnt == 0) { // 找到一个完整的括号对
part.add(now.toString());
now = new StringBuilder();
}
}

List<String> subRes = new ArrayList<>();

if (part.size() == 1) {
// 如果只有一个完整的括号对，递归处理去掉最外层括号后的子表达式
subRes.add("(" + dfs(part.get(0).substring(1, part.get(0).length() - 1)) + ")");
} else {
// 递归处理多个括号对
for (String p : part) {
subRes.add(dfs(p));
}
}

// 排序子表达式，使得字典序最大
Collections.sort(subRes, (a, b) -> compare(a, b));

// 返回拼接后的结果
return String.join("", subRes);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String s = sc.next(); // 输入括号字符串
System.out.println(dfs(s)); // 输出处理后的结果
}
}

python
from functools import cmp_to_key

# 读取输入的括号字符串
s = input()

# 自定义比较函数，比较 a 和 b 的拼接顺序，决定字典序的顺序
# 如果 a + b > b + a，返回 1，表示 a 应该排在 b 的后面
# 如果 a + b < b + a，返回 -1，表示 a 应该排在 b 的前面
# 否则返回 0 表示相等
def compare(a, b):
if a + b > b + a:
return 1
elif a + b < b + a:
return -1
return 0

# 深度优先搜索 (DFS) 函数，用来递归处理括号表达式
def dfs(s):
# 如果当前字符串为空，直接返回空字符串
if len(s) == 0:
return ""

part = []  # 用于存储当前括号层的所有子括号表达式
now = ""   # 临时变量，记录当前子表达式
cnt = 0    # 计数器，判断当前括号是否匹配

# 遍历字符串中的每个字符
for c in s:
if c == '(':  # 遇到左括号时，计数器加 1
cnt += 1
else:  # 遇到右括号时，计数器减 1
cnt -= 1
now += c  # 将当前字符加入到子表达式中

# 当计数器为 0 时，说明当前子表达式是一个完整的括号对
if cnt == 0:
part.append(now)  # 将完整的子表达式存入 part 列表中
now = ""  # 重置 now，开始处理下一个子表达式

sub_res = []  # 存储处理后的子表达式结果

# 如果 part 只有一个完整的括号对
if len(part) == 1:
# 递归处理去掉最外层括号的子表达式，并将结果重新加上括号
sub_res.append("(" + dfs(part[0][1:-1]) + ")")
else:
# 否则递归处理每个子表达式
for p in part:
sub_res.append(dfs(p))

# 排序所有子表达式，按照自定义的 compare 函数
# 比较规则是，如果 a + b < b + a，则 a 应该排在 b 的前面
return ''.join(sorted(sub_res, key=cmp_to_key(compare)))

# 调用 dfs 函数，计算并输出字典序最大的括号表达式
print(dfs(s))

cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// 自定义比较器函数，比较两个字符串拼接后的字典序
bool compare(const string& a, const string& b) {
return a + b < b + a;
}

// 深度优先搜索函数，递归处理括号表达式
string dfs(string s) {
if (s.empty()) return "";

vector<string> part;
string now;
int cnt = 0;

// 分割括号表达式，按完整的括号对划分
for (char c : s) {
if (c == '(') cnt++;
else cnt--;
now += c;
if (cnt == 0) { // 找到一个完整的括号对
part.push_back(now);
now.clear();
}
}

vector<string> subRes;

if (part.size() == 1) {
// 如果只有一个完整的括号对，递归处理去掉最外层括号后的子表达式
subRes.push_back("(" + dfs(part[0].substr(1, part[0].size() - 2)) + ")");
} else {
// 递归处理多个括号对
for (string p : part) {
subRes.push_back(dfs(p));
}
}

// 排序子表达式，使得字典序最大
sort(subRes.begin(), subRes.end(), compare);

// 返回拼接后的结果
string result;
for (const string& str : subRes) {
result += str;
}
return result;
}

int main() {
string s;
cin >> s; // 输入括号字符串
cout << dfs(s) << endl; // 输出处理后的结果
return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第2题-村落基站建设（P2268）
- 链接：https://codefun2000.com/p/P2268

> 页面标题：#P2268. 第2题-村落基站建设

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

假设村落二叉树形状分布，我们要选择在哪些村落建设基站。如果某个村落建设了基站，那么它和它相邻的村落(本节点、父节点，子节点)也会有信号覆盖。
计算出最少需要建设的基站数。
输入描述
使用完全二叉树的数组形式表示，从左到右，从上到下遍历，111表示节点存在，000表示节点不存在。

1<=1<=1<=节点数范围<=8191<=8191<=8191
111表示节点存在，000表示节点不存在。。

输出描述
基站个数
样例1
输入
1 1 1 1 0 1 1

输出
2

说明
最少需要222个基站才能覆盖所有村落

样例2
输入
1 1 0 1 0 0 0

输出
1

说明
只需要111个基站就能覆盖所有村落

▶️

#### TextSol

video solution

题目描述
假设村落以二叉树的形状分布，我们需要选择在哪些村落建设基站。如果某个村落建设了基站，那么它和它相邻的村落（包括本节点、父节点和子节点）都会有信号覆盖。
计算出最少需要建设的基站数。
该题是leetcodeleetcodeleetcode原题:https://leetcode.cn/problems/binary-tree-cameras/solutions/422860/jian-kong-er-cha-shu-by-leetcode-solution/
思路：树上动态规划

输入和树构建：输入是一个数组形式的完全二叉树，1 表示节点存在，0 表示节点不存在。代码通过递归构建二叉树。

动态规划状态定义：定义 dp 状态表示在某个节点处的最小基站数需求，有三种状态：

dp_0: 该节点有基站，覆盖自己和左右子节点。
dp_1: 该节点没有基站，但被其子节点的基站覆盖。
dp_2: 该节点和其子节点都没有基站，但此节点会被其父节点的基站覆盖。

递归和状态转移：在 dfs 函数中递归计算 dp 状态，根据左右子节点的不同 dp 状态更新当前节点的 dp 值。

叶节点：如果是叶节点，则 dp_0 = 1（需要一个基站），dp_1 = inf（无法被子节点覆盖），dp_2 = 0（可被父节点覆盖）。
非叶节点：根据左右子节点的 dp 值，使用不同的组合来最小化当前节点的 dp 值。
这三行代码实现了在当前节点放置基站或不放置基站的情况下，计算该节点的最小基站覆盖数量。这三种状态的计算基于左右子节点的 dp 值，具体解释如下：

1. node.dp_0 = min(left_0, left_1, left_2) + min(right_0, right_1, right_2) + 1

含义：dp_0 表示当前节点 node 自己放置一个基站的情况下，覆盖该节点和其子节点所需的最少基站数。
计算逻辑：

在当前节点放置一个基站可以直接覆盖自己以及左右子节点。
因此，左右子节点可以处于任意状态（dp_0, dp_1, dp_2），因为无论左右子节点是否放置基站，都能通过当前节点的基站信号覆盖到。
为了最小化基站数量，我们取左右子节点的 dp 值中的最小值。
+1 表示在当前节点放置了一个基站。

2. node.dp_1 = min(left_0 + min(right_0, right_1), right_0 + min(left_0, left_1))

含义：dp_1 表示当前节点 node 不放置基站，但被其左右子节点的基站覆盖的情况下，所需的最少基站数。
计算逻辑：

要实现这种覆盖，左右子节点中至少有一个必须放置基站来覆盖当前节点。
这里有两种选择来最小化基站数量：

左子节点放置基站（left_0），右子节点可被覆盖（min(right_0, right_1)）。
右子节点放置基站（right_0），左子节点可被覆盖（min(left_0, left_1)）。

这两种方案中取最小值，即为最少基站数量。

3. node.dp_2 = left_1 + right_1

含义：dp_2 表示当前节点 node 不放置基站，且依赖父节点放置基站覆盖自己的情况下，左右子节点的最小基站数。
计算逻辑：

在这种情况下，当前节点必须通过父节点的基站信号覆盖自己，因此不能依赖左右子节点来覆盖自己。
左右子节点也需要被覆盖到，因此它们各自必须满足 dp_1（即被它们的子节点覆盖）。
左右子节点处于 dp_1 状态的总和即为 dp_2 的值。

结果计算：在根节点处，返回 min(dp_0, dp_1) 即为满足覆盖条件的最小基站数。

python实现
arr = list(map(int, input().split()))  # 读取输入数组，表示二叉树的结构
n = len(arr)  # 节点数
inf = 10**9  # 设置一个很大的数作为无穷大，表示不可能的情况

class Node:
def __init__(self):
self.left = None  # 左子节点
self.right = None  # 右子节点
self.dp_0 = inf  # 该节点放置基站的最小基站数
self.dp_1 = inf  # 该节点未放置基站，但被子节点覆盖的最小基站数
self.dp_2 = inf  # 该节点未放置基站，但被父节点覆盖的最小基站数

root = Node()  # 初始化根节点

# 构建二叉树
def build_tree(node, i):
left = 2 * i + 1
right = 2 * i + 2
if left < n and arr[left] == 1:
node.left = Node()
build_tree(node.left, left)
if right < n and arr[right] == 1:
node.right = Node()
build_tree(node.right, right)

build_tree(root, 0)  # 从根节点构建树

# 深度优先搜索计算dp状态
def dfs(node):
if not node.left and not node.right:
node.dp_0 = 1  # 叶节点放基站
node.dp_1 = inf  # 叶节点无法通过子节点被覆盖
node.dp_2 = 0  # 叶节点可以由父节点覆盖
return

# 左子节点的dp值
if node.left:
dfs(node.left)
left_0 = node.left.dp_0
left_1 = node.left.dp_1
left_2 = node.left.dp_2
else:
left_0 = inf  # 左节点不存在时不可能放基站
left_1 = 0  # 左节点不存在时默认被覆盖
left_2 = inf  # 左节点不存在时不可能仅被父节点覆盖

# 右子节点的dp值
if node.right:
dfs(node.right)
right_0 = node.right.dp_0
right_1 = node.right.dp_1
right_2 = node.right.dp_2
else:
right_0 = inf
right_1 = 0
right_2 = inf

# 当前节点的dp值
node.dp_0 = min(left_0, left_1, left_2) + min(right_0, right_1, right_2) + 1
node.dp_1 = min(left_0 + min(right_0, right_1), right_0 + min(left_0, left_1))
node.dp_2 = left_1 + right_1

dfs(root)  # 从根节点开始执行DFS
print(min(root.dp_0, root.dp_1))  # 输出最小基站数，取根节点放基站或被子节点覆盖的较小值

cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

// 定义二叉树节点结构
struct Node {
Node* left;
Node* right;
int dp_0; // 当前节点放置基站的最小基站数
int dp_1; // 当前节点未放置基站，但被子节点覆盖的最小基站数
int dp_2; // 当前节点未放置基站，但被父节点覆盖的最小基站数

Node() : left(nullptr), right(nullptr), dp_0(INF), dp_1(INF), dp_2(INF) {}
};

// 全局变量存储输入数组和节点数
vector<int> arr;
int n;

// 构建二叉树的递归函数
Node* build_tree(int i) {
if (i >= n || arr[i] != 1)
return nullptr;

Node* node = new Node();
node->left = build_tree(2 * i + 1);
node->right = build_tree(2 * i + 2);
return node;
}

// 深度优先搜索计算dp状态的递归函数
void dfs(Node* node) {
if (!node->left && !node->right) {
node->dp_0 = 1;    // 叶节点放基站
node->dp_1 = INF;  // 叶节点无法通过子节点被覆盖
node->dp_2 = 0;    // 叶节点可以由父节点覆盖
return;
}

// 处理左子节点
int left_0 = INF, left_1 = 0, left_2 = INF;
if (node->left) {
dfs(node->left);
left_0 = node->left->dp_0;
left_1 = node->left->dp_1;
left_2 = node->left->dp_2;
}

// 处理右子节点
int right_0 = INF, right_1 = 0, right_2 = INF;
if (node->right) {
dfs(node->right);
right_0 = node->right->dp_0;
right_1 = node->right->dp_1;
right_2 = node->right->dp_2;
}

// 计算当前节点的dp_0
node->dp_0 = min({left_0, left_1, left_2}) + min({right_0, right_1, right_2}) + 1;

// 计算当前节点的dp_1
node->dp_1 = min(left_0 + min(right_0, right_1),
right_0 + min(left_0, left_1));

// 计算当前节点的dp_2
node->dp_2 = left_1 + right_1;
}

int main(){
// 读取输入数组
string input_line;
getline(cin, input_line);
int num;
stringstream ss(input_line);
while (ss >> num){
arr.push_back(num);
}
n = arr.size();

// 构建二叉树
Node* root = build_tree(0);
if (!root){
cout << 0;
return 0;
}

// 执行深度优先搜索计算dp值
dfs(root);

// 输出最小基站数，取根节点放基站或被子节点覆盖的较小值
cout << min(root->dp_0, root->dp_1);

// 释放内存（可选）
// 这里没有实现树的释放，为了简化代码

return 0;
}

java
import java.util.*;
import java.io.*;

public class Main {
static final int INF = (int)1e9; // 定义一个很大的数作为无穷大

// 定义二叉树节点结构
static class Node {
Node left;  // 左子节点
Node right; // 右子节点
int dp0;    // 当前节点放置基站的最小基站数
int dp1;    // 当前节点未放置基站，但被子节点覆盖的最小基站数
int dp2;    // 当前节点未放置基站，但被父节点覆盖的最小基站数

Node() {
this.left = null;
this.right = null;
this.dp0 = INF;
this.dp1 = INF;
this.dp2 = INF;
}
}

static List<Integer> arr = new ArrayList<>(); // 存储输入数组
static int n; // 节点总数

// 构建二叉树的递归函数
static Node buildTree(int i) {
if (i >= n || arr.get(i) != 1)
return null;

Node node = new Node();
node.left = buildTree(2 * i + 1);   // 左子节点索引为2*i + 1
node.right = buildTree(2 * i + 2);  // 右子节点索引为2*i + 2
return node;
}

// 深度优先搜索计算dp状态的递归函数
static void dfs(Node node) {
if (node.left == null && node.right == null) {
node.dp0 = 1;    // 叶节点放基站
node.dp1 = INF;  // 叶节点无法通过子节点被覆盖
node.dp2 = 0;    // 叶节点可以由父节点覆盖
return;
}

// 处理左子节点
int left0 = INF, left1 = 0, left2 = INF;
if (node.left != null) {
dfs(node.left);
left0 = node.left.dp0;
left1 = node.left.dp1;
left2 = node.left.dp2;
}

// 处理右子节点
int right0 = INF, right1 = 0, right2 = INF;
if (node.right != null) {
dfs(node.right);
right0 = node.right.dp0;
right1 = node.right.dp1;
right2 = node.right.dp2;
}

// 计算当前节点的dp0
node.dp0 = Math.min(Math.min(left0, left1), left2) + Math.min(Math.min(right0, right1), right2) + 1;

// 计算当前节点的dp1
node.dp1 = Math.min(left0 + Math.min(right0, right1),
right0 + Math.min(left0, left1));

// 计算当前节点的dp2
node.dp2 = left1 + right1;
}

public static void main(String[] args) throws IOException {
// 读取输入
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String inputLine = br.readLine();
String[] tokens = inputLine.trim().split("\\s+");
for (String token : tokens) {
arr.add(Integer.parseInt(token));
}
n = arr.size();

// 构建二叉树
Node root = buildTree(0);
if (root == null) {
System.out.println(0);
return;
}

// 执行深度优先搜索计算dp值
dfs(root);

// 输出最小基站数，取根节点放基站或被子节点覆盖的较小值
System.out.println(Math.min(root.dp0, root.dp1));
}
}

核心逻辑总结

dp_0 表示当前节点放基站。
dp_1 表示当前节点不放基站，被子节点覆盖。
dp_2 表示当前节点不放基站，期望被父节点覆盖。

通过 DFS 递归向上计算，每个节点的 dp 值基于子节点的 dp 状态逐层累积，使得在最小化基站数的前提下，确保所有节点都能被覆盖。

---

### 第2题-序列化热点调用栈树（P2265）
- 链接：https://codefun2000.com/p/P2265

> 页面标题：#P2265. 第2题-序列化热点调用栈树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

调用栈指从主函数执行到某个函数的调用路径，
如 AAA->BBB ，经过这条调用栈到达的其他调用栈称为其子调用栈，如 AAA->BBB->DDD 是 AAA->BBB 的子调用栈；
使用某性能分析工具对软件运行过程中的调用栈进行采样分析，得到的热点调用栈数据为树形结构。
树的每个节点代表一条调用栈，子节点为父节点的子调用栈，每个节点有一个数值为采样到该调用栈的样本数量。
现需要刷新各节点的数值为包含其子调用栈的总样本数量，请编码实现。
数的层序遍历，指的是从上到下遍历每层，每层从左到右遍历各节点；为了标识子节点关系，对于 NNN 个节点的树的层序遍历，插入 NNN 个 −1-1−1 ，第 iii 个 −1-1−1 和第 i+1i+1i+1 个 −1-1−1 中间的节点序列为第 iii 个节点的子节点序列，根节点为第 111 个节点;
输入描述
第一行为树的总节点数量 NNN ，取值范围 [1，1000][1，1000][1，1000] ；
第二行为树的序列化输入，采用层序遍历，共 2N2N2N 个数据，包括 NNN 个节点的样本数和 NNN 个节点的子节点序列的分隔符(参见示例)；
各节点样本数取值范围 [0，10000][0，10000][0，10000] ；
输出描述
输出刷新各节点数值后的树，与输入格式保持一致。
样例1
输入
6
5 -1 2 3 8 -1 -1 1 7 -1 -1 -1

输出
26 -1 2 11 8 -1 -1 1 7 -1 -1 -1

说明
第一行表示树一共有 666 个节点:
第二行为按照层序遍历的序列化输入，共 121212 个数据(含 666 个节点的样本数和 666 个节点的子节点序列的分隔符)，含义分别为：

5：第一个节点(即根节点)样本数为5；
-1：分隔第一个节点(即根节点)的子节点序列；
2：第二个节点的样本数为2，它是第一个节点(即根节点)的第一个子节点；
3：第三个节点的样本数为3，它是第一个节点(即根节点)的第二个子节点；
8：第四个节点的样本数为8，它是第一个节点(即根节点)的第三个子节点；
-1：分隔第二个节点的子节点序列；后续无有效数值，表示该节点无子节点；
-1：分隔第三个节点的子节点序列；
1：第五个节点的样本数为1，它是第三个节点的第一个子节点；
7：第六个节点的样本数为7，它是第三个节点的第二个子节点；
-1：分隔第四个节点的子节点，后续无有效数值，表示该节点无子节点；
-1：分隔第五个节点的子节点，后续无有效数值，表示该节点无子节点；
-1：分隔第六个节点的子节点，后续无有效数值，表示该节点无子节点；

构造输入树形结构：

根据树形结构计算各节点包含子节点的样本数:
调用栈 AAA->CCC 有子调用栈 AAA->CCC->EEE 和 AAA->CCC->FFF ，其包含子调用栈的样本数量为 3+1+7=113+1+7=113+1+7=11；
根节点调用栈 AAA 包含了调用栈 AAA->BBB、AAA->CCC 和 AAA->DDD，其包含子调用栈的样本数量为 5+2+11+8=265+2+11+8=265+2+11+8=26;
刷新后的热点调用栈树:

按照层序遍历序列化输出:

26 -1 2 11 8 -1 -1 1 7 -1 -1 -1

#### TextSol

题面描述
本题要求我们处理一个表示调用栈的树形结构，树的每个节点包含一个样本数量，节点间通过分隔符 -1 来标识。输入包含树的节点总数和层序遍历的序列化数据，输出需要更新每个节点的样本数量，使其等于该节点自身的样本数量加上所有子节点的样本数量之和。通过解析输入构建树，计算新样本数量后，按相同格式输出更新后的数据。
思路
就是很简单的树的递归求和，dfsdfsdfs一遍即可，输入输出比较抽象注意处理
具体实现

数据结构定义：

使用 sampleCount 数组来存储每个节点的样本数量。
tree 是一个邻接表，用于存储树的结构，便于进行深度优先搜索（DFS）。
visited 数组用于标记节点是否被访问，以避免重复访问。

输入处理：

首先读取节点总数 n。
然后，通过一个循环读取 2*n 个值，分别代表节点的样本数和分隔符 -1。如果读到 -1，则表示当前节点的子节点序列结束，准备进入下一个节点。
代码使用两个索引 currentNodeIdx 和 childNodeIdx 来分别跟踪当前节点和子节点的索引，并建立节点之间的连接。

DFS 样本数量计算：

通过 DFS 从根节点开始遍历整棵树。每当访问一个子节点时，将其样本数量累加到父节点的样本数量中。
该过程保证了每个节点在计算时，其所有子节点的样本数量已被计算完成。

输出格式化：

输出根节点的样本数量后，按层序遍历的顺序输出每个节点的样本数量，节点之间通过 -1 进行分隔。
在输出过程中，使用 visited 数组确保每个节点只输出一次。

复杂度分析：

时间复杂度为 O(N)，其中 N 为节点数，因为每个节点和边只被访问一次。
空间复杂度也是 O(N)，主要是用于存储树结构和样本数量的数组。

cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_NODES = 1010; // 最大节点数量
int sampleCount[MAX_NODES]; // 每个节点的样本数量
int n; // 节点总数
vector<int> tree[MAX_NODES]; // 存储树的邻接表
bool visited[MAX_NODES]; // 访问标记，用于DFS

// 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
void dfs(int currentNode, int parentNode) {
for (auto childNode : tree[currentNode]) {
if (childNode == parentNode) continue; // 避免访问父节点
dfs(childNode, currentNode); // 递归访问子节点
sampleCount[currentNode] += sampleCount[childNode]; // 累加子节点的样本数
}
}

int main() {
cin >> n; // 读取节点总数
int currentNodeIdx = 1; // 当前节点索引（从1开始）
int childNodeIdx = 1; // 子节点索引（从1开始）

for (int i = 1; i <= 2 * n; i++) {
int value; // 当前输入的值
cin >> value;
if (value == -1) {
currentNodeIdx++; // 进入下一个节点的子节点序列
} else {
sampleCount[childNodeIdx] = value; // 记录当前节点的样本数
childNodeIdx++;
// 连接当前节点与父节点（currentNodeIdx - 1）
if (childNodeIdx > 2) { // 确保至少有一个子节点
tree[currentNodeIdx - 1].push_back(childNodeIdx - 1); // 添加子节点
tree[childNodeIdx - 1].push_back(currentNodeIdx - 1); // 添加父节点
}
}
}

dfs(1, -1); // 从根节点1开始进行DFS计算样本总数

cout << sampleCount[1] << " " << -1 << " "; // 输出根节点的样本总数和分隔符
visited[1] = true; // 标记根节点为已访问

for (int i = 1; i <= n; i++) {
int size = tree[i].size(); // 当前节点的子节点数量
if (size > 1) { // 如果当前节点有多个子节点
for (int j = 0; j < size; j++) {
int childNode = tree[i][j]; // 当前子节点
if (!visited[childNode]) { // 如果该子节点未被访问过
visited[childNode] = true; // 标记为已访问
cout << sampleCount[childNode] << " "; // 输出子节点的样本数
}
}
}
if (i != n) cout << -1 << " "; // 输出分隔符
}

return 0; // 程序结束
}

python
# 最大节点数量
MAX_NODES = 1010
# 每个节点的样本数量
sample_count = [0] * MAX_NODES
# 节点总数
n = 0
# 存储树的邻接表
tree = [[] for _ in range(MAX_NODES)]
# 访问标记，用于DFS
visited = [False] * MAX_NODES

# 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
def dfs(current_node, parent_node):
for child_node in tree[current_node]:
if child_node == parent_node:
continue  # 避免访问父节点
dfs(child_node, current_node)  # 递归访问子节点
sample_count[current_node] += sample_count[child_node]  # 累加子节点的样本数

def main():
global n
n = int(input())  # 读取节点总数
current_node_idx = 1  # 当前节点索引（从1开始）
child_node_idx = 1  # 子节点索引（从1开始）

# 读取所有输入值
values = list(map(int, input().split()))

for value in values:
if value == -1:
current_node_idx += 1  # 进入下一个节点的子节点序列
else:
sample_count[child_node_idx] = value  # 记录当前节点的样本数
child_node_idx += 1
# 连接当前节点与父节点（current_node_idx - 1）
if child_node_idx > 2:  # 确保至少有一个子节点
tree[current_node_idx - 1].append(child_node_idx - 1)  # 添加子节点
tree[child_node_idx - 1].append(current_node_idx - 1)  # 添加父节点

dfs(1, -1)  # 从根节点1开始进行DFS计算样本总数

print(sample_count[1], -1, end=" ")  # 输出根节点的样本总数和分隔符
visited[1] = True  # 标记根节点为已访问

for i in range(1, n + 1):
size = len(tree[i])  # 当前节点的子节点数量
if size > 1:  # 如果当前节点有多个子节点
for j in range(size):
child_node = tree[i][j]  # 当前子节点
if not visited[child_node]:  # 如果该子节点未被访问过
visited[child_node] = True  # 标记为已访问
print(sample_count[child_node], end=" ")  # 输出子节点的样本数
if i != n:
print(-1, end=" ")  # 输出分隔符

if __name__ == "__main__":
main()  # 调用主函数

java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
static final int MAX_NODES = 1010; // 最大节点数量
static int[] sampleCount = new int[MAX_NODES]; // 每个节点的样本数量
static List<Integer>[] tree = new ArrayList[MAX_NODES]; // 存储树的邻接表
static boolean[] visited = new boolean[MAX_NODES]; // 访问标记，用于DFS
static int n; // 节点总数

// 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
static void dfs(int currentNode, int parentNode) {
for (int childNode : tree[currentNode]) {
if (childNode == parentNode) continue; // 避免访问父节点
dfs(childNode, currentNode); // 递归访问子节点
sampleCount[currentNode] += sampleCount[childNode]; // 累加子节点的样本数
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt(); // 读取节点总数

// 初始化邻接表
for (int i = 0; i < MAX_NODES; i++) {
tree[i] = new ArrayList<>();
}

int currentNodeIdx = 1; // 当前节点索引（从1开始）
int childNodeIdx = 1; // 子节点索引（从1开始）

for (int i = 1; i <= 2 * n; i++) {
int value = scanner.nextInt(); // 当前输入的值
if (value == -1) {
currentNodeIdx++; // 进入下一个节点的子节点序列
} else {
sampleCount[childNodeIdx] = value; // 记录当前节点的样本数
childNodeIdx++;
// 连接当前节点与父节点（currentNodeIdx - 1）
if (childNodeIdx > 2) { // 确保至少有一个子节点
tree[currentNodeIdx - 1].add(childNodeIdx - 1); // 添加子节点
tree[childNodeIdx - 1].add(currentNodeIdx - 1); // 添加父节点
}
}
}

dfs(1, -1); // 从根节点1开始进行DFS计算样本总数

System.out.print(sampleCount[1] + " " + -1 + " "); // 输出根节点的样本总数和分隔符
visited[1] = true; // 标记根节点为已访问

for (int i = 1; i <= n; i++) {
int size = tree[i].size(); // 当前节点的子节点数量
if (size > 1) { // 如果当前节点有多个子节点
for (int j = 0; j < size; j++) {
int childNode = tree[i].get(j); // 当前子节点
if (!visited[childNode]) { // 如果该子节点未被访问过
visited[childNode] = true; // 标记为已访问
System.out.print(sampleCount[childNode] + " "); // 输出子节点的样本数
}
}
}
if (i != n) System.out.print(-1 + " "); // 输出分隔符
}

scanner.close(); // 关闭扫描器
}
}

---

### 第2题-序列化热点调用栈树（P2259）
- 链接：https://codefun2000.com/p/P2259

> 页面标题：#P2259. 第2题-序列化热点调用栈树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

调用栈指从主函数执行到某个函数的调用路径，
如 AAA->BBB ，经过这条调用栈到达的其他调用栈称为其子调用栈，如 AAA->BBB->DDD 是 AAA->BBB 的子调用栈；
使用某性能分析工具对软件运行过程中的调用栈进行采样分析，得到的热点调用栈数据为树形结构。
树的每个节点代表一条调用栈，子节点为父节点的子调用栈，每个节点有一个数值为采样到该调用栈的样本数量。
现需要刷新各节点的数值为包含其子调用栈的总样本数量，请编码实现。
数的层序遍历，指的是从上到下遍历每层，每层从左到右遍历各节点；为了标识子节点关系，对于 NNN 个节点的树的层序遍历，插入 NNN 个 −1-1−1 ，第 iii 个 −1-1−1 和第 i+1i+1i+1 个 −1-1−1 中间的节点序列为第 iii 个节点的子节点序列，根节点为第 111 个节点;
输入描述
第一行为树的总节点数量 NNN ，取值范围 [1，1000][1，1000][1，1000] ；
第二行为树的序列化输入，采用层序遍历，共 2N2N2N 个数据，包括 NNN 个节点的样本数和 NNN 个节点的子节点序列的分隔符(参见示例)；
各节点样本数取值范围 [0，10000][0，10000][0，10000] ；
输出描述
输出刷新各节点数值后的树，与输入格式保持一致。
样例1
输入
6
5 -1 2 3 8 -1 -1 1 7 -1 -1 -1

输出
26 -1 2 11 8 -1 -1 1 7 -1 -1 -1

说明
第一行表示树一共有 666 个节点:
第二行为按照层序遍历的序列化输入，共 121212 个数据(含 666 个节点的样本数和 666 个节点的子节点序列的分隔符)，含义分别为：

5：第一个节点(即根节点)样本数为5；
-1：分隔第一个节点(即根节点)的子节点序列；
2：第二个节点的样本数为2，它是第一个节点(即根节点)的第一个子节点；
3：第三个节点的样本数为3，它是第一个节点(即根节点)的第二个子节点；
8：第四个节点的样本数为8，它是第一个节点(即根节点)的第三个子节点；
-1：分隔第二个节点的子节点序列；后续无有效数值，表示该节点无子节点；
-1：分隔第三个节点的子节点序列；
1：第五个节点的样本数为1，它是第三个节点的第一个子节点；
7：第六个节点的样本数为7，它是第三个节点的第二个子节点；
-1：分隔第四个节点的子节点，后续无有效数值，表示该节点无子节点；
-1：分隔第五个节点的子节点，后续无有效数值，表示该节点无子节点；
-1：分隔第六个节点的子节点，后续无有效数值，表示该节点无子节点；

构造输入树形结构：

根据树形结构计算各节点包含子节点的样本数:
调用栈 AAA->CCC 有子调用栈 AAA->CCC->EEE 和 AAA->CCC->FFF ，其包含子调用栈的样本数量为 3+1+7=113+1+7=113+1+7=11；
根节点调用栈 AAA 包含了调用栈 AAA->BBB、AAA->CCC 和 AAA->DDD，其包含子调用栈的样本数量为 5+2+11+8=265+2+11+8=265+2+11+8=26;
刷新后的热点调用栈树:

按照层序遍历序列化输出:

26 -1 2 11 8 -1 -1 1 7 -1 -1 -1

#### TextSol

题面描述
本题要求我们处理一个表示调用栈的树形结构，树的每个节点包含一个样本数量，节点间通过分隔符 -1 来标识。输入包含树的节点总数和层序遍历的序列化数据，输出需要更新每个节点的样本数量，使其等于该节点自身的样本数量加上所有子节点的样本数量之和。通过解析输入构建树，计算新样本数量后，按相同格式输出更新后的数据。
思路
就是很简单的树的递归求和，dfsdfsdfs一遍即可，输入输出比较抽象注意处理
具体实现

数据结构定义：

使用 sampleCount 数组来存储每个节点的样本数量。
tree 是一个邻接表，用于存储树的结构，便于进行深度优先搜索（DFS）。
visited 数组用于标记节点是否被访问，以避免重复访问。

输入处理：

首先读取节点总数 n。
然后，通过一个循环读取 2*n 个值，分别代表节点的样本数和分隔符 -1。如果读到 -1，则表示当前节点的子节点序列结束，准备进入下一个节点。
代码使用两个索引 currentNodeIdx 和 childNodeIdx 来分别跟踪当前节点和子节点的索引，并建立节点之间的连接。

DFS 样本数量计算：

通过 DFS 从根节点开始遍历整棵树。每当访问一个子节点时，将其样本数量累加到父节点的样本数量中。
该过程保证了每个节点在计算时，其所有子节点的样本数量已被计算完成。

输出格式化：

输出根节点的样本数量后，按层序遍历的顺序输出每个节点的样本数量，节点之间通过 -1 进行分隔。
在输出过程中，使用 visited 数组确保每个节点只输出一次。

复杂度分析：

时间复杂度为 O(N)，其中 N 为节点数，因为每个节点和边只被访问一次。
空间复杂度也是 O(N)，主要是用于存储树结构和样本数量的数组。

cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_NODES = 1010; // 最大节点数量
int sampleCount[MAX_NODES]; // 每个节点的样本数量
int n; // 节点总数
vector<int> tree[MAX_NODES]; // 存储树的邻接表
bool visited[MAX_NODES]; // 访问标记，用于DFS

// 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
void dfs(int currentNode, int parentNode) {
for (auto childNode : tree[currentNode]) {
if (childNode == parentNode) continue; // 避免访问父节点
dfs(childNode, currentNode); // 递归访问子节点
sampleCount[currentNode] += sampleCount[childNode]; // 累加子节点的样本数
}
}

int main() {
cin >> n; // 读取节点总数
int currentNodeIdx = 1; // 当前节点索引（从1开始）
int childNodeIdx = 1; // 子节点索引（从1开始）

for (int i = 1; i <= 2 * n; i++) {
int value; // 当前输入的值
cin >> value;
if (value == -1) {
currentNodeIdx++; // 进入下一个节点的子节点序列
} else {
sampleCount[childNodeIdx] = value; // 记录当前节点的样本数
childNodeIdx++;
// 连接当前节点与父节点（currentNodeIdx - 1）
if (childNodeIdx > 2) { // 确保至少有一个子节点
tree[currentNodeIdx - 1].push_back(childNodeIdx - 1); // 添加子节点
tree[childNodeIdx - 1].push_back(currentNodeIdx - 1); // 添加父节点
}
}
}

dfs(1, -1); // 从根节点1开始进行DFS计算样本总数

cout << sampleCount[1] << " " << -1 << " "; // 输出根节点的样本总数和分隔符
visited[1] = true; // 标记根节点为已访问

for (int i = 1; i <= n; i++) {
int size = tree[i].size(); // 当前节点的子节点数量
if (size > 1) { // 如果当前节点有多个子节点
for (int j = 0; j < size; j++) {
int childNode = tree[i][j]; // 当前子节点
if (!visited[childNode]) { // 如果该子节点未被访问过
visited[childNode] = true; // 标记为已访问
cout << sampleCount[childNode] << " "; // 输出子节点的样本数
}
}
}
if (i != n) cout << -1 << " "; // 输出分隔符
}

return 0; // 程序结束
}

python
# 最大节点数量
MAX_NODES = 1010
# 每个节点的样本数量
sample_count = [0] * MAX_NODES
# 节点总数
n = 0
# 存储树的邻接表
tree = [[] for _ in range(MAX_NODES)]
# 访问标记，用于DFS
visited = [False] * MAX_NODES

# 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
def dfs(current_node, parent_node):
for child_node in tree[current_node]:
if child_node == parent_node:
continue  # 避免访问父节点
dfs(child_node, current_node)  # 递归访问子节点
sample_count[current_node] += sample_count[child_node]  # 累加子节点的样本数

def main():
global n
n = int(input())  # 读取节点总数
current_node_idx = 1  # 当前节点索引（从1开始）
child_node_idx = 1  # 子节点索引（从1开始）

# 读取所有输入值
values = list(map(int, input().split()))

for value in values:
if value == -1:
current_node_idx += 1  # 进入下一个节点的子节点序列
else:
sample_count[child_node_idx] = value  # 记录当前节点的样本数
child_node_idx += 1
# 连接当前节点与父节点（current_node_idx - 1）
if child_node_idx > 2:  # 确保至少有一个子节点
tree[current_node_idx - 1].append(child_node_idx - 1)  # 添加子节点
tree[child_node_idx - 1].append(current_node_idx - 1)  # 添加父节点

dfs(1, -1)  # 从根节点1开始进行DFS计算样本总数

print(sample_count[1], -1, end=" ")  # 输出根节点的样本总数和分隔符
visited[1] = True  # 标记根节点为已访问

for i in range(1, n + 1):
size = len(tree[i])  # 当前节点的子节点数量
if size > 1:  # 如果当前节点有多个子节点
for j in range(size):
child_node = tree[i][j]  # 当前子节点
if not visited[child_node]:  # 如果该子节点未被访问过
visited[child_node] = True  # 标记为已访问
print(sample_count[child_node], end=" ")  # 输出子节点的样本数
if i != n:
print(-1, end=" ")  # 输出分隔符

if __name__ == "__main__":
main()  # 调用主函数

java
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
static final int MAX_NODES = 1010; // 最大节点数量
static int[] sampleCount = new int[MAX_NODES]; // 每个节点的样本数量
static List<Integer>[] tree = new ArrayList[MAX_NODES]; // 存储树的邻接表
static boolean[] visited = new boolean[MAX_NODES]; // 访问标记，用于DFS
static int n; // 节点总数

// 深度优先搜索（DFS）函数，计算每个节点包含子节点的样本总数
static void dfs(int currentNode, int parentNode) {
for (int childNode : tree[currentNode]) {
if (childNode == parentNode) continue; // 避免访问父节点
dfs(childNode, currentNode); // 递归访问子节点
sampleCount[currentNode] += sampleCount[childNode]; // 累加子节点的样本数
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt(); // 读取节点总数

// 初始化邻接表
for (int i = 0; i < MAX_NODES; i++) {
tree[i] = new ArrayList<>();
}

int currentNodeIdx = 1; // 当前节点索引（从1开始）
int childNodeIdx = 1; // 子节点索引（从1开始）

for (int i = 1; i <= 2 * n; i++) {
int value = scanner.nextInt(); // 当前输入的值
if (value == -1) {
currentNodeIdx++; // 进入下一个节点的子节点序列
} else {
sampleCount[childNodeIdx] = value; // 记录当前节点的样本数
childNodeIdx++;
// 连接当前节点与父节点（currentNodeIdx - 1）
if (childNodeIdx > 2) { // 确保至少有一个子节点
tree[currentNodeIdx - 1].add(childNodeIdx - 1); // 添加子节点
tree[childNodeIdx - 1].add(currentNodeIdx - 1); // 添加父节点
}
}
}

dfs(1, -1); // 从根节点1开始进行DFS计算样本总数

System.out.print(sampleCount[1] + " " + -1 + " "); // 输出根节点的样本总数和分隔符
visited[1] = true; // 标记根节点为已访问

for (int i = 1; i <= n; i++) {
int size = tree[i].size(); // 当前节点的子节点数量
if (size > 1) { // 如果当前节点有多个子节点
for (int j = 0; j < size; j++) {
int childNode = tree[i].get(j); // 当前子节点
if (!visited[childNode]) { // 如果该子节点未被访问过
visited[childNode] = true; // 标记为已访问
System.out.print(sampleCount[childNode] + " "); // 输出子节点的样本数
}
}
}
if (i != n) System.out.print(-1 + " "); // 输出分隔符
}

scanner.close(); // 关闭扫描器
}
}

---

### 第2题-最小换序代价（P2262）
- 链接：https://codefun2000.com/p/P2262

> 页面标题：#P2262. 第2题-最小换序代价

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定 222 个长度为均为 nnn 的整数数组 nums1nums1nums1 和 nums2nums2nums2 ，每次操作可以交换数组 nums2nums2nums2 中任意 222 个元素，其代价为两个下标的和。
目标是对于所有的下标 iii 。0<=i<n0<=i<n0<=i<n ，nnn 为数组的长度，都满足nums1[i]≠nums2[i]nums1[i] \neq nums2[i]nums1[i]=nums2[i]。
返回满足目标的最小代价和，如果达不成目标，返回 −1-1−1 。
输入描述
输入格式:
第一行输入整数数组的长度 nnn
第二行输入长度为 nnn 的整数数组 nums1nums1nums1
第二行输入长度为 nnn 的整数数组 nums2nums2nums2
1<=n<=1051 <=n <= 10^51<=n<=105
1<=nums1[i],nums2[i]<=1051 <= nums1[i],nums2[i]<=10^51<=nums1[i],nums2[i]<=105
输出描述
最小代价和
样例1
输入
4
1 2 3 4
1 2 3 4

输出
6

说明
其中代价和最小的一种方法为:
交换下标为 000 和 111 的两个值，代价为 0+1=10+1=10+1=1 ，现在 nums1=[2,1,3,4]nums1=[2,1,3,4]nums1=[2,1,3,4] 。
交换下标为 222 和 333 的两个值，代价为 2+3=52+3=52+3=5 ，现在 nums1=[2,1,4,3]nums1=[2,1,4,3]nums1=[2,1,4,3]。
总代价为 666 。
样例2
输入
3
2 1 1
1 1 2

输出
-1

说明
无论怎么操作，都无法要求。所以返回 −1-1−1 。

▶️

#### TextSol

video solution

题面描述:
给定两个长度为 nnn 的整数数组 nums1nums1nums1 和 nums2nums2nums2，可以通过交换数组 nums2nums2nums2 中任意两个元素来使得所有下标 iii 满足 nums1[i]=nums2[i]nums1[i] = nums2[i]nums1[i]=nums2[i]，每次交换的代价为两个被交换元素下标的和。目标是计算使两个数组在对应位置相等的最小代价和，如果无法通过交换使两个数组相等，则返回 −1-1−1。输入格式为：第一行输入整数 nnn，表示数组的长度；第二行和第三行分别输入长度为 nnn 的数组 nums1nums1nums1 和 nums2nums2nums2。输出格式为满足要求的最小代价和，或无法满足时输出 −1-1−1。
思路:
记需要交换的总对数为 swapCount，其中要交换的数的众数为 modeValue，众数个数为 modeCount，我们分两种情况讨论：

如果 modeCount <= swapCount / 2，即众数个数为总数的一半：

如果 swapCount 为偶数，那么可以直接内部两两交换即可。
如果 swapCount 为奇数，记为 2*k + 1，那么最极端的情况也是 k 个 a，k 个 b，1 个 c，这样才能拼成一个奇数且满足众数个数不超过总数一半。
那么让 k - 1 个 a 和 k - 1 个 b 交换，剩下一个 a、b 和 c，那么至少有两个数可以和 nums1[0] 交换，剩下两个交换即可，依然可以内部解决。

如果 modeCount > swapCount / 2，只需从前往后找不相等且不等于众数的数与众数交换，最后应满足 modeCount <= swapCount / 2。如不能满足则输出 -1。

代码详解

变量定义：

swapCount：需要交换的元素总个数，即满足 nums1[i] == nums2[i] 的那些元素。
modeCount：记录当前众数的数量。
modeValue：当前的众数，即出现最多的数。

第一遍遍历数组：

统计哪些元素需要被交换（即 nums1[i] == nums2[i] 的那些元素）。
更新这些元素的出现次数，并确定当前的众数和众数的数量。

第二遍遍历数组：

如果众数的数量超过了总交换数的一半，需要逐步处理不等于众数的元素，尝试与众数进行交换，直到众数的个数不再超过总数的一半。

输出结果：

如果通过交换不能满足要求（即 modeCount > swapCount / 2），则输出 -1。
否则，输出最小的交换代价 totalCost。

cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_SIZE = 1e5 + 10;
int nums1[MAX_SIZE], nums2[MAX_SIZE];
int swapCount; // 需要交换的元素总数
int modeCount; // 众数的个数
int countMap[MAX_SIZE]; // 记录每个数的个数
int modeValue; // 众数的值

signed main() {
int n;
cin >> n; // 输入数组的长度
for (int i = 0; i < n; i++) cin >> nums1[i]; // 输入第一个数组
for (int i = 0; i < n; i++) cin >> nums2[i]; // 输入第二个数组

int totalCost = 0; // 记录总交换代价

// 统计冲突的元素
for (int i = 0; i < n; i++) {
if (nums1[i] == nums2[i]) {
totalCost += i; // 当前索引的代价
++swapCount; // 需要交换的总数增加
++countMap[nums1[i]]; // 统计当前元素的个数

// 更新众数和众数个数
int currentValue = nums1[i];
if (countMap[currentValue] > modeCount) {
modeCount = countMap[currentValue];
modeValue = currentValue;
}
}
}

// 处理冲突的元素
for (int i = 0; i < n && modeCount * 2 > swapCount; i++) {
int a = nums1[i], b = nums2[i];
// 交换众数与其他不同的元素
if (a != b && a != modeValue && b != modeValue) {
totalCost += i; // 计算交换代价
++swapCount; // 需要交换的总数增加
}
}

// 判断是否能满足条件
if (modeCount * 2 > swapCount) {
cout << -1 << endl; // 无法满足条件
} else {
cout << totalCost << endl; // 输出总交换代价
}

return 0;
}

python
# 定义常量和初始化数组
MAX_SIZE = int(1e5 + 10)
nums1 = [0] * MAX_SIZE
nums2 = [0] * MAX_SIZE
swapCount = 0  # 需要交换的数的总个数
modeCount = 0   # 记录当前众数的个数
countMap = [0] * MAX_SIZE  # 记录每个数的出现次数
modeValue = 0  # 当前的众数

# 输入数组长度和元素
n = int(input())
nums1 = list(map(int, input().split()))
nums2 = list(map(int, input().split()))

totalCost = 0  # 记录总交换代价

# 第一遍遍历数组，统计需要交换的元素
for i in range(n):
if nums1[i] == nums2[i]:
totalCost += i  # 计算交换代价
swapCount += 1  # 交换总数增加
countMap[nums1[i]] += 1  # 记录当前元素的出现次数
currentValue = nums1[i]  # 当前元素值

# 更新众数和众数的个数
if countMap[currentValue] > modeCount:
modeCount = countMap[currentValue]
modeValue = currentValue

# 第二遍遍历数组，处理众数
for i in range(n):
if modeCount * 2 <= swapCount:
break  # 如果众数个数不超过总数的一半，结束处理

a = nums1[i]
b = nums2[i]

# 交换不等于众数的元素
if a != b and a != modeValue and b != modeValue:
totalCost += i  # 计算交换代价
swapCount += 1  # 交换总数增加

# 输出结果
if modeCount * 2 > swapCount:
print(-1)  # 无法满足条件
else:
print(totalCost)  # 输出总交换代价

java
import java.util.Scanner;

public class Main {
public static final int MAX_SIZE = (int) 1e5 + 10;
public static int[] nums1 = new int[MAX_SIZE];
public static int[] nums2 = new int[MAX_SIZE];
public static int swapCount = 0; // 需要交换的元素总个数
public static int modeCount = 0; // 当前众数的个数
public static int[] countMap = new int[MAX_SIZE]; // 记录每个数的出现次数
public static int modeValue = 0; // 当前的众数

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt(); // 输入数组长度

// 输入第一个数组
for (int i = 0; i < n; i++) {
nums1[i] = sc.nextInt();
}
// 输入第二个数组
for (int i = 0; i < n; i++) {
nums2[i] = sc.nextInt();
}

int totalCost = 0; // 记录总交换代价

// 第一遍遍历数组，统计需要交换的元素
for (int i = 0; i < n; i++) {
if (nums1[i] == nums2[i]) {
totalCost += i; // 计算交换代价
swapCount++; // 交换总数增加
countMap[nums1[i]]++; // 记录当前元素的出现次数
int currentValue = nums1[i]; // 当前元素值

// 更新众数和众数的个数
if (countMap[currentValue] > modeCount) {
modeCount = countMap[currentValue];
modeValue = currentValue;
}
}
}

// 第二遍遍历数组，处理众数
for (int i = 0; i < n && modeCount * 2 > swapCount; i++) {
int a = nums1[i];
int b = nums2[i];
// 交换不等于众数的元素
if (a != b && a != modeValue && b != modeValue) {
totalCost += i; // 计算交换代价
swapCount++; // 交换总数增加
}
}

// 输出结果
if (modeCount * 2 > swapCount) {
System.out.println(-1); // 无法满足条件
} else {
System.out.println(totalCost); // 输出总交换代价
}

sc.close(); // 关闭输入流
}
}

---

### 第2题-解密字符串（P2253）
- 链接：https://codefun2000.com/p/P2253

> 页面标题：#P2253. 第2题-解密字符串

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个加密字符串SSS，你需要按照以下规则对其解密并输出。解密规则:
111.若当前字符为字母A−ZA-ZA−Z，a−za-za−z，无需解密，原样输出。
222.若当前字符为'('，则其后会跟两个正整数x、yx、yx、y和一个字符')’，正整数xxx和yyy之间以逗号为分隔符，你需从当前解密串倒数第xxx个字符开始复制yyy个字符作为解密后的信息输出。
需要考虑yyy大于“剩余可复制字符数"的情况，此时复制需要多次完成先复制全部剩余字符输出，此时解密串的长度已变长，继续111次或者多次复制，直到复制完yyy个字符。参考样例111和样例222。
约束:

0<s.length<=10000< s.length <=10000<s.length<=1000，解密后的字符串长度<=2000<=2000<=2000
0<x<=990 < x <= 990<x<=99, 0<y<=990 < y <= 990<y<=99，且输入保证xxx不会越界，即xxx小于当前解密串的长度。
输入的字符串中只包含大小写字母和(x,yx,yx,y)格式子串

输入描述
输入共一行，代表加密字符串，包含大小写字母和(x,yx,yx,y)格式子串
输出描述
输出共一行，表示解密后的字符串，只包含大小写字母
样例1
输入
ABCDE(3,2)(2,3)

输出
ABCDECDCDC

说明
ABCDE ABCDEABCDE不需要解密，原样输出。
(3,23,23,2)解密，向后退3个字符，
ABCDE
|

复制222个字符，得到ABCDECDABCDECDABCDECD,(3,23,23,2)解密结束;
(2,32,32,3)解密，向后退222个字符，
ABCDECD
|

只有222个字符，先复制222个字符CDCDCD，得到ABCDECDCDABCDECDCDABCDECDCD,
ABCDECDCD
|

继续复制1个字符CCC，得到ABCDECDCDCABCDECDCDCABCDECDCDC。(2,32,32,3)解密完毕。
样例2
输入
ABCD(3,8)(10,10)mn

输出
ABCDBCDBCDBCCDBCDBCDBCmn

说明
ABCD ABCDABCD不需要解密，原样输出，
(3,83,83,8)解密，向后退333个字符，到字符BBB的位置
ABCD
|

先复制333个字符得到ABCDBCDABCDBCDABCDBCD,还剩下5个字符待复制
ABCDBCD
|

再复制333个字符得到ABCDBCDBCDABCDBCDBCDABCDBCDBCD,还剩下222个字符复制
ABCDBCDBCD
|

再复制222个字符得到ABCDBCDBCDBCABCDBCDBCDBCABCDBCDBCDBC，还剩下000个字符待复制，(3,83,83,8)解密结束
(10,1010,1010,10)解密,向后退101010个字符
ABCDBCDBCDBC
|

复制10个字符得到ABCDBCDBCDBCCDBCDBCDBCABCDBCDBCDBCCDBCDBCDBCABCDBCDBCDBCCDBCDBCDBC,(10,1010,1010,10)解密结束
mnmnmn不需要解密，原样输出，解密结束，结果为:ABCDBCDBCDBCCDBCDBCDBCmnABCDBCDBCDBCCDBCDBCDBCmnABCDBCDBCDBCCDBCDBCDBCmn

#### TextSol

题目描述
给定一个加密字符串 SSS，需要按照以下规则对其进行解密并输出。
解密规则：

字母字符：若当前字符为字母 A-Z、a-z，无需解密，原样输出。

括号表达式：若当前字符为 '('，则其后会跟两个正整数 x、y，以及一个右括号 ')'，其中正整数 x 和 y 之间以逗号分隔。你需要从当前解密串的末尾向前数第 x 个字符开始，复制长度为 y 的字符串并追加到解密结果中。

需要注意的是，如果 y 大于可复制的字符数，则需要多次复制，直到复制满 y 个字符。复制过程中，解密串的长度会增加，这会影响后续的复制操作。
思路
模拟，枚举原始字符串碰到括号进行substr操作即可。
具体模拟步骤

逐字符处理：遍历输入字符串，对于每个字符，按照规则处理。

解析括号表达式：当遇到 '(' 时，需要解析出两个整数 x 和 y。

处理复制操作：

计算复制的起始位置：pos = res.length() - x。
复制长度为 y 的字符串，如果剩余可复制的字符数不足 y，则需要多次复制，直到复制满 y 个字符。

更新解密结果：在复制过程中，解密结果 res 的长度会增加，需要动态更新。

cpp
#include <iostream>
#include <string>

int main() {
std::string s; // 输入的加密字符串
std::getline(std::cin, s);
std::string res; // 解密后的结果字符串
for (size_t i = 0; i < s.length(); ++i) {
if (s[i] == '(') {
// 解析 x 和 y
int x = 0, y = 0;
++i; // 跳过 '('
// 解析 x
while (s[i] != ',') {
x = x * 10 + (s[i] - '0');
++i;
}
++i; // 跳过 ','
// 解析 y
while (s[i] != ')') {
y = y * 10 + (s[i] - '0');
++i;
}
// 进行复制操作
int pos = res.length() - x; // 复制的起始位置
while (y > 0) {
int len = std::min((int)res.length() - pos, y); // 本次可复制的长度
res += res.substr(pos, len); // 追加复制的字符串
y -= len; // 更新剩余需要复制的长度
}
} else {
// 字母字符，直接添加到结果中
res += s[i];
}
}
// 输出解密后的字符串
std::cout << res << std::endl;
return 0;
}

python
s = input()
res = ''
i = 0
while i < len(s):
if s[i] == '(':
i += 1  # 跳过 '('
x = 0
while s[i] != ',':
x = x * 10 + int(s[i])
i += 1
i += 1  # 跳过 ','
y = 0
while s[i] != ')':
y = y * 10 + int(s[i])
i += 1
i += 1  # 跳过 ')'
pos = len(res) - x  # 复制的起始位置
while y > 0:
length = min(len(res) - pos, y)  # 本次可复制的长度
res += res[pos:pos+length]  # 追加复制的字符串
y -= length  # 更新剩余需要复制的长度
else:
res += s[i]
i += 1
print(res)

java
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String s = sc.nextLine();
StringBuilder res = new StringBuilder();
int i = 0;
while (i < s.length()) {
if (s.charAt(i) == '(') {
i++; // 跳过 '('
int x = 0;
while (s.charAt(i) != ',') {
x = x * 10 + (s.charAt(i) - '0');
i++;
}
i++; // 跳过 ','
int y = 0;
while (s.charAt(i) != ')') {
y = y * 10 + (s.charAt(i) - '0');
i++;
}
i++; // 跳过 ')'
int pos = res.length() - x; // 复制的起始位置
while (y > 0) {
int len = Math.min(res.length() - pos, y); // 本次可复制的长度
res.append(res.substring(pos, pos + len)); // 追加复制的字符串
y -= len; // 更新剩余需要复制的长度
}
} else {
res.append(s.charAt(i));
i++;
}
}
System.out.println(res.toString());
}
}

---

### 第2题-铺设消防栓（P2256）
- 链接：https://codefun2000.com/p/P2256

> 页面标题：#P2256. 第2题-铺设消防栓

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

消防员正在给城市铺设消防栓，城市的道路可以看作一个连通且无回路的图，每条道路有两个底座，消防栓必须铺设在底座上，每条道路必须有消防栓盖；交叉路口只有一个消防栓底座；交叉路口的消防栓可以覆盖连接的所有道路，求至少需要多少个消防栓才能覆盖城市所有的道路?
输入描述
每个 casecasecase ，第一行一个整数 nnn ，表示底座数。(1<=n<=15001<=n<=15001<=n<=1500)
接下来 nnn 行，每行以 a:(b)a:(b)a:(b) 这样的格式开头，aaa 表示底座的编号(0<=a<=n−10<=a<=n-10<=a<=n−1), bbb 表示与该底座相连接的底座数，接下来 bbb 个数，表示与该底座相连的底座编号。
输出描述
一个数字，为需要的消防栓的最少个数
样例1
输入
3
0:(2) 1 2
1:(0)
2:(0)

输出
1

说明
000 号底座与 111 号和 222 号相连，那么只需要在 000 号铺设一个消防栓即可覆盖所有的道路，如下图所示：

样例2
输入
8
0:(3) 1 2 3
1:(1) 6
2:(0)
3:(0)
6:(1) 7
7:(2) 4 5
4:(0)
5:(0)

输出
3

说明

如图所示，在绿色节点上铺设消防栓即可覆盖全部道路
提示
动态规划

▶️

#### TextSol

video solution

题目描述
消防员需要在城市中铺设消防栓。城市的道路可以看作是一棵连通且无回路的树，每个节点代表一个底座，边代表道路。
1.消防栓必须安装在底座上 => 消防栓只能放置在树的节点上
2.每条道路必须有消防栓盖 => 任何一条边都需要满足：所连接的两个节点至少有一个节点上有消防栓。
3.交叉路口只有一个消防栓底座，可以覆盖所有连接的道路 =》 每个节点最多放置一个消防栓，放置了就可以覆盖所有其他节点。
4.求覆盖所有道路所需的最少消防栓数量。 =》
给定一棵树，求选出最少的节点集合setsetset , 使得a:每一个节点至少有一个邻居属于集合setsetset，且b:任意一条边所连接的两个节点至少有一个节点属于集合setsetset。
我们发现b 包含a 。 所以就是：给定一棵树，求选出最少的节点集合setsetset , 使得任意一条边所连接的两个节点至少有一个节点属于集合setsetset。
思路
要解决这个问题，最终我们需要将其转化为树的最小顶点覆盖问题，并利用动态规划进行高效求解。具体而言，对树进行深度优先搜索（DFS），为每个节点维护两个状态：选中该节点（铺设消防栓）和不选中该节点。若选中当前节点，其子节点可以选择或不选择，取最小值；若不选中当前节点，则所有子节点必须被选中以覆盖相应的道路。通过这种方式深入分析每个节点的最优选择，最终在根节点处得到覆盖所有道路所需的最少消防栓数量。

通过 DFS 遍历树，并计算每个节点的 dp 值。

dp[u][1] 表示节点 u 被选中，其值为 1 加上所有子节点的最小覆盖数（子节点可以选或不选，取最小值）。
dp[u][0] 表示节点 u 不被选中，其值为所有子节点必须被选中的覆盖数。

最终答案就是min(dp[0][0],dp[0][1])min(dp[0][0],dp[0][1])min(dp[0][0],dp[0][1])
cpp
#include <bits/stdc++.h>
using namespace std;

// 定义最大节点数
const int MAX = 1505;

// 全局变量
vector<vector<int>> adj(MAX); // 邻接表
int dp_val[MAX][2]; // dp[u][0]: u不被选中, dp[u][1]: u被选中
bool visited_flag[MAX]; // 访问标记

// 深度优先搜索计算dp值
int dfs(int u) {
visited_flag[u] = true;
dp_val[u][0] = 0; // u不被选中时，初始化为0
dp_val[u][1] = 1; // u被选中时，初始化为1
for(auto &v: adj[u]){
if(!visited_flag[v]){
dfs(v); // 递归计算子节点
dp_val[u][1] += min(dp_val[v][0], dp_val[v][1]); // u被选中，子节点可选或不选，取最小值
dp_val[u][0] += dp_val[v][1]; // u不被选中，子节点必须被选中
}
}
return min(dp_val[u][0], dp_val[u][1]); // 返回当前节点的最小覆盖数
}

int main(){
// 优化输入速度
ios::sync_with_stdio(false);
cin.tie(NULL);

int n;
// 读取直到文件结束（处理多组测试用例）
while(cin >> n){
// 清空邻接表
for(int i=0;i<n;i++) adj[i].clear();
// 读取n行描述
for(int i=0;i<n;i++){
string line;
cin >> ws; // 读取前导空格
getline(cin, line);
// 解析格式 a:(b) x1 x2 ... xb
int a, b;
size_t pos1 = line.find(":(");
a = stoi(line.substr(0, pos1));
size_t pos2 = line.find(")", pos1);
b = stoi(line.substr(pos1+2, pos2 - pos1 -2));
// 读取后面的b个数字
if(b > 0){
size_t start = pos2 + 1;
// 提取子节点编号
while(start < line.size() && line[start] == ' ') start++; // 跳过空格
string nums = line.substr(start);
// 分割数字
int v;
stringstream ss(nums);
while(ss >> v){
adj[a].push_back(v);
adj[v].push_back(a); // 无向图
}
}
}
// 重置访问标记
fill(visited_flag, visited_flag + n, false);
// 处理极端情况：只有一个节点
if(n == 1){
cout << "1\n";
continue;
}
// 假设根节点为0
cout << dfs(0) << "\n";
}
}

java
import java.util.*;
import java.io.*;

public class Main {
static int n;
static ArrayList<ArrayList<Integer>> adj;
static int[][] dp;
static boolean[] visited;

public static void main(String[] args) throws IOException{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String line;
// 读取直到文件结束（处理多组测试用例）
while((line = br.readLine()) != null){
line = line.trim();
if(line.equals("")) continue;
n = Integer.parseInt(line);
adj = new ArrayList<>();
for(int i=0;i<n;i++) adj.add(new ArrayList<>());
// 读取n行描述
for(int i=0;i<n;i++){
String desc = br.readLine();
if(desc == null || desc.trim().equals("")) continue;
desc = desc.trim();
int pos1 = desc.indexOf(":(");
int a = Integer.parseInt(desc.substring(0, pos1));
int pos2 = desc.indexOf(")", pos1);
int b = Integer.parseInt(desc.substring(pos1+2, pos2));
if(b > 0){
String connectionsStr = desc.substring(pos2+1).trim();
if(!connectionsStr.equals("")){
String[] connections = connectionsStr.split(" ");
for(int j=0; j<connections.length; j++){
if(connections[j].equals("")) continue;
int v = Integer.parseInt(connections[j]);
adj.get(a).add(v);
adj.get(v).add(a);
}
}
}
}
// 初始化DP和访问数组
dp = new int[n][2];
visited = new boolean[n];
// 处理特殊情况
if(n == 1){
System.out.println(1);
continue;
}
// 递归计算
dfs(0);
// 输出结果
System.out.println(Math.min(dp[0][0], dp[0][1]));
}
}

// 深度优先搜索计算DP值
static void dfs(int u){
visited[u] = true;
dp[u][0] = 0; // u不被选中
dp[u][1] = 1; // u被选中
for(int v : adj.get(u)){
if(!visited[v]){
dfs(v);
dp[u][1] += Math.min(dp[v][0], dp[v][1]); // u被选中，子节点可选或不选，取最小值
dp[u][0] += dp[v][1]; // u不被选中，子节点必须被选中
}
}
}
}

python
import sys
from collections import defaultdict

# 定义最大节点数
MAX = 1505

# 全局变量
adj = defaultdict(list)  # 邻接表
dp_val = [[0] * 2 for _ in range(MAX)]  # dp[u][0]: u不被选中, dp[u][1]: u被选中
visited_flag = [False] * MAX  # 访问标记

# 深度优先搜索计算dp值
def dfs(u):
visited_flag[u] = True
dp_val[u][0] = 0  # u不被选中时，初始化为0
dp_val[u][1] = 1  # u被选中时，初始化为1
for v in adj[u]:
if not visited_flag[v]:
dfs(v)  # 递归计算子节点
dp_val[u][1] += min(dp_val[v][0], dp_val[v][1])  # u被选中，子节点可选或不选，取最小值
dp_val[u][0] += dp_val[v][1]  # u不被选中，子节点必须被选中
return min(dp_val[u][0], dp_val[u][1])  # 返回当前节点的最小覆盖数

def main():
input = sys.stdin.read
data = input().strip().splitlines()
idx = 0
while idx < len(data):
n = int(data[idx].strip())
idx += 1

# 清空邻接表
adj.clear()

for i in range(n):
line = data[idx].strip()
idx += 1
# 解析格式 a:(b) x1 x2 ... xb
pos1 = line.find(":(")
a = int(line[:pos1])
pos2 = line.find(")", pos1)
b = int(line[pos1 + 2:pos2])
# 读取后面的b个数字
if b > 0:
nums = line[pos2 + 1:].strip()
neighbors = list(map(int, nums.split()))
for v in neighbors:
adj[a].append(v)
adj[v].append(a)  # 无向图

# 重置访问标记
visited_flag[:] = [False] * n

# 处理极端情况：只有一个节点
if n == 1:
print(1)
continue

# 假设根节点为0
print(dfs(0))

if __name__ == "__main__":
main()

---

### 第2题-多个集合的交集运算（P2247）
- 链接：https://codefun2000.com/p/P2247

> 页面标题：#P2247. 第2题-多个集合的交集运算

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

两个集合AAA和BBB的交集指的是，所有属于集合AAA目属于集合BBB的元素所组成的集合。
给定nnn个字符串集合，每个字符串集合si(1<=i<=n)si(1 <=i<=n)si(1<=i<=n)中字符串数目为AiAiAi，对每个字符串集合SiSiSi，请找到序号最小的j(j≠i)j(j≠i) j(j=i)满足SjSjSj与SiSiSi的交集中字符串个数最多，并输出与交集中的字符串个数。如果SiSiSi与任何其他集合的交集都为空。
我们认为交集个数全部为000，输出其他集合中序号最小的即可。例如样例111中S4输出的是1 01\ 01 0；例如S1S1S1与其他集合交集全为空，则输出2 02\ 02 0.
输入描述
第一行一个数nnn，表示字符串集合的数量;从第二行开始，共分为nnn个部分:
第iii部分第一行一个数AiAiAi，表示该字符串集合SiSiSi中的字符串数量;下接AiAiAi行，代表SiSiSi内的所有字符串。
约束:
1、1<n<=1001、1 <n <=1001、1<n<=100
2、0<Ai<=1002、0 <Ai <= 1002、0<Ai<=100
333、单个字符串的长度为len,0<len<=100len, 0 < len <= 100len,0<len<=100
字符串中只包含大小写字母与数字
输出描述
输出共nnn行，每行两个数字jjj和xxx，分隔符为111个空格；jjj代表与SiSiSi交集中字符串个数最多的是SjSjSj；xxx代表SiSiSi与SjSjSj交集中的字符串个数。
样例1
输入
4
3
123
456
789
3
234
345
4567
5
123
456
789
0123
4567
1
6789

输出
3 3
3 1
1 3
1 0

说明
1.对于字符串集合S1S1S1{"123123123","456456456","789789789}，与S3S3S3的交集中字符串个数最多，它俩的交集中有333个字符串，即{"123123123","456456456","789789789"}
222.对于字符串集合S2S2S2{"234234234","345345345'',"456745674567"}，与S3S3S3的交集中字符串个数最多，它俩的交集中有111个字符串，即{"456745674567"}
333.对于字符串集合S3S3S3{"123123123","456456456","789789789","012301230123","456745674567”}，与其S1S1S1的交集中字符串个数最多，它俩的交集中有333个字符串，即{"123123123","456456456","789789789"}
444.对于字符串集合S4S4S4{"678967896789"}，与S1、S2、S3S1、S2、S3S1、S2、S3的交集全部为空，序号最小的是S1S1S1,输出1 01\ 01 0。
样例2
输入
3
2
123
678
3
728
8888
1000
2
123
728

输出
3 1
3 1
1 1

说明
111.对于字符串集合S1S1S1{"123123123","678678678"}，与S3S3S3的交集中字符串个数最多，它俩的交集中有111个字符串，即{"123123123"}
222.对于字符串集合S2S2S2 {"728728728","888888888888","100010001000"}，与S3S3S3的交集中字符串个数最多，它俩的交集中有111个字符串，即{"728728728"}
333.对于字符串集合S3S3 S3{"123123123","728728728"}，与S1S1S1的交集中字符串个数最多，它俩的交集中有111个字符串，即{"123123123"}

▶️

#### TextSol

video solution

题解
题面描述
给定nnn个字符串集合，每个集合SiS_iSi​包含AiA_iAi​个字符串。对于每个集合SiS_iSi​，需要找到另一个集合SjS_jSj​（j≠ij \neq ij=i），使得SiS_iSi​与SjS_jSj​的交集中字符串的数量最多。如果存在多个满足条件的SjS_jSj​，则选择序号最小的那个。如果SiS_iSi​与任何其他集合的交集都为空，则选择序号最小的SjS_jSj​（j≠ij \neq ij=i），并输出交集的字符串数量为000。
思路

数据结构选择：

使用vector<set<string>>来存储所有的字符串集合。set可以自动去重，并且支持高效的查找操作（O(log⁡n)O(\log n)O(logn)时间复杂度）。

读取输入：

首先读取集合的数量nnn。
对于每个集合SiS_iSi​，读取其包含的字符串数量AiA_iAi​，然后将这些字符串存入对应的set中。

计算交集：

对于每个集合SiS_iSi​，遍历所有其他集合SjS_jSj​（j≠ij \neq ij=i），计算SiS_iSi​与SjS_jSj​的交集大小。
具体实现上，遍历SiS_iSi​中的每个字符串，检查它是否存在于SjS_jSj​中，如果存在，则计数加一。

选择最优集合：

对于每个SiS_iSi​，记录与之交集最大的SjS_jSj​的序号和交集大小。
如果有多个SjS_jSj​的交集大小相同，则选择序号最小的SjS_jSj​。
如果所有SjS_jSj​与SiS_iSi​的交集大小都为000，则选择序号最小的SjS_jSj​（j≠ij \neq ij=i），并输出交集大小为000。

处理边界情况：

当n=1n=1n=1时，只有一个集合，按照题意此时不会出现，因为1<n≤1001 < n \leq 1001<n≤100。
当某个集合SiS_iSi​与所有其他集合的交集都为空时，确保选择序号最小的SjS_jSj​（j≠ij \neq ij=i）。

cpp
#include <iostream>
#include <vector>
#include <set>
#include <string>
using namespace std;

int main(){
int n; // 集合的数量
cin >> n;
// 使用vector存储每个集合，集合内部使用set以便快速查找
vector< set<string> > sets(n);

// 读取每个集合的字符串
for(int i=0; i<n; i++){
int Ai; // 第i个集合中的字符串数量
cin >> Ai;
for(int j=0; j<Ai; j++){
string s;
cin >> s;
sets[i].insert(s); // 将字符串插入到第i个集合中
}
}

// 对于每个集合Si，寻找与其交集最大且序号最小的Sj
for(int i=0; i<n; i++){
int max_common = -1; // 当前最大的交集大小
int chosen_j = -1; // 选择的集合Sj的序号（1-based）
for(int j=0; j<n; j++){
if(j == i) continue; // 跳过与自身比较
// 计算Si与Sj的交集大小
int common = 0;
for(const auto &s : sets[i]){
if(sets[j].count(s)) common++;
}
// 如果当前交集大小大于之前的最大值，更新max_common和chosen_j
if(common > max_common){
max_common = common;
chosen_j = j+1; // 序号从1开始
}
// 如果当前交集大小等于最大值，并且j的序号更小，则更新chosen_j
else if(common == max_common && (chosen_j == -1 || (j+1) < chosen_j)){
chosen_j = j+1;
}
}
// 如果所有交集大小都是0，选择序号最小的集合Sj（j≠i）
if(max_common == 0){
chosen_j = 1;
if(chosen_j == i+1 && n >1){
chosen_j = 2;
}
}
// 输出结果：Sj的序号和交集大小
cout << chosen_j << " " << (max_common >0 ? max_common : 0) << "\n";
}
return 0;
}

python
# 读取集合的数量
n = int(input())

# 用来存储每个字符串对应的集合索引
string_to_sets = {}

# 存储每个集合的字符串元素
sets = [0]  # sets[0]不使用，集合编号从1开始

# 读取每个集合的信息
for i in range(1, n + 1):
ai = int(input())  # 当前集合的元素数量
current_set = {input() for _ in range(ai)}  # 当前集合的字符串元素
sets.append(current_set)  # 将当前集合添加到集合列表中

# 更新每个字符串所在的集合索引
for string in current_set:
if string not in string_to_sets:
string_to_sets[string] = []
string_to_sets[string].append(i)

# 对每个集合进行交集大小的计算
for i in range(1, n + 1):
intersection_count = [0] * (n + 1)  # 用来统计每个集合与集合i的交集大小

# 统计与集合i有交集的其他集合
for string in sets[i]:
for set_idx in string_to_sets[string]:
intersection_count[set_idx] += 1

# 排除集合i本身和计数器的初始化值
intersection_count[i] = intersection_count[0] = -1

# 输出与集合i交集最大的集合序号和交集大小
print(intersection_count.index(max(intersection_count)), max(intersection_count))

java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

// 读取集合的数量
int n = Integer.parseInt(scanner.nextLine());

// 用来存储每个字符串对应的集合索引
Map<String, List<Integer>> stringToSets = new HashMap<>();

// 存储每个集合的字符串元素
List<Set<String>> sets = new ArrayList<>();
sets.add(new HashSet<>());  // sets[0]不使用，集合编号从1开始

// 读取每个集合的信息
for (int i = 1; i <= n; i++) {
int ai = Integer.parseInt(scanner.nextLine());  // 当前集合的元素数量
Set<String> currentSet = new HashSet<>();
for (int j = 0; j < ai; j++) {
String str = scanner.nextLine();
currentSet.add(str);  // 当前集合的字符串元素
}
sets.add(currentSet);  // 将当前集合添加到集合列表中

// 更新每个字符串所在的集合索引
for (String str : currentSet) {
stringToSets.putIfAbsent(str, new ArrayList<>());
stringToSets.get(str).add(i);
}
}

// 对每个集合进行交集大小的计算
for (int i = 1; i <= n; i++) {
int[] intersectionCount = new int[n + 1];  // 用来统计每个集合与集合i的交集大小

// 统计与集合i有交集的其他集合
for (String str : sets.get(i)) {
for (int setIdx : stringToSets.get(str)) {
intersectionCount[setIdx] += 1;
}
}

// 排除集合i本身和计数器的初始化值
intersectionCount[i] = -1;
intersectionCount[0] = -1;

// 输出与集合i交集最大的集合序号和交集大小
int maxIntersection = -1;
int maxSetIdx = -1;
for (int j = 1; j <= n; j++) {
if (intersectionCount[j] > maxIntersection) {
maxIntersection = intersectionCount[j];
maxSetIdx = j;
}
}

System.out.println(maxSetIdx + " " + maxIntersection);
}

scanner.close();
}
}

---

### 第2题-安装监控器（P2250）
- 链接：https://codefun2000.com/p/P2250

> 页面标题：#P2250. 第2题-安装监控器

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某数据中心机房内摆放了M排N列机柜，现需要在每排选择一个机柜安装监控器来监视本排机柜的用电量，由于监控器在安装位置太近的话会产生相互干扰，安装时需要满足条件:安装监控器的机柜不能在同一排或同一列，并且不能在同一斜线上(454545°或135135135*的正斜线)，请问一共有多少种监控器安装方案。
输入描述
机柜排数MMM和列数NNN，值的范围[1，151，151，15);
输出描述
监控器安装方案数量。
如果没有方案返回000。
样例1
输入
2 3

输出
2

说明
第二排监控器需安装在第一排监控器相距222列以上的机柜，共有222种安装方案。图中000代表未安装监视器的机柜，111代表安装监控器的机柜。
111.方案1

222.方案222

样例2
输入
3 3

输出
0

说明
无法同时满足监控器所在机柜不在同一排、同一列、同一斜线上。图中000代表未安装监视器的机柜，111代表安装监控器的机柜。
111.第一排监控器所在机柜和第三排监控器所在机柜在同一列。

222.第二排监控器所在机柜和第三排监控器所在机柜在同一斜线。

▶️

#### TextSol

video solution

题解
问题分析
题目要求在一个 m * n 的矩阵中，给每一排的机柜放置一个监控器（每行只能放一个），同时要满足以下限制条件：

每列只能放一个监控器。
不能在同一条对角线上（即 45度 和 135度 的斜线）放置两个监控器。

该问题可以看成是一个变形的 "N 皇后" 问题，目标是计算出满足所有限制条件的不同放置方案的数量。
解题思路
我们可以使用深度优先搜索（DFS）和回溯算法来求解。具体步骤如下：

定义状态变量：

column_vis：用于记录已经被监控器占用的列。
left_vis：用于记录已经被占用的正对角线。对角线的索引为 ROW + COL  ，也就是说ROW + COL相同的都在同一行
right_vis：用于记录已经被占用的反对角线。对角线的索引为ROW - COl，也就是说ROW - COL相同的都在同一行

递归函数 dfs(row)：

该函数尝试在当前行 row 放置一个监控器。
如果 row 等于 n（行数），则说明已经成功放置了所有监控器，返回 1 表示找到一种有效方案。
初始化 ans 为 0，用于累加有效方案的数量。

循环遍历每一列：

遍历当前行中所有列，尝试在每个列位置放置一个监控器。
检查当前列和两条对角线是否已经被占用：

如果 col 在 column_vis，或 left 在 left_vis，或 right 在 right_vis，则跳过当前列，继续尝试其他列。

如果当前列可用，则将其加入对应的集合（表示该列和对角线被占用），并递归调用 dfs(row + 1)，继续放置下一行的监控器。
回溯：撤销当前行的放置，将 col、left 和 right 从对应集合中移除，尝试其他放置方法。

返回结果：

初始调用 dfs(0) 开始从第 0 行放置监控器。
最终返回所有可能的有效方案数。

代码实现
python
n, m = map(int, input().split())

# 初始化集合记录列和对角线的占用情况
column_vis = set()
left_vis = set()
right_vis = set()

def dfs(row):
# 如果当前行已经是第 n 行，说明前面的行已成功放置，找到一个有效方案
if row == n:
return 1

ans = 0  # 统计方案数
for col in range(m):
# 计算当前单元格的正对角线和反对角线标识
left = row + col
right = row - col

# 检查是否可以放置监控器
if col in column_vis or left in left_vis or right in right_vis:
continue

# 放置监控器并标记占用
column_vis.add(col)
left_vis.add(left)
right_vis.add(right)

# 递归搜索下一行
ans += dfs(row + 1)

# 回溯，移除占用标记
column_vis.remove(col)
left_vis.remove(left)
right_vis.remove(right)

return ans

# 输出所有有效方案数
print(dfs(0))

java
import java.util.HashSet;
import java.util.Scanner;

public class Main {
static int n, m;
static HashSet<Integer> column_vis = new HashSet<>(); // 记录已占用的列
static HashSet<Integer> left_vis = new HashSet<>();   // 正对角线 (row + col)
static HashSet<Integer> right_vis = new HashSet<>();  // 反对角线 (row - col)

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt();
m = scanner.nextInt();
scanner.close();

System.out.println(dfs(0));
}

static int dfs(int row) {
if (row == n) {
return 1; // 已放置完所有行，找到一个合法方案
}

int ans = 0;
for (int col = 0; col < m; col++) {
int left = row + col;
int right = row - col;

// 检查列和对角线是否被占用
if (column_vis.contains(col) || left_vis.contains(left) || right_vis.contains(right)) {
continue;
}

// 放置监控器并标记该列和对角线
column_vis.add(col);
left_vis.add(left);
right_vis.add(right);

// 递归调用下一行
ans += dfs(row + 1);

// 回溯，移除占用标记
column_vis.remove(col);
left_vis.remove(left);
right_vis.remove(right);
}
return ans;
}
}

C++
#include <iostream>
#include <unordered_set>
using namespace std;

int n, m;
unordered_set<int> column_vis;  // 记录已占用的列
unordered_set<int> left_vis;    // 记录正对角线占用情况 (row + col)
unordered_set<int> right_vis;   // 记录反对角线占用情况 (row - col)

int dfs(int row) {
if (row == n) {
return 1;  // 已放置完所有行，找到一个合法方案
}

int ans = 0;
for (int col = 0; col < m; ++col) {
int left = row + col;
int right = row - col;

// 检查列和对角线是否被占用
if (column_vis.count(col) || left_vis.count(left) || right_vis.count(right)) {
continue;
}

// 放置监控器并标记该列和对角线
column_vis.insert(col);
left_vis.insert(left);
right_vis.insert(right);

// 递归调用下一行
ans += dfs(row + 1);

// 回溯，移除占用标记
column_vis.erase(col);
left_vis.erase(left);
right_vis.erase(right);
}
return ans;
}

int main() {
cin >> n >> m;
cout << dfs(0) << endl;
return 0;
}

复杂度分析

时间复杂度：由于使用了回溯法，时间复杂度为 O(N!)O(N!)O(N!)，其中 N 是行数。
空间复杂度：需要额外的空间存储列和对角线的占用情况，空间复杂度为 O(N)O(N)O(N)。

---

### 第2题-商城双11大促销（P2601）
- 链接：https://codefun2000.com/p/P2601

> 页面标题：#P2601. 第2题-商城双11大促销

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

商城双111111大促销，每种商品限购两件。一共有MMM种商品。每种商品的原始价格为XXX元。买一件折扣价是YYY元，买两件折扣价是ZZZ元。其中X>=Y>=ZX>=Y>=ZX>=Y>=Z。小明银行卡里有余额NNN元。在NNN元的范围内怎么购买商品，才可以获得最多的优惠金额?
输入描述
第111行:商品种类MMM，MMM的范围是[1,20][1,20][1,20]。
第222到M+1M+1M+1行:每个商品的原始价格XXX元，购买一件的折扣价YYY元，购买两件的折扣价ZZZ元。 X\Y\Z的范围是[1,1000][1,1000][1,1000]。
第M+2M+2M+2行:小明银行卡余额NNN元。N的范围是[1,20000][1,20000][1,20000]，NNN元至少可以购买一件商品。
输出描述
输出可以获得的最多优惠金额
样例1
输入
2
10 8 6
8 6 6
20

输出
10

说明
第一个商品买222件，第二个商品买111件。总共花费2∗6+6=182^*6+6=182∗6+6=18元在202020元范围内。
第一件商品优惠888元(222件)，第二件商品优惠222元(111件)。总共优惠101010元。
样例2
输入
3
10 8 4
20 17 13
30 20 10
50

输出
55

说明
第一个商品买222件，第二个商品买111件第三个商品买222件。总共花费2∗4+17+2∗10=412^*4+17+2^*10=412∗4+17+2∗10=41元在505050元范围内。
第一件商品优惠121212元(222件)，第二件商品优惠333元(111件)，第三件商品优惠404040元(222件)，总共优惠555555元。

#### TextSol

题解
题面分析
在双11大促销中，商城共有 MMM 种商品，每种商品限购两件，原始价格为 XXX 元，购买一件的折扣价为 YYY 元，购买两件的折扣价为 ZZZ 元，其中满足 X≥Y≥ZX \geq Y \geq ZX≥Y≥Z。小明的银行卡余额为 NNN 元。在不超过 NNN 元的预算内，如何购买商品才能获得最大的优惠金额？
问题转化
本问题可以转化为 多重背包问题。具体来说：

背包容量：小明的银行卡余额 NNN 元。
物品种类：每种商品视为一种物品，每种商品有三种选择（不购买、购买一件、购买两件）。
物品属性：

不购买：花费 0 元，优惠 0 元。
购买一件：花费 YYY 元，优惠 X−YX - YX−Y 元。
购买两件：花费 2×Z2 \times Z2×Z 元，优惠 2×X−2×Z2 \times X - 2 \times Z2×X−2×Z 元。

目标是选择购买方案，使得在不超过 NNN 元的预算内，获得的总优惠金额最大化。
详细思路
1. 定义状态
使用一个一维动态规划数组 dp[j]，表示在花费不超过 jjj 元时，能够获得的最大优惠金额。

初始化：dp[0] = 0，表示不花钱时的优惠金额为 0。
其他状态：初始时，所有 dp[j]（1≤j≤N1 \leq j \leq N1≤j≤N）都设为 0。

2. 状态转移
对于每种商品，考虑三种购买方式，并更新 dp 数组：

不购买：不改变 dp[j] 的值。
购买一件：

花费：YYY 元。
优惠：X−YX - YX−Y 元。
转移：如果当前预算 jjj 满足 j≥Yj \geq Yj≥Y，则

dp[j] = max(dp[j], dp[j - Y] + (X - Y))

购买两件：

花费：2×Z2 \times Z2×Z 元。
优惠：2×X−2×Z2 \times X - 2 \times Z2×X−2×Z 元。
转移：如果当前预算 jjj 满足 j≥2×Zj \geq 2 \times Zj≥2×Z，则

dp[j] = max(dp[j], dp[j - 2 * Z] + (2 * X - 2 * Z))

注意：在进行状态转移时，应从高到低遍历预算金额 jjj，以避免在同一商品的不同购买方式之间产生重复计算。
3. 实现细节

遍历顺序：对于每种商品，先考虑购买两件，再考虑购买一件，最后是不购买。这是为了确保在计算时不会遗漏任何可能的购买组合。
避免重复计算：通过从高到低遍历预算金额，可以保证每种商品的购买方式在当前商品处理时只被使用一次。
优化空间：使用一维数组 dp 即可满足需求，无需使用二维数组。

4. 边界条件与特殊情况

最小预算：题目保证 NNN 至少可以购买一件商品，因此无需处理无法购买任何商品的情况。
商品价格：由于 X≥Y≥ZX \geq Y \geq ZX≥Y≥Z，购买两件的总花费 2×Z2 \times Z2×Z 可能小于或等于购买一件的花费 YYY。需要根据具体情况选择最优的购买方式。
商品数量限制：每种商品最多购买两件，因此在购买两件时应确保不超过限购数量。

代码
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
int M;
cin >> M;
vector<int> X(M), Y(M), Z(M);
for (int i = 0; i < M; ++i) {
cin >> X[i] >> Y[i] >> Z[i];
}
int N;
cin >> N;
vector<int> dp(N + 1, 0); // dp[i]表示花费i元能获得的最大优惠金额

for (int i = 0; i < M; ++i) {
vector<pair<int, int>> items; // 每种商品的购买方案
// 不购买
items.push_back({0, 0});
// 购买一件
int cost1 = Y[i];
int discount1 = X[i] - Y[i];
if (cost1 <= N) {
items.push_back({cost1, discount1});
}
// 购买两件
int cost2 = 2 * Z[i]; // 修正：总成本为2 * Z[i]
int discount2 = 2 * X[i] - 2 * Z[i]; // 修正：总优惠为2 * (X[i] - Z[i])
if (cost2 <= N) {
items.push_back({cost2, discount2});
}
// 动态规划，倒序遍历
for (int j = N; j >= 0; --j) {
for (auto &item : items) {
int cost = item.first;
int discount = item.second;
if (j >= cost) {
dp[j] = max(dp[j], dp[j - cost] + discount);
}
}
}
}
cout << dp[N] << endl;
return 0;
}

python
M = int(input())
X, Y, Z = [], [], []
for _ in range(M):
xi, yi, zi = map(int, input().split())
X.append(xi)
Y.append(yi)
Z.append(zi)
N = int(input())
dp = [0] * (N + 1)  # dp[i]表示花费i元能获得的最大优惠金额

for i in range(M):
items = []
# 不购买
items.append((0, 0))
# 购买一件
cost1 = Y[i]
discount1 = X[i] - Y[i]
if cost1 <= N:
items.append((cost1, discount1))
# 购买两件
cost2 = 2 * Z[i]  # 修正：总成本为2 * Z[i]
discount2 = 2 * X[i] - 2 * Z[i]  # 修正：总优惠为2 * (X[i] - Z[i])
if cost2 <= N:
items.append((cost2, discount2))
# 动态规划，倒序遍历
for j in range(N, -1, -1):
for cost, discount in items:
if j >= cost:
dp[j] = max(dp[j], dp[j - cost] + discount)

print(dp[N])

java
import java.util.Scanner;
import java.util.ArrayList;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int M = sc.nextInt();
int[] X = new int[M];
int[] Y = new int[M];
int[] Z = new int[M];
for (int i = 0; i < M; i++) {
X[i] = sc.nextInt();
Y[i] = sc.nextInt();
Z[i] = sc.nextInt();
}
int N = sc.nextInt();
int[] dp = new int[N + 1]; // dp[i]表示花费i元能获得的最大优惠金额

for (int i = 0; i < M; i++) {
ArrayList<int[]> items = new ArrayList<>();
// 不购买
items.add(new int[]{0, 0});
// 购买一件
int cost1 = Y[i];
int discount1 = X[i] - Y[i];
if (cost1 <= N) {
items.add(new int[]{cost1, discount1});
}
// 购买两件
int cost2 = 2 * Z[i]; // 修正：总成本为2 * Z[i]
int discount2 = 2 * X[i] - 2 * Z[i]; // 修正：总优惠为2 * (X[i] - Z[i])
if (cost2 <= N) {
items.add(new int[]{cost2, discount2});
}
// 动态规划，倒序遍历
for (int j = N; j >= 0; j--) {
for (int[] item : items) {
int cost = item[0];
int discount = item[1];
if (j >= cost) {
dp[j] = Math.max(dp[j], dp[j - cost] + discount);
}
}
}
}
System.out.println(dp[N]);
sc.close();
}
}

---

### 第2题-服务器休息计划（P2607）
- 链接：https://codefun2000.com/p/P2607

> 页面标题：#P2607. 第2题-服务器休息计划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明计划在假期安排一次自驾旅行。从小明所在的城市，到旅行目的地，仅有一条高速公路，该高速公路上有 NNN 个服务区，每个服务区都提供了餐饮、休息等服务，需要一定的花费。为了避免疲劳驾驶，每经过 MMM 个服务区，至少必须进入其中的某个服务区，停车休息一次。休息时，需要一定的花费。请帮小明安排一个服务区休息计划，使其在服务区的总花费最少。
输入描述
第一行:两个整数 NNN ，MMM 。其中 NNN 表示服务区的数量，MMM 表示经过连续 MMM 个服务区，必须至少停车休息一次。
第二行:包含 NNN 个整数的数组。第 iii 个元素，表示第 iii 个服务区休息时需要的费用(假定在服务区 iii 停车休息，一定会消费该服务区对应的费用)其中:

0<N<=100000<N<= 100000<N<=10000

0<M<=500<M <= 500<M<=50

输出描述
一行，表示在服务区休息的最小总花费。
样例1
输入
5 3
5 6 9 10 6

输出
9

说明
在第 333 个服务区休息一次，花费为 999 最少。
样例2
输入
4 2
3 2 2 5

输出
4

说明
在第 222 个服务区和第 333 个服务区休息，总花费为 2+2=42+2=42+2=4 最少

#### TextSol

题解
题面分析
小明计划在假期安排一次自驾旅行。从小明所在的城市，到旅行目的地，仅有一条高速公路，该高速公路上有 NNN 个服务区，每个服务区都提供了餐饮、休息等服务，需要一定的花费。为了避免疲劳驾驶，每经过 MMM 个服务区，至少必须进入其中的某个服务区，停车休息一次。休息时，需要一定的花费。请帮小明安排一个服务区休息计划，使其在服务区的总花费最少。
思路
本题要求在 NNN 个服务区中安排休息点，使得每经过连续 MMM 个服务区至少休息一次，并且总花费最小。可以采用动态规划的方法来解决。具体步骤如下：

定义状态：

定义 dp[i] 表示在第 i 个服务区之前（即前 i 个服务区）满足条件的最小总花费。
为了更清晰地表示状态，我们还可以引入一个辅助数组 last_rest[i]，表示在第 i 个服务区之前，最后一次休息的位置。

状态转移：

对于每个服务区 i，我们需要考虑在前 M 个服务区内的任意一个位置 j 休息，然后在 i 处休息。因此，状态转移方程为：

其中，cost[j-1] 表示在第 j 个服务区休息的花费（数组下标从 0 开始）。

初始化：

dp[0] = 0，表示在起点没有花费。
对于 1 ≤ i ≤ M，dp[i] = min(cost[0..i-1])，因为在前 M 个服务区内至少需要一个休息点。

最终结果：

为了满足最后的 M 个服务区中至少休息一次的要求，最终结果应为 dp[N]，即在前 N 个服务区内满足条件的最小总花费。

优化思路
上述动态规划的时间复杂度为 O(N×M)O(N \times M)O(N×M)，当 NNN 和 MMM 较大时，可能会导致运行时间较长。为了优化时间复杂度，可以采用以下方法：

滑动窗口最小值：

使用滑动窗口维护前 M 个 dp[j-1] 的最小值，从而将状态转移的时间复杂度降为 O(N)O(N)O(N)。
具体做法是使用双端队列（deque）来维护一个单调递增的队列，队列中存储的是可能的 j-1 索引，并保证队列头部始终是最小的 dp[j-1]。

实现细节：

在遍历每个服务区 i 时，首先移除队列中不在 [i-M, i-1] 范围内的元素。
然后，当前 dp[i] 就是队列头部元素对应的 dp[j-1] 加上当前服务区的费用 cost[i-1]。
最后，维护队列的单调性，将当前 i 插入队列，并移除所有在 dp[i] 之后比 dp[i] 大的元素。

cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main(){
ios::sync_with_stdio(false);
cin.tie(0);
int N, M;
cin >> N >> M;
vector<int> cost(N);
for(auto &x: cost) cin >> x;
// dp[i]表示在第i个服务区休息时的最小总花费
vector<long long> dp(N+1, 1e18);
dp[0] = 0;
// 使用双端队列维护窗口内的最小dp[j]
deque<int> dq;
dq.push_back(0);
for(int i=1; i<=N; ++i){
// 保证窗口内的j满足i - j <= M
while(!dq.empty() && i - dq.front() > M){
dq.pop_front();
}
if(!dq.empty()){
dp[i] = dp[dq.front()] + cost[i-1];
}
// 保持队列单调递增
while(!dq.empty() && dp[i] <= dp[dq.back()]){
dq.pop_back();
}
dq.push_back(i);
}
// 最终结果是在最后M个dp[j]中取最小值
long long res = 1e18;
for(int i=max(1, N-M+1); i<=N; ++i){
res = min(res, dp[i]);
}
cout << res;
}

python
import sys
from collections import deque

def main():
import sys
input = sys.stdin.read
data = input().split()
N, M = map(int, data[:2])
cost = list(map(int, data[2:2+N]))
INF = float('inf')
dp = [INF]*(N+1)
dp[0] = 0
dq = deque()
dq.append(0)
for i in range(1, N+1):
# 移除不在窗口内的j
while dq and i - dq[0] > M:
dq.popleft()
if dq:
dp[i] = dp[dq[0]] + cost[i-1]
# 保持队列单调递增
while dq and dp[i] <= dp[dq[-1]]:
dq.pop()
dq.append(i)
# 最终结果是在最后M个dp[j]中取最小值
res = INF
start = max(1, N-M+1)
for j in range(start, N+1):
res = min(res, dp[j])
print(int(res))

if __name__ == "__main__":
main()

java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] first = br.readLine().trim().split("\\s+");
int N = Integer.parseInt(first[0]);
int M = Integer.parseInt(first[1]);
String[] second = br.readLine().trim().split("\\s+");
int[] cost = new int[N];
for(int i=0;i<N;i++) cost[i] = Integer.parseInt(second[i]);
long INF = Long.MAX_VALUE;
long[] dp = new long[N+1];
Arrays.fill(dp, INF);
dp[0] = 0;
Deque<Integer> dq = new ArrayDeque<>();
dq.addLast(0);
for(int i=1;i<=N;i++){
// 移除不在窗口内的j
while(!dq.isEmpty() && i - dq.peekFirst() > M){
dq.pollFirst();
}
if(!dq.isEmpty()){
dp[i] = dp[dq.peekFirst()] + cost[i-1];
}
// 保持队列单调递增
while(!dq.isEmpty() && dp[i] <= dp[dq.peekLast()]){
dq.pollLast();
}
dq.addLast(i);
}
// 最终结果是在最后M个dp[j]中取最小值
long res = INF;
int start = Math.max(1, N-M+1);
for(int j=start; j<=N; j++){
res = Math.min(res, dp[j]);
}
System.out.println(res);
}
}

---

### 第2题-文本编辑器（P2371）
- 链接：https://codefun2000.com/p/P2371

> 页面标题：#P2371. 第2题-文本编辑器

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明玩腻了记事本，打算自己写一个文本编辑器。该编辑器有以下功能：

插入：insert str。表示将字符串strstrstr插入到当前游标所处位置，同时游标移动到strstrstr的右边。
删除：delete len。表示将游标左边长度为lenlenlen的字符串删除。要求该功能命令合法，即len≥0len\ge 0len≥0，如果len<0len\lt0len<0或者lenlenlen大于字符串长度，则认为输入非法，不进行操作。
移动：move cnt。将游标移动cntcntcnt次，如果为负数，向左移动，为正数，向右移动。如果cntcntcnt超过字符串左右边界，那么认为非法，不进行移动。
复制：copy。将游标左边字符串复制并插入到游标的右边。游标位置不变。

现在小明已经写好了该文本编辑器，而你正在使用它，那么输入一系列命令后，会得到什么结果呢？
输入描述
每行仅输入一个功能对应的操作。如果为endendend，代表操作结束。
初始时，字符串为空。游标位置为000。
1≤str.length≤401 \le str.length \le 401≤str.length≤40
1≤len≤401 \le len \le 401≤len≤40
−40≤cnt≤40-40 \le cnt \le 40−40≤cnt≤40
调用insert，delete，move和copy的总次数不超过200次。
输出描述
最终的文本结果，注意，结果应当包含游标，用"|"表示。
样例
输入
insert test
insert pass
move 10
delete 4
insert fail
move -4
copy
end

输出
test|testfail

#### TextSol

题面描述
塔子哥开发了一个文本编辑器，支持插入、删除、移动游标和复制文本等基本功能。用户通过输入相应的命令来操作文本，直到输入“end”表示结束。每个命令影响游标位置和文本内容，最终输出的结果中需要用“|”标识游标的位置。例如，输入一系列操作后，若文本为“testtestfail”，游标在“test”和“testfail”之间，则输出为“test|testfail”。
思路：模拟
定义两个双端队列分别表示游标左边和右边的文本。

插入：我们将字符串中的每个字符添加到左边的双端队列的末尾。
删除：我们从左边的双端队列的末尾删除指定数量的字符。
移动：我们将指定数量的字符从一个双端队列的末尾移动到另一个双端队列的开头。如果移动的数量为负数，我们从左边的双端队列移动字符到右边的双端队列；如果移动的数量为正数，我们从右边的双端队列移动字符到左边的双端队列。
复制：我们将左边的双端队列的所有字符复制到右边的双端队列的开头。

最后，我们将左边的双端队列和右边的双端队列中的所有字符连接起来，然后输出。
题解
塔子哥开发了一个文本编辑器，使用两个双端队列来分别表示游标左侧和右侧的文本内容。这种结构使得插入、删除、移动游标和复制文本等操作都可以高效进行。具体操作如下：

插入操作（insert）：将输入字符串的每个字符添加到游标左侧的双端队列末尾。这意味着新插入的文本位于游标的左侧。

删除操作（delete）：从游标左侧的双端队列末尾删除指定数量的字符。若请求删除的字符数量超过当前可删除的字符数，则只删除可删除的字符。

移动操作（move）：根据指定的数量，将字符从一个双端队列的末尾移动到另一个双端队列的开头。如果移动的数量为负数，则从游标左侧的双端队列移动字符到右侧；如果为正数，则相反。此操作需要检查是否会超出队列的边界。

复制操作（copy）：将游标左侧的所有字符复制到游标右侧的双端队列的开头。

输出结果（print）：将游标左侧和右侧的内容连接起来，中间用“|”表示游标的位置。

最后，用户通过输入一系列操作命令（如insert、delete、move、copy），直到输入“end”命令表示结束，程序将输出最终的文本结果。
时间复杂度
O(n)O(n)O(n)
代码
C++
#include <bits/stdc++.h>
using namespace std;

// 定义两个双端队列，分别表示游标左边和右边的文本
deque<char> front, back;

// 插入操作，将输入字符串的字符添加到左侧双端队列末尾
void insert() {
string str;
cin >> str; // 读取输入的字符串
for(char t: str) {
front.push_back(t); // 将每个字符添加到左侧队列
}
}

// 删除操作，从左侧双端队列末尾删除指定数量的字符
void del() {
int len;
cin >> len; // 读取要删除的字符数量
while(len > 0 && len <= front.size()) { // 确保删除操作合法
front.pop_back(); // 从左侧队列末尾删除字符
len--; // 减少删除计数
}
}

// 移动操作，将字符从一个双端队列的末尾移动到另一个双端队列的开头
void move() {
int cnt;
cin >> cnt; // 读取要移动的字符数量
// 处理负数移动：从左侧移动到右侧
while(cnt < 0 && -cnt <= front.size()) {
cnt++; // 计数递增
back.push_front(front.back()); // 从左侧队列末尾移动到右侧队列开头
front.pop_back(); // 移除左侧队列末尾字符
}
// 处理正数移动：从右侧移动到左侧
while(cnt > 0 && cnt <= back.size()) {
cnt--; // 计数递减
front.push_back(back.front()); // 从右侧队列开头移动到左侧队列末尾
back.pop_front(); // 移除右侧队列开头字符
}
}

// 复制操作，将左侧队列的所有字符复制到右侧队列的开头
void copy() {
auto tmp = front; // 备份左侧队列
while(tmp.size()) {
back.push_front(tmp.back()); // 从备份队列末尾移动到右侧队列开头
tmp.pop_back(); // 移除备份队列末尾字符
}
}

// 输出操作，打印最终的文本结果
void print() {
string s;
for(char t: front) s += t; // 将左侧队列的字符连接到字符串s
s += "|"; // 添加游标标识
for(char t: back) s += t; // 将右侧队列的字符连接到字符串s
cout << s << endl; // 输出结果
}

int main() {
string op;
while(cin >> op) { // 循环读取操作命令
switch(op[0]) { // 根据命令类型调用相应的函数
case 'i': // 插入
insert();
break;
case 'd': // 删除
del();
break;
case 'm': // 移动
move();
break;
case 'c': // 复制
copy();
break;
case 'e': // 输出并结束
print();
return 0; // 程序结束
}
}
}

python代码
# 初始化两个列表，s_left表示游标左侧的文本，s_right表示游标右侧的文本
s_left = []
s_right = []

# 持续读取用户输入的操作
while True:
info = input().strip()  # 读取输入并去掉两端的空白字符

if ' ' in info:  # 检查输入是否包含空格，表示是带参数的操作
op, obj = info.split()  # 分割操作类型和参数

if op == 'insert':  # 如果操作是插入
s_left.extend(list(obj))  # 将字符串的每个字符添加到游标左侧的列表中

elif op == 'delete' and 0 <= int(obj) <= len(s_left):  # 如果操作是删除，且删除长度合法
# 从游标左侧删除指定数量的字符
s_left[len(s_left) - int(obj):len(s_left)] = []  # 切片删除指定范围的字符

elif op == 'move':  # 如果操作是移动
if -len(s_left) <= int(obj) < 0:  # 检查是否为负数移动，且移动量合法
# 从游标左侧移动字符到游标右侧
tmp = s_left[len(s_left) + int(obj):len(s_left)]  # 获取要移动的字符
s_left[len(s_left) + int(obj):len(s_left)] = []  # 从左侧删除这些字符
s_right = tmp + s_right  # 将这些字符添加到右侧

elif 0 < int(obj) <= len(s_right):  # 检查是否为正数移动，且移动量合法
# 从游标右侧移动字符到游标左侧
tmp = s_right[0:int(obj)]  # 获取要移动的字符
s_right[0:int(obj)] = []  # 从右侧删除这些字符
s_left += tmp  # 将这些字符添加到左侧

else:
op = info  # 处理没有参数的操作
if op == 'end':  # 如果操作是结束
break  # 退出循环

elif op == 'copy':  # 如果操作是复制
s_right = s_left + s_right  # 将游标左侧的文本复制到游标右侧

# 输出结果，将左侧和右侧的文本连接并在中间插入游标标识符“|”
print(''.join(s_left + ['|'] + s_right))

Java代码
import java.io.BufferedReader; // 引入BufferedReader类，用于高效读取输入
import java.io.IOException; // 引入IOException类，用于处理输入输出异常
import java.io.InputStreamReader; // 引入InputStreamReader类，将字节流转换为字符流
import java.util.Locale; // 引入Locale类，虽然在此代码中未使用
import java.util.StringTokenizer; // 引入StringTokenizer类，虽然在此代码中未使用

public class Main {
public static void main(String[] args) throws IOException { // 主函数，抛出IOException
BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); // 创建BufferedReader对象用于读取输入
StringBuilder sb = new StringBuilder(); // 创建StringBuilder对象用于构建字符串
String s = ""; // 定义字符串s以存储每行输入
int pos = 0; // 初始化游标位置为0

// 读取第一行输入
s = br.readLine();
if (s.length() == 0) // 如果输入为空，则继续读取下一行
s = br.readLine();

// 循环处理输入操作，直到遇到"end"
while (!s.equals("end")) {
String[] operations = s.trim().split(" "); // 按空格分割输入操作和参数
if (operations[0].equals("insert")) { // 如果操作是插入
sb.insert(pos, operations[1]); // 在游标位置插入指定字符串
pos += operations[1].length(); // 更新游标位置
} else if (operations[0].equals("delete")) { // 如果操作是删除
int len = Integer.valueOf(operations[1]); // 将要删除的长度转换为整数
// 检查删除长度是否合法
if (len >= 0 && len <= pos) {
sb.delete(pos - len, pos); // 从游标左侧删除指定长度的字符
pos = pos - len; // 更新游标位置
}
} else if (operations[0].equals("move")) { // 如果操作是移动
int cnt = Integer.valueOf(operations[1]); // 将移动的数量转换为整数
if (cnt > 0 && pos + cnt <= sb.length()) { // 正向移动
pos = pos + cnt; // 更新游标位置
} else if (cnt < 0 && pos + cnt >= 0) { // 反向移动
pos = pos + cnt; // 更新游标位置
}
} else if (operations[0].equals("copy")) { // 如果操作是复制
sb.insert(pos, sb.substring(0, pos)); // 将游标左侧的字符串复制并插入到游标位置
}
// 读取下一行输入
s = br.readLine();
if (s.length() == 0) // 如果输入为空，则继续读取下一行
s = br.readLine();
}
// 输出最终结果，将左侧和右侧的文本连接并在中间插入游标标识符“|”
System.out.println(sb.substring(0, pos) + "|" + sb.substring(pos, sb.length()));
}
}

---

### 第2题-频率搬移值分配（P2368）
- 链接：https://codefun2000.com/p/P2368

> 页面标题：#P2368. 第2题-频率搬移值分配

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在无线通信设备中通常使用超外差接收机，超外差接收机是利用本地产生的振荡波与输入信号混频，将输入信号频率变换为某个预先确定的频率的方法。也就是说，信号通过一个混频器后，频率就会搬移一个数值。在项目中由于要节省器件，混频器需要尽可能的共享，我们设计了二又树型的混频器组，可以同时把信号搬移到不同的频率上。
二又树为完全二叉树。我们给定二叉树的层数和从根节点开始到每个子节点的频率搬移总和输出二又树。
规则: 节点的值为它的所有叶子节点的目标频率值最大值和最小值的平均值 (非整数向下取整)减去 它所有父节点的总和。

A

频率范围10~70， 则值是(10+70)/2=40

B

C

频率范围30~70，则值是(30+70)/2-40=10

D

E
F

G
频率范围70，则值是70-10-40=20

10
20
30
70
目标帧率

满足:

A+B+D=10A+B+D=10A+B+D=10
A+B+E=20A+B+E=20A+B+E=20
A+C+F=30A+C+F=30A+C+F=30
A+C+G=70A+C+G=70A+C+G=70

输入描述

叶子节点的数目 (必定是 2n2^n2n)，1≤叶子节点的数目≤40961 \leq 叶子节点的数目  \leq 40961≤叶子节点的数目≤4096
每个叶子节点的目标频率值，二叉树的数组形式表示，把二叉树的结点依次自上而下，自左至右储存到数组中，0≤目标频率值≤10000000 \leq 目标频率值 \leq 10000000≤目标频率值≤1000000

输出描述
以数组形式的二叉树表示
样例
输入
4
18 24 2 3

输出
13 8 -11 -3 3 0 1

解释
第000层:所有叶子节点最大最小值的平均值为(2+24)/2=13(2+24)/2=13 (2+24)/2=13所有父节点值为000，最终为 13−0=1313-0=1313−0=13
第111层左节点:所有叶子节点 最大最小值的平均值为(18+24)/2=21(18+24)/2=21(18+24)/2=21 所有父节点值为13，最终为21−13=821-13=821−13=8
第111层右节点:所有叶子节点 最大最小值的平均值为(2+3)/2=2(2+3)/2=2 (2+3)/2=2所有父节点值为131313，最终为2−13=−112-13=-112−13=−11
第222层第111个节点:所有叶子节点 最大最小值的平均值为18/1=1818/1=18 18/1=18所有父节点值为13+8=2113+8 =2113+8=21，最终为18−21=−318-21=-318−21=−3
第222层第222个节点: 所有叶子节点 最大最小值的平均值为24/1=2424/1=2424/1=24 所有父节点值为13+8=2113+8 =2113+8=21，最终为24−21=324 - 21=324−21=3
第222层第333个节点: 所有叶子节点 最大最小值的平均值为2/1=22/1=22/1=2 所有父节点值为13+(−11)13+(-11)13+(−11)=222，最终为2−2=02-2 =02−2=0
第222层第444个节点: 所有叶子节点 最大最小值的平均值为3/1=33/1=33/1=3 所有父节点值为13+(−11)=213+(-11)=213+(−11)=2，最终为3−2=13-2 = 13−2=1

13

频率范围2~24.则值是(2+24)/2=13

8

-11

频率范围2-4，则值是(2+4)/2-13=-10

-3

3
0

1
频率范围4，则值是4-(-10)-13=1

18
24
2
3
目标帧率

#### TextSol

题面描述
在无线通信设备中，超外差接收机通过将输入信号与本地产生的振荡波混频来变换频率。为了节省器件，设计了一种二又树型的混频器组，可以同时将信号搬移到不同的频率。给定一个完全二叉树的层数和每个叶子节点的目标频率值，我们需要计算树中每个节点的值，节点值由其所有叶子节点的最大值和最小值的平均值减去其所有父节点值的总和。最终以数组形式输出该二叉树的节点值。
思路: DFS
建立一个满二叉树，从下往上建树，每个节点存储当前最大值和最小值，叶子结点最大值和最小值一样，没个节点只需要考虑自己的左孩子和右孩子。由两个孩子来更新自身的最大值和最小值。从下往上建树后从上向下DFS，每层携带一个参数表示所有父亲的值的和。
题解
在无线通信设备中，超外差接收机的信号处理可以通过构建满二叉树来实现。这个树的每个节点存储当前子树的最大值和最小值，以便在后续的信号处理中快速计算频率的范围。具体步骤如下：

树的构建：我们从下往上建立满二叉树，叶子节点直接使用给定的目标频率值。非叶子节点通过其左右孩子节点更新自身的最大值和最小值。具体而言，叶子节点的最大值和最小值相同，父节点的最大值为其两个孩子的最大值，最小值为其两个孩子的最小值。

DFS遍历：构建完树后，使用深度优先搜索（DFS）从上到下遍历树。每次遍历时，携带一个参数表示所有父节点的值的和，这样可以在计算当前节点的最终值时，减去父节点的和。

输出结果：最终，输出每个节点的值，表示它在树中的状态。

代码
C++
#include <bits/stdc++.h>

using namespace std;

using ll = long long; // 定义长整型别名
using pii = pair<int, int>; // 定义一个整数对，用于存储最大值和最小值

int main() {
ios::sync_with_stdio(0); // 加速输入输出
cin.tie(0);

int n;
cin >> n; // 读取叶子节点的数量
vector<int> a(n + 1); // 用于存储叶子节点的目标频率值
for (int i = 1; i <= n; i++) {
cin >> a[i]; // 读取每个叶子节点的目标频率值
}

vector<ll> seg(n * 2); // 用于存储树节点的值，大小为2n

// 建树函数，返回当前节点的最小值和最大值
function<pii(int, int, int)> build = [&](int x, int l, int r) -> pii {
if (l == r) { // 如果到达叶子节点
seg[x] = a[l]; // 叶子节点的值为目标频率值
return {a[l], a[l]}; // 返回最小值和最大值（相同）
} else {
int mid = l + (r - l) / 2; // 计算中间位置
pii a = build(x * 2, l, mid); // 递归建造左子树
pii b = build(x * 2 + 1, mid + 1, r); // 递归建造右子树
int mi = min(a.first, b.first); // 当前节点的最小值
int mx = max(a.second, b.second); // 当前节点的最大值
seg[x] = (mx + mi) / 2; // 当前节点的值为最大值和最小值的平均值
return {mi, mx}; // 返回当前节点的最小值和最大值
}
};

build(1, 1, n); // 从根节点开始建树

// DFS遍历函数，x为当前节点，p为父节点值的和
function<void(int, ll)> dfs = [&](int x, ll p) -> void {
if (x >= n * 2) return; // 超出节点范围，结束递归
seg[x] -= p; // 当前节点值减去父节点的和
// 递归遍历左右子树，将当前节点值和传递给孩子节点
dfs(x * 2, p + seg[x]);
dfs(x * 2 + 1, p + seg[x]);
};

dfs(1, 0); // 从根节点开始DFS，初始父节点值为0

// 输出结果
for (int i = 1; i < n * 2; i++) {
cout << seg[i] << ' '; // 输出每个节点的值
}
cout << endl; // 换行
}

java
import java.util.Scanner;

public class Main {
static int n;
static int[] a;
static long[] seg;

static class Pair {
int first, second;

Pair(int f, int s) {
first = f;
second = s;
}
}

static Pair build(int x, int l, int r) {
if (l == r) { // 叶子节点的最大值和最小值一样
seg[x] = a[l];
return new Pair(a[l], a[l]);
} else {
int mid = l + (r - l) / 2;
Pair a = build(x * 2, l, mid); // 左孩子建树
Pair b = build(x * 2 + 1, mid + 1, r); // 右孩子建树
int mi = Math.min(a.first, b.first); // 更新当前节点的孩子最大值
int mx = Math.max(a.second, b.second); // 更新当前节点的孩子最小值
seg[x] = (mx + mi) / 2; // 当前节点权值
return new Pair(mi, mx);
}
}

static void dfs(int x, long p) { // 从上向下遍历，将父节点的和作为参数向下传递
if (x >= n * 2) return;
seg[x] -= p;
dfs(x * 2, p + seg[x]);
dfs(x * 2 + 1, p + seg[x]);
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt();
a = new int[n + 1];
seg = new long[n * 2 + 1];

for (int i = 1; i <= n; i++) {
a[i] = scanner.nextInt();
}

build(1, 1, n);
dfs(1, 0);

for (int i = 1; i < n * 2; i++) {
System.out.print(seg[i] + " ");
}
System.out.println();
}
}

python
import sys

n = int(input())
a = [0] + list(map(int, input().split()))

seg = [0] * (n * 2)

def build(x, l, r):
if l == r: # 叶子节点的最大值和最小值一样
seg[x] = a[l]
return (a[l], a[l])
else:
mid = l + (r - l) // 2
a_l, a_r = build(x * 2, l, mid) # 左孩子建树
b_l, b_r = build(x * 2 + 1, mid + 1, r) # 右孩子建树
mi = min(a_l, b_l) # 更新当前节点的孩子最大值
mx = max(a_r, b_r) # 更新当前节点的孩子最小值
seg[x] = (mx + mi) // 2 # 当前节点权值
return (mi, mx)

build(1, 1, n)

def dfs(x, p): # 从上向下遍历，将父节点的和作为参数向下传递
if x >= n * 2:
return
seg[x] -= p
dfs(x * 2, p + seg[x])
dfs(x * 2 + 1, p + seg[x])

dfs(1, 0)

for i in range(1, n * 2):
print(seg[i], end=' ')

print()

---

### 第2题-连通（P2365）
- 链接：https://codefun2000.com/p/P2365

> 页面标题：#P2365. 第2题-连通

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
题目要求计算一个无向图的连通块数量。输入包含两个整数 n 和 m，分别表示图中点的数量和边的数量，接着是 m 行，每行两个整数 u 和 v，表示点 u 和点 v 之间的无向边。输出应为该图的连通块数。示例输入为 4（点数）、1（边数）和边 0 1，输出为 3，表示图中共有 3 个连通块。
思路
并查集裸题，每次加边直接并查集合并，判断连通块的时候可以使用fa[i]是不是原来初始化时候设置的值。

初始化一个大小为 n 的数组 fa，每个元素初始为其自身，表示每个点自成一个连通块。
通过 Un 函数将输入的边连接的两个点合并在同一个连通块中。
通过遍历 fa 数组，统计根节点（即初始化时的节点值）数量，从而得到连通块的数量。

具体步骤：

输入点的数量 n 和边的数量 m。
对于每条边，通过并查集的合并操作将两个节点连接起来。
最后遍历 fa 数组，统计不同的根节点数目，即为连通块的数量。

代码
C++
#include<bits/stdc++.h>

using namespace std;

const int M = 205;  // 定义常量 M，表示最大节点数
int fa[M];  // 用于存储并查集的父节点

// 初始化并查集，将每个节点的父节点设为其自身
inline void init() {
for (int i = 0; i < M; i++)
fa[i] = i;
}

// 查找节点 x 的根节点，并进行路径压缩
int findfa(int x) {
return x == fa[x] ? x : fa[x] = findfa(fa[x]);
}

// 合并两个节点 a 和 b 所在的集合
void Un(int a, int b) {
int fa1 = findfa(a);  // 查找 a 的根节点
int fa2 = findfa(b);  // 查找 b 的根节点
if (fa1 != fa2)
fa[fa1] = fa2;  // 将 fa1 的根节点指向 fa2，完成合并
}

int main() {
init();  // 初始化并查集
int n, m, u, v;  // 定义点数 n、边数 m 以及每条边的两个端点 u 和 v
cin >> n >> m;  // 输入点数和边数
for (int i = 1; i <= m; i++) {  // 遍历每一条边
cin >> u >> v;  // 输入边的两个端点
Un(u, v);  // 合并两个端点
}

int ans = 0;  // 用于统计连通块的数量
for (int i = 0; i < n; i++)
ans += (fa[i] == i);  // 统计根节点的数量，即连通块的数量

cout << ans << endl;  // 输出连通块的数量
return 0;  // 程序结束
}

java
import java.util.Scanner;

public class Main {
static final int M = 205; // 定义常量 M，表示最大节点数
static int[] fa = new int[M]; // 用于存储并查集的父节点数组

// 初始化并查集，将每个节点的父节点设为其自身
static void init() {
for (int i = 0; i < M; i++) {
fa[i] = i; // 初始化时每个节点的父节点是其自身
}
}

// 查找节点 x 的根节点，并进行路径压缩
static int findfa(int x) {
return x == fa[x] ? x : (fa[x] = findfa(fa[x])); // 如果 x 是根节点，返回 x，否则递归查找其父节点
}

// 合并两个节点 a 和 b 所在的集合
static void Un(int a, int b) {
int fa1 = findfa(a); // 查找 a 的根节点
int fa2 = findfa(b); // 查找 b 的根节点
if (fa1 != fa2) { // 如果 a 和 b 不在同一个集合
fa[fa1] = fa2; // 将 fa1 的根节点指向 fa2，完成合并
}
}

public static void main(String[] args) {
init(); // 初始化并查集
Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象以读取输入
int n = scanner.nextInt(); // 输入点数 n
int m = scanner.nextInt(); // 输入边数 m
for (int i = 1; i <= m; i++) { // 遍历每一条边
int u = scanner.nextInt(); // 输入边的一个端点 u
int v = scanner.nextInt(); // 输入边的另一个端点 v
Un(u, v); // 合并两个端点所在的集合
}
int ans = 0; // 用于统计连通块的数量
for (int i = 0; i < n; i++) { // 遍历每个节点
if (fa[i] == i) { // 如果节点 i 是根节点
ans++; // 统计根节点的数量，即连通块的数量
}
}
System.out.println(ans); // 输出连通块的数量
}
}

python
def init():
global fa  # 声明 fa 为全局变量
fa = list(range(M))  # 初始化 fa 数组，每个节点的父节点指向自身

def findfa(x):
# 查找节点 x 的根节点，并进行路径压缩
if x == fa[x]:
return x  # 如果 x 是根节点，返回 x
fa[x] = findfa(fa[x])  # 递归查找父节点，同时进行路径压缩
return fa[x]  # 返回根节点

def Un(a, b):
# 合并两个节点 a 和 b 所在的集合
fa1 = findfa(a)  # 查找 a 的根节点
fa2 = findfa(b)  # 查找 b 的根节点
if fa1 != fa2:  # 如果 a 和 b 不在同一个集合
fa[fa1] = fa2  # 将 fa1 的根节点指向 fa2，完成合并

M = 205  # 定义常量 M，表示最大节点数
init()  # 初始化并查集
n = int(input())  # 输入点数 n
m = int(input())  # 输入边数 m
for i in range(1, m + 1):  # 遍历每一条边
u, v = map(int, input().split())  # 输入边的两个端点 u 和 v
Un(u, v)  # 合并两个端点所在的集合
ans = 0  # 用于统计连通块的数量
for i in range(n):  # 遍历每个节点
if fa[i] == i:  # 如果节点 i 是根节点
ans += 1  # 统计根节点的数量，即连通块的数量
print(ans)  # 输出连通块的数量

题目描述
给你一个图，问有多少连通块。
输入描述
第一行一个整数n，表示点的个数。(1≤n≤200)(1 \leq n \leq200)(1≤n≤200)
第二行一个整数m，表示边的个数。(1≤m≤200)(1\leq m \leq200)(1≤m≤200)
接下来m行每行两个整数u,v表示有一条u到v的边 (0≤u,v<n)(0\leq u,v < n)(0≤u,v<n)
输出描述
输出连通块的个数
样例
输入
4
1
0 1

输出
3

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 118ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-传球（P2363）
- 链接：https://codefun2000.com/p/P2363

> 页面标题：#P2363. 第2题-传球

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在一个 n×mn \times mn×m 的 0-1 矩阵中，我们需要从第一列的任意一个 1 出发，找到到达最后一列任意一个 1 的最少步数。如果无法到达，则输出 -1。输入的第一行为两个整数 nnn 和 mmm，接下来是 nnn 行，每行包含 mmm 个数，数值为 0 或 1。输出应为最短步数。
思路：多源BFS
多源BFS模板题：LeetCode 542. 01 矩阵
本题可以把第一列的所有元素为1的位置作为起点，将最后一列所有元素为1的位置作为终点，求起点到终点的最短距离，即为多源BFS
具体步骤：

初始化起点：将第一列中所有值为 1 的位置作为起点，加入队列中。
BFS遍历：从队列中逐个取出节点，探索四个方向（上下左右），如果发现相邻位置的值为 1 且未被访问过，就将该位置加入队列并标记为已访问。
终止条件：当遍历到最后一列时，输出当前步数。
无解情况：如果队列为空仍未到达最后一列，输出 -1。

时间复杂度
O(nm)O(nm)O(nm)
代码
C++
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

// 定义节点结构体，存储当前坐标和步数
struct Node {
int x, y, step; // x, y 表示坐标，step 表示从起点到当前节点的步数
Node(int _x, int _y, int _step) : x(_x), y(_y), step(_step) {}
};

int main() {
int m, n;
cin >> m >> n; // 输入矩阵的行数 m 和列数 n

// 初始化矩阵和访问标记
vector<vector<int>> grid(m, vector<int>(n)); // 存储矩阵
vector<vector<bool>> visited(m, vector<bool>(n, false)); // 标记访问状态

// 输入矩阵数据
for (int i = 0; i < m; ++i) {
for (int j = 0; j < n; ++j) {
cin >> grid[i][j];
}
}

queue<Node> q; // BFS 队列

// 将第一列中的所有值为 1 的位置作为起点放入队列
for (int i = 0; i < m; ++i) {
if (grid[i][0] == 1) {
q.push(Node(i, 0, 0)); // 起点坐标及初始步数为 0
visited[i][0] = true; // 标记为已访问
}
}

// 定义四个方向的移动 (上下左右)
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

// 开始 BFS 遍历
while (!q.empty()) {
Node current = q.front(); // 获取当前节点
q.pop(); // 从队列中移除

int x = current.x; // 当前 x 坐标
int y = current.y; // 当前 y 坐标
int step = current.step; // 当前步数

// 检查是否到达最后一列
if (y == n - 1 && grid[x][y] == 1) {
cout << step << endl; // 输出步数
return 0; // 结束程序
}

// 遍历四个方向
for (int dir = 0; dir < 4; ++dir) {
int nx = x + dx[dir]; // 新的 x 坐标
int ny = y + dy[dir]; // 新的 y 坐标

// 检查新坐标是否在矩阵内且未被访问
if (0 <= nx && nx < m && 0 <= ny && ny < n
&& grid[nx][ny] == 1 && !visited[nx][ny]) {
visited[nx][ny] = true; // 标记为已访问
q.push(Node(nx, ny, step + 1)); // 将新节点加入队列
}
}
}

// 如果队列为空且未找到可达的终点，输出 -1
cout << -1 << endl;

return 0;
}

python代码
# 输入矩阵的行数 m 和列数 n
m, n = map(int, input().split())
grid = []  # 初始化矩阵

# 输入矩阵数据
for i in range(m):
grid.append(list(map(int, input().split())))

# 深度优先搜索（DFS）相关的变量
dp = [[float('inf')] * n for _ in range(m)]  # dp数组，初始化为无穷大
res = [float('inf')]  # 结果数组，用于存储最短路径

def dfs(i, j, path, grid):
# 检查边界条件：超出矩阵范围或遇到障碍（不是1）
if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1:
return

# 如果到达最后一列，更新最短路径
if j == n - 1:
res[0] = min(res[0], path)
return

# 剪枝：如果当前路径长度已经不如最优解，直接返回
if path >= res[0]:
return

# 剪枝：如果当前路径长度已经大于等于已记录的最短路径，返回
if path >= dp[i][j]:
return

# 更新当前路径长度
dp[i][j] = path
grid[i][j] = 2  # 标记当前节点为已访问（设为2）

# 递归调用四个方向的DFS
dfs(i, j + 1, path + 1, grid)  # 向右
dfs(i - 1, j, path + 1, grid)  # 向上
dfs(i + 1, j, path + 1, grid)  # 向下
dfs(i, j - 1, path + 1, grid)  # 向左

grid[i][j] = 1  # 回溯，重置当前节点为未访问（设为1）

import copy

# 检查最后一列是否有可达的1
for j in range(n):
flag = 0  # 标记是否找到可达的1
for i in range(m):
if grid[i][j] == 1:
flag = 1  # 找到可达的1，标记为1
break
if flag == 0:
print(-1)  # 如果没有找到1，则直接输出-1
exit(0)

# 从第一列的所有1出发，执行DFS
for i in range(m):
dfs(i, 0, 0, copy.deepcopy(grid))  # 深拷贝防止修改原始grid

# 检查结果并输出
if res[0] == float('inf'):
print(-1)  # 如果没有找到可达的路径，输出-1
else:
print(res[0])  # 输出最短路径长度

Java代码
import java.io.*;
import java.util.*;

// 定义一个记录类 Pair，用于存储节点的坐标和路径长度
record Pair(int x, int y, int path) {}

public class Main {
// 定义移动方向：右、下、上
final static int[][] move = {{0, 1}, {1, 0}, {-1, 0}};
static int res; // 用于存储最短路径
static int mat[][]; // 矩阵

public static void main(String[] args) {
Scanner in = new Scanner(System.in); // 创建输入流
int n = in.nextInt(); // 输入矩阵的行数
int m = in.nextInt(); // 输入矩阵的列数
mat = new int[n][m]; // 初始化矩阵

// 输入矩阵数据
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
mat[i][j] = in.nextInt(); // 读取矩阵每个位置的值
}
}

res = 0x3f3f3f3f; // 将结果初始化为一个较大的数（无穷大）

// 遍历第一列，寻找所有值为1的起点，进行 BFS
for (int i = 0; i < n; i++) {
if (mat[i][0] == 1) { // 只对第一列中的 1 进行 BFS
bfs(i, n, m); // 从这个位置开始 BFS
}
}

// 检查是否找到路径，未找到则输出 -1
res = res == 0x3f3f3f3f ? -1 : res;
System.out.println(res); // 输出最短路径或 -1
}

static void bfs(int i, int n, int m) {
boolean[][] v = new boolean[n][m]; // 初始化访问标记数组
Queue<Pair> q = new ArrayDeque<>(); // 创建队列用于 BFS
q.offer(new Pair(i, 0, 0)); // 将起点放入队列
v[i][0] = true; // 标记起点为已访问

// BFS 遍历
while (!q.isEmpty()) {
Pair p = q.poll(); // 取出队列中的节点
int x = p.x(); // 当前节点的 x 坐标
int y = p.y(); // 当前节点的 y 坐标
int path = p.path(); // 从起点到当前节点的路径长度

// 如果到达最后一列，更新最短路径
if (y == m - 1) {
res = Math.min(res, path);
}

// 遍历可能的移动方向
for (int z = 0; z < 3; z++) {
int xx = x + move[z][0]; // 计算新的 x 坐标
int yy = y + move[z][1]; // 计算新的 y 坐标

// 检查新的坐标是否在矩阵范围内且未被访问且为 1
if (xx >= 0 && xx < n && yy >= 0 && yy < m && !v[xx][yy] && mat[xx][yy] == 1) {
q.offer(new Pair(xx, yy, path + 1)); // 将新节点加入队列
v[xx][yy] = true; // 标记为已访问
}
}
}
}
}

题目描述
有一个n∗mn*mn∗m的01矩阵，你需要从第一列的任意一个1出发，到达最后一列的任意一个1。途径的点必须为1，求最少的步数。
输入描述
第一行两个整数n,mn,mn,m，代表两个有一个n行m列的01矩阵
接下来n行，每行m个数。每个数非0即1
输出描述
输出最短步数，当不可达时输出-1。
样例
输入
3 4
0 1 1 0
1 1 1 1
0 1 0 1

输出
3

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 73ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-迷宫（P2360）
- 链接：https://codefun2000.com/p/P2360

> 页面标题：#P2360. 第2题-迷宫

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述
在一个包含两行和m列的糖果迷宫中，小A和小B从左上角出发，目标是到达右下角。小A在路径中尽量减少小B可以获得的糖果，而小B希望在小A走完后能尽可能多地吃到糖果。通过动态规划的方法，我们可以计算出小B最多能够吃掉的糖果数量。具体实现时，首先记录小A的路径及其获得的糖果，然后基于小A的路径计算小B的最大糖果数，最终得出小B可以获得的最大糖果总数。
题目分析
我们需要计算小A和小B分别在迷宫中移动时所能吃到的糖果数量。小A从左上角开始，向右或向下移动，直到到达终点。小B则从小A结束的地方开始，从终点位置返回到左上角，但不能吃小A吃过的糖果。小A的目标是尽量减少小B吃掉的糖果，而小B希望在小A走完后能吃到尽可能多的糖果。
思路

前缀和的计算：

我们需要计算小A和小B在每一列之前吃掉的糖果和。通过前缀和数组，我们能够快速获得任意区间内的糖果总数。
对于每一行，建立一个前缀和数组qzs，其中qzs[i][j]表示第i行前j列的糖果总和。这样可以方便地计算出小A和小B在任意分割点之前和之后的糖果数量。

分割点的选择：

小A从左上角出发到达某个分割点，然后停止，接着小B从该分割点开始向右走至终点。在这个过程中，我们需要考虑每一个可能的分割点。
对于每一个分割点i，小A在分割点之前的总糖果数为qzs[0][i + 1]（第一行的前缀和），而小B在该分割点之后的糖果数则为qzs[1][m] - qzs[1][i]（第二行的前缀和减去分割点的糖果）。

最小化最大值：

对于每个分割点，计算小A在分割点之前和小B在分割点之后所能吃到的糖果数量。我们需要找出小B可能吃到的最大糖果数，并对所有分割点的结果取最小值。这样可以确保小A所吃的糖果数量最小化时，小B所能获得的糖果数量最大。

代码实现：

代码中首先读取糖果迷宫的数据，计算前缀和，然后遍历每一个可能的分割点，计算相应的糖果数量，最后输出小B能够吃到的最大糖果数。

时间复杂度
整个算法的时间复杂度为 (O(m))，因为我们只需遍历一次二维数组来计算前缀和，另外一次遍历进行计算，整体为线性复杂度。
代码实现
C++ 代码
#include <bits/stdc++.h>
using namespace std;

int main() {
int m;
cin >> m;

// 初始化糖果迷宫和前缀和数组
vector<vector<int>> grid(2, vector<int>(m));
vector<vector<int>> qzs(2, vector<int>(m + 1));

// 读取第一行糖果并计算前缀和
for (int j = 0; j < m; j++) {
cin >> grid[0][j];
qzs[0][j + 1] = qzs[0][j] + grid[0][j];
}

// 读取第二行糖果并计算前缀和
for (int j = 0; j < m; j++) {
cin >> grid[1][j];
qzs[1][j + 1] = qzs[1][j] + grid[1][j];
}

// 初始化最小糖果损失值为较大数
long long ans = INT_MAX;

// 遍历每个分割点，从0到m-1
for (int i = 0; i < m; i++) {
// 计算小B在该分割点的最大可能值
int tmp = max(qzs[1][i], qzs[0][m] - qzs[0][i + 1]);
// 更新答案，取最小值
ans = min(ans, static_cast<long long>(tmp));
}

// 输出小B最多能吃到的糖果数量
cout << ans << endl;

return 0;
}

Python 代码
# 输入迷宫的列数
m = int(input())
# 读取糖果分布并初始化前缀和数组
grid = [list(map(int, input().split())) for _ in range(2)]

# 初始化前缀和数组
qzs = [[0] * (m + 1) for _ in range(2)]
for j in range(m):
# 计算第一行前缀和
qzs[0][j + 1] = qzs[0][j] + grid[0][j]
# 计算第二行前缀和
qzs[1][j + 1] = qzs[1][j] + grid[1][j]

# 设定答案为一个较大的值
ans = float('inf')
# 遍历所有分割点，找到最优分割
for i in range(1, m + 1):
# 计算小B在当前分割点的最优结果
tmp = max(qzs[1][i - 1], qzs[0][m] - qzs[0][i])
# 更新最优解
ans = min(ans, tmp)

# 输出小B最多可以吃到的糖果数
print(ans)

Java 代码
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int m = sc.nextInt();

// 初始化糖果迷宫和前缀和数组
int[][] grid = new int[2][m];
int[][] qzs = new int[2][m + 1];

// 读取第一行糖果并计算前缀和
for (int j = 0; j < m; j++) {
grid[0][j] = sc.nextInt();
qzs[0][j + 1] = qzs[0][j] + grid[0][j];
}

// 读取第二行糖果并计算前缀和
for (int j = 0; j < m; j++) {
grid[1][j] = sc.nextInt();
qzs[1][j + 1] = qzs[1][j] + grid[1][j];
}

// 初始化最小糖果损失值为较大数
long ans = Integer.MAX_VALUE;

// 遍历每个分割点，从0到m-1
for (int i = 0; i < m; i++) {
// 计算小B在该分割点的最大可能值
int tmp = Math.max(qzs[1][i], qzs[0][m] - qzs[0][i + 1]);
// 更新答案，取最小值
ans = Math.min(ans, tmp);
}

// 输出小B最多能吃到的糖果数量
System.out.println(ans);
}
}

代码注释总结

前缀和数组：qzs[0][j+1] 记录小A在迷宫第0行的糖果和，qzs[1][j+1] 记录小B在迷宫第1行的糖果和。
分割点循环：遍历每一个可能的分割点，通过比较小B和小A的前缀和，计算当前点的最小损失值。
更新和输出：在遍历完所有列后，输出小B的最大糖果数量。

题目描述
小明有一个神奇的糖果迷宫，这个迷宫是一个矩形迷宫，包含了两行（行数为2）和m列（列数为m）的格子。每个格子中都有不同的分数，由二维数组a[i][j]表示，其中i表示行号，j表示列号。
小A和小B从迷宫的左上角（位置a[0][0]）出发，走到迷宫的右下角（位置a[1][m-1]）。在这个过程中，他只能进行向右或向下的移动，每到达一个格子，他们都会吃掉这个格子的糖果。
假设小A先走，他会获得吃掉路径中的糖果，然后小B开始走，他不能重复吃掉小A吃过的糖果。
小A的目标是要尽量减少小B吃掉的糖果总数，而小B则希望在小A走完后，自己能吃掉更多的糖果总数。
请你计算小B最多可以吃掉多少糖果。
输入格式
第一行一个整数 m，表示迷宫的列数。
接下来两行，每行 m 个整数，表示当前位置的糖果数。
输出格式
输出小B最多可以吃掉的糖果数。
4
1 5 2 7
5 3 4 1

8

说明
1≤m≤1051 \le m \le 10^51≤m≤105

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

大厂笔试真题突击

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 70ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-计算式（P2357）
- 链接：https://codefun2000.com/p/P2357

> 页面标题：#P2357. 第2题-计算式

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

前置知识
不熟悉大数加法/乘法的同学可以先学习一下这两道Leetcode的题目
大数加法：2. 两数相加 - 力扣（LeetCode）
大数乘法：43. 字符串相乘 - 力扣（LeetCode）
题解思路
给定两个多项式的系数数组，要求对这两个多项式进行加法、减法或乘法操作。多项式的计算可以通过以下步骤实现：

输入和反转数组：

多项式是按降幂顺序给出的，例如 [1, 2, 3] 表示 x2+2x+3x^2 + 2x + 3x2+2x+3。
为了方便运算，先将数组反转，使其按升幂顺序排列。这样，指数为 i 的项对应数组中的第 i 个元素。

运算符选择：

若操作符为 +，则对两个系数数组逐位相加。
若操作符为 -，则逐位相减。
若操作符为 *，则需要逐项相乘，模拟多项式乘法。

去除前导零：

运算结束后，可能会产生高次项的系数为零的情况。
将多项式结果的前导零去除（除非最终结果是 0，避免无效的高次项）。

代码复杂度分析

时间复杂度：

加法和减法：逐位相加或相减，时间复杂度为 O(n)O(n)O(n)。
乘法：双重循环模拟多项式乘法，时间复杂度为 O(n2)O(n^2)O(n2)。

空间复杂度：

需要额外的数组存储运算结果，因此空间复杂度为 O(n2)O(n^2)O(n2)。

时间复杂度
乘法是O(n2)O(n^2)O(n2)，加法/减法是O(n)O(n)O(n)

代码
C++
#include <bits/stdc++.h>
using namespace std;

// 加法运算
vector<int> add(vector<int>& a, vector<int>& b) {
int n = max(a.size(), b.size());
vector<int> res(n, 0);
// 将两个数组逐位相加
for (int i = 0; i < n; i++) {
if (i < a.size()) res[i] += a[i];
if (i < b.size()) res[i] += b[i];
}
reverse(res.begin(), res.end());
// 去除前导零
while (res.size() > 1 && res[0] == 0) {
res.erase(res.begin());
}
return res;
}

// 减法运算
vector<int> subtract(vector<int>& a, vector<int>& b) {
int n = max(a.size(), b.size());
vector<int> res(n, 0);
// 将两个数组逐位相减
for (int i = 0; i < n; i++) {
if (i < a.size()) res[i] += a[i];
if (i < b.size()) res[i] -= b[i];
}
reverse(res.begin(), res.end());
// 去除前导零
while (res.size() > 1 && res[0] == 0) {
res.erase(res.begin());
}
return res;
}

// 乘法运算
vector<int> multiply(vector<int>& a, vector<int>& b) {
int n = a.size() + b.size() - 1;
vector<int> res(n, 0);
// 双重循环模拟多项式乘法
for (int i = 0; i < a.size(); i++) {
for (int j = 0; j < b.size(); j++) {
res[i + j] += a[i] * b[j];
}
}
reverse(res.begin(), res.end());
// 去除前导零
while (res.size() > 1 && res[0] == 0) {
res.erase(res.begin());
}
return res;
}

int main() {
string s;
getline(cin, s);
stringstream ss(s.substr(1, s.length() - 2));
vector<int> a;
int x;
while (ss >> x) a.push_back(x);
reverse(a.begin(), a.end());

getline(cin, s);
ss.clear();
ss.str(s.substr(1, s.length() - 2));
vector<int> b;
while (ss >> x) b.push_back(x);
reverse(b.begin(), b.end());

char op;
cin >> op;

vector<int> res;
if (op == '+') res = add(a, b);
else if (op == '-') res = subtract(a, b);
else if (op == '*') res = multiply(a, b);

// 输出结果并格式化为多项式的数组表示
cout << "[";
for (int i = 0; i < res.size(); i++) {
if (i != 0) cout << " ";
cout << res[i];
}
cout << "]" << endl;

return 0;
}

python代码
def readIn ():
x = list(map(int , input()[1:-1].split(' ')))
y = list(map(int , input()[1:-1].split(' ')))
return x , y
def solve(x):
return x[::-1]
def mul (a , b , n , m):
ans = [0] * (n + m - 1)
for i in range(n):
for j in range(m):
ans[i + j] += a[i] * b[j]
return ans

a , b = readIn()
n = len(a)
m = len(b)
a = solve(a)
b = solve(b)
c = input()
ans = []
if c == '-':
for i in range(max(n , m)):
s = 0
if i < n:
s += a[i]
if i < m:
s -= b[i]
ans.append(s)

if c == '*':
ans = mul(a , b , n , m)

if c == '+':
for i in range(max(n , m)):
s = 0
if i < n:
s += a[i]
if i < m:
s += b[i]
ans.append(s)

def get(x):
while len(x) > 1 and x[-1] == 0:
x.pop()
return x

ans = solve(get(ans))

output = "[" + " ".join(map(str , ans)) + "]"

print (output)

Java代码
import java.util.*;

class Main {
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int[] a = parseInput(in.nextLine());
int[] b = parseInput(in.nextLine());
char op = in.nextLine().charAt(0);

int[] result;
if (op == '+') {
result = add(a, b);
} else if (op == '-') {
result = subtract(a, b);
} else {
result = multiply(a, b);
}

System.out.print("[");
boolean first = true;
for (int num : result) {
if (!first) System.out.print(" ");
System.out.print(num);
first = false;
}
System.out.println("]");
}

// 解析输入的数组字符串
private static int[] parseInput(String s) {
s = s.replace("[", "").replace("]", "");
String[] tokens = s.split("\\s+");
int[] arr = new int[tokens.length];
for (int i = 0; i < tokens.length; i++) {
arr[i] = Integer.parseInt(tokens[i]);
}
return reverse(arr);
}

// 反转数组
private static int[] reverse(int[] arr) {
for (int i = 0; i < arr.length / 2; i++) {
int temp = arr[i];
arr[i] = arr[arr.length - i - 1];
arr[arr.length - i - 1] = temp;
}
return arr;
}

// 加法
private static int[] add(int[] a, int[] b) {
int maxLen = Math.max(a.length, b.length);
int[] result = new int[maxLen];
for (int i = 0; i < maxLen; i++) {
result[i] = (i < a.length ? a[i] : 0) + (i < b.length ? b[i] : 0);
}
return reverse(trimLeadingZeros(result));
}

// 减法
private static int[] subtract(int[] a, int[] b) {
int maxLen = Math.max(a.length, b.length);
int[] result = new int[maxLen];
for (int i = 0; i < maxLen; i++) {
result[i] = (i < a.length ? a[i] : 0) - (i < b.length ? b[i] : 0);
}
return reverse(trimLeadingZeros(result));
}

// 乘法
private static int[] multiply(int[] a, int[] b) {
int[] result = new int[a.length + b.length - 1];
for (int i = 0; i < a.length; i++) {
for (int j = 0; j < b.length; j++) {
result[i + j] += a[i] * b[j];
}
}
return reverse(trimLeadingZeros(result));
}

// 去除前导零
private static int[] trimLeadingZeros(int[] arr) {
int nonZeroIndex = 0;
while (nonZeroIndex < arr.length - 1 && arr[nonZeroIndex] == 0) {
nonZeroIndex++;
}
return Arrays.copyOfRange(arr, nonZeroIndex, arr.length);
}
}

题目描述
给定两个多项式的系数，第i项表示指数为n-i的系数。输出两个多项式的求和结果。
输入描述
第一行表示一个多项式的系数，第二行表示另一行多项式的系数，第三行表示多项式运算符
运算符只包含+、-、*。数组长度小于等于128，数组范围为[−512,512][-512, 512][−512,512]
输出描述
输出运算后的系数数组，需要去除前缀零。
样例
输入
[1 2 3 4 5 6]
[-4 -5 -6]
+

输出
[1 2 3 0 0 0]

说明
多项式系数数组[1[1[1 222 333 444 555 6]6]6]
表示多项式A(x)=x5+2x4+3x3+4x2+5x+6A(x)=x^5+2x^4+3x^3+4x^2+5x+6A(x)=x5+2x4+3x3+4x2+5x+6
多项式系数数组[−4[-4[−4 −5-5−5 −6]-6]−6]
表示多项式B(X)=−4x2−5x−6B(X)=-4x^2-5x-6B(X)=−4x2−5x−6
A(x)+B(X)=x5+2x4+3x3A(x)+B(X)=x^5 +2x^4 + 3x^3A(x)+B(X)=x5+2x4+3x3，对应的多项式系数数组为[1[1[1 222 333 000 000 0]0]0]

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 73ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-读书（P2354）
- 链接：https://codefun2000.com/p/P2354

> 页面标题：#P2354. 第2题-读书

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥想要最大化他的快乐值，针对每本书的满意值进行阅读安排。阅读每本书花费1单位时间，书的快乐值为已花费时间与满意值的乘积。给定满意值的字符串输入，例如"4,3,2"，表示书的满意值为4、3和2，塔子哥需要确定阅读顺序或选择不读某些书籍以获得最大的快乐值。输出为数字，代表最大快乐值之和。比如，输入"4,3,2"的输出为20，因为按照满意值的顺序阅读能够获得最大快乐值；而对于"-1,-4,-5"这样的输入，输出为0，因为不阅读任何书籍是最优选择。
思路：贪心
其实本质上就是最大化∑i×a[i]\sum i\times a[i]∑i×a[i]
对于正整数的情况，一定是优先把数值低的放在前面，数值高的放在后面，即直接对原数组进行升序排列即可。
题解思路

优化阅读顺序：对于正的满意值，越高的满意值越应该在后面阅读，因为随着阅读时间的增加，乘积会增大。因此，我们将书籍的满意值进行升序排列，优先阅读满意值较低的书籍。

计算最大快乐值：根据阅读顺序，我们可以通过一个循环计算每本书的贡献，累加得到最大快乐值。

时间复杂度
O(nlogn)O(nlogn)O(nlogn)
代码
C++
#include<bits/stdc++.h>
using namespace std;

int main() {
string line;
// 读取输入的满意值字符串
getline(cin, line);
stringstream ss(line);
string token;
vector<int> a;

// 分割字符串并将每个满意值转为整数
while (std::getline(ss, token, ',')) {
int x = stoi(token);
a.push_back(x);
}

// 对满意值进行升序排序
sort(a.begin(), a.end());

int ans = 0; // 用于存储最大快乐值
int n = a.size();

// 遍历数组，计算最大快乐值
for (int i = 0; i < n; i++) {
// 重置当前时间和当前快乐值
int t = 1, now = 0;

// 从第i本书开始计算
for (int j = i; j < n; j++) {
// 仅计算满意值大于0的书籍
now += t * a[j]; // 计算当前书籍的贡献
t++; // 增加时间
ans = max(ans, now); // 更新最大快乐值
}
}

cout << ans << endl; // 输出最大快乐值
return 0;
}

python代码
# 从输入中读取书籍的满意值，并将其转换为整数列表
books = list(map(int, input().split(",")))

# 对满意值进行升序排序
books.sort()

# 计算书籍的数量
num_book = len(books)

# 初始化最大快乐值为0
ret = 0

# 尝试舍弃从第一本书到第num_book本书的每一本书
for i in range(num_book):
new_ret = 0  # 初始化新的快乐值
# 计算剩余书籍的快乐值
for j in range(i, num_book):
new_ret += books[j] * (j - i + 1)  # 计算每本剩余书籍的贡献并累加

# 更新最大快乐值ret
ret = max(ret, new_ret)

# 输出最终计算得到的最大快乐值
print(ret)

Java代码
import java.util.Arrays; // 导入数组操作相关的类
import java.util.Scanner; // 导入扫描器类以读取输入
import java.util.stream.IntStream; // 导入流处理类以进行数组的流操作

public class Main {
@SuppressWarnings({ "resource" }) // 忽略未关闭的Scanner警告
public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 创建Scanner对象以读取输入
String[] strs = sc.nextLine().split(","); // 读取一行输入并以逗号分隔，存入字符串数组
int[] arr = Arrays.stream(strs).mapToInt(Integer::parseInt).toArray(); // 将字符串数组转换为整数数组

Arrays.sort(arr); // 对整数数组进行升序排序

int res = 0; // 初始化最大快乐值为0

// 遍历数组，计算从每个位置到末尾的满意值和
for (int i = 0; i < arr.length; i++) {
int sum = 0;
for(int j = i; j < arr.length; j++){
sum += arr[j] * (j - i + 1);
}
res = Math.max(res, sum);
}

// 输出最终计算得到的最大快乐值
System.out.println(res);
}
}

题目描述
  小明是个爱学习的孩子，并且喜好读书，并且更喜欢读好书，在某一天他要读n本书，读每一本书都要花费1单位时间，并且小明对每一本书有一个满意值，同时读完每一本书小明都会收获一定的快乐值，现在小明想知道要按照怎样的顺序读书读哪些书能使他收获的快乐值总和最大
  每本书籍的快乐值为读这本书和之前所有书所花费的时间乘以对这本书的满意值，可按照任意顺序读书，也可以放弃读某些书。
设书的总数为n，书的满意值为m
1≤n≤5001\leq n\leq 5001≤n≤500
−1000≤m≤1000-1000\leq m\leq 1000−1000≤m≤1000
输入描述
输入为字符串，字符串内容为代表每本书籍的满意值，例如输入为"4,3,2"，表示有3本书，满意值分别是4、3和2
输出描述
输出为数字，代表最大的快乐值之和
样例
输入1
4,3,2

输出1
20

说明
按照原来顺序相反的时间阅读书籍(2 * 1 +3 * 2+4 * 3=20)，满意值越高的书籍越后面读可以获得最大的快乐值。
输入2
-1,-4,-5

输出2
0

说明
这些书籍满意值都很低，所以不阅读任何书籍可以获得最大的快乐值 。
输入3
-1,-8,0,5,-9

输出3
14

说明
去掉第二个和最后一本书籍，最大的快乐时间系数和为(-1 * 1+0 * 2+5 * 3=14)每书籍都需要花费1单位时间来阅读 。

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 112ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-滑雪冒险（P2351）
- 链接：https://codefun2000.com/p/P2351

> 页面标题：#P2351. 第2题-滑雪冒险

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥是一位极限滑雪爱好者，他希望探索滑雪场的最长路径。给定一个滑雪场的高度矩阵，要求滑雪路径从一个点滑向周围的相邻点，且下一个点的高度必须严格低于当前点。输入包括矩阵的行数和列数，以及每个点的高度。输出最长的滑雪路径长度。你是否想要了解具体的解题思路或方法？
题解：记忆化搜索
定义f[i][j]f[i][j]f[i][j]表示以(i,j)(i,j)(i,j)点开始的最大路径，由于只能向比它权值低的点走，因此对于所有可以前往的路径(a,b)(a,b)(a,b)
应该有f[i][j]=max(f[i][j],f[a][b]+1)f[i][j]=max(f[i][j],f[a][b]+1)f[i][j]=max(f[i][j],f[a][b]+1)
初始化所有的f[i][j]=−1f[i][j]=-1f[i][j]=−1，然后对于每一个点(i,j)(i,j)(i,j)，跑一遍DFS，加一个记忆化搜索的判断
方法步骤

定义数据结构：

使用二维数组 g 存储滑雪场的高度。
使用二维数组 f 存储从每个点出发的最大路径长度，初始值设为 -1 表示尚未计算。

DFS 函数：

通过递归的方式计算以 (x, y) 为起点的最大路径长度。如果已经计算过（f[x][y] != -1），直接返回已存储的结果。
否则，将路径长度初始化为 1（包括当前点）。
检查四个方向（上、下、左、右），如果相邻点高度低于当前点，递归调用 DFS 计算相邻点的最大路径长度，并更新当前点的最大路径长度。

主函数：

输入滑雪场的高度信息。
对于每个点调用 DFS 函数，计算并更新最大路径长度。

输出结果：

最后，输出所有点中找到的最长路径长度。

if(f[i][j]!=-1){   //说明该点已经被访问过 直接返回
return f[i][j];
}

C++
#include<bits/stdc++.h>
using namespace std;

const int N=210; // 定义最大数组大小
int g[N][N], n, m, f[N][N]; // g 存储高度, f 存储最大路径长度
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, 1, -1}; // 四个方向的偏移量

// 深度优先搜索函数
int dfs(int x, int y) {
// 如果已经计算过，直接返回结果
if(f[x][y] != -1) return f[x][y];
f[x][y] = 1; // 当前点的路径长度至少为 1
int t = 0; // 用于记录下方可达的最大路径长度

// 遍历四个相邻的方向
for(int i = 0; i < 4; i++) {
int a = dx[i] + x, b = dy[i] + y; // 计算相邻点的坐标
// 检查边界条件和高度条件
if(a < 0 || a >= n || b < 0 || b >= m || g[a][b] >= g[x][y]) continue;
// 递归 DFS 计算相邻点的路径长度
t = max(t, dfs(a, b));
}

f[x][y] += t; // 更新当前点的路径长度
return f[x][y]; // 返回当前点的最大路径长度
}

int main() {
cin >> n >> m; // 输入滑雪场的行列数
for(int i = 0; i < n; i++) {
for(int j = 0; j < m; j++) {
cin >> g[i][j]; // 输入每个点的高度
}
}

memset(f, -1, sizeof f); // 初始化路径长度数组
int res = 1; // 记录最长路径，初始为 1

// 对每个点调用 DFS 计算最大路径长度
for(int i = 0; i < n; i++) {
for(int j = 0; j < m; j++) {
res = max(res, dfs(i, j)); // 更新最长路径
}
}

cout << res << endl; // 输出结果
return 0;
}

Java
import java.util.*;

public class Main {
// 定义滑雪场的高度数组和记忆化数组
static int[][] g = new int[210][210]; // g[i][j]表示(i,j)点的高度
static int[][] f = new int[210][210]; // f[i][j]表示从(i,j)开始的最大滑雪路径长度
static int n, m; // n为行数，m为列数
// 四个方向的偏移量，分别是上、下、左、右
static int[] dx = {-1, 1, 0, 0}, dy = {0, 0, 1, -1};

// 深度优先搜索函数
static int dfs(int x, int y) {
// 如果该点的最大路径长度已经计算过，直接返回
if (f[x][y] != -1) return f[x][y];
f[x][y] = 1; // 初始化路径长度为1（包括当前点）
int t = 0; // 用于记录可达的最大路径长度

// 遍历四个相邻的方向
for (int i = 0; i < 4; i++) {
int a = dx[i] + x, b = dy[i] + y; // 计算相邻点的坐标
// 检查边界条件和高度条件，确保只向低于当前高度的点滑动
if (a < 0 || a >= n || b < 0 || b >= m || g[a][b] >= g[x][y]) continue;
// 递归调用DFS函数计算相邻点的最大路径长度
t = Math.max(t, dfs(a, b));
}

// 更新当前点的最大路径长度
f[x][y] += t;
return f[x][y]; // 返回当前点的最大路径长度
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 创建输入扫描器
n = sc.nextInt(); // 输入行数
m = sc.nextInt(); // 输入列数
// 输入每个点的高度
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
g[i][j] = sc.nextInt();
}
}

// 初始化记忆化数组f为-1，表示尚未计算
for (int i = 0; i < n; i++) {
Arrays.fill(f[i], -1); // 将每一行的所有值设置为-1
}

int res = 1; // 记录最长路径长度，初始为1
// 对每个点调用DFS函数计算最大路径长度
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
res = Math.max(res, dfs(i, j)); // 更新最长路径
}
}

// 输出最长滑雪路径长度
System.out.println(res);
}
}

Python3
# 读取行数 n 和列数 m
n, m = map(int, input().split())
# 读取滑雪场的高度矩阵 g
g = [list(map(int, input().split())) for _ in range(n)]
# 初始化记忆化数组 f，用于存储每个点的最大路径长度，初始值为 -1
f = [[-1] * m for _ in range(n)]
# 定义四个方向的偏移量：上、下、左、右
dx, dy = [-1, 1, 0, 0], [0, 0, 1, -1]

# 深度优先搜索函数
def dfs(x, y):
# 如果该点的最大路径长度已经计算过，直接返回
if f[x][y] != -1:
return f[x][y]

# 初始化当前点的路径长度为 1（包括当前点）
f[x][y] = 1
t = 0  # 用于记录可达的最大路径长度

# 遍历四个相邻的方向
for i in range(4):
a, b = dx[i] + x, dy[i] + y  # 计算相邻点的坐标
# 检查边界条件和高度条件，确保只向低于当前高度的点滑动
if a < 0 or a >= n or b < 0 or b >= m or g[a][b] >= g[x][y]:
continue  # 跳过不满足条件的点

# 递归调用 DFS 函数计算相邻点的最大路径长度
t = max(t, dfs(a, b))

# 更新当前点的最大路径长度
f[x][y] += t
return f[x][y]  # 返回当前点的最大路径长度

res = 1  # 记录最长路径，初始为 1
# 对每个点调用 DFS 函数计算最大路径长度
for i in range(n):
for j in range(m):
res = max(res, dfs(i, j))  # 更新最长路径

# 输出最长滑雪路径长度
print(res)

题目描述
小明是一个喜欢探索极限的滑雪家, 他热衷于探索怎样才能使滑雪的路径最长
小明从滑雪场的一个点滑向另一个点需要两个要求 :
1 : 另一个点在小明当前点的附近 (前, 后, 左, 右)
2 : 另一个点的高度严格小于当前点
输入描述
给定长为 RRR, 宽为 CCC 的滑雪场
接下来 RRR 行, 每行 CCC 个数字, 表示滑雪场每个点的高度
1≤R,C≤2001\le R,C\le 2001≤R,C≤200
0≤Grid[i][j]≤231−10 \le Grid[i][j] \le 2^{31} - 10≤Grid[i][j]≤231−1
输出描述
最长的滑雪路径长度
样例
输入
3 3
9 6 4
5 6 7
2 1 1

输出
5

说明
最长的滑雪路径为[7,6,5,2,1]，因此这条路径的节点的个数为5

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 80ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-树（P2349）
- 链接：https://codefun2000.com/p/P2349

> 页面标题：#P2349. 第2题-树

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥想构造一棵包含值为1到n的节点的二叉搜索树，并求出所有可能的不同二叉搜索树中，高度不超过k的数量。给定两个整数n和k（满足1 ≤ n, k ≤ 35），请输出符合条件的二叉搜索树的数量。例如，输入为5和4时，输出为26。
思路：动态规划/记忆化搜索
定义cache[i][j]cache[i][j]cache[i][j]有iii个节点，并且树的高度不超过jjj的情况下，可以构造的二叉查找树的数量。
具体可以使用动态规划或者记忆化搜索来实现
初始状态为cache[n][k]cache[n][k]cache[n][k]，枚举到当前剩余节点个数为mmm时，我们可以分别枚举给左子树分配[1:m][1:m][1:m]个节点，右子树分配[m−1:0][m-1:0][m−1:0]个节点，并将对应的方案累乘，即为当前的方案数，累加当前方案数即为最终答案
为了避免重复计算，需要使用记忆化搜索
dfs(cnt, dep)函数表示当前有cnt个节点，树的高度为dep时，能构造出的二叉查找树的数量。
如果cnt为0，表示没有节点，那么只能构造出一棵空树，所以返回1。如果dep为0，表示树的高度已经超过了k，那么不能再构造出新的树，所以返回0。
初始状态

基础情况：

当节点数为 0 时，即 cnt == 0，返回 1，因为空树是唯一的。
当高度 dep == 0 而节点数不为 0 时，返回 0，因为这表示树的高度已经超过了 kkk。

状态转移：

对于每个节点 iii，可以选择作为根节点的值，然后分别将剩余的节点分配给左子树和右子树。左子树可以有 [1:i][1:i][1:i] 个节点，右子树可以有 [i−1:0][i-1:0][i−1:0] 个节点。
对于每种选择，左右子树的组合数量相乘，然后累加到结果中。

代码
C++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 40; // 定义最大节点数
// cache数组，记录状态
int cache[N][N];

// 记忆化搜索函数，计算cnt个节点高度不超过dep的二叉搜索树数量
int dfs(int cnt, int dep) {
// 如果当前状态已经计算过，直接返回结果
if (cache[cnt][dep] != -1) return cache[cnt][dep];

// 如果没有节点，则返回1（空树）
if (cnt == 0) return 1;

// 如果高度已经超出k，则返回0
if (dep == 0) return 0;

int res = 0; // 用于累计结果
// 遍历每个节点作为根节点
for (int i = 1; i <= cnt; ++i) {
// 计算左子树和右子树的数量并累加
res += dfs(i - 1, dep - 1) * dfs(cnt - i, dep - 1);
}
// 记录结果到cache数组
return cache[cnt][dep] = res;
}

int main() {
int n, k; // n为节点数，k为高度限制
cin >> n >> k; // 输入n和k
memset(cache, -1, sizeof cache); // 初始化cache数组为-1
cout << dfs(n, k) << endl; // 输出结果
return 0; // 程序结束
}

python代码
from functools import lru_cache

# 读取输入的节点数 n 和树的最大高度 k
n, k = map(int, input().split())

@lru_cache(maxsize=None)  # 使用 lru_cache 装饰器实现记忆化搜索，避免重复计算
def dfs(cnt, dep):
# 如果当前没有节点，返回 1，因为空树是唯一的
if cnt == 0:
return 1
# 如果当前深度小于等于 0，返回 0，因为无法构造树
if dep <= 0:
return 0

ans = 0  # 初始化结果计数器
# 遍历所有可能的根节点
for i in range(cnt):
# 递归计算左子树的数量，节点数为 i，深度减 1
lc = dfs(i, dep - 1)
# 递归计算右子树的数量，节点数为 cnt - i - 1，深度减 1
rc = dfs(cnt - i - 1, dep - 1)
# 累加左右子树的组合数量
ans += lc * rc

return ans  # 返回当前节点数和深度下的树的数量

# 输出从 n 个节点和最大深度 k 能构造的二叉搜索树的数量
print(dfs(n, k))

Java代码
import java.util.Scanner;

public class Main {
static final int N = 40; // 定义常量 N，表示最大节点数
static int[][] cache = new int[N][N]; // 创建二维数组 cache，用于存储已经计算过的结果

// 深度优先搜索函数，计算在 n 个节点且高度不超过 k 的情况下可构造的树的数量
static int dfs(int n, int k) {
// 如果当前状态已计算过，直接返回结果
if (cache[n][k] != -1) return cache[n][k];
// 如果节点数为 0 且高度为 0，返回 1（表示空树）
if (k == 0 && n == 0) return 1;
// 如果节点数不为 0 但高度为 0，返回 0（无法构造树）
if (k == 0 && n != 0) return 0;
// 如果节点数为 0，返回 1（空树）
if (n == 0) return 1;

int res = 0; // 初始化结果计数器
// 遍历所有可能的根节点
for (int i = 1; i <= n; ++i) {
// 递归计算左子树和右子树的组合数量
res += dfs(i - 1, k - 1) * dfs(n - i, k - 1);
}
// 记录当前状态的结果到 cache 数组
return cache[n][k] = res;
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象用于输入
int n = scanner.nextInt(); // 读取节点数 n
int k = scanner.nextInt(); // 读取树的最大高度 k

// 初始化 cache 数组为 -1，表示尚未计算
for (int i = 0; i < N; i++) {
for (int j = 0; j < N; j++) {
cache[i][j] = -1;
}
}

// 输出从 n 个节点和最大深度 k 能构造的二叉搜索树的数量
System.out.println(dfs(n, k));
}
}

题目描述
定义二叉搜索树为满足如下性质的特殊二叉树：

若其左子树不为空，则左子树上所有结点的值均小于其根结点的值；
若其右子树不为空，则右子树上所有结点的值均大于其根结点的值；

若满足以上条件，则称该二叉树的左右子树分别为二叉查找树。
给定一个整数 nnn，小明想构造一棵二叉查找树，由值为 111 到 nnn 的结点构成，请你帮小明求出所有能够构造出的不同二叉查找树中，高度不超过 kkk 的数量。（根节点高度为 111）
输入描述
两个整数 nnn 和 kkk，满足 1≤n,k≤351 \le n, k \le 351≤n,k≤35。
输出描述
一个整数，表示答案。
5 4

26

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 71ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-通话不中断的最短路径（P2346）
- 链接：https://codefun2000.com/p/P2346

> 页面标题：#P2346. 第2题-通话不中断的最短路径

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在一个 M×NM \times NM×N 的网格中，每个单元格代表不同的能量强度，其中灰色单元格为禁地，橙色单元格为能量覆盖区域，绿色单元格为生命之树，表示生命之树散发的初始能量强度。能量强度会向外传播，每向外一格减少 111，最低为 000。若某位置接收到多棵生命之树的能量，取最大值。如果能量强度低于阈值 ThThTh，则能量中断。任务是从左上角到右下角寻找一条信号不中断的最短路径，若不存在则返回 000。
思路：Dijkstra算法，最短路
容易这个问题可以分成两部分求解：
第一步：求解网格内每个点的最大信号强度。
第二步：对最大信号强度大于等于 ThThTh，且相邻的点对连边，最后输出出发点到终点的最短路。
对于第一步，我们可以先建一个图，把网格上的每一个点映射到图上的点，并在图上创建一个虚拟的源点，对于每个网格图上的点，当它的信号强度为 WWW 时, 从源点到网格图上的点连一条边权为 −W-W−W 的边。
然后对于每个在网格图上相邻的节点，我们在它们之间连一条边权为 111 的边，此时虚拟源点到每个网格图上的点的最短路即为负的最大信号强度，因为容易发现我们只是把操作反着进行了。
对于第二步，我们通过 BFSBFSBFS，求解出发点到终点的最短路，注意特判出发点不合法的情况。
题解
这个问题可以分为两个主要部分进行求解：

计算每个网格点的最大信号强度：

我们可以构建一个图，将网格中的每个点映射为图上的点，并创建一个虚拟源点。对于每个网格点，当其信号强度为 WWW 时，从源点到该网格点连一条权重为 −W-W−W 的边。这样，当我们进行最短路径计算时，实际得到的是每个点的最大信号强度的负值。
此外，对于相邻的网格点（上下左右），我们在它们之间连一条权重为 111 的边。这样，每个网格点的最短路径即为负的最大信号强度。

寻找从起点到终点的最短路径：

在确定了每个点的最大信号强度后，我们需要判断哪些点的信号强度大于等于给定的阈值 ThThTh，并在这些点之间建立边。最后，使用广度优先搜索（BFS）算法，计算从起点到终点的最短路径。

代码
cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int grid[1005][1005]; // 存储网格信号强度的数组
int th, n, m; // 阈值，网格的行数和列数
vector<int> d{-1, 0, 1, 0, -1}; // 方向数组，用于快速计算相邻节点的坐标

// 自定义比较器，用于优先队列，按边权大小排序
struct Compare {
bool operator()(const vector<int>& a, const vector<int>& b) {
return a[0] > b[0]; // 边权较大的排在后面
}
};

// BFS求解函数，返回从起点到终点的最短路径
int solve(queue<vector<int>> q2) {
int dis = 0; // 记录当前的距离
while (!q2.empty()) {
int siz = q2.size(); // 当前队列大小

for (int i = 1; i <= siz; i++) {
vector<int> tp = q2.front(); // 获取队头元素
q2.pop(); // 弹出队头元素

// 如果到达终点，返回当前距离
if (tp[0] == n - 1 && tp[1] == m - 1) {
return dis;
}

// 遍历四个方向
for (int j = 1; j <= 4; j++) {
int tx = tp[0] + d[j - 1]; // 新行坐标
int ty = tp[1] + d[j]; // 新列坐标

// 检查边界及信号强度是否符合条件
if (tx >= 0 && ty >= 0 && tx < n && ty < m && grid[tx][ty] >= th) {
grid[tx][ty] = 0; // 将信号强度置为0，作为访问标记
q2.push({tx, ty}); // 将新坐标入队
}
}
}
dis++; // 增加距离
}

return 0; // 没有有效路径，返回0
}

int main() {
cin >> th >> n >> m; // 输入阈值、行数和列数
int k; // 生命之树的个数
cin >> k;

// 处理每棵生命之树的信息
for (int i = 0; i < k; i++) {
int x, y, w; // 生命之树的坐标和初始能量强度
cin >> x >> y >> w;
grid[x][y] = -w; // 将生命之树的初始能量变为负值
}

priority_queue<vector<int>, vector<vector<int>>, Compare> q; // 优先队列用于Dijkstra算法

// 初始化优先队列，计算从源点到每个点的最短路径
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
q.push({grid[i][j], i, j}); // 将每个点的信号强度及坐标入队
}
}

while (!q.empty()) {
vector<int> tp = q.top(); // 获取队顶元素
q.pop(); // 弹出队顶元素

// 如果该节点的值已经被松弛过，跳过
if (grid[tp[1]][tp[2]] != tp[0]) continue;

// 遍历四个方向进行松弛操作
for (int i = 1; i <= 4; i++) {
int tx = tp[1] + d[i - 1]; // 新行坐标
int ty = tp[2] + d[i]; // 新列坐标

// 检查边界
if (tx >= 0 && ty >= 0 && tx < n && ty < m) {
// 如果新计算的路径更优，更新信号强度并入队
if (grid[tx][ty] > tp[0] + 1) {
grid[tx][ty] = tp[0] + 1;
q.push({tp[0] + 1, tx, ty});
}
}
}
}

// 将信号强度转换回题目要求的格式
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
grid[i][j] = max(0, -grid[i][j]); // 重新计算信号强度
}
}

// 对信号强度大于等于 Th 的点进行BFS，寻找路径
queue<vector<int>> q2;
if (grid[0][0] < th) { // 特判出发点是否合法
cout << 0 << endl; // 如果出发点信号强度不够，输出0
return 0;
}

q2.push({0, 0}); // 将出发点入队
grid[0][0] = 0; // 标记为已访问
int dis = 0; // 距离初始化

cout << solve(q2) << endl; // 调用BFS求解并输出结果

return 0;
}

题目描述
在游戏世界中，给定一个 MMM * NNN 的网格，其中每个单元格都填有数字，数字大小表示覆盖能量强度。灰色网格代表禁地，橙色网格代表能量覆盖区域，绿色网格代表生命之树，绿色网格内数字大小表示该生命之树散发的能量的初始强度。
已知每个网格内的能量强度每向外(上下左右)传播一格，能量强度减 111，最小减为 000 。
0表示无信号，如下图示。当某个位置可以同时接收到多棵生命之树的能量时，取其中接收能量强度的最大值作为该位置的能量强度，对于给定网格，请判断是否存在一条路径，使得从左上角移动到右下角过程中能量不中断，只能上下左右移动。假设接吸收的能量强度低于门限 ThThTh ，能量就会中断。
注意:出发点固定在网格的左上角，终点是网格的右下角。
输入
第一行输入能量强度 ThThTh 。( 1≤Th≤1001 \le Th \le 100 1≤Th≤100)
第二行输入矩阵 MMM 、NNN 。(1≤M≤100，1≤N≤1001 \le M \le 100，1\le N \le1001≤M≤100，1≤N≤100)
第三行输入生命之树的个数 KKK。 (1≤K≤1001 \le K \le 1001≤K≤100)
后续 KKK 行输入生命之树的位置及初始能量强度。(前两个值表示生命之树所在行、列索引，第 333 个值表示生命之树初始能量强度)
输出
返回信号不中断的最短路径，不存在返回 000。
样例1
输入
1
4 4
2
0 1 2
3 2 3

输出
6

说明

能量强度门限 ThThTh = 111

MMM = 444,NNN = 444

444 * 444 网格中一共包含 222 棵生命之树

222 棵生命之树的位置，其中第 111 个生命之树在第 000 行第 111 列、初始能量强度 = 222 ；第 222 棵生命之树在第 333 行第 222 列、初始能量强度 = 333

样例2
输入
1
5 5
5
0 1 2
0 4 3
2 3 2
4 0 3
4 3 2

输出
8

说明

能量强度门限 ThThTh = 111
MMM = 555 , NNN = 555
555 * 555 网格中一共包含 555 棵生命之树
555 棵生命之树的位置，其中第 111 棵生命之树在第 000 行第 111 列、初始能量强度 = 222:第 222 棵生命之树在第 000 行第 444列、初始能量强度 =333;第 333 棵生命之树在第 222 行第 333 列、初始能量强度 = 222 ;第 444 棵生命之树在第 444 行第 000 列 、初始能量强度 333 ;第 555 棵生命之树在第 444 行第 333 列、初始能量强度= 222;

注：如上Grid ，绿色表示生命之树，橙色为生命之树散发的能量往外传播后覆盖的区域，按照途中箭头方向移动路径最短。

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 82ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-大模型训练（P2343）
- 链接：https://codefun2000.com/p/P2343

> 页面标题：#P2343. 第2题-大模型训练

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
在这个问题中，我们需要计算出一个量子计算机所需的最低算力，以便在给定的时刻内完成所有子任务。任务的算力需求由一个列表表示，且要求在 T 个时刻内完成这些任务，同时在每个时刻调度的多个任务的算力需求总和不能超过量子计算机的最大算力。通过合理安排任务，可以求得最低的算力需求，以确保所有任务在指定时限内完成。
思路：二分
二分最低的算力需求，因为越高的算力，往往可以越快的完成所有任务，所以满足递增性，可以二分。
对于每个算力需求，直接遍历模拟是否满足在T时刻内完成所有任务。
题解
这个问题要求我们找到量子计算机所需的最低算力，以便在给定的 T 个时刻内完成所有子任务。由于较高的算力能够更快地完成任务，因此可以利用二分查找来优化我们的搜索过程。
思路

定义问题：

给定一个任务的算力需求列表 tasks 和时刻限制 T，我们需要找出最小的算力值 S，使得在 T 个时刻内可以完成所有任务。

二分查找：

将算力需求的范围设定为 [1, 10^9]（可根据实际情况调整）。因为任何有效的算力需求都应该在这个范围内。
利用二分查找法，不断缩小查找范围，以找到最小的满足条件的算力。

模拟检查：

对于每一个猜测的算力 y，遍历任务列表并模拟如何在 T 个时刻内安排任务。
如果当前的算力总和超出 y，则需要增加一个时刻，并重置当前算力。
如果在模拟结束时使用的时刻超过 T，则说明该算力不足。

结果输出：

最终找到的 l 即为所需的最低算力。

JavaScript
// 读取输入，并将其拆分为字符串数组
let input = readline().split(' ');
// 将输入的第一个值转换为整数 N，表示任务数量
let N = parseInt(input[0]);
// 将输入的第二个值转换为整数 T，表示可用的时刻数
let T = parseInt(input[1]);
// 读取任务的算力需求，并将其转换为数字数组 a
let a = readline().split(' ').map(Number);

// 初始化二分查找的左右边界
let l = 1; // 最小算力
let r = 1e9; // 最大算力

// 定义检查函数 check(y)，用于判断当前算力 y 是否能够在 T 时刻内完成所有任务
function check(y) {
let cur = 0; // 当前时刻内的算力总和
let res = 1; // 当前使用的时刻数

// 遍历每个任务的算力需求
for (let x of a) {
// 如果当前任务的算力加上当前总和超出 y
if (cur + x > y) {
res += 1; // 需要增加一个时刻
cur = 0; // 重置当前算力总和
}

cur += x; // 将当前任务的算力加到当前总和

// 如果在分配任务时当前算力超过了 y，返回 false
if (cur > y) {
return false;
}
}

// 返回使用的时刻数是否小于等于 T
return res <= T;
}

// 进行二分查找
while (l < r) {
// 计算中间值
let mid = (l + r) >> 1;

// 如果当前算力 mid 能满足条件
if (check(mid)) {
r = mid; // 尝试更小的算力
} else {
l = mid + 1; // 否则，增加算力
}
}

// 输出找到的最低算力
print(l);

Java
import java.util.Scanner; // 导入 Scanner 类用于输入处理

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in); // 创建 Scanner 对象以接收输入

// 读取任务数量 N 和可用的时刻数 T
int N = scanner.nextInt();
int T = scanner.nextInt();

// 创建数组 a 存储每个任务的算力需求
int[] a = new int[N];
for (int i = 0; i < N; i++) {
a[i] = scanner.nextInt(); // 读取每个任务的算力需求
}

// 初始化二分查找的左右边界
int l = 1; // 最小算力
int r = (int) 1e9; // 最大算力

// 进行二分查找
while (l < r) {
int mid = (l + r) >> 1; // 计算中间值

// 检查当前算力 mid 是否满足条件
if (check(a, mid, T)) {
r = mid; // 如果满足条件，尝试更小的算力
} else {
l = mid + 1; // 否则，增加算力
}
}

// 输出找到的最低算力
System.out.println(l);
}

// 检查给定算力 y 是否能够在 T 时刻内完成所有任务
private static boolean check(int[] a, int y, int T) {
int cur = 0; // 当前时刻内的算力总和
int res = 1; // 当前使用的时刻数

// 遍历每个任务的算力需求
for (int x : a) {
// 如果当前任务的算力加上当前总和超出 y
if (cur + x > y) {
res += 1; // 需要增加一个时刻
cur = 0; // 重置当前算力总和
}

cur += x; // 将当前任务的算力加到当前总和

// 如果在分配任务时当前算力超过了 y，返回 false
if (cur > y) {
return false;
}
}

// 返回使用的时刻数是否小于等于 T
return res <= T;
}
}

Python
# 读取输入：N 为任务数量，T 为可用的时刻数
N, T = map(int, input().split())
# 读取每个任务的算力需求，并存储在列表 a 中
a = list(map(int, input().split()))

# 初始化二分查找的左右边界
l, r = 1, int(1e9)

# 定义检查函数 check(y)，用于判断当前算力 y 是否能够在 T 时刻内完成所有任务
def check(y):
cur, res = 0, 1  # cur 表示当前时刻的算力总和，res 表示当前使用的时刻数
for x in a:  # 遍历每个任务的算力需求
# 如果当前任务的算力加上当前总和超出 y
if cur + x > y:
res += 1  # 需要增加一个时刻
cur = 0  # 重置当前算力总和
cur += x  # 将当前任务的算力加到当前总和
# 如果在分配任务时当前算力超过了 y，说明不满足条件
if cur > y:
return False
# 返回使用的时刻数是否小于等于 T
return res <= T

# 进行二分查找
while l < r:
mid = (l + r) >> 1  # 计算中间值
if check(mid):  # 如果当前算力 mid 能满足条件
r = mid  # 尝试更小的算力
else:  # 否则，增加算力
l = mid + 1  # 尝试更大的算力

# 输出找到的最低算力
print(l)

C++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
int N, T; // N为任务数量，T为时刻数量
cin >> N >> T;

vector<int> a(N); // 存储每个任务的算力需求
for (int i = 0; i < N; ++i) {
cin >> a[i];
}

int l = 1; // 最小算力
int r = 1e9; // 最大算力

// 检查给定算力y是否能够在T时刻内完成所有任务
auto check = [&](int y) {
int cur = 0; // 当前时刻内的算力总和
int res = 1; // 当前时刻数

for (int x : a) {
// 如果当前任务的算力加上当前总和超出y
if (cur + x > y) {
res += 1; // 需要新增一个时刻
cur = 0; // 重置当前算力
}

cur += x; // 增加当前任务的算力

// 如果在分配任务时当前算力超过了y，返回false
if (cur > y) {
return false;
}
}

// 返回使用的时刻数是否小于等于T
return res <= T;
};

// 二分查找
while (l < r) {
int mid = (l + r) >> 1; // 计算中间值

if (check(mid)) { // 如果满足条件，说明算力可以更低
r = mid; // 缩小右边界
} else { // 否则，增加算力
l = mid + 1; // 缩小左边界
}
}

cout << l << endl; // 输出找到的最低算力

return 0;
}

题目描述
现有训练子任务模型的列表tasks, tasks[i]表示第i个子任务的算力需求，为了保证模型计算的时间，要求所有任务在T时刻内完成计算。
每个时刻，需要按照给出子任务模型的算力需求列表调度到量子计算机完成计算，任意时刻调度的多个子任务的算力需求综合不能超过量子计算机的最大算力负荷。
请返回量子计算机所需要提供的最低算力，可以在T时刻内计算完全部子任务模型
输入描述
输入：包含两行，第一行2个整数N, T，分别表示子任务模型列表长度，计算子任务模型的时刻要求。
第二行包含N个整数：task[1] task[2] task[3] ... task[n]分别表示第i个子任务的算力需求
输出描述
输出：一行包含一个整数，表示量子计算机所需要的最低算力
备注：

1 <= T <= N <= 50000
1 <= tasks[i] <= 500

示例1
输入
10 5
1 2 3 4 5 6 7 8 9 10

输出
15

说明：
最低算力需求为15时，可以在5时刻范围内完成所有任务
时刻1: 完成1，2,3,4,5的任务；时刻2：完成6,7的任务；时刻3：完成8任务；时刻4：完成9任务；时刻5：完成10任务
示例2
输入
6 3
4 4 2 1 2 3

输出
6

说明：
时刻1:4； 时刻2:4,2； 时刻3:1,2,3

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 69ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-大礼包（P2340）
- 链接：https://codefun2000.com/p/P2340

> 页面标题：#P2340. 第2题-大礼包

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
某公司为新用户推出大礼包，用户从任意一天注册后，可以连续登录xxx天并领取金币。金币数量与一年中nnn个月的日历相关，每个月第一天得1个金币，第二天得2个金币，以此类推。输入包含月数nnn和连续登录天数xxx，以及每个月的天数d1,d2,…,dnd_1, d_2, \ldots, d_nd1​,d2​,…,dn​。要求计算用户在注册后连续登录xxx天，最多可以获得的金币总数，且连续登录可能跨年。
题解
塔子哥希望找到连续 x 天内可以获得最多金币的方案。为了实现这一目标，我们的日历数据是一个长度为 n 的数组 d，其中每个元素表示每个月的天数。由于塔子哥可以跨越到下一年的第一个月，因此我们需要考虑跨年情况。为了解决这个问题，我们采用了以下思路：

双倍日历数组：将日历数组 d 复制一份，形成一个长度为 2n 的数组。这一做法确保我们可以在任何地方找到长度为 x 的连续天数，并且能够平滑地处理跨年情况。

滑动窗口算法：我们通过滑动窗口的方式来计算在不同起点下，连续 x 天可以获得的金币总数。窗口的初始位置从 0 开始，每次移动一格，尝试不同的起点。

动态调整窗口：在窗口滑动过程中，维护当前窗口中的天数和金币总和。如果当前窗口内的天数和大于 x，则从左侧移除天数，直到窗口中的天数和小于等于 x。

计算金币总数：当窗口天数和恰好等于 x 时，直接记录当前金币总和；如果小于 x，则计算剩余天数并用 sumup() 方法加上右侧不足的金币数。

更新最优解：每次计算得到的总金币数与当前的最优解比较，保留最大值。

代码解释

get(int n) 函数：计算从 1 到 n 的金币数量，这里使用了高效的数学公式。

主函数逻辑：

输入 n 和 x，以及每个月的天数，并创建一个长度为 2n 的数组。
使用滑动窗口遍历双倍数组，每次更新当前窗口的天数和金币总数。
通过动态调整窗口的左侧，确保总天数不超过 x。
计算当前窗口的金币总数，并实时更新最大金币数量 res。

时间复杂度
该算法的时间复杂度为 (O(n))，每个元素最多被访问两次，因此可以在线性时间内找到答案。
代码实现
C++代码
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 400010;  // 2倍日历数组的最大长度
typedef long long LL;

// 计算从1到n的和，用于金币数量计算
LL get(int n) {
return (1ll + n) * n / 2;  // 使用公式计算1到n的和
}

int main() {
LL n, x;
cin >> n >> x;  // 输入月数和连续登录天数

// 定义2倍长度数组，并输入日历数据
LL a[N * 2];  // 双倍长度的数组
for(int i = 0; i < n; i++) {
cin >> a[i];  // 输入每个月的天数
a[i + n] = a[i]; // 复制一份，形成双倍数组
}

LL s = 0;  // 当前窗口的总天数
LL res = 0;  // 最优解，最大金币数
LL t = 0;  // 当前窗口的金币总数

// 滑动窗口遍历数组
for(int i = 0, j = 0; i < 2 * n; ++i) {
s += a[i];  // 更新当前窗口的天数和
t += get(a[i]);  // 计算当前天数的金币数量并累加到总金币数

// 动态调整窗口，保持总天数不超过x
while (s - a[j] >= x) {
s -= a[j];  // 从窗口左侧移除天数
t -= get(a[j++]);  // 移除相应的金币数量
}

// 计算当前窗口金币数并更新最优解
res = max(res, t - get(s - x));  // 如果窗口的天数小于x，计算缺失部分金币并更新结果
}

cout << res << endl;  // 输出最大金币数
return 0;
}

Python代码
# 计算从 l 到 r 的连续整数和
def sumup(l, r):
return r * (r + 1) // 2 - l * (l - 1) // 2

# 输入日历长度和连续天数
n, x = map(int, input().split())
d = list(map(int, input().split()))
d += d  # 复制日历数据以处理跨年情况

ans = 0  # 初始化答案为0
cursum = 0  # 当前窗口天数和
cur = 0  # 当前窗口金币总数
l = 0  # 左窗口边界

# 滑动窗口遍历
for i in range(n * 2):
cursum += d[i]
cur += d[i] * (d[i] + 1) // 2

# 若窗口天数和超过 x ，从左边界移除
while cursum > x:
cursum -= d[l]
cur -= d[l] * (d[l] + 1) // 2
l += 1

# 计算当前窗口金币数并更新最优解
curans = cur
cnt = x - cursum
if l > 0:
curans += sumup(d[l - 1] - cnt + 1, d[l - 1])
ans = max(ans, curans)

print(ans)

Java代码
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
long x = scanner.nextLong();
long[] d = new long[2 * n];

// 读取日历数据并复制一份
for (int i = 0; i < n; i++) {
d[i] = scanner.nextLong();
d[i + n] = d[i];
}

long dayCnt = 0;  // 当前窗口的总天数
long coinSum = 0;  // 当前窗口金币总数
int j = 0;  // 左窗口边界
long ans = 0;  // 最大金币数

// 滑动窗口遍历日历数组
for (int i = 0; i < 2 * n; i++) {
dayCnt += d[i];
coinSum += d[i] * (1 + d[i]) / 2;

// 动态调整窗口大小
while (dayCnt > x) {
dayCnt -= d[j];
coinSum -= d[j] * (1 + d[j]) / 2;
j++;
}

// 计算当前窗口金币数并更新最优解
long rest = x - dayCnt;
long curans = coinSum;
if (j > 0) {
curans += sumup(d[j - 1] - rest + 1, d[j - 1]);
}
ans = Math.max(ans, curans);
}

System.out.println(ans);
}

// 计算从 l 到 r 的和，用于补全天数
public static long sumup(long l, long r) {
return r * (r + 1) / 2 - l * (l - 1) / 2;
}
}

代码注释说明

滑动窗口和范围控制：窗口控制中，dayCnt 记录窗口中连续天数之和，若超过 x 天，则缩小左边界。
金币计算：每个元素 d[i] 对应的金币数为连续整数的和，可以通过公式 d[i] * (1 + d[i]) / 2 计算。
剩余天数计算：若窗口天数和小于 x，则调用 sumup() 计算剩余金币，以补全连续天数，使总天数等于 x。
最终输出：输出记录的最大金币数。

某公司日对新用户推出大礼包，从任意一天注册开始，连续登录xxx天，每天可以领取一定的金币，领取金币的数量与该公司新设计的虚假世界的日历相关，该日历一年有nnn个月，第iii个月有did_idi​天，每一年都一样。在每个月第一天会得到1个金币，第天会得到2个金币币第三天会得到3个金币，后面次类推。
请计算新用户注册后连续登陆xxx天，最多可以获取多少金币。
请注意，连续登陆可能会跨年。
解答要求
时间限制:C/C++ 500ms,其他语言:1000ms
内存限制:C/C++ 256MB, 其他语言:512MB
输入
第一行包含两个整数nnn和x(1≤n≤2∗105)x(1\leq n\leq 2*10^{5})x(1≤n≤2∗105)，分别表示一年中的月数和连续登陆的天数。第二行包含 nnn 个整数 d1,d2,...,dnd_1,d_2,...,d_nd1​,d2​,...,dn​，did_idi​表示第iii个月的天数(1≤di≤1061 ≤ d_i ≤ 10^{6}1≤di​≤106)
用例保证，1≤x≤d1+d2+...+dn1 \leq x \leq  d_1+ d_2 + ...+ d_n1≤x≤d1​+d2​+...+dn​。
输出
打印新用户连续号陆x天最多可以获取的金币数量
样例1
输入
3 2
1 3 1

输出
5

解释
一年中每天获取的金币数是{1,1,2,3,1}\{1,1,2,3,1\}{1,1,2,3,1}(对应每个月中的天数)。如果在一年中的第3天开始注册陆，最多可以获取 2+3=52+3=52+3=5 个金币。
样例2
输入
3 6
3 3 3

输出
12

解释
一年中每天获取的金币数是{1,2,3,1,2,3,1,2,3}\{1,2,3,1,2,3,1,2,3\}{1,2,3,1,2,3,1,2,3}(对应每个月中的天数)。如果在一年中的第12天开始注册登陆，最多可以获取3+1+2+3+1+2=123+1+2+3+1+2=123+1+2+3+1+2=12个金币.
样例3
输入
5 6
4 2 3 1 3

输出
15

解释
一年中每天获取的金币数是{1,2,3,4,1,2,1,2,3,1,1,2,3}\{1,2,3,4,1,2,1,2,3,1,1,2,3\}{1,2,3,4,1,2,1,2,3,1,1,2,3}(对应每个月中的天数)。如果在一年中的第12天开始注册登陆，最多可以获取2+3+1+2+3+4=152+3+1+2+3+4=152+3+1+2+3+4=15个金币

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 78ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-互不重叠线段的最大价值（P2415）
- 链接：https://codefun2000.com/p/P2415

> 页面标题：#P2415. 第2题-互不重叠线段的最大价值

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题目大意
这道题目要求在坐标的x轴上选择若干条互不重叠的线段，使得所选线段的总价值最大
思路
每条线段由中点的横坐标、半径长度和价值决定。具体来说，线段的起点和终点分别为 p[i] - r[i] 和 p[i] + r[i]。选择的线段必须满足任意两条线段不重叠，即对于任意两条线段 i 和 j，要么 p[i] + r[i] <= p[j] - r[j]，要么 p[j] + r[j] <= p[i] - r[i]。
为了求解这个问题，我们可以采用动态规划的方法。以下是具体的步骤和分析：

线段的表示与排序
首先，我们需要将每条线段表示为一个结构体，包含起点、终点和价值。然后，将所有线段按照结束位置（即 p[i] + r[i]）从小到大排序。这一步的目的是为了在后续的动态规划中，能够方便地找到不重叠的线段。

动态规划的状态定义
定义一个数组 dp，其中 dp[i] 表示前 i 条线段中，选择互不重叠的线段所能获得的最大总价值。

状态转移方程
对于第 i 条线段，有两种选择：

不选择第 i 条线段：此时 dp[i] = dp[i-1]。
选择第 i 条线段：则需要找到最后一条不与第 i 条线段重叠的线段 j，此时 dp[i] = dp[j] + w[i]。
最终，dp[i] 取这两种情况的最大值。

寻找不重叠的线段
为了高效地找到最后一条不与当前线段重叠的线段 j，我们可以使用二分查找。因为线段已经按照结束位置排序，二分查找可以在较短的时间内完成。

初始化与边界条件
dp[0] = w[0]，表示只选择第一条线段时的最大价值。
对于 i > 0，按照状态转移方程逐步计算 dp[i]。

最终结果
最终的答案为 dp[n-1]，即选择前 n 条线段中，互不重叠的线段所能获得的最大总价值。

代码
Java代码
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

class node {
public int p, r, w;
}
class cmp implements Comparator<node> {	//自定义排序
public int compare(node a, node b) {
if (a.p < b.p)
return -1;
return 1;
}
}
class Main {
public static node[] a;
public static int M = 10010, n;
public static int[] dp;

public static int func() {
int ans = 0;
// 枚举每个线段i
for (int i = 0; i < n; i++) {
// 枚举其他线段j
for (int j = 0; j < i; j++) {
// 如果可以转移
if (a[i].p - a[i].r >= a[j].p + a[j].r) {
// 转移
dp[i] = Math.max(a[i].w + dp[j], dp[i]);
}
}
// 所有线段为结尾的取最优解
ans = Math.max(ans, dp[i]);
}
return ans;
}

public static void main(String[] args) {
dp = new int[M];
a = new node[M];
for (int i = 0; i < M; i++)
a[i] = new node();
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt();
for (int i = 0; i < n; i++) {
a[i].p = scanner.nextInt();
}
for (int i = 0; i < n; i++) {
a[i].r = scanner.nextInt();
}
for (int i = 0; i < n; i++) {
a[i].w = scanner.nextInt();
}
// 对中点排序
Arrays.sort(a, 0, n, new cmp());
// dp[0] = a[0].w;
for (int i = 0; i < n; i++) {
dp[i] = a[i].w;
}
System.out.println(func());
}
}

Python代码
class seg:
p,r,w=0,0,0
n=int(input())
dp=[0 for i in range(n)]
a=[seg() for i in range(n)]
b=list(map(int,input().split()))
for i in range(n):
a[i].p=b[i]
b=list(map(int,input().split()))
for i in range(n):
a[i].r=b[i]
b=list(map(int,input().split()))
for i in range(n):
a[i].w=b[i]
a.sort(key=lambda x:x.p)
ans=0
for i in range(n):
dp[i]=a[i].w
for i in range(n): #枚举每个线段i
for j in range(i): #枚举其他线段j
if a[i].p-a[i].r>=a[j].p+a[j].r: #转移
dp[i]=max(a[i].w+dp[j],dp[i])
ans=max(ans,dp[i]) #所有线段为结尾的取最优解
print(ans)

C++代码
#include<bits/stdc++.h>
using namespace std;

const int M = 1e4 + 4;
int dp[M];
int n;

struct node{
int p, r;
int w;
// 自定义排序
bool operator< (node &b)const{
return p < b.p;
}
}a[M];
// 动态规划
int func(){
int ans = 0;
// 枚举每个线段i
for(int i = 0; i < n; i++){
// 枚举其他线段j
for(int j = 0; j < i; j++){
// 如果可以转移
if(a[i].p - a[i].r >= a[j].p + a[j].r){
// 转移
dp[i] = max(a[i].w + dp[j], dp[i]);
}
}
// 所有线段为结尾的取最优解
ans = max(ans, dp[i]);
}
return ans;
}

int main(){
cin >> n;
for(int i = 0; i < n; i++){
cin >> a[i].p;
}
for(int i = 0; i < n; i++){
cin >> a[i].r;
}
for(int i = 0; i < n; i++){
cin >> a[i].w;
}
// 对中点排序
sort(a, a + n);
// dp[0] = a[0].w;
for(int i = 0; i < n; i++){
dp[i] = a[i].w;
}
cout << func() << endl;
return 0;
}

Js代码
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';

process.stdin.on('data', (data) => {
input += data;
return;
});
process.stdin.on('end', () => {
function cmp(a, b) {
return a.p - b.p;
}
function seg() {
this.p = 0;
this.r=0;
this.w=0;
}
let inputArray = input.split('\n');
let n = Number(inputArray[0]);
var a = new Array();
var b = new Array();
for (let i = 0; i < n; i++)
a[i] = new seg();
for (let i = 0; i < n; i++)
b[i] = Number(inputArray[1].split(' ')[i]);
for (let i = 0; i < n; i++)
a[i].p = b[i];
for (let i = 0; i < n; i++)
b[i] = Number(inputArray[2].split(' ')[i]);
for (let i = 0; i < n; i++)
a[i].r = b[i];
for (let i = 0; i < n; i++)
b[i] = Number(inputArray[3].split(' ')[i]);
for (let i = 0; i < n; i++)
a[i].w = b[i];
a.sort(cmp);
let dp = new Array();
for (let i = 0; i < n; i++) {
dp[i] = a[i].w;
}
let ans = 0;
// 枚举每个线段i
for (let i = 0; i < n; i++) {
// 枚举其他线段j
for (let j = 0; j < i; j++) {
// 如果可以转移
if (a[i].p - a[i].r >= a[j].p + a[j].r) {
// 转移
dp[i] = Math.max(a[i].w + dp[j], dp[i]);
}
}
// 所有线段为结尾的取最优解
ans = Math.max(ans, dp[i]);
}
console.log(ans);
});

题目大意
在坐标的x轴上有nnn条线段，第i条线段拥有wiw_iwi​的价值。请问选出若干条互不重叠的线段的最大价值是多少？
输入描述：
第一行一个整数n≤2000n \leq 2000n≤2000，代表线段的条数。
第二行n个整数，代表每条线段中点的横坐标。
第三行n个整数，代表每条线段的半径长度（即整条线段长度的一半）。
第四行n个整数，代表每条线段的价值
样例
输入
7
3 4 6 8 3 2 6
2 3 2 1 3 2 2
2 5 2 5 7 8 3

输出
13

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 70ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-最佳检测顺序（P2411）
- 链接：https://codefun2000.com/p/P2411

> 页面标题：#P2411. 第2题-最佳检测顺序

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明有一家云存储服务提供商，他们家的核心产品是一个可扩展的分布式存储系统。他们的客户使用他们的服务来存储和管理各种数据，包括文档、图片、视频等。由于客户对数据的可靠性和可用性要求非常高，他们需要提供高可用性的存储服务，以确保在任何情况下都能保持服务的可用性。
为了实现高可用性，他们使用了主备模式来管理他们的存储系统。当主节点发生故障时，系统会自动将业务切换到备用节点。为了保证存储系统的稳定性，他们需要及时检测服务状态，并在必要时触发主备切换。
在存储系统中，不同的服务之间存在 依赖关系 ，每个服务最多只会依赖一个其他服务并且保证依赖不成环。例如，某些服务可能需要访问其他服务的数据才能正常工作。因此，当某个服务发生故障时，它所依赖的服务也会受到影响，可能导致更多的服务发生故障。
为了最大限度地减少服务故障对业务的影响，他们需要优先检测对业务影响大的服务，并按照 节点编号升序编排 检测顺序，现在请你帮忙解决一下这个问题。
注意： 如果业务影响相同时，则按节点编号大小升序编排。
输入描述
第一行输入两个整数nnn 代表业务节点总个数。(1≤n≤100000)(1 \leq n \leq 100000)(1≤n≤100000)
接下来一行nnn个整数,第iii 个整数fif_ifi​ 代表ii i 依赖 fif_ifi​  (i∈[0,n−1])(i \in [0,n-1])(i∈[0,n−1]) 。
1.若fi=−1f_i = -1fi​=−1 , 则代表没有节点依赖
2.数据保证fi≠if_i \neq ifi​=i
输出描述
一行nnn个整数，以空格隔开，代表最终的排序结果.
样例1
输入
5
-1 -1 1 2 3

输出
1 2 3 0 4

#### TextSol

题目思路
这道题目要求对云存储系统中的服务节点进行排序，以便在检测服务状态时，能够优先检测对业务影响较大的节点。具体来说，影响力大的节点是指当该节点发生故障时，会影响更多依赖它的其他节点。为了实现这一目标，我们需要计算每个节点的影响力，即该节点及其所有后继节点的数量。然后，根据影响力对节点进行排序，影响力大的节点排在前面；如果影响力相同，则按节点编号的升序排列。
1. 依赖关系的表示
首先，我们需要理解服务节点之间的依赖关系。题目中指出，每个节点最多只依赖一个其他节点，并且依赖关系不成环。因此，整个系统的依赖关系可以表示为一组树结构或森林结构，每棵树的根节点是没有依赖的节点（f[i] = -1）。
2. 计算每个节点的影响力
影响力大的节点意味着该节点所在的子树规模大，即该节点及其所有后继节点的数量较多。因此，我们可以通过**深度优先搜索（DFS）**遍历每棵树，计算每个节点的子树大小。
具体步骤：
1.构建树结构：
使用一个数组fa[]表示每个节点的父节点。
使用邻接表e[]来存储每个节点的子节点。
2.深度优先搜索（DFS）：
从每棵树的根节点开始，递归计算每个节点的子树大小cnt[]。
cnt[i]表示节点i及其所有后继节点的总数量。
3. 排序节点
计算完每个节点的影响力后，我们需要根据以下规则对节点进行排序：
按影响力降序排列：影响力大的节点排在前面。
按节点编号升序排列：如果两个节点的影响力相同，则编号小的节点排在前面。
4. 输出排序结果
根据排序后的节点顺序输出节点编号，即为检测节点的优先顺序。
5. 时间复杂度分析
构建树结构：遍历所有节点，时间复杂度为O(n)。
DFS计算子树大小：每个节点只被访问一次，时间复杂度为O(n)。
排序：使用快速排序或其他高效排序算法，时间复杂度为O(n log n)。
总体时间复杂度：O(n log n)，适用于n最多为100,000的情况。
类似题目推荐
本质就是考察了一下dfs和自定义排序。较为经典。
LeetCode

112. 路径总和
129. 求根到叶子节点数字之和
236. 二叉树的最近公共祖先

CodeFun2000
1.P1224 携程 2023.04.15-春招-第三题-魔法之树
2.P1196 华为实习 2023-04-19-第二题-塔子哥出城
3.P1159. 2022年清华大学(深圳)保研夏令营机试题-第一题-树上计数
4.P1190 华为实习 2023.04.12-第二题-获取最多食物
5.P1044. 拼多多内推笔试-2023.2.22.投喂珍珠

更多请见:知识点分类-训练-深度优先搜索专栏

代码
CPP
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n;
int fa[N];				//节点i的父节点
vector<int> e[N];		//节点i的子节点
int cnt[N];				//节点i的子树中的节点个数
int dfs(int s)		//计算s的 子树中的节点个数
{
cnt[s] = 1;		//s本身
for(int g: e[s])	//遍历s的每个子节点
{
cnt[s] += dfs(g);	//递归计算每个子节点的子树的节点个数，然后加到s上
}
return cnt[s];		//返回s的子树的节点个数
}
int ans[N];
bool cmp(int &x, int &y) {		//重写排序函数，按照子树中节点个数排序，相等时按大小排序
if(cnt[x] == cnt[y]) return x < y;
return cnt[x] > cnt[y];
}
int main()
{
cin >> n;
for(int i = 0 ; i < n ; i++) {
cin >> fa[i];		//输入i的父节点
if(fa[i] != -1) {		//-1代表i没有父节点，此时i为一棵树的根节点
e[fa[i]].push_back(i);	//添加到父节点的子节点集合中
}
}
for(int i = 0 ; i < n ; i++) {
ans[i] = i;		//顺便初始化一下排序的值
if(fa[i] == -1)	//i为一棵树的根节点，从这个点开始遍历
dfs(i);
}
sort(ans, ans+n, cmp);	//排序
for(int i = 0 ; i < n ; i ++) {
cout << ans[i] << " \n"[i+1==n];	//输出，" \n"[i+1==n]代表最后一次输出回车，前面输出空格分割
}
}

python
from collections import defaultdict
n = int(input())
e = defaultdict(list)
a = list(map(int,input().split()))
# 读入 + 存图
for i in range(n):
if a[i] != -1:
e[a[i]].append(i)
# cnt 子树大小
cnt = [0] * n
# dfs 求子树大小
def dfs(u):
cnt[u] = 1
for v in e[u]:
dfs(v)
cnt[u] += cnt[v]
# 按题目要求排序
res = []
for i in range(n):
if cnt[i] == 0:
dfs(i)
res.append([i , cnt[i]])
res.sort(key = lambda x : (-x[1] , x[0]))
print(" ".join(map(str,[x[0] for x in res])))

Java
import java.lang.reflect.Array;
import java.util.*;

public class Main {
static int N = 100010;
static int n;
static Map<Integer, List<Integer>> graph = new HashMap<>();
static boolean[] visited = new boolean[N];
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
n = in.nextInt();
for(int i = 0; i < N; i++){
graph.put(i, new ArrayList<>());
}
// 读入,存图
for(int i = 0; i < n; i++){
int temp = in.nextInt();
if(temp != -1){
add(temp, i);
}
}
// dfs 求后继结点个数 , 以二元组形式存储，以便之后的自定义排序
List<int[]> res = new ArrayList<>();
for(int i = 0; i < n; i++){
res.add(new int[]{dfs(i), i});
}
// 自定义排序
Collections.sort(res, new Comparator<int[]>() {
@Override
public int compare(int[] a, int[] b) {
// 根据题解,优先按后继结点个数降序排序
if (a[0] != b[0]) {
return b[0] - a[0];
} else { // 相同情况下 按节点编号升序排序
return Integer.compare(a[1], b[1]);
}
}
});
// 输出答案
for(int[] pair : res){
System.out.print(pair[1] + " ");
}
}
// 计算后继节点个数
private static int dfs(int i){
int count = 0;
for(int j : graph.get(i)){
count += dfs(j);
}
return count+1;
}
private static void add(int a, int b){
graph.get(a).add(b);
}
}
// bt  guanam

Go
package main

import (
"fmt"
"sort"
)

const N int = 1e5 + 10

var f []int = make([]int, N)
var n int

type node struct {
id     int
sonCnt int
}

func dfs(edges [][]int, x int) int {
if len(edges[x]) == 0 {
return 1
}
res := 1
for _, v := range edges[x] {
res += dfs(edges, v)
}
return res
}

func main() {
//构建有向图 计算每个节点的子节点个数 排序
fmt.Scan(&n)
//有向图的邻接边
edges := make([][]int, n)
for i := range edges {
edges[i] = make([]int, 0)
}
outDegree := make([]int, n) //每个节点的出度
for i := 0; i < n; i++ {
fmt.Scan(&f[i])
if f[i] != -1 {
edges[f[i]] = append(edges[f[i]], i)
outDegree[f[i]]++
}
}
cnt := make([]int, n)
for i := 0; i < n; i++ {
if outDegree[i] == 0 { //如果出度为0 子节点就只算它自己
cnt[i] = 1
} else { //出度不为0 dfs它的所有直接子节点 更新它的总子节点个数
cnt[i] = dfs(edges, i)
}
}
nodes := make([]node, n)
for i := 0; i < n; i++ {
nodes[i].id = i
nodes[i].sonCnt = cnt[i]
}
sort.Slice(nodes, func(i, j int) bool {
if nodes[i].sonCnt != nodes[j].sonCnt { //子节点数量不同时 按照子节点数量降序排列
return nodes[i].sonCnt > nodes[j].sonCnt
}
return nodes[i].id < nodes[j].id //相同时 按照编号升序排列
})
for i := 0; i < n; i++ {
fmt.Printf("%d", nodes[i].id)
if i != n-1 {
fmt.Printf(" ")
}
}
}
// by xchen

Js
// 创建 readline interface 实例
const rl = require('readline').createInterface({input: process.stdin});

// 获取 readline 迭代器
const iter = rl[Symbol.asyncIterator]();

// 定义异步函数，并使用 IIFE 函数立即执行
void async function () {
// 读取第一行输入，n 代表节点个数
const n = parseInt(await readline());

// 读取第二行输入，F 代表以空格分隔的每个节点的父节点编号
const F = (await readline()).split(' ').map(item => parseInt(item));

// 创建 Map，存放每个节点的父节点后继位置的数组
const map = new Map();

// 定义数组存放每个节点所对应的后继结点个数
const count = [];

// 遍历每个节点，判断其父节点是否存在，如果存在，则将该节点下标加入其对应的数组中，否则跳过
for (let i = 0; i < n; i++) {
if (F[i] !== -1) {
if (map.has(F[i])) {
map.set(F[i], [...map.get(F[i]), i]);   // 将该节点下标 push 进去其父节点后继位置的数组中
}
else {
map.set(F[i], [i]);    // 新建一个数组，存放当前节点下标，指定其为其父节点的后继位置
}
}
}

// 定义深度优先遍历函数，参数分别为 map 和 currV，返回值为当前节点的后继结点个数
const dfs = (map, currV) => {
if (!map.has(currV) || map.get(currV) === 0) {   // 当前节点不存在或其没有后继结点，返回 1

return 1;
}
let res = 1;   // res 表示当前节点及其后继结点的总个数
const edge = map.get(currV);   // 获取当前节点的后继位置数组
for (let V of edge) {
res += dfs(map, V);   // 递归计算每个后继结点的后继结点总个数，并将结果加到 res 上
}
return res;   // 返回当前节点及其后继结点的总个数
}

// 定义二维数组 comp 存放每个节点的下标和其所对应的后继结点个数
const comp = new Array(n).fill(0).map(item => new Array(2).fill(0));
const res = [];

// 遍历每个节点，计算其所对应的后继结点总数并存入 comp 中
for (let i = 0; i < n; i++) {
comp[i][0] = i;   // 第一列存放节点下标
comp[i][1] = dfs(map, i);   // 第二列存放节点的后继结点总个数
}

// 对二维数组 comp 进行排序，先按第二列倒序排序，之后按第一列顺序排序
comp.sort((a, b) => {
if (a[1] === b[1]) {
return a[0] - b[0];
}
else {
return b[1] - a[1];
}
})

// 将排序后的节点下标存入 res 数组中
for (let pair of comp) {
res.push(pair[0])
}

// 输出 res 数组中的元素，以空格分隔
console.log(res.join(' '))
}()

---

### 第2题-第k大字母（P2417）
- 链接：https://codefun2000.com/p/P2417

> 页面标题：#P2417. 第2题-第k大字母

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

_（未抓到题解文本；可能未开放/需要权限/或页面结构不同）_

---

### 第2题-幼儿园排队报数（P2405）
- 链接：https://codefun2000.com/p/P2405

> 页面标题：#P2405. 第2题-幼儿园排队报数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一位幼儿园院长，他是一位富有经验和激情的教育专业人士。他对幼儿教育充满热情，致力于为幼儿提供最佳的教育和关爱。
作为幼儿园院长，小明在幼儿园的管理和运营方面有着丰富的经验。他深刻理解幼儿的成长和发展需要，关注每一个幼儿的个性和特点，并积极引导他们在安全、温馨、富有启发性的学习环境中成长。
今年春季，小明幼儿园开课了。开春小朋友入学报名参加互联网各大厂的春招。小朋友都排好队。但小朋友的身高有高有低，所以塔老师让所有小朋友报数：以自身为基准向队尾看，有几个比自己矮的小朋友就报几
换句话说：给定整数数组 numsnumsnums 即为排队的小朋友，要求返回新的数组 countscountscounts , counts[i]counts[i]counts[i] 为小朋友的报数
输入描述
第一行是数组长度 NNN
第二行是幼儿园小朋友的队列，一个长度 NNN 的整型数组
1≤nums.length≤1051 \leq nums.length \leq 10^51≤nums.length≤105 , 40≤nums[i]≤11040 \leq nums[i] \leq 11040≤nums[i]≤110
counts.length=nums.lengthcounts.length = nums.length counts.length=nums.length
输出描述
新的整型数组，数组元素是输入中对应位置小朋友的报数
样例
输入
5
81 82 76 75 100

输出
2 2 1 0 0

样例解释：
818181 的右侧有2个更小的元素(76,75)(76,75)(76,75)
828282 的右侧有2个更小的元素(76,75)(76,75)(76,75)
767676 的右侧仅有1个更小的元素(75)(75)(75)
757575 的右侧没有更小的元素
100100100 的也右侧没有更小的元素

#### TextSol

题解描述
在这道题中，需要计算每个小朋友右侧比自己身高低的人的数量。这是一个典型的数组统计问题，可以通过暴力统计方法解决。
代码思路
暴力统计法的核心思想是：

从右到左遍历每一个小朋友，使用一个数组 cnt 来记录当前所有出现过的不同高度小朋友的数量。
每当遍历到一个新的小朋友时，通过数组 cnt 中的数据可以快速计算出比当前小朋友低的所有小朋友的数量。
由于小朋友的身高范围有限（40到110），因此我们可以利用一个定长的数组来存储每个身高出现的频次，从而避免复杂的数据结构并提升性能。

具体步骤如下：

输入数据：首先读取小朋友的数量 n，然后读取每个小朋友的身高并存储在数组 a 中。
遍历并统计：从右向左遍历小朋友，记录当前小朋友的高度，将此高度计数加1，然后在计数数组 cnt 中统计出比当前小朋友低的所有身高的人数总和。
输出结果：结果存储在数组 ans 中，最后依次输出 ans 数组内容。

时间复杂度
对于每个小朋友，统计比自己低的高度的操作在高度范围内（40到110，即70种不同的身高）循环一次。因此时间复杂度为 (O(n \times h))，其中 (h) 为可能的身高值数量，即常数 70。所以，整体复杂度约为 (O(n))，性能可以满足要求。
C++代码
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
int a[N];        // 每个小朋友的高度
int cnt[200];    // 每个高度的小朋友个数
int ans[N];      // 最后答案
int n;

int main() {
cin >> n;
for(int i = 1; i <= n; i++) {
cin >> a[i];        // 输入每个小朋友的高度
}

// 从右向左遍历所有小朋友
for(int i = n; i > 0; i--) {
cnt[a[i]]++;        // 更新当前小朋友高度的计数
for(int j = 40; j < a[i]; j++) {
ans[i] += cnt[j];        // 累加比当前小朋友低的所有小朋友个数
}
}

// 输出最终结果
for(int i = 1; i <= n; i++) {
cout << ans[i] << " \n"[i == n];  // 输出结果，并避免行末空格
}
}

Python代码
# 输入数据
n = int(input())
a = list(map(int, input().split()))

# 初始化每个身高小朋友的计数和结果数组
cnt = [0] * 200
ans = [0] * n

# 从右向左遍历
for i in range(n - 1, -1, -1):
cnt[a[i]] += 1  # 更新当前小朋友的身高计数
# 统计比当前小朋友身高低的数量
ans[i] = sum(cnt[j] for j in range(40, a[i]))

# 输出结果
print(" ".join(map(str, ans)))

Java代码
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();

int[] a = new int[n + 1];  // 存储每个小朋友的身高
int[] cnt = new int[200];  // 记录每个高度的出现次数
int[] ans = new int[n + 1]; // 存储每个小朋友的报数结果

// 输入每个小朋友的身高
for (int i = 1; i <= n; i++) {
a[i] = scanner.nextInt();
}

// 从右向左遍历小朋友
for (int i = n; i > 0; i--) {
cnt[a[i]]++;  // 更新当前小朋友身高的计数
// 计算比当前小朋友低的身高数量
for (int j = 40; j < a[i]; j++) {
ans[i] += cnt[j];
}
}

// 输出报数结果
for (int i = 1; i <= n; i++) {
System.out.print(ans[i] + (i == n ? "\n" : " "));
}

scanner.close();
}
}

说明

数组 cnt：用于记录每种身高出现的频次，从而可以直接查询到比当前身高小的所有小朋友的数量。
遍历顺序：从右向左遍历，以便在统计过程中能够依次更新右侧的身高信息。
高度范围处理：身高的最小值是 40，因此在循环统计低于当前身高的小朋友数量时从 40 开始。这里假设高度的上限不会超过 200，从而将 cnt 定义为长度 200。

这种方法利用身高范围的限制和哈希表统计，从而使复杂度控制在 (O(n)) 左右，可以应对较大的数据输入。

---

### 第2题-地铁耗时最短的线路（P2807）
- 链接：https://codefun2000.com/p/P2807

> 页面标题：#P2807. 第2题-地铁耗时最短的线路

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

大湾区某城市地铁线路非常密集，乘客很难一眼看出选择哪条线路乘型比较合适，为了解决这个问题，地铁公司希望你开发一个程序帮助乘客挑选合适的乘坐线路，使得乘坐时间最短，地铁公司可以提供的数据是各相邻站点之间的乘坐时间。
输入描述
第一行:NNN，站点总数,3<=N<=203<=N<=203<=N<=20.
第二行:乘客的出发和到达站点。
第三行起:相邻站点之间的乘坐时间，每对站点一行，站点名称是单个小写字母，站点名一定包括出发和到达站点，输入保证只有一个唯一解;
结束行:000000000000
输出描述
耗时最短的线路
样例1
输入
12
a e
a b 2
b c 2
c d 2
d e 2
f b 3
b g 3
g h 2
h i 3
j h 2
h e 3
e k 2
k l 4
0000

输出
a b c d e

说明
输入对应的地铁图如下:

线路а->b->c->d->e耗时最短
样例2
输入
12
f k
a b 2
b c 2
c d 2
d e 2
f b 3
b g 3
g h 2
h i 3
j h 2
h e 3
e k 2
k l 4
0000

输出
f b c d e k

说明
输入对应的地铁图如下:

f->b->c->d->e->K是耗时最短的线路

▶️

#### TextSol

video solution

题解
题面描述
给定一个地铁线路网络，其中有NNN个站点（3≤N≤203 \le N \le 203≤N≤20）以及各个相邻站点之间的乘坐时间。输入中：

第一行为站点总数NNN；
第二行为乘客的出发站sss和到达站ttt；
接下来的若干行每行给出两个站点和它们之间的乘坐时间，输入持续到出现结束符"0000""0000""0000"为止。

本题中地铁网络被视为无向图，即每条输入的边可以双向使用。保证输入中起点与终点之间存在唯一一条耗时最短的路径。要求程序输出由各站点名称组成、以空格分隔的完整最短路径线路。

解题思路

构图：
将输入数据构造为一个无向图。每个站点作为图中的节点，每条输入边对应两个方向的边（即u→vu \to vu→v和v→uv \to uv→u），边的权值均为乘坐时间www。

算法选择：
使用DijkstraDijkstraDijkstra算法求解从出发站sss到终点ttt的最短时间路径。由于各边权均为正值，DijkstraDijkstraDijkstra能够高效地给出正确解。

路径还原：
在执行DijkstraDijkstraDijkstra过程中记录每个节点的前驱节点，最终利用该前驱记录由终点回溯到起点，再反转得到完整的最短路径。

代码分析

变量定义：

站点总数用变量NNN表示；
出发站和到达站分别用sss和ttt表示；
图采用邻接表形式存储（例如unordered_mapunordered\_mapunordered_map、dictdictdict或HashMapHashMapHashMap），存储每个节点的邻边及对应乘坐时间。

无向边构造：
读入每条边数据时，分别添加u→vu \to vu→v和v→uv \to uv→u两个方向的边。

DijkstraDijkstraDijkstra算法实现：

初始化距离映射distdistdist（所有站点距离设为无穷大∞\infty∞，起点sss距离置为000），并构造前驱记录映射prevprevprev；
利用优先队列维护当前最短路径候选，更新相邻边时检查是否可以用更小的距离更新终点的距离，并记录前驱节点。

问题本质：
本题归结为图论中的单源最短路径问题，核心在于如何正确构造无向图以及利用$$Dijkstra$$算法计算最短距离并恢复最短路径。

C++C++C++ 参考代码
#include <iostream>
#include <sstream>
#include <vector>
#include <unordered_map>
#include <limits>
#include <queue>
#include <string>
#include <algorithm>
using namespace std;

// 定义边结构体，表示两个节点之间的乘坐时间
struct Edge {
char to;      // 目的节点
int time;     // 乘坐时间
};

int main(){
int N;
cin >> N; // 输入站点总数N

char start, end;
cin >> start >> end; // 输入出发站s和到达站t

// 构造无向图，使用邻接表存储，每个输入边添加两个方向的边
unordered_map<char, vector<Edge>> graph;
while(true){
string u_str;
cin >> u_str;  // 如果遇到结束符"0000"则退出
if(u_str == "0000") break;
char u = u_str[0];
char v;
int t;
cin >> v >> t; // 读取两个站点和乘坐时间w
graph[u].push_back({v, t});
graph[v].push_back({u, t}); // 添加反向边
}

// 初始化距离映射和前驱映射
unordered_map<char, int> dist;
unordered_map<char, char> prev;
const int INF = numeric_limits<int>::max(); // 设定无穷大INF
// 确保图中每个涉及的节点都在距离映射中
for(auto &entry : graph){
dist[entry.first] = INF;
for(auto edge : entry.second){
if(dist.find(edge.to) == dist.end()){
dist[edge.to] = INF;
}
}
}
dist[start] = 0; // 起点距离置为0

// 定义优先队列，按照距离从小到大排序
using pii = pair<int, char>; // 表示(距离, 节点)
priority_queue<pii, vector<pii>, greater<pii>> pq;
pq.push({0, start});

// Dijkstra 算法核心循环
while(!pq.empty()){
auto [current_time, cur] = pq.top();
pq.pop();
if(current_time > dist[cur]) continue;
// 遍历当前节点的所有出边
for(auto edge : graph[cur]){
char next = edge.to;
int new_time = current_time + edge.time;
if(new_time < dist[next]){
dist[next] = new_time;
prev[next] = cur; // 记录前驱节点
pq.push({new_time, next});
}
}
}

// 使用前驱映射还原完整最短路径
vector<char> path;
for(char cur = end; cur != start; cur = prev[cur])
path.push_back(cur);
path.push_back(start);
reverse(path.begin(), path.end());

// 输出站点路径，站点之间用空格分隔
for(size_t i = 0; i < path.size(); i++){
cout << path[i];
if(i != path.size() - 1)
cout << " ";
}
cout << endl;

return 0;
}

PythonPythonPython 参考代码
import sys
import heapq

# 读取所有输入数据
lines = sys.stdin.read().strip().splitlines()
# 第一行：站点总数N
N = int(lines[0])
# 第二行：出发站s和到达站t
start, end = lines[1].split()
start = start.strip()
end = end.strip()

# 构造无向图，使用字典存储邻接边 (目的站, 乘坐时间)
graph = {}
i = 2
while i < len(lines):
if lines[i].strip() == "0000":
break
parts = lines[i].split()
u = parts[0].strip()
v = parts[1].strip()
t = int(parts[2])
# 添加 u -> v 的边
if u not in graph:
graph[u] = []
graph[u].append((v, t))
# 添加 v -> u 的边（无向图）
if v not in graph:
graph[v] = []
graph[v].append((u, t))
i += 1

# 初始化距离字典和前驱字典
INF = float('inf')
dist = {}
prev = {}
# 确保图中所有涉及的节点都在距离字典中
for u in graph:
if u not in dist:
dist[u] = INF
for (v, time) in graph[u]:
if v not in dist:
dist[v] = INF

dist[start] = 0

# 使用 heapq 实现优先队列，存储格式为 (距离, 节点)
pq = [(0, start)]
while pq:
current_time, cur = heapq.heappop(pq)
if current_time > dist[cur]:
continue
# 遍历当前节点的所有出边
for (next_node, w) in graph[cur]:
new_time = current_time + w
if new_time < dist[next_node]:
dist[next_node] = new_time
prev[next_node] = cur
heapq.heappush(pq, (new_time, next_node))

# 利用前驱字典回溯恢复完整最短路径
path = []
cur = end
while cur != start:
path.append(cur)
cur = prev[cur]
path.append(start)
path.reverse()

# 输出最短路径，站点之间空格分隔
print(" ".join(path))

JavaJavaJava 参考代码
import java.util.*;
import java.io.*;

public class MetroShortestPath {
// 定义边的类，包含目的站点和乘坐时间
static class Edge {
char to;     // 目的站点
int time;    // 乘坐时间

public Edge(char to, int time) {
this.to = to;
this.time = time;
}
}

// 用于优先队列中，存储(距离, 节点)对
static class Node implements Comparable<Node> {
char station;
int distance;

Node(char station, int distance) {
this.station = station;
this.distance = distance;
}

public int compareTo(Node other) {
return this.distance - other.distance;
}
}

public static void main(String[] args) throws Exception {
Scanner sc = new Scanner(System.in);
// 读取站点总数N
int N = sc.nextInt();
// 读取出发站s和到达站t
char start = sc.next().charAt(0);
char end = sc.next().charAt(0);

// 构造无向图，使用 HashMap 存储每个节点的邻接边，两条边表示无向边
Map<Character, List<Edge>> graph = new HashMap<>();
while (sc.hasNext()) {
String token = sc.next();
if (token.equals("0000"))
break;
char u = token.charAt(0);
char v = sc.next().charAt(0);
int t = sc.nextInt();
// 添加 u -> v 的边
if (!graph.containsKey(u)) {
graph.put(u, new ArrayList<>());
}
graph.get(u).add(new Edge(v, t));
// 添加 v -> u 的边（无向图）
if (!graph.containsKey(v)) {
graph.put(v, new ArrayList<>());
}
graph.get(v).add(new Edge(u, t));
}

// 初始化距离映射和前驱映射
Map<Character, Integer> dist = new HashMap<>();
Map<Character, Character> prev = new HashMap<>();
final int INF = Integer.MAX_VALUE;

// 确保所有涉及的节点均被初始化
for (Character u : graph.keySet()) {
dist.put(u, INF);
for (Edge edge : graph.get(u)) {
if (!dist.containsKey(edge.to)) {
dist.put(edge.to, INF);
}
}
}
dist.put(start, 0); // 出发站距离设为0

// 使用优先队列实现 Dijkstra 算法
PriorityQueue<Node> pq = new PriorityQueue<>();
pq.add(new Node(start, 0));

while (!pq.isEmpty()) {
Node curNode = pq.poll();
char cur = curNode.station;
int current_time = curNode.distance;
if (current_time > dist.get(cur))
continue;
if (graph.containsKey(cur)) {
for (Edge edge : graph.get(cur)) {
char next = edge.to;
int new_time = current_time + edge.time;
if (new_time < dist.get(next)) {
dist.put(next, new_time);
prev.put(next, cur);
pq.add(new Node(next, new_time));
}
}
}
}

// 利用前驱映射恢复完整最短路径
List<Character> path = new ArrayList<>();
for (char cur = end; cur != start; cur = prev.get(cur)) {
path.add(cur);
}
path.add(start);
Collections.reverse(path);

// 输出最短路径，各站点之间以空格分隔
StringBuilder sb = new StringBuilder();
for (int i = 0; i < path.size(); i++) {
sb.append(path.get(i));
if(i != path.size() - 1)
sb.append(" ");
}
System.out.println(sb.toString());

sc.close();
}
}

---

### 第2题-仓库管理（P2849）
- 链接：https://codefun2000.com/p/P2849

> 页面标题：#P2849. 第2题-仓库管理

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小华是一个仓库管理员，他的日常就是管理仓库产品的入库出库。
有四种操作：
ininin sss，给一个只包含小写字符和数字的字符串 sss ，表示一个新的产品入库，
产品编号为 sss 。
outoutout ，表示一个出库请求，小华会将最晚入库的产品出库。
countcountcount ，表示清点仓库里的产品数量。
checkcheckcheck ，表示查询仓库里编号字典序最小的产品。(字典序的顺序是先按照
第一个字符以升序排列;如果第一个字符一样，那就比较第二个、第三个
乃至后面的字母。如果比到最后两个串不一样长(比如，123123123 和
123451234512345 )，那么把短者排在前。)
输入描述
第一行一个整数 q(1<=q<=200000)q(1<=q<=200000)q(1<=q<=200000) 表示操作的次数。
接下来 qqq 行每行一个操作，为四种操作之一。
保证所有产品的编号都是仅包含数字和小写字母的字符串，每个字符串长
度不超过 202020 。
保证所有产品的编号互不相同。
输出描述
对于每个 outoutout 操作，输出一行，包含一个字符串，表示被出库的产品编号。
如果没有能出库的产品输出 EMPTYEMPTYEMPTY 。
对于每个 countcountcount 操作，输出一行，包含一个整数，表示当前仓库里的产品
数量。
样例1
输入
13
check
in c1
in c2
count
check
in b3
in b4
count
check
out
check
out
check

输出
EMPTY
2
c1
4
b3
b4
b3
b3
c1

说明
首先 checkcheckcheck 操作，此时仓库里没有产品输出 EMPTYEMPTYEMPTY。
后面 ininin c1c1c1 ininin c2c2c2 两个操作，仓库中有 c1c1c1 ，c2c2c2 两个产品，因此 countcountcount 操
作，输出为 222 。
checkcheckcheck 输出仓库里编号字典序最小的产品编号 c1c1c1。
然后 ininin b3b3b3 ininin b4b4b4 ，仓库中有 c1，c2，b3，b4c1，c2，b3，b4c1，c2，b3，b4 四个产品，countcountcount 操作输出
444 ，checkcheckcheck 输出仓库里编号字典序最小的产品编号 b3b3b3 ，outoutout 将最晚入
库的产品出库，输出 b4b4b4 ，checkcheckcheck 输出仓库里编号字典序最小的产品编号 b3b
3b3 。outoutout 将最晚入库的产品出库，输出 b3b3b3 ，此时仓库只有 c1，c2c1，c2c1，c2 两个
产品，checkcheckcheck 输出仓库里编号最小的产品编号 c1c1c1 。

#### TextSol

题目描述
小华管理一个仓库，支持四种操作：

in s：将编号为字符串 s（仅包含小写字母和数字，且各不相同）的产品入库。
out：将最晚入库的产品出库，并输出其编号；若仓库空，输出 EMPTY。
count：输出当前仓库中产品的数量。
check：输出仓库中编号按字典序最小的产品；若仓库空，输出 EMPTY。

要求在 q≤2×105q\le 2\times10^5q≤2×105 次操作内高效完成上述四种操作。
解题思路
数据结构设计

栈（stack）：维护入库顺序，用于 out 操作快速取出“最晚入库”产品。
最小堆（min‑heap） + 哈希集合（hash set）（Python 方案）

check 操作需要快速获取字典序最小者；使用堆顶即可。
由于 out 从栈中删除最新元素，需要在堆中做“懒删除”：出库时只从集合中移除，不立即从堆里删除；check 时弹出堆顶直到它在集合里才输出。

平衡二叉搜索树（Java/C++ 方案）

使用 TreeSet（Java）或 std::multiset（C++）维护所有在库编号，支持插入、删除、取最小均为 O(log⁡n)O(\log n)O(logn)。

操作实现

in s

栈 push(s)；集合/树插入 s；堆 push(s)（Python）。

out

如果栈空，输出 EMPTY；否则栈顶 pop() 得到编号 s，并从集合/树中删除，输出 s。

count

输出集合/树的大小。

check

Python：弹出堆顶直到该编号在集合中或堆空；若堆空输出 EMPTY，否则输出堆顶但不弹出。
Java/C++：若树为空输出 EMPTY，否则输出 first()/*begin()。

复杂度分析

Python（堆 + 哈希集合）：

in：O(log⁡n)O(\log n)O(logn)（堆）
out：O(1)O(1)O(1)（栈） + O(1)O(1)O(1)（集合）
check：均摊 O(log⁡n)O(\log n)O(logn)（堆）

Java/C++（栈 + 平衡树）：

所有操作均为 O(log⁡n)O(\log n)O(logn)（插入/删除/查找/取最小）或 O(1)O(1)O(1)（栈）

总体时间复杂度 O(qlog⁡q)O(q\log q)O(qlogq)，空间复杂度 O(q)O(q)O(q)。

代码实现
Python
import sys
import heapq

def main():
input = sys.stdin.readline
q = int(input())
stack = []
min_heap = []
in_set = set()

for _ in range(q):
op = input().split()
if op[0] == 'in':
s = op[1]
stack.append(s)            # 记录入库顺序
heapq.heappush(min_heap, s)  # 用于 check
in_set.add(s)              # 在库集合
elif op[0] == 'out':
# 出库最晚入库的产品
if not stack:
print('EMPTY')
else:
s = stack.pop()
in_set.remove(s)
print(s)
elif op[0] == 'count':
print(len(in_set))
elif op[0] == 'check':
# 查询字典序最小
while min_heap and min_heap[0] not in in_set:
heapq.heappop(min_heap)
if not min_heap:
print('EMPTY')
else:
print(min_heap[0])

if __name__ == '__main__':
main()

Java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int q = Integer.parseInt(br.readLine());
Deque<String> stack = new ArrayDeque<>();
TreeSet<String> tree = new TreeSet<>();

for (int i = 0; i < q; i++) {
String[] parts = br.readLine().split(" ");
String cmd = parts[0];
if (cmd.equals("in")) {
String s = parts[1];
stack.push(s);     // 入栈记录顺序
tree.add(s);       // 树集维护字典序
} else if (cmd.equals("out")) {
// 出库最晚入库的产品
if (stack.isEmpty()) {
System.out.println("EMPTY");
} else {
String s = stack.pop();
tree.remove(s);
System.out.println(s);
}
} else if (cmd.equals("count")) {
System.out.println(tree.size());
} else if (cmd.equals("check")) {
if (tree.isEmpty()) {
System.out.println("EMPTY");
} else {
System.out.println(tree.first());
}
}
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int q;
cin >> q;
vector<string> stack_;
multiset<string> ms;

while (q--) {
string cmd;
cin >> cmd;
if (cmd == "in") {
string s;
cin >> s;
stack_.push_back(s);  // 记录入库顺序
ms.insert(s);         // multiset 维护字典序
}
else if (cmd == "out") {
// 出库最晚入库的产品
if (stack_.empty()) {
cout << "EMPTY\n";
} else {
string s = stack_.back();
stack_.pop_back();
ms.erase(ms.find(s));
cout << s << "\n";
}
}
else if (cmd == "count") {
cout << ms.size() << "\n";
}
else if (cmd == "check") {
if (ms.empty()) {
cout << "EMPTY\n";
} else {
cout << *ms.begin() << "\n";
}
}
}
return 0;
}

---

### 第2题-寻找最便宜的地铁换乘方案（P2846）
- 链接：https://codefun2000.com/p/P2846

> 页面标题：#P2846. 第2题-寻找最便宜的地铁换乘方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

已知 AAA 市运营了 NNN 条地铁线路，市民在乘坐地铁时单条线路通票 222 元，换乘一次加 111 元。给出 NNN 条线路的所有站名列表，请帮乘客寻找从出发站到目的站最便官的地铁换乘方案，并输出票价。每条地铁线路不包含环路，即没有相同站名。
输入描述
第一行为地铁线路个数 NNN ，范围是 [1,1000][1,1000][1,1000]；
第二行 到 N+1N+1N+1 行：每条线路依次包含的站名，每个站名包含的字符个数不超过 100100100 ，站点个数也不超过 100100100 ，依次用空格隔开，不同线路中相同的站点名表示是一个换乘站；
第 N+2N+2N+2 行，出发站和目的站，用空格隔开。
输入保证：若可达则为唯一解。
输出描述
第一行按照出发站-换乘站(可以是多个)-目的站的格式输出换乘方案的字符串;
第二行输出换乘方案的总票价。
如果没有任何方案可实现出发站到目的站，只输出一行： NANANA 。
样例1
输入
3
A B C D F
C E G H
B G I J
A J

输出
A-B-J
3

说明
从出发站 AAA 到目的站 JJJ 有两个方案：一号线到 CCC 站后换乘二号线，到 GGG 站后换乘三号线到 JJJ 站，换乘两次，总票价 444 元；一号线到 BBB 站后换乘三号线到 JJJ 站，换乘一次，总票价 333 元。因此按照第二个方案愉出。
样例2
输入
3
A B C D F
E G H
G I J
A J

输出
NA

说明
从出发站 AAA 所在的一号线没有任何一个换乘站可以到二号线和三号线，因此没有方案抵达目的站 JJJ ，输出 NANANA 。

▶️

#### TextSol

video solution

题解
题目描述
已知 A 市运营了 NNN 条地铁线路，市民在乘坐地铁时单条线路通票 2 元，换乘一次加 1 元。给出 NNN 条线路的所有站名列表，请帮乘客寻找从出发站到目的站最便宜的地铁换乘方案，并输出票价。每条地铁线路不包含环路（即没有相同站名）。不同线路中相同的站点名表示可以在该站点换乘。输入保证若可达则唯一解。

输入

第一行：地铁线路个数 NNN，范围 [1,1000][1,1000][1,1000]
接下来的 NNN 行：第 iii 条线路依次包含的站名（站名间用空格分隔，每个站名长度 ≤100\le100≤100，每条线路站点数 ≤100\le100≤100）
第 N+2N+2N+2 行：出发站和目的站，用空格分隔

输出

若存在方案，第一行按“出发站-换乘站(可多)-目的站”格式输出换乘方案，第二行输出总票价。
若不可达，只输出一行 NA。

思路

建图模型

将每个线路上的每个站点视为一个状态，状态用 (line,pos)(\text{line},\text{pos})(line,pos) 表示；
同一线路上相邻站点间的移动视为“权重 0”边；
同一站点在不同线路间的换乘视为“权重 1”边。

最少换乘次数

初始从所有包含出发站的状态出发，使用 0-1 BFS（双端队列）在上述图中搜索，计算到达每个状态的最少换乘次数 d[line][pos]d[\text{line}][\text{pos}]d[line][pos]；
当到达目的站对应的任一状态时即可停止，题目保证唯一最优解。

路径回溯

搜索过程中记录每个状态的前驱状态 pre[line][pos]\mathrm{pre}[\text{line}][\text{pos}]pre[line][pos]；
从终点状态反向回溯到起点，得到完整的状态路径；
按路径中线路编号变化提取出所有换乘站。

票价计算

票价 =  2  +  (换乘次数)=\;2\;+\;\bigl(\text{换乘次数}\bigr)=2+(换乘次数)，其中换乘次数即最少换乘次数。

cpp
#include <bits/stdc++.h>
using namespace std;
struct S{ int l,p,t; }; // l: 线号, p: 位置, t: 换乘数
int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);
int N; cin>>N; cin.ignore();
vector<vector<string>> L(N);
for(int i=0;i<N;i++){
string ln; getline(cin,ln);
istringstream ss(ln);
string st;
while(ss>>st) L[i].push_back(st);
}
string A,B; cin>>A>>B;
unordered_map<string,vector<pair<int,int>>> M;
for(int i=0;i<N;i++)
for(int j=0;j<(int)L[i].size();j++)
M[L[i][j]].push_back({i,j});
if(!M.count(A)||!M.count(B)){
cout<<"NA"; return 0;
}
const int INF = 1e9;
vector<vector<int>> D(N);
vector<vector<pair<int,int>>> P(N);
for(int i=0;i<N;i++){
D[i].assign(L[i].size(),INF);
P[i].assign(L[i].size(),{-1,-1});
}
deque<S> dq;
for(auto &pr:M[A]){
int l=pr.first, p=pr.second;
D[l][p]=0;
dq.push_back({l,p,0});
}
bool ok=false; int el,ep;
while(!dq.empty()){
auto c=dq.front(); dq.pop_front();
if(L[c.l][c.p]==B){
ok=true; el=c.l; ep=c.p; break;
}
if(c.t> D[c.l][c.p]) continue;
// 同线移动
if(c.p>0 && c.t< D[c.l][c.p-1]){
D[c.l][c.p-1]=c.t;
P[c.l][c.p-1]={c.l,c.p};
dq.push_front({c.l,c.p-1,c.t});
}
if(c.p+1<(int)L[c.l].size() && c.t< D[c.l][c.p+1]){
D[c.l][c.p+1]=c.t;
P[c.l][c.p+1]={c.l,c.p};
dq.push_front({c.l,c.p+1,c.t});
}
// 换乘
string cur=L[c.l][c.p];
for(auto &pr:M[cur]){
int nl=pr.first, np=pr.second;
if(nl==c.l) continue;
if(c.t+1< D[nl][np]){
D[nl][np]=c.t+1;
P[nl][np]={c.l,c.p};
dq.push_back({nl,np,c.t+1});
}
}
}
if(!ok){
cout<<"NA"; return 0;
}
// 回溯
vector<pair<int,int>> path;
for(int l=el,p=ep; l!=-1; ){
path.push_back({l,p});
auto pr=P[l][p];
l=pr.first; p=pr.second;
}
reverse(path.begin(),path.end());
// 提取站点：出发-换乘-目的
vector<string> R;
int pl=path[0].first, pp=path[0].second;
R.push_back(L[pl][pp]);
for(int i=1;i<(int)path.size();i++){
int cl=path[i].first, cp=path[i].second;
if(cl!=pl) R.push_back(L[cl][cp]);
pl=cl; pp=cp;
}
if(R.back()!=B) R.push_back(B);
int tr=(int)R.size()-2;
int fare=2+tr;
for(int i=0;i<(int)R.size();i++){
cout<<R[i]<<(i+1==(int)R.size()?"":"-");
}
cout<<"\n"<<fare;
return 0;
}

python
# Python 3 实现
import sys
from collections import deque, defaultdict
def main():
input = sys.stdin.readline
N = int(input().strip())
lines = []
for _ in range(N):
lines.append(input().strip().split())
A, B = input().split()
# 站名 -> [(线号, 位置), ...]
M = defaultdict(list)
for i, ln in enumerate(lines):
for j, st in enumerate(ln):
M[st].append((i, j))
if A not in M or B not in M:
print("NA")
return
INF = 10**9
# D[i][j]: 到达线 i、位置 j 的最小换乘数
D = [ [INF]*len(lines[i]) for i in range(N) ]
# P 用于回溯前驱 (prev_line, prev_pos)
P = [ [(-1, -1)]*len(lines[i]) for i in range(N) ]
dq = deque()
# 多源起点
for l, p in M[A]:
D[l][p] = 0
dq.append((l, p, 0))
found = False
end = (-1, -1)
while dq:
l, p, t = dq.popleft()
# 找到终点
if lines[l][p] == B:
found = True
end = (l, p)
break
if t > D[l][p]:
continue
# 同线前后移动（权重0）
for np in (p-1, p+1):
if 0 <= np < len(lines[l]) and t < D[l][np]:
D[l][np] = t
P[l][np] = (l, p)
dq.appendleft((l, np, t))
# 换乘（权重1）
for nl, np in M[lines[l][p]]:
if nl == l: continue
if t+1 < D[nl][np]:
D[nl][np] = t+1
P[nl][np] = (l, p)
dq.append((nl, np, t+1))
if not found:
print("NA")
return
# 回溯路径
path = []
l, p = end
while l != -1:
path.append((l, p))
l, p = P[l][p]
path.reverse()
# 提取换乘站序列
route = [ lines[path[0][0]][path[0][1]] ]
prev_l = path[0][0]
for l, p in path[1:]:
if l != prev_l:
route.append(lines[l][p])
prev_l = l
if route[-1] != B:
route.append(B)
# 计算票价
transfers = len(route) - 2
fare = 2 + transfers
print("-".join(route))
print(fare)
if __name__ == "__main__":
main()

java
// Java 实现
import java.io.*;
import java.util.*;
public class Main {
static class State {
int l, p, t;
State(int l, int p, int t) { this.l = l; this.p = p; this.t = t; }
}
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine().trim());
List<List<String>> lines = new ArrayList<>();
for (int i = 0; i < N; i++) {
lines.add(Arrays.asList(br.readLine().trim().split("\\s+")));
}
String[] ab = br.readLine().split("\\s+");
String A = ab[0], B = ab[1];
// 站名 -> List of (线号, 位置)
Map<String, List<int[]>> M = new HashMap<>();
for (int i = 0; i < N; i++) {
List<String> ln = lines.get(i);
for (int j = 0; j < ln.size(); j++) {
M.computeIfAbsent(ln.get(j), k -> new ArrayList<>()).add(new int[]{i, j});
}
}
if (!M.containsKey(A) || !M.containsKey(B)) {
System.out.println("NA");
return;
}
final int INF = 1_000_000_000;
int[][] D = new int[N][];
int[][][] P = new int[N][][];
for (int i = 0; i < N; i++) {
int sz = lines.get(i).size();
D[i] = new int[sz];
P[i] = new int[sz][2];
Arrays.fill(D[i], INF);
for (int j = 0; j < sz; j++) {
P[i][j][0] = P[i][j][1] = -1;
}
}
Deque<State> dq = new ArrayDeque<>();
for (int[] pr : M.get(A)) {
int l = pr[0], p = pr[1];
D[l][p] = 0;
dq.addLast(new State(l, p, 0));
}
boolean found = false;
int el = -1, ep = -1;
while (!dq.isEmpty()) {
State cur = dq.pollFirst();
int l = cur.l, p = cur.p, t = cur.t;
if (lines.get(l).get(p).equals(B)) {
found = true; el = l; ep = p; break;
}
if (t > D[l][p]) continue;
// 同线移动（权重0）
for (int np : new int[]{p-1, p+1}) {
if (np >= 0 && np < lines.get(l).size() && t < D[l][np]) {
D[l][np] = t;
P[l][np] = new int[]{l, p};
dq.addFirst(new State(l, np, t));
}
}
// 换乘（权重1）
String curSt = lines.get(l).get(p);
for (int[] pr : M.get(curSt)) {
int nl = pr[0], np = pr[1];
if (nl == l) continue;
if (t + 1 < D[nl][np]) {
D[nl][np] = t + 1;
P[nl][np] = new int[]{l, p};
dq.addLast(new State(nl, np, t + 1));
}
}
}
if (!found) {
System.out.println("NA");
return;
}
// 回溯
List<int[]> path = new ArrayList<>();
int l = el, p = ep;
while (l != -1) {
path.add(new int[]{l, p});
int nl = P[l][p][0], np = P[l][p][1];
l = nl; p = np;
}
Collections.reverse(path);
// 提取路线
List<String> route = new ArrayList<>();
int prevL = path.get(0)[0], prevP = path.get(0)[1];
route.add(lines.get(prevL).get(prevP));
for (int i = 1; i < path.size(); i++) {
int cl = path.get(i)[0], cp = path.get(i)[1];
if (cl != prevL) {
route.add(lines.get(cl).get(cp));
}
prevL = cl; prevP = cp;
}
if (!route.get(route.size()-1).equals(B)) {
route.add(B);
}
int transfers = route.size() - 2;
int fare = 2 + transfers;
System.out.println(String.join("-", route));
System.out.println(fare);
}
}

---

### 第2题-游戏中最后玩家的生命值（P2895）
- 链接：https://codefun2000.com/p/P2895

> 页面标题：#P2895. 第2题-游戏中最后玩家的生命值

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一款游戏，里面有NNN个游戏玩家 (1<=N<100000)(1<=N<100000)(1<=N<100000)，每个玩家都有一个初始的生命能量值lifePower(0<=lifePower<=231−1)lifePower(0<=lifePower<=2^{31-1})lifePower(0<=lifePower<=231−1)
游戏规则：经过多玩家111对111 PKPKPK 直到游戏结束，每一轮PKPKPK都是从游戏中尚存的所有玩家中挑选生命能量值最小且不为000的222个玩家进行PKPKPK(如果在挑选符合PKPKPK条件的222个玩家过程中，能量值相同的候选玩家有多个时，则挑选玩家编号小的玩家参与PKPKPK)，如是两个玩家的生命能量值相同，则222个玩家同归于尽，生命能量值都归为000，PKPKPK后都退出游戏；如果222个玩家的生命能量值不同，则能量值大的玩家胜出，PKPKPK过程胜出玩家会消耗掉另一个玩家的同等数量的生命能量值，但是PKPKPK胜出后，则剩余生命能量值会膨胀333倍(最大不超过323232位有符号整数的最大值即 231−12^{31}-1231−1)，即为该玩家最终的生命能量值为剩余生分能量值的333倍。PKPKPK胜出的玩家仍可继续游戏；
如果游戏无法挑选出222个符合条件的玩家进行PKPKPK时，游戏结束；
请设计一个高效的算法，让游戏按规则进行玩家PK，直到游戏结束。
输入描述
第一行为游戏玩家的数量，取值范围：1<=N<1000001<=N<1000001<=N<100000
第二行为空格间隔的 NNN 个游戏玩家的生命能量值 lifePowerlifePowerlifePower，按照玩家编号从111到NNN排列。取值范围：0<=lifePower<231−10<= lifePower <2^{31}-10<=lifePower<231−1
输出描述
打印最后PKPKPK胜出玩家的编号和该玩家的最终生命能量值，以111个空格为间隔。如果游戏经过PK后，没有留存下来生命能量值大于000的玩家，则打印−1-1−1。
样例1
输入
4
2 5 1 8

输出
4 6

说明
第111轮PKPKPK，最小的222个玩家是玩家111和玩家333，生命能力值分别是222和111，玩家111胜出，剩余能量值为111，膨胀333倍后最终生命能量值为333
第111轮PKPKPK后所有玩家的生命能量值为:333 555 000 888
第222轮PKPKPK，最小的222个玩家是玩家111和玩家222，生命能力值分别是333和555，玩家222胜出，剩余能量值为222，膨胀333倍后最终生命能量值为666
第222轮PKPKPK后所有玩家的生命能量值为:000 666 000 888
第333轮PKPKPK，最小的222个玩家是玩家222和玩家444(也是最后222个玩家)，生命能量值分别是666和888，玩家444胜出，剩余能量值为222，膨胀333倍后最终生命能量值为666
第333轮PKPKPK后所有玩家的生命能量值为:000 000 000 666
返回 444 666
样例2
输入
3
2 5 9

输出
-1

说明
第111轮PKPKPK，最小的222个玩家是玩家111和玩家222，生命能力值分别是222和555，玩家222胜出，剩余能量值为333，膨胀333倍后最终生命能量值为999
第111轮PKPKPK后所有玩家的生命能量值为:000 999 999
第222轮PKPKPK，最小的222个玩家是玩家222和玩家333，生命能力值分别是999和999，同归于尽，最后游戏没有剩余玩家，返回−1-1−1

#### TextSol

题解思路
该问题要求模拟一系列“玩家1对1对战”的过程，每轮选择当前生命值最小且不为0的两名玩家进行PK，直到无法匹配出两名玩家或所有玩家生命值归零。
显然，每轮都要快速地找到当前生命值最小的两名玩家，因此可以使用 优先队列(最小堆) 来维护玩家集合。
算法步骤

初始化

将编号和生命值均大于0的玩家以 (life, id) 为键插入最小堆。

循环PK

当堆中元素少于2时，终止循环。
弹出堆顶的两名玩家 (life1, id1) 和 (life2, id2)。
若 life1 == life2，则两人同归于尽，直接丢弃。
否则，胜者为生命值较大的那位（设 life_big, id_big），剩余生命值 rem = life_big - life_smaint，计算新生命值 newLife = rem * 3，并将 (newLife, id_big) 重新插入堆中。

输出结果

循环结束后，若堆为空，则输出 -1；
否则堆中仅剩一位玩家，弹出并输出其编号和生命值。

相关算法

优先队列（Priority Queue）
用于动态维护一个集合，支持在 O(log⁡N)O(\log N)O(logN) 时间内的插入与删除最小元素操作。

复杂度分析

初始化建堆需要 O(N)O(N)O(N)（或 O(Nlog⁡N)O(N\log N)O(NlogN) 若逐个插入）；
每轮PK涉及两次堆弹出和一次可能的堆插入，共 O(log⁡N)O(\log N)O(logN)；
最多进行 N−1N-1N−1 次PK，故总时间复杂度为  O(Nlog⁡N)O(N\log N)O(NlogN)
空间复杂度主要用于存储堆，最多 O(N)O(N)O(N)。

代码实现
Python
import sys
import heapq

MAX_LIFE = 2**31 - 1

def solve():
input = sys.stdin.readline
n = int(input().strip())
lives = list(map(int, input().split()))

# 最小堆，元素为 (life, id)
heap = []
for i, v in enumerate(lives, start=1):
if v > 0:
heapq.heappush(heap, (v, i))

while len(heap) >= 2:
life1, id1 = heapq.heappop(heap)
life2, id2 = heapq.heappop(heap)
if life1 == life2:
# 同归于尽
continue
# 分出胜负
if life1 > life2:
life_big, id_big, life_smaint = life1, id1, life2
else:
life_big, id_big, life_smaint = life2, id2, life1
rem = life_big - life_smaint
new_life = rem * 3
if new_life > MAX_LIFE:
new_life = MAX_LIFE
if new_life > 0:
heapq.heappush(heap, (new_life, id_big))

# 输出
if not heap:
print(-1)
else:
life, pid = heap[0]
print(pid, life)

if __name__ == "__main__":
solve()

Java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
private static final int MAX_LIFE = Integer.MAX_VALUE;

static class Player implements Comparable<Player> {
int life, id;
Player(int l, int i) { life = l; id = i; }
@Override
public int compareTo(Player o) {
// 先按生命值升序，再按 id 升序
if (life != o.life) return Integer.compare(life, o.life);
return Integer.compare(id, o.id);
}
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine().trim());
StringTokenizer st = new StringTokenizer(br.readLine());
PriorityQueue<Player> pq = new PriorityQueue<>();

// 1. 初始化：只将生命值>0的玩家入堆
for (int i = 1; i <= n; i++) {
int v = Integer.parseInt(st.nextToken());
if (v > 0) {
pq.offer(new Player(v, i));
}
}

// 2. 循环 PK
while (pq.size() >= 2) {
Player p1 = pq.poll();
Player p2 = pq.poll();
if (p1.life == p2.life) {
// 同归于尽，直接丢弃
continue;
}
// 胜者和败者
Player win = p1.life > p2.life ? p1 : p2;
Player lose = p1.life > p2.life ? p2 : p1;
long rem = (long)win.life - lose.life;      // 防溢出用 long
long nl = rem * 3;
if (nl > MAX_LIFE) nl = MAX_LIFE;           // clamp
if (nl > 0) {
pq.offer(new Player((int)nl, win.id));
}
}

// 3. 输出
if (pq.isEmpty()) {
System.out.println(-1);
} else {
Player ans = pq.peek();
System.out.println(ans.id + " " + ans.life);
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

static const int MAX_LIFE = INT_MAX;

struct Player {
int life;
int id;
};

struct Cmp {
bool operator()(const Player &a, const Player &b) const {
// 小顶堆：生命值小的排在前，若相等按 id
if (a.life != b.life) return a.life > b.life;
return a.id > b.id;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
priority_queue<Player, vector<Player>, Cmp> pq;

// 1. 初始化
for (int i = 1; i <= n; ++i) {
int v;
cin >> v;
if (v > 0) {
pq.push({v, i});
}
}

// 2. 循环 PK
while (pq.size() >= 2) {
Player p1 = pq.top(); pq.pop();
Player p2 = pq.top(); pq.pop();
if (p1.life == p2.life) {
// 同归于尽
continue;
}
// 胜负判定
Player win = (p1.life > p2.life ? p1 : p2);
Player lose = (p1.life > p2.life ? p2 : p1);
long rem = (long)win.life - lose.life;
long nl = rem * 3;
if (nl > MAX_LIFE) nl = MAX_LIFE;   // clamp
if (nl > 0) {
pq.push({(int)nl, win.id});
}
}

// 3. 输出
if (pq.empty()) {
cout << -1 << "\n";
} else {
Player ans = pq.top();
cout << ans.id << " " << ans.life << "\n";
}

return 0;
}

---

### 第2题-二叉树换装（P2892）
- 链接：https://codefun2000.com/p/P2892

> 页面标题：#P2892. 第2题-二叉树换装

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

假设我们有一颗装满彩灯的二叉树，树的每个节点代表一个灯泡。每个灯泡有三种颜色状态：红色(用整数 111 表示)、绿色(用整数 222 表示)和蓝色(用整数 333 表示)。每个节点上都配有一个开关，当按下某个节点的开关时，以该节点为根节点的子树上所有节点的灯泡颜色都会根据当前的颜色按照 "红−>绿−>蓝−>红−>…红 -> 绿 -> 蓝 -> 红 ->…红−>绿−>蓝−>红−>…"的循环切换顺序切换一次颜色。
给定二叉树的初始颜色状态 initial 和目标颜色状态 target，两者都以层序遍历的一维整数数组的形式表示，数组元素对应二叉树层序遍历的节点的颜色。如果某个节点在二叉树中不存在，则在数组中使用 000 表示。
目标：计算将二叉树从初始颜色状态 initial 切换到目标颜色状态 target 所需的最少开关切换次数。
解释补充：

“层序遍历"是指从上到下、从左到右逐层遍历二叉树的节点，并将遍历结果保存在一维数组中，如果某个节点在二叉树中不存在，则在数组中使用 000 表示。

切换开关的影响是“传递性"的，即切换一个节点的开关会影响以该节点为根节点的子树上所有节点的灯泡颜色。

输入描述
第一行榆入为一个整数n，代表intiamp和largeu的数组大小
第二行输入为n个整数，代表imnitial的元系值
第三行输入为n个整数，target的元系值
参数取值范围:

initial.lenght==targets.lenghtinitial.lenght == targets.lenghtinitial.lenght==targets.lenght

0<=initial[i]<=30 <= initial[i] <= 30<=initial[i]<=3 ，且为整数

0<=targets[i]<=30 <= targets[i] <= 30<=targets[i]<=3，且为整数

如果 initial[i]==0initial[i] ==0initial[i]==0 ，则 targets[i]==0targets[i] ==0targets[i]==0

1<=initial.lenght<=1061 <= initial.lenght <= 10^61<=initial.lenght<=106

输出描述
一个整数，表示最少开关切换次数。
样例1
输入
5
1 2 3 0 1
2 3 1 0 2

输出
1

说明
初始状态initial[]为[1，2，3，8，1]，代表二叉树为:

1
/ \
2   3
\
1

切换一次根节点颜色:

1->2
/ \
2->3  3->1
\
1->2

切换后变为:

2
/ \
3   1
\
2

即为:[2，3，1，8，2]，满足目标状态target[]，总共切换了1次，所以返回为1

样例2
输入
7
1 2 3 1 2 3 1
3 1 2 3 1 2 1

输出
3

说明
初始状态initial[]为[1，2，3，1，2，3，1]，代表树为:

1
/    \
2      3
/  \    /  \
1    2  3    1

切换一次根节点变为:

2
/      \
3        1
/   \    /   \
2     3  1     2

切换一次根节点变为:

3
/      \
1        2
/   \    /   \
3     1  2     3

切换末尾节点一次:

3
/      \
1        2
/   \    /   \
3     1  2    3->1

即为:[3，1，2，3，1，2，1]，满足目标状态target[]，总共切换了3次，所以返回为3

▶️

#### TextSol

video solution

题解
题面描述
有一颗装满彩灯的二叉树，树的每个节点代表一个灯泡。每个灯泡有三种颜色状态：红色（用整数111表示）、绿色（用整数222表示）和蓝色（用整数333表示）。每个节点上都配有一个开关，当按下某个节点的开关时，以该节点为根节点的子树上所有节点的灯泡颜色都会根据当前的颜色按照“红 → 绿 → 蓝 → 红 → …”的循环切换顺序切换一次颜色。
给定二叉树的初始颜色状态initialinitialinitial和目标颜色状态targettargettarget，两者都以层序遍历的一维整数数组的形式表示，数组元素对应二叉树层序遍历的节点的颜色。如果某个节点在二叉树中不存在，则在数组中使用000表示。
目标是计算将二叉树从初始颜色状态initialinitialinitial切换到目标颜色状态targettargettarget所需的最少开关切换次数。
思路
我们可以通过深度优先遍历（DFS）的方法，从根节点开始处理每个节点的颜色变化。
每个节点的颜色变换受其父节点的影响，因为父节点的开关操作会影响该节点及其子树的颜色。因此，对于每个节点，我们计算从其当前颜色到目标颜色所需的最小开关次数。
具体步骤如下：

使用深度优先遍历（DFS）遍历二叉树。
每次遍历到一个节点时，判断当前节点的颜色与目标颜色的差异。
如果需要切换颜色，则记录一次操作，并通过递归的方式将影响传播到其子节点。
每次切换开关时，将当前节点的颜色变化传递给其左右子节点，保证子树的颜色也能正确变化。

通过这样的方法，能够确保在最少的开关次数下将所有节点的颜色从initialinitialinitial转换为targettargettarget。
cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
// 定义节点数量
int n;
// 定义初始颜色状态数组和目标颜色状态数组
vector<int> a, b;
// 最少开关次数
ll ans = 0;
// 深度优先遍历函数
void dfs(int i, int f) {
// 如果节点不存在或者超出范围，直接返回
if (i >= n || a[i] == 0) return;
// 当前节点的颜色偏移
int cur = (a[i] - 1 + f) % 3;
// 计算当前节点到目标颜色所需的切换次数
int need = (b[i] - 1 - cur + 3) % 3;
// 累加所需的开关次数
ans += need;
// 更新偏移量，将需要的颜色变化传递给子树
int nf = (f + need) % 3;
// 递归遍历左子树
dfs(2 * i + 1, nf);
// 递归遍历右子树
dfs(2 * i + 2, nf);
}
int main() {
ios::sync_with_stdio(false);
cin.tie(NULL);
// 读取节点数
cin >> n;
// 初始化数组 a 和 b
a.resize(n);
b.resize(n);
// 读取初始颜色状态数组
for (int i = 0; i < n; i++) cin >> a[i];
// 读取目标颜色状态数组
for (int i = 0; i < n; i++) cin >> b[i];
// 从根节点开始深度优先遍历，初始偏移量为0
dfs(0, 0);
// 输出最少的开关次数
cout << ans << "\n";
return 0;
}

Java
import java.io.*;
import java.util.*;

public class Main {
static int n;
static int[] a, b;
static long ans = 0;

// 深度优先遍历函数
static void dfs(int i, int f) {
if (i >= n || a[i] == 0) return;  // 如果当前节点不存在，则返回
int cur = (a[i] - 1 + f) % 3;  // 计算当前节点的颜色偏移
int need = (b[i] - 1 - cur + 3) % 3;  // 计算需要的颜色变化
ans += need;  // 累加所需的开关次数
int nf = (f + need) % 3;  // 更新偏移量
dfs(2 * i + 1, nf);  // 递归遍历左子树
dfs(2 * i + 2, nf);  // 递归遍历右子树
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
n = Integer.parseInt(br.readLine());  // 读取节点数
a = new int[n];  // 初始颜色状态
b = new int[n];  // 目标颜色状态
StringTokenizer st = new StringTokenizer(br.readLine());
for (int i = 0; i < n; i++) a[i] = Integer.parseInt(st.nextToken());  // 读取初始状态
st = new StringTokenizer(br.readLine());
for (int i = 0; i < n; i++) b[i] = Integer.parseInt(st.nextToken());  // 读取目标状态
dfs(0, 0);  // 从根节点开始深度优先遍历
System.out.println(ans);  // 输出最少的开关次数
}
}

Python
import sys
sys.setrecursionlimit(10**7)

# 深度优先遍历函数
def dfs(i, f):
global ans
if i >= n or a[i] == 0:  # 如果当前节点不存在，则返回
return
cur = (a[i] - 1 + f) % 3  # 计算当前节点的颜色偏移
need = (b[i] - 1 - cur + 3) % 3  # 计算需要的颜色变化
ans += need  # 累加所需的开关次数
nf = (f + need) % 3  # 更新偏移量
dfs(2*i + 1, nf)  # 递归遍历左子树
dfs(2*i + 2, nf)  # 递归遍历右子树

def main():
global n, a, b, ans
data = sys.stdin.read().split()  # 读取输入
n = int(data[0])  # 读取节点数
a = list(map(int, data[1:1+n]))  # 读取初始颜色状态
b = list(map(int, data[1+n:1+2*n]))  # 读取目标颜色状态
ans = 0
dfs(0, 0)  # 从根节点开始深度优先遍历
print(ans)  # 输出最少的开关次数

if __name__ == "__main__":
main()

---

### 第2题-日志严重性能逆序列（P2933）
- 链接：https://codefun2000.com/p/P2933

> 页面标题：#P2933. 第2题-日志严重性能逆序列

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一家快速发展的互联网公司里，系统工程师小李正在开发一款高效的日志分析工具，旨在帮助运维团队更好地理解和优化语音合成系统的运行状况。为了提高工具的洞察力，他需要解决一个关键问题:如何通过分析一段时间内的合成请求的实时率 RTFRTFRTF (合成耗时 /目标文本的音频时长)记录来识别“性能逆序对”的总数,实时率越高代表性能越差。
在这个系统中，“性能逆序对”被定义为一种情况，即如果某次请求的实时率比之后某次请求的实时率大，则这两者构成一个“性能逆序对”。这可以帮助运维团队识别出系统的性能退化点或者异常波动，从而采取措施优化系统性能。
具体来说，给定一个数组 recordrecordrecord ，它代表了一段时间内每次请求的实时率* 100100100 (按时间顺序排列，因正常场景实时率 <1<1<1 ，因此对数值进行放大 100100100 并取整)。小李的任务是设计并实现一个程序，该程序能够计算并返回这段时间内存在的“性能逆序对"总数。每个“性能逆序对”由两个索引 iii 和 jjj 组成，满足条件 0<=i<j<record.length0<=i<j<record.length0<=i<j<record.length 并且 record[i]>record[j]record[i] >record[j]record[i]>record[j] 。如果 record[i]−record[j]>thresholdrecord[i]-record[j]>thresholdrecord[i]−record[j]>threshold ，则该性能逆序对称为"严重性能逆序对"。
请协助小李完成这个功能的开发，确保它能高效地处理大量的日志数据，并提供即时反馈。具体任务包括编写一个函数，输入是一个整数数组 recordrecordrecord，输出是其中存在的“严重性能逆序对”的总数。
输入描述
每组数据第一行为严重性能逆序对的阈值 thresholdthresholdthreshold ，第二行为日志数量 nnn ,第三行为日志数据的数组 recordrecordrecord ，数组数值可能重复
输入范围限制:
0<record.length<=1000000<record.length <= 1000000<record.length<=100000
0<record[i]<=500000< record[i] <= 500000<record[i]<=50000
输出描述
严重性能逆序对的总数
样例1
输入
2
5
9 7 5 4 6

输出
4

说明
输入：record=[9,7,5,4,6],threshold=2record=[9,7,5,4,6],threshold=2record=[9,7,5,4,6],threshold=2
输出：444
解释：日志中的严重性能逆序对为 (9,5),(9,4),(9,6),(7,4)(9,5),(9,4),(9,6),(7,4)(9,5),(9,4),(9,6),(7,4)，这些逆序对满足序对第一个值大于第二个且差值大于 222
样例2
输入
3
2
5 1

输出
1

说明
输入：record=[5,1],threshold=3record=[5,1],threshold=3record=[5,1],threshold=3
输出：111
解释：日志中的严重性能逆序对为 (5,1)(5,1)(5,1) ，这些逆序对满足序对第一个值大于第二个且差值大于 333
样例3
输入
3
2
1 5

输出
0

说明
输入：record=[1,5],threshold−3record=[1,5],threshold-3record=[1,5],threshold−3
输出：000
解释：无逆序列

#### TextSol

题解
题面描述
给定长度为 nnn 的整数数组 record\textit{record}record （值域 1≤record[i]≤500001\le \textit{record}[i]\le 500001≤record[i]≤50000），以及一个阈值 threshold\textit{threshold}threshold。要求统计所有满足以下条件的“严重性能逆序对”数目：

对于索引对 (i,j)(i,j)(i,j) ，满足 0≤i<j<n0 \le i < j < n0≤i<j<n；
并且 record[i]>record[j]\textit{record}[i] > \textit{record}[j]record[i]>record[j] 且 record[i]−record[j]>thresholdrecord[i]-record[j]>thresholdrecord[i]−record[j]>threshold ，则该性能逆序对称为"严重性能逆序对"。

输出满足上述条件的逆序对总数。数组长度可达 10510^5105，需在线性或近线性时间内完成。

思路

离散化
由于 record[i]\textit{record}[i]record[i] 最大为 500005000050000，可直接作为树状数组大小，但若值域更大则需先离散化。

倒序遍历
我们从右向左扫描数组，维护一个树状数组 BIT，用于统计已经遍历过的元素的出现次数。

查询计数
对于当前元素 x=record[i]x = \textit{record}[i]x=record[i]，要找出后面位置上所有满足
y<x−thresholdy < x - \textit{threshold}y<x−threshold
的元素个数，即查询

更新树状数组
在查询完当前 xxx 后，将其在 BIT 中的计数加 1：
update(x,+1).  \text{update}(x, +1).
update(x,+1).

复杂度

每次查询与更新均为 O(log⁡M)O(\log M)O(logM)，其中 MMM 为值域大小（此处 M≤5×104M\le5\times10^4M≤5×104）。
总时间 O(nlog⁡M)O(n\log M)O(nlogM)，空间 O(M)O(M)O(M)。

C++
#include <bits/stdc++.h>
using namespace std;

// 树状数组大小
static const int MAXV = 50000;

struct Fenwick {
vector<int> bit;
int n;
Fenwick(int _n): n(_n) { bit.assign(n+1, 0); }
// 返回 x 的最低位
int lowbit(int x) { return x & -x; }
// 在下标 x 加上 Δ
void update(int x, int delta) {
for (; x <= n; x += lowbit(x))
bit[x] += delta;
}
// 查询前缀 [1..x] 的和
int query(int x) {
int s = 0;
for (; x > 0; x -= lowbit(x))
s += bit[x];
return s;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int threshold, n;
cin >> threshold >> n;
vector<int> record(n);
for (int i = 0; i < n; i++) {
cin >> record[i];
}

Fenwick fw(MAXV);
long long ans = 0;
// 倒序遍历
for (int i = n - 1; i >= 0; i--) {
int x = record[i];
int limit = x - threshold - 1;
if (limit >= 1) {
ans += fw.query(limit);
}
fw.update(x, 1);
}

cout << ans << "\n";
return 0;
}

Python
import sys
input = sys.stdin.readline

# 树状数组类
class Fenwick:
def __init__(self, n):
self.n = n
self.bit = [0] * (n+1)

def lowbit(self, x):
return x & -x

def update(self, x, delta):
while x <= self.n:
self.bit[x] += delta
x += self.lowbit(x)

def query(self, x):
s = 0
while x > 0:
s += self.bit[x]
x -= self.lowbit(x)
return s

def main():
threshold = int(input())
n = int(input())
record = list(map(int, input().split()))

fw = Fenwick(50000)
ans = 0
# 倒序遍历
for x in reversed(record):
limit = x - threshold - 1
if limit >= 1:
ans += fw.query(limit)
fw.update(x, 1)
print(ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static final int MAXV = 50000;
static class Fenwick {
int[] bit;
int n;
Fenwick(int n) {
this.n = n;
bit = new int[n+1];
}
// lowbit 函数
int lowbit(int x) { return x & -x; }
// 在 x 位置加 delta
void update(int x, int delta) {
for (; x <= n; x += lowbit(x)) {
bit[x] += delta;
}
}
// 查询 [1..x] 前缀和
int query(int x) {
int s = 0;
for (; x > 0; x -= lowbit(x)) {
s += bit[x];
}
return s;
}
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int threshold = Integer.parseInt(br.readLine());
int n = Integer.parseInt(br.readLine());
StringTokenizer st = new StringTokenizer(br.readLine());
Fenwick fw = new Fenwick(MAXV);

long ans = 0;
int[] record = new int[n];
for (int i = 0; i < n; i++) {
record[i] = Integer.parseInt(st.nextToken());
}
// 倒序遍历
for (int i = n - 1; i >= 0; i--) {
int x = record[i];
int limit = x - threshold - 1;
if (limit >= 1) {
ans += fw.query(limit);
}
fw.update(x, 1);
}
System.out.println(ans);
}
}

---

### 第2题-建设基站（P2927）
- 链接：https://codefun2000.com/p/P2927

> 页面标题：#P2927. 第2题-建设基站

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一棵二叉树，每个节点上都住了一户居民。现在要给这棵树上的居民建设基站，每个基站只能覆盖她所在与相邻的节点，请问信号覆盖这棵树最少需要建设多少个基站
输入描述
一个整数数组nums(1<=num.length<=3000)nums(1<=num.length<=3000)nums(1<=num.length<=3000)，用空格分隔，表示二叉树的节点值，正整数表示存在节点，NNN表示不存在节点，如[1 2 3 4 N 5 6][1\ 2\ 3\ 4\ N\ 5\ 6][1 2 3 4 N 5 6]表示一颗如下所示的树，最少需要建设222个基站
输出描述
最少需要建设的基站个数
样例1
输入
1 2 3 4 N 5 6

输出
2

说明
如图,222个基站可以覆盖所有节点

样例2
输入
1 2 N 3 N N 4

输出
2

说明
如图,222个基站可以覆盖所有节点(左右两种方案都能覆盖所有的节点)

▶️

#### TextSol

video solution

题面描述
给定一棵 二叉树，树上每个节点代表一户居民。需要在若干节点上建设基站，每个基站可以覆盖其所在节点及与其相邻的左右子节点和父节点，覆盖距离为 111。求覆盖整棵树的最少基站数量。

思路
对每个节点 uuu，定义三种状态：

f[u][0]f[u][0]f[u][0]：在节点 uuu 放置基站，覆盖整棵子树所需的最少基站数。
f[u][1]f[u][1]f[u][1]：不在节点 uuu 放置基站，且节点 uuu 已被覆盖（由子节点或父节 点的基站覆盖）。
f[u][2]f[u][2]f[u][2]：不在节点 uuu 放置基站，且节点 uuu 未被覆盖，等待其父节点来覆盖。

设节点 uuu 的左、右孩子为 lll 和 rrr，则有转移：
1.放基站：

“1”：在节点 (u) 自身放一个基站。
子树贡献：既然基站能覆盖父节点和所有相邻子节点，无论左／右子节点的覆盖情况如何，都已经被 (u) 的基站覆盖了，所以子节点可以自由选择最优状态（放、不放但已覆盖、不放且未覆盖）来最小化总数。
因此，左右子树各取三种状态中的最小值。

2.已被覆盖且不放：

前提：(u) 本身不放，但要被覆盖，必有“相邻”节点放基站。
两种覆盖来源：

左子节点放（状态 0），此时右子节点只需“不放但已被覆盖”（状态 1）或“放”（状态 0），保证右侧也不会遗漏。
右子节点放（状态 0），对称地左子节点取 0 或 1。

取以上两种方案中更小者。

注意：这里只考虑子节点覆盖的情况，因为「父节点放」的覆盖会在递归回溯到父时处理，不必在子树内枚举。

3.未被覆盖且不放：

前提：(u) 自身不放，又不被子节点覆盖，必须等待父节点来覆盖。
子节点要保证“已覆盖”，否则子节点若也未被覆盖，既无自身基站，又没人覆盖，就会死角。
因此左右子节点都只能处于“已被覆盖”（状态 1）。

边界说明

对于空节点（nullnullnull）：

当作 已覆盖，因为它不需要覆盖也不会产生盲区：

“放基站”状态无意义，设为极大值: 。

这样，三条转移就能完整描述所有可能的放／不放、被／未被覆盖组合，递归合并后保证全局最优。
时间复杂度 O(n)O(n)O(n)，空间复杂度 O(h)O(h)O(h)。

C++
#include <bits/stdc++.h>
using namespace std;

struct TreeNode {
int val;
TreeNode *left, *right;
TreeNode(int x): val(x), left(nullptr), right(nullptr) {}
};

const int INF = 1e9;
class Solution {
public:
// dfs 返回长度为 3 的数组：f0, f1, f2
array<int,3> dfs(TreeNode* u) {
if (!u) {
// 空节点：放基站不可能(无限大)，已覆盖/未覆盖均为 0
return {INF, 0, 0};
}
auto L = dfs(u->left);
auto R = dfs(u->right);
array<int,3> f;
// f[u][0]
f[0] = 1 + min({L[0],L[1],L[2]}) + min({R[0],R[1],R[2]});
// f[u][1]
f[1] = min(
L[0] + min(R[0], R[1]),
R[0] + min(L[0], L[1])
);
// f[u][2]
f[2] = L[1] + R[1];
return f;
}

int minStation(TreeNode* root) {
auto f = dfs(root);
// 根节点取 0 或 1
return min(f[0], f[1]);
}
};

// 层序建树
TreeNode* buildTree(const vector<string>& nums) {
if (nums.empty() || nums[0]=="N") return nullptr;
TreeNode* root = new TreeNode(stoi(nums[0]));
queue<TreeNode*> q; q.push(root);
int i = 1;
while (i < nums.size()) {
TreeNode* cur = q.front(); q.pop();
if (nums[i] != "N") {
cur->left = new TreeNode(stoi(nums[i]));
q.push(cur->left);
}
i++;
if (i < nums.size() && nums[i] != "N") {
cur->right = new TreeNode(stoi(nums[i]));
q.push(cur->right);
}
i++;
}
return root;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

vector<string> nums;
string s;
while (cin >> s) nums.push_back(s);
TreeNode* root = buildTree(nums);
Solution sol;
cout << sol.minStation(root);
return 0;
}

Python
# 定义二叉树节点
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None

import sys
sys.setrecursionlimit(10000)

class Solution:
def dfs(self, u):
if not u:
# 空节点：放基站无限大，已覆盖/未覆盖为 0
return float('inf'), 0, 0
L0, L1, L2 = self.dfs(u.left)
R0, R1, R2 = self.dfs(u.right)
# f[u][0]
f0 = 1 + min(L0, L1, L2) + min(R0, R1, R2)
# f[u][1]
f1 = min(L0 + min(R0, R1), R0 + min(L0, L1))
# f[u][2]
f2 = L1 + R1
return f0, f1, f2

def minStation(self, root):
f0, f1, _ = self.dfs(root)
return min(f0, f1)

# 层序建树
from collections import deque

def buildTree(nums):
if not nums or nums[0]=='N':
return None
root = TreeNode(int(nums[0]))
q = deque([root])
i = 1
while i < len(nums):
node = q.popleft()
if nums[i] != 'N':
node.left = TreeNode(int(nums[i]))
q.append(node.left)
i += 1
if i < len(nums) and nums[i] != 'N':
node.right = TreeNode(int(nums[i]))
q.append(node.right)
i += 1
return root

if __name__ == '__main__':
nums = sys.stdin.read().split()
root = buildTree(nums)
print(Solution().minStation(root))

Java
import java.util.*;
class TreeNode {
int val;
TreeNode left, right;
TreeNode(int x) { val = x; }
}

public class Solution {
private static final int INF = 1000000000;

// 返回长度为3的数组：f0,f1,f2
public int[] dfs(TreeNode u) {
if (u == null) {
// 空节点
return new int[]{INF, 0, 0};
}
int[] L = dfs(u.left);
int[] R = dfs(u.right);
int[] f = new int[3];
// f0
f[0] = 1 + Math.min(Math.min(L[0],L[1]),L[2])
+ Math.min(Math.min(R[0],R[1]),R[2]);
// f1
f[1] = Math.min(
L[0] + Math.min(R[0],R[1]),
R[0] + Math.min(L[0],L[1])
);
// f2
f[2] = L[1] + R[1];
return f;
}

public int minStation(TreeNode root) {
int[] f = dfs(root);
return Math.min(f[0], f[1]);
}

// 层序建树
public static TreeNode buildTree(List<String> nums) {
if (nums.isEmpty() || nums.get(0).equals("N")) return null;
TreeNode root = new TreeNode(Integer.parseInt(nums.get(0)));
Queue<TreeNode> q = new LinkedList<>(); q.offer(root);
int i = 1;
while (i < nums.size()) {
TreeNode cur = q.poll();
if (!nums.get(i).equals("N")) {
cur.left = new TreeNode(Integer.parseInt(nums.get(i)));
q.offer(cur.left);
}
i++;
if (i < nums.size() && !nums.get(i).equals("N")) {
cur.right = new TreeNode(Integer.parseInt(nums.get(i)));
q.offer(cur.right);
}
i++;
}
return root;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
List<String> nums = new ArrayList<>();
while (sc.hasNext()) nums.add(sc.next());
TreeNode root = buildTree(nums);
System.out.println(new Solution().minStation(root));
}
}

---

### 第3题-F1值最优的决策树剪枝（P3480）
- 链接：https://codefun2000.com/p/P3480

> 页面标题：#P3480. 第3题-F1值最优的决策树剪枝

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

决策树生成算法递归地产生决策树，直到不能继续下去为止，这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。
在决策树学习中将已生成的树进行简化的过程称为剪枝。具体地，剪枝从已生成的树上裁掉一些子树或叶节点，并将其根节点或父节点作为新的叶节点，从而简化分类树模型。
小AAA希望通过决策树的方法解决一个二分类任务。在该二分类的任务中，标签 111 是正分类，标签 000 是负分类。现在小A已经训练了一个未剪枝的二分类的决策树。他希望对该决策树进行剪枝，能够在验证集上达到最优的 F1F1F1 值。
给定一个二叉树为待剪枝的二分类决策树，每个节点有 333 个参数 fi、thi、labelif_i、th_i、label_ifi​、thi​、labeli​ 。当节点非叶节点时，fi、thif_i、th_ifi​、thi​ 表示该节点决策应用的特征编号和阈值。在数据的第 fif_ifi​ 个特征小于等于 thith_ithi​ 时决策走左节点，大于 thith_ithi​ 时走右节点。决策树的预测通过该规则推理到叶节点时，叶节点的 labelilabel_ilabeli​ 为该条数据的预测结果。
请输出小AAA通过剪枝在验证集上可以达到的最优 F1F1F1 值。
输入描述
第一行为一个 N、M、KN、M、KN、M、K 。其中，N(1<=N<=100)N(1<=N<=100)N(1<=N<=100) 表示决策树的节点个数。M(1<=M<=300)M(1<=M<=300)M(1<=M<=300) 表示验证集条数。K(1<=K<=100)K(1<=K<=100)K(1<=K<=100) 表示每条验证集特征个数。
随后 NNN 行，第 iii 行表示第 iii 个节点，根节点编号为 111 ，每行包括 555 个整数 li、ri、fi、thi、labelil_i、r_i、f_i、th_i、label_ili​、ri​、fi​、thi​、labeli​ 。其中 li、ril_i、r_ili​、ri​ 分别表示节点的左右子节点编号 (0<=liri<=100)(0<=l_ir_i<=100)(0<=li​ri​<=100) 。若 li=0、ri=0l_i =0、r_i=0li​=0、ri​=0 则表示无子节点，不存在只有一个子节点的情况。当节点非叶节点时，fi、thif_i、th_ifi​、thi​ 表示该节点的特征编号和阔值，否则 fi、thif_i、th_ifi​、thi​ 为 000 。labelilabel_ilabeli​ 表示当该节点作为叶节点时的分类结果( labelilabel_ilabeli​ 取值为 000 或 111 )。
随后 MMM 行为验证集特征和 labellabellabel，每行 K+1K+1K+1 个整数，前 KKK 个整数为该条数据的特征，最后一个整数位该条数据的 labellabellabel 。
输出描述
请输出一个浮点数，为验证集可达到的最优 F1F1F1 值，四舍五入保留小数点后 666 位。
样例1
输入
7 3 2
2 3 1 50 0
4 5 2 50 0
6 7 2 50 1
0 0 0 0 0
0 0 0 0 1
0 0 0 0 0
0 0 0 0 1
30 60 1
30 30 1
60 30 1

输出
0.800000

说明
原始决策树为

第一条数据的终止节点为 555 ，节点 predictlabelpredict_labelpredictl​abel 为 111 ，预测正确。
第二条数据的终止节点为 444 ，节点 predictlabelpredict_labelpredictl​abel 为 000 ，预测错误。
第三条数据的终止节点为 666 ，节点 predictlabelpredict_labelpredictl​abel 为 000 ，预测错误。
PrecisionPrecisionPrecision 为 111 , RecallRecallRecall 为 1/3,F11/3,F11/3,F1 ScoreScoreScore 为 1/21/21/2 。
决策树可将节点 6、76、76、7 裁剪掉，裁剪后的决策树为：

第一条数据的终止节点为 555 ，节点 predictlabelpredict_labelpredictl​abel 为 111 ，预测正确。
第二条数据的终止节点为 444 ，节点 predictlabelpredict_labelpredictl​abel 为 000 ，预测错误。
第三条数据的终止节点为 333 ，节点 predictlabelpredict_labelpredictl​abel 为 111 ，预测正确。
PrecisionPrecisionPrecision 为 1,Recall1,Recall1,Recall 为 2/3,F12/3,F12/3,F1 ScoreScoreScore 为 4/5=0.8000004/5=0.8000004/5=0.800000 。
样例2
输入
7 3 3
2 3 3 87 1
0 0 1 3 0
4 5 1 38 1
0 0 2 8 1
6 7 2 94 1
0 0 2 44 1
0 0 2 9 0
30 78 73 0
73 99 99 1
72 3 2 0

输出
1.000000

提示
F1F1F1 值计算公式：
F1=2∗(Precision∗Recall)/(Precision+Recall)F1=2*(Precision *Recall) /(Precision + Recall)F1=2∗(Precision∗Recall)/(Precision+Recall)

▶️

#### TextSol

video solution

题解思路
方法思路

问题分析：决策树可能过拟合训练数据，需要通过剪枝提高泛化能力。对于每个节点，考虑将其转换为叶节点后的F1值，选择最优方案。
算法选择：使用深度优先搜索(DFS)后序遍历决策树。对于每个节点，计算：

保留子树时的F1值（递归处理左右子树）
剪枝为叶节点时的F1值

关键操作：比较两种方案的F1值，选择较大的一个，实现贪心剪枝。
复杂度分析：每个节点处理一次，每次处理需要遍历验证数据子集。时间复杂度为O(N*M)，其中N为节点数，M为验证集大小。

解题代码
Python代码
import sys

def main():
data = sys.stdin.read().split()
it = iter(data)

n = int(next(it)); m = int(next(it)); k = int(next(it))

# 读取节点信息
nodes = {}
for i in range(1, n + 1):
left_id = int(next(it))
right_id = int(next(it))
feature = int(next(it))
threshold = int(next(it))
label = int(next(it))
nodes[i] = {
'left': left_id,
'right': right_id,
'feature': feature,
'threshold': threshold,
'label': label,
'is_leaf': left_id == 0 and right_id == 0
}

# 读取验证数据
validation_data = []
for _ in range(m):
features = [float(next(it)) for _ in range(k)]
true_label = int(next(it))
validation_data.append((features, true_label))

def evaluate_with_label(pred_label, data_subset):
tp = fp = fn = 0
for _, true_label in data_subset:
if pred_label == 1 and true_label == 1:
tp += 1
elif pred_label == 1 and true_label == 0:
fp += 1
elif pred_label == 0 and true_label == 1:
fn += 1
precision = tp / (tp + fp) if tp + fp > 0 else 0
recall = tp / (tp + fn) if tp + fn > 0 else 0
f1 = 2 * precision * recall / (precision + recall) if precision + recall > 0 else 0
return tp, fp, fn, f1

def prune(node_id, data_subset):
node = nodes[node_id]

# 作为叶子评估（剪枝为叶）
tp_leaf, fp_leaf, fn_leaf, f1_leaf = evaluate_with_label(node['label'], data_subset)
if node['is_leaf'] or not data_subset:
return tp_leaf, fp_leaf, fn_leaf, f1_leaf

# 分割数据
left_data, right_data = [], []
for features, true_label in data_subset:
if features[node['feature'] - 1] <= node['threshold']:
left_data.append((features, true_label))
else:
right_data.append((features, true_label))

left_stat = prune(node['left'], left_data)
right_stat = prune(node['right'], right_data)

left_tp, left_fp, left_fn, _ = left_stat
right_tp, right_fp, right_fn, _ = right_stat

tp_sub = left_tp + right_tp
fp_sub = left_fp + right_fp
fn_sub = left_fn + right_fn
precision_sub = tp_sub / (tp_sub + fp_sub) if tp_sub + fp_sub > 0 else 0
recall_sub = tp_sub / (tp_sub + fn_sub) if tp_sub + fn_sub > 0 else 0
f1_sub = 2 * precision_sub * recall_sub / (precision_sub + recall_sub) if precision_sub + recall_sub > 0 else 0

# 选更优方案
if f1_leaf > f1_sub:
return tp_leaf, fp_leaf, fn_leaf, f1_leaf
else:
return tp_sub, fp_sub, fn_sub, f1_sub

# 从根节点开始剪枝
_, _, _, best_f1 = prune(1, validation_data)
print("{:.6f}".format(best_f1))

if __name__ == "__main__":
main()

Java代码
import java.io.*;
import java.util.*;

public class Main {
static class Node {
int l, r, f, th, label;
boolean isLeaf() { return l==0 && r==0; }
}
static class Stat {
int tp=0, fp=0, fn=0;
double f1() {
double P = (tp+fp)>0 ? (double)tp/(tp+fp) : 0.0;
double R = (tp+fn)>0 ? (double)tp/(tp+fn) : 0.0;
return (P+R)>0 ? 2.0*P*R/(P+R) : 0.0;
}
void add(Stat o){ tp+=o.tp; fp+=o.fp; fn+=o.fn; }
}

static Node[] nodes;
static int[][] X;
static int[] Y;

// 将一批样本用某个pred_label作为叶子预测
static Stat evalWithLabel(int predLabel, List<Integer> idx){
Stat s = new Stat();
for(int t: idx){
if(predLabel==1 && Y[t]==1) s.tp++;
else if(predLabel==1 && Y[t]==0) s.fp++;
else if(predLabel==0 && Y[t]==1) s.fn++;
}
return s;
}

static Stat prune(int id, List<Integer> idx){
Node nd = nodes[id];

// 方案A：把当前节点剪为叶子
Stat leaf = evalWithLabel(nd.label, idx);
if (nd.isLeaf() || idx.isEmpty()) return leaf;

// 数据分流
ArrayList<Integer> L = new ArrayList<>(idx.size());
ArrayList<Integer> Rr = new ArrayList<>(idx.size());
for(int t: idx){
// nd.f在非叶必>=1
if (X[t][nd.f-1] <= nd.th) L.add(t);
else Rr.add(t);
}

// 方案B：保留子树；若子节点缺失（编号为0），用“当前节点label作叶子”的方式替代
Stat keepLeft  = prune(nd.l, L);
Stat keepRight = prune(nd.r, Rr);
Stat keep = new Stat(); keep.add(keepLeft); keep.add(keepRight);

return (leaf.f1() > keep.f1()) ? leaf : keep;
}

public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);
Integer N = fs.nextInt(); if (N==null) return;
int M = fs.nextInt(), K = fs.nextInt();

nodes = new Node[N+1];
for(int i=1;i<=N;i++){
Node nd = new Node();
nd.l = fs.nextInt(); nd.r = fs.nextInt();
nd.f = fs.nextInt(); nd.th = fs.nextInt(); nd.label = fs.nextInt();
nodes[i] = nd;
}

X = new int[M][K]; Y = new int[M];
for(int i=0;i<M;i++){
for(int j=0;j<K;j++) X[i][j] = fs.nextInt();
Y[i] = fs.nextInt();
}

ArrayList<Integer> all = new ArrayList<>(M);
for(int i=0;i<M;i++) all.add(i);

double best = prune(1, all).f1();
System.out.printf(Locale.US, "%.6f%n", best);
}

// 轻量输入
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1<<16];
private int ptr=0, len=0;
FastScanner(InputStream is){ in=is; }
private int read() throws IOException {
if (ptr>=len){ len=in.read(buffer); ptr=0; if(len<=0) return -1; }
return buffer[ptr++];
}
Integer nextInt() throws IOException {
int c, sgn=1, x=0;
do { c=read(); if(c==-1) return null; } while(c<=32);
if(c=='-'){ sgn=-1; c=read(); }
for(; c>32; c=read()) x = x*10 + (c-'0');
return x*sgn;
}
}
}

C++代码
#include <bits/stdc++.h>
using namespace std;

struct Node {
int l, r, f, th, label;
bool is_leaf() const { return l == 0 && r == 0; }
};

struct Stat {
int tp=0, fp=0, fn=0;
double f1() const {
double P = (tp+fp)? (double)tp/(tp+fp) : 0.0;
double R = (tp+fn)? (double)tp/(tp+fn) : 0.0;
return (P+R>0)? 2.0*P*R/(P+R) : 0.0;
}
};

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);
int N,M,K;
if(!(cin>>N>>M>>K)) return 0;

vector<Node> nodes(N+1);
for(int i=1;i<=N;i++){
cin>>nodes[i].l>>nodes[i].r>>nodes[i].f>>nodes[i].th>>nodes[i].label;
}
vector<vector<int>> X(M, vector<int>(K));
vector<int> Y(M);
for(int i=0;i<M;i++){
for(int j=0;j<K;j++) cin>>X[i][j];
cin>>Y[i];
}

function<Stat(int, const vector<int>&)> prune = [&](int id, const vector<int>& idx)->Stat{
const auto &nd = nodes[id];
// 评估剪为叶子
Stat leaf;
for(int t: idx){
int pred = nd.label;
if(pred==1 && Y[t]==1) leaf.tp++;
else if(pred==1 && Y[t]==0) leaf.fp++;
else if(pred==0 && Y[t]==1) leaf.fn++;
}
if(nd.is_leaf() || idx.empty()) return leaf;

// 保留子树
vector<int> L, Rr;
L.reserve(idx.size()); Rr.reserve(idx.size());
for(int t: idx){
if (X[t][nd.f-1] <= nd.th) L.push_back(t);
else Rr.push_back(t);
}
Stat ls = prune(nd.l, L), rs = prune(nd.r, Rr);
Stat keep; keep.tp = ls.tp+rs.tp; keep.fp = ls.fp+rs.fp; keep.fn = ls.fn+rs.fn;

// 选择更优
return (leaf.f1() > keep.f1()) ? leaf : keep;
};

vector<int> all(M); iota(all.begin(), all.end(), 0);
double best = prune(1, all).f1();
cout.setf(std::ios::fixed); cout<<setprecision(6)<<best<<"\n";
return 0;
}

---

### 第3题-亲和调度任务组（P2317）
- 链接：https://codefun2000.com/p/P2317

> 页面标题：#P2317. 第3题-亲和调度任务组

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

调度器上有一组将调度的任务（jobjobjob），大部分任务之间存在亲和关系，需要优先把具有亲和关系的任务调度到同一个核上面，不亲和的任务不能运行在同一个核上面；
现在给定一组待调度的任务（任务编号和任务执行时间），同时会给出任务之间不存在亲和关系的列表（未给出的默认是亲和关系）。请设计一个调度器，按照如下要求：
1、找出一组包含亲和任务数量最多的亲和调度任务组；
2、如果规则111有多个解，给出所有任务执行时间之和最小的。并输出该亲和调度任务组的所有任务执行时间之和。
亲和调度任务组定义：一组可以在同一核上面执行的亲和任务集合
解答要求
时间限制 C/C++1000msC/C++1000msC/C++1000ms ，其他语言:2000ms2000ms2000ms
内存限制 C/C++256MBC/C++256MBC/C++256MB，其他语言:512MB512MB512MB
输入
首行是一个整数jobNumjobNumjobNum，表示任务数量，任务编号[1，jobNum][1，jobNum][1，jobNum]，取值范围[1,30][1,30][1,30]
第二行jobNumjobNumjobNum个整数，表示每个任务的执行时间
第三行是一个整数mutexNummutexNummutexNum，表示不存在亲和关系的列表个数
接下来mutexNummutexNummutexNum行，每一行表示111对不亲和的任务编号，任务编号范围[1,jobNum][1,jobNum][1,jobNum]
输出
一个整数，表示所有任务的最短执行时间。
样例1
输入
3
2 3 10
1
1 2

输出
12

解释:有333个待调度任务，任务111和任务222不亲和，不能在一个核上执行；
1.亲和调度任务组有：“任务111”“任务222”“任务333”，“任务111+任务333”，“任务222+任务333”；
2.包含任务数量最参的亲和调度任务组合有两种:“任务111+任务333”，或“任务222+任务333”；
3.两个任务的执行时间分别为121212和131313，选样执行时间较小的“任务111+任务333”，输出121212。
样例2
输入
1
1
0

输出
1

解释:只有一个任务，返回这个任务的执行时间。
样例3
输入
3
2 3 10
3
1 2
2 3
1 3

输出
2

解释：有333个待调度任务，任务111和任务222、任务222和任务333、任务111和任务333不亲和，不能在一个核上执行；
1、亲和调度任务组有:“任务111”，“任务222”，“任务333”；
2、包含任务数量最多的亲和调度任务组合有333种:“任务111”，“任务222”，“任务333”；
3、333个场景的执行时间分别为2、3、102、3、102、3、10，选择执行时间较小的“任务111”，输出222。

▶️

#### TextSol

video solution

塔子哥的小提示
如果考试中遇到此类题型，建议直接使用DFS O(2n)O(2^n)O(2n) 暴力计算结果,说不定官方手软，给这种暴力解法70%以上的通过率。所以塔子哥不建议没有竞赛经验的同学死磕正确解法。
思路1:最大团搜索算法
该问题就是最大团搜索算法的模板题。在搜索出每个最大团之后把团内节点的权值累加更新即可
思路2:折半搜索(meet in the mid) + 子集dp
前置知识:二进制枚举技巧
一个最简单的思路就是O(2n)O(2^n)O(2n)枚举所有子集，但是这样复杂度超了。我们观察到n=30n = 30n=30 , 自然想到可以将集合分成两个部分∣A∣=∣B∣=15|A| = |B| = 15∣A∣=∣B∣=15  ， 这样我们就可以分别对∣A∣,∣B∣|A| , |B|∣A∣,∣B∣ 暴力计算最大亲和的子集了.
此时的问题在于：如何解决A,BA,BA,B 集合之间的不亲和情况。
例如来自AAA集合的100110011001 , 那也就是第1,4个节点被选中，假设他们对于B集合的第2，3个点不亲和。那么也就是二进制状态011001100110不亲和。反过来也就是100110011001亲和。那么我们就只需要求出BBB集合在100110011001限定状态下最多能互相亲和的个数。
这个个数可以使用子集dpdpdp求出，如果s本身就是亲和的，那么dp[s]=∣s∣dp[s] = |s|dp[s]=∣s∣ , 也就是s中二进制个数。
否则，考虑dp[s]=max(dp[x])dp[s] = max(dp[x])dp[s]=max(dp[x]) , x是s的真子集。且x二进制中个数恰好比s少1。 复杂度O(2∣A∣)O(2^{|A|})O(2∣A∣)
最后枚举AAA集合的亲和子集，匹配B集合的dp ， 加起来即可。总复杂度O(2n2)O(2^{\frac{n}{2}})O(22n​) 。
最大团思路
MAX_N = 31  # 最大顶点数为31

# 初始化邻接矩阵,记录哪些顶点之间存在边
adjacency_matrix = [[False for _ in range(MAX_N)] for _ in range(MAX_N)]

# 存储一些顶点的信息
some_vertices = [[0 for _ in range(MAX_N)] for _ in range(MAX_N)]
none_vertices = [[0 for _ in range(MAX_N)] for _ in range(MAX_N)]
all_vertices = [[0 for _ in range(MAX_N)] for _ in range(MAX_N)]
vertex_values = [0] * MAX_N  # 存储每个顶点的权值

answer_size = 0  # 最大团的大小
answer_sum = 0  # 最大团中所有顶点权值之和

def dfs(depth, selected_count, some_count, none_count):
global answer_size, answer_sum
# 当没有"some"顶点和"none"顶点时,说明找到了一个最大团
if some_count == 0 and none_count == 0:
current_sum = 0
for i in range(selected_count):
current_sum += vertex_values[all_vertices[depth][i]]
# 更新最大团的大小和权值之和
if answer_size < depth:
answer_size = depth
answer_sum = float('inf')
if answer_size == depth:
answer_sum = min(answer_sum, current_sum)
return

start_vertex = some_vertices[depth][0]
for i in range(some_count):
vertex = some_vertices[depth][i]
# 如果当前顶点与上一个"some"顶点存在边,则跳过
if adjacency_matrix[start_vertex][vertex]:
continue
# 将当前顶点添加到当前选择的顶点集合中
for j in range(selected_count):
all_vertices[depth + 1][j] = all_vertices[depth][j]
all_vertices[depth + 1][selected_count] = vertex
new_some_count, new_none_count = 0, 0
# 更新"some"和"none"顶点集合
for j in range(some_count):
if adjacency_matrix[vertex][some_vertices[depth][j]]:
some_vertices[depth + 1][new_some_count] = some_vertices[depth][j]
new_some_count += 1
for j in range(none_count):
if adjacency_matrix[vertex][none_vertices[depth][j]]:
none_vertices[depth + 1][new_none_count] = none_vertices[depth][j]
new_none_count += 1
# 递归调用DFS
dfs(depth + 1, selected_count + 1, new_some_count, new_none_count)
# 将当前顶点从"some"集合移动到"none"集合
some_vertices[depth][i] = 0
none_vertices[depth][none_count] = vertex
none_count += 1

if __name__ == "__main__":
n = int(input())  # 读取顶点数
vertex_values = [0] + list(map(int, input().split()))  # 读取每个顶点的权值
m = int(input())  # 读取边数
# 初始化邻接矩阵
for i in range(1, n + 1):
for j in range(1, n + 1):
if i != j:
adjacency_matrix[i][j] = True
# 读取边的信息,并更新邻接矩阵
for i in range(1, m + 1):
u, v = map(int, input().split())
adjacency_matrix[u][v] = adjacency_matrix[v][u] = False
# 初始化"some"顶点集合
for i in range(n):
some_vertices[1][i] = i + 1
# 调用DFS函数
dfs(1, 0, n, 0)
print(answer_sum)  # 输出最大团中所有顶点权值之和

meet in the mid + 子集和dp
n = int(input())
time = [0] + list(map(int, input().split())) # 读入每个点的时间
edge = [[] for _ in range(n + 1)] # 记录每个点的边
edge_num = int(input()) # 读入边的数量
for i in range(edge_num): # 读入边
u, v = map(int, input().split())
if u == v:
continue
edge[u].append(v)
edge[v].append(u)
num_A = n // 2 # A集合的点数和B集合的点数 以及集合的大小
size_A = 1 << num_A
num_B = n - num_A
size_B = 1 << num_B
def map_to (i , offest):
return i + offest
# 计算A集合和B集合的好子集
def calc_good_subset(edge , num , sz, offset):
is_good_subset = [False] * sz
is_good_subset[0] = True
subset_sum = [0] * sz
# 遍历所有的子集
for i in range(sz):
subset = []
# 计算子集的时间和
for j in range(num):
if i >> j & 1:
subset.append(j + 1)
subset_sum[i] += time[map_to(j + 1, offset)]
good = True
# 判断子集是否合法 , 即子集中的点之间没有边
for j in subset:
for k in subset:
if map_to(k , offset) in edge[map_to(j , offset)]:
good = False
break
# 如果合法则标记为True
if good:
is_good_subset[i] = True
return is_good_subset , subset_sum
# 计算A集合和B集合的好子集以及时间和
is_good_subset_A , sum_A = calc_good_subset(edge , num_A , size_A ,0)
is_good_subset_B , sum_B = calc_good_subset(edge , n - num_A , size_B , num_A)

# 计算二进制中1的个数
def get_bits (x):
res = 0
while x:
res += x & 1
x >>= 1
return res

# dp转移出B集合的信息，包括i以及他的子集的状态下最多的点数和在保持最多点数情况下的最小的时间和
subset_info = [[-10**9 , 10**9] for _ in range(size_B)]
subset_info[0] = [0 , 0]
for i in range(size_B):
if is_good_subset_B[i]:
subset_info[i] = [get_bits(i) , sum_B[i]]
for j in range(num_B):
if i >> j & 1:
g = i ^ (1 << j) # 去掉j这个点
# 先考虑点的个数尽量多的
if subset_info[i][0] < subset_info[g][0]:
subset_info[i][0] = subset_info[g][0]
subset_info[i][1] = subset_info[g][1]
# 点的个数相同的情况下，考虑时间总和小的
elif subset_info[i][0] == subset_info[g][0]:
if subset_info[i][1] > subset_info[g][1]:
subset_info[i][1] = subset_info[g][1]

# 考虑合并A集合和B集合的冲突
max_num = -1
min_sum = 10**9
for i in range(size_A):
if not is_good_subset_A[i]:
continue
subset = []
for j in range(num_A):
if (i >> j & 1) == 0:
continue
subset.append(j + 1)
# 计算B集合的好状态
good_states = (1 << num_B) - 1
for j in subset:
# 如果A集合中的点和B集合中的点有冲突，则去掉B集合中的点
for k in edge[j]:
# 如果k在B集合中
if k > num_A:
# 如果k在B集合中的点和A集合中的点有冲突
if (good_states >> (k - num_A - 1)) & 1:
# ban掉k这个点
good_states ^= 1 << (k - num_A - 1)
# 去掉A集合中的点,只保留B集合中的点
num = get_bits(i) + subset_info[good_states][0]
tot_s = sum_A[i] + subset_info[good_states][1]
# 如果点数更多或者点数相同但是时间更少
if max_num < num or (max_num == num and min_sum > tot_s):
max_num = num
min_sum = tot_s
print(min_sum)

c++
#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <climits>
#include <algorithm>

using namespace std;

int jobNum;
vector<int> times;
unordered_map<int, unordered_set<int>> mutex;
int ans = 1;
int cost = INT_MAX;

bool check(int i, const unordered_set<int>& usd) {
for (int u : usd) {
if (mutex[u].count(i) || mutex[i].count(u)) return false;
}
return true;
}

void dfs(int i, unordered_set<int>& usd, int time) {
//停止条件
if (i >= jobNum) {
if (ans <= (int)usd.size()) {
if (ans < (int)usd.size()) {
ans = usd.size();
cost = time;
} else if (ans == (int)usd.size()) {
if (time < cost) {
cost = time;
}
}
}
return;
}
if (usd.size() + jobNum - i + 1 < ans) return ;
dfs(i + 1, usd, time);
if (check(i, usd)) {
usd.insert(i);
dfs(i + 1, usd, time + times[i]);
usd.erase(i);
}
}

int main() {
cin.tie(0);
cin >> jobNum;
times.resize(jobNum);
for (int i = 0; i < jobNum; i++) {
cin >> times[i];
}

int mutexNum;
cin >> mutexNum;

for (int i = 0; i < mutexNum; i++) {
int a, b;
cin >> a >> b;
a--; b--;
mutex[a].insert(b);
mutex[b].insert(a);
}

unordered_set<int> usd;
dfs(0, usd, 0);

cout << cost << endl;

return 0;
}

视频讲解

---

### 第3题-参加博览会（P2314）
- 链接：https://codefun2000.com/p/P2314

> 页面标题：#P2314. 第3题-参加博览会

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有nnn场编号从000到n−1n-1n−1的博览会将要举办，编号为iii的博览会举办时间为[starti,endistart_i,end_istarti​,endi​],即从第startistart_istarti​天到第endiend_iendi​天，包含第startistart_istarti​天和第endiend_iendi​天。
小明计划参加这些博览会，每天最多可以参加kkk场博览会。请问小明最多可以参加多少场博览会。需注意，小明不需要全程参加一场博览会，只需要在某一天参加即可。
输入描述
第一行输入包含两个整数nnn和kkk，nnn表示博览会的数量，kkk表示每天最多可以参加的博览会的数量，1≤n≤104,1≤k≤101≤n≤10^4,1≤k≤101≤n≤104,1≤k≤10。以下nnn行每行包含两个整数startistart_istarti​和endiend_iendi​，表示第iii场博览会的举办时间，1≤starti≤endi≤1091≤ start_i≤end_i≤10^91≤starti​≤endi​≤109。
输出描述
小明最多能参加的博览会数量。
样例1
输入
3 1
1 2
2 3
1 1

输出
3

解释
小明每天可以参加111场博览会，那么他可以在第111天参加第三场博览会，第222天参加第一场博览会，第3天参加第二场博览会，因此最多可以参加3场博览会。
样例2
输入
5 2
1 1
2 2
1 2
2 2
1 1

输出
4

解释
小明每天可以参加222场博览会，那么他可以在第111天参加第一场博览会和第五场博览会，第222天参加第二场博览会和第三场博览会，因此最多可以参加4场博览会。

▶️

#### TextSol

video solution

题面描述:
有nnn场博览会将举办，第iii场博览会的举办时间为从第startistart_istarti​天到第endiend_iendi​天（包含这两天）。小塔每天最多可以参加kkk场博览会，且不需要全程参加某场博览会，只需在某一天参加即可。给定博览会的数量nnn和每天最多可参加的博览会数量kkk，以及每场博览会的举办时间[starti,endi][start_i, end_i][starti​,endi​]，请问小塔最多可以参加多少场博览会。输入包括两整数nnn和kkk，接下来nnn行是博览会的时间范围[starti,endi][start_i, end_i][starti​,endi​]。输出为小塔最多能参加的博览会数量。
题意化简
给定k个时间区间[x,y],从左到右每天只能选择k个时间区间。问最多能选多少个区间？
思路：贪心 + 优先队列
LeetCode 1353. 最多可以参加的会议数目的变种。
大家如果会做上面这个题，就会做本题。思想很简单。
贪心性质:对于第 i 天，如果有若干的会议都可以在这一天开，那么我们肯定是让 endDay 小的会议先在这一天开才会使答案最优，因为 endDay 大的会议可选择的空间是比 endDay 小的多的，所以在满足条件的会议需要让 endDay 小的先开。
做法:考虑随时间推移，维护一个按结束时间排序的小根堆，然后在每个时间戳，从堆里连续取k个出来解决掉即可。
解题思路
要解决这个问题，可以从以下两点进行考虑：

贪心策略的选择：

在某一天，如果有多个博览会可以选择参加，优先选择结束时间（即endiend_iendi​）较早的博览会。因为结束时间较晚的博览会有更多天可以选择，结束时间较早的博览会选择的空间较小，这样可以避免浪费可选的天数。因此，每次都应该优先参加结束时间较早的博览会。

利用最小堆：

我们需要随时从当前可以参加的博览会中选择结束时间最早的几个。最小堆是一种合适的数据结构，因为它可以帮助我们在O(log⁡n)O(\log n)O(logn)的时间复杂度内找到最早结束的博览会。
我们从起始的时间戳开始，按时间推移，每天从当前可参加的博览会中取出kkk场，并将它们从堆中移除，直到所有博览会都被处理完为止。

具体步骤

输入数据：我们读取nnn个博览会的起止时间[starti,endi][start_i, end_i][starti​,endi​]。

排序：首先按照博览会的开始时间startistart_istarti​进行排序。这样可以保证我们在时间流逝的过程中，按顺序处理所有博览会。

最小堆的使用：我们使用一个最小堆queue来存储当前可以参加的博览会的结束时间，堆的性质保证了我们总能先处理掉结束时间最早的博览会。

贪心策略执行：

对于每一个时间戳，我们首先移除掉那些已经结束的博览会（即结束时间小于当前时间的博览会）。
然后将当前可以参加的博览会加入到堆中（这些博览会的开始时间小于等于当前时间）。
接着从堆中取出最多kkk个结束时间最早的博览会，记录参加的数量。

时间推进：如果某个时间戳没有博览会可参加，则将时间推进到下一个可以参加博览会的开始时间。

代码
python
import heapq

n, k = map(int, input().split())
a = [tuple(map(int, input().split())) for _ in range(n)]

# 根据开始时间排序
a.sort(key=lambda x: x[0])

# 模拟当前的时间
start = 0
# 优先队列，存储结束时间
queue = []
# 当前博览会的索引, 从0开始，从小往大遍历
idx = 0
# 参加的博览会数量
ans = 0

while idx < n or queue:
# 移除已结束的博览会
while queue and queue[0] < start:
heapq.heappop(queue)

# 添加当前可以参加的博览会
while idx < n and a[idx][0] <= start:
heapq.heappush(queue, a[idx][1])
idx += 1

# 如果没有可参加的博览会，更新开始时间
if not queue:
if idx == n:
break
start = max(start, a[idx][0])
while idx < n and a[idx][0] <= start:
heapq.heappush(queue, a[idx][1])
idx += 1
# 参加博览会
for _ in range(k):
if queue:
ans += 1
heapq.heappop(queue)

start += 1

print(ans)

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int k = sc.nextInt();
int[][] input = new int[n][2];
for (int i = 0; i < n; i++) {
input[i][0] = sc.nextInt();
input[i][1] = sc.nextInt();
}
sc.close();
// 按开始时间排序
Arrays.sort(input, (a, b) -> Integer.compare(a[0], b[0]));
// 小根堆（按结束时间排序）
PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Integer.compare(a[1], b[1]));
int i = 0, d = input[0][0], res = 0;
while (i < n || !pq.isEmpty()) {
// 添加所有开始时间小于等于当前时间 d 的事件到优先队列
while (i < n && input[i][0] <= d) {
pq.add(input[i++]);
}
// 移除所有结束时间小于当前时间 d 的事件
while (!pq.isEmpty() && pq.peek()[1] < d) {
pq.poll();
}
// 处理当前时间 d 上的最多 k 个事件
int j = 0;
while (!pq.isEmpty() && j < k) {
pq.poll();
res++;
j++;
}
d++;
}

System.out.println(res);
}
}

Cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int main() {
int n, k; // 输入博览会的数量n和每次可以参加的博览会数量k
cin >> n >> k;

vector<vector<int>> a(n, vector<int>(2)); // 用于存储博览会的开始和结束时间
for (int i = 0; i < n; i++) {
cin >> a[i][0] >> a[i][1]; // 读取开始和结束时间
}

// 根据开始时间排序
sort(a.begin(), a.end(), [](const vector<int>& x, const vector<int>& y) {
return x[0] < y[0];
});

int start = 0; // 当前时间
priority_queue<int, vector<int>, greater<int>> queue; // 最小堆用于存储结束时间
int idx = 0; // 当前处理的博览会索引
int ans = 0; // 参加的博览会数量

while (idx < n || !queue.empty()) {
// 移除已结束的博览会
while (!queue.empty() && queue.top() < start) {
queue.pop();
}

// 添加当前可以参加的博览会
while (idx < n && a[idx][0] <= start) {
queue.push(a[idx][1]); // 将结束时间加入优先队列
idx++;
}

// 如果没有可参加的博览会，更新开始时间
if (queue.empty()) {
if (idx == n) {
break;
}
start = max(start, a[idx][0]);
}
while (idx < n && a[idx][0] <= start){
queue.push(a[idx][1]);
idx++;
}
// 参加博览会
for (int i = 0; i < k; i++) {
if (!queue.empty()) {
ans++; // 参加博览会
queue.pop(); // 弹出结束时间
}
}

start++; // 增加当前时间
}

cout << ans << endl; // 输出参加的博览会数量
return 0; // 结束程序
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第3题-维修工（P2311）
- 链接：https://codefun2000.com/p/P2311

> 页面标题：#P2311. 第3题-维修工

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

维修工要给nnn个客户更换设备，为每个用户更换一个设备。维修工背包内最多装kkk个设备，如果背包里有设备可以直接前往下一个客户更换或回公司补充设备，没有则需要回公司取设备。
这些客户有优先级，维修工需要按照优先级给客户更换设备，优先级levellevellevel用数字表示，数字小的优先级高。
维修工从公司出发，给nnn个客户更换设备，最后再返回公司。
请计算维修工完成这项工作所需要经历的最短总距离是多少。维修工可以走斜线，请参考样例111图示。
输入描述
第一行两个正整数n,k(1≤k≤n≤2000)n,k(1≤k≤n≤2000)n,k(1≤k≤n≤2000),表示客户数和维修工背包容量。
第二行两个正整数x,yx,yx,y，用空格分隔(1≤x,y≤106)(1≤x,y≤10^6)(1≤x,y≤106),表示公司的坐标
接下来nnn行每行三个正整数xi,yi,levelix_i,y_i,level_ixi​,yi​,leveli​，用空格分隔,
(1≤xi,yi≤106,1≤leveli≤n)(1≤x_i,y_i≤10^6,1≤level_i≤n)(1≤xi​,yi​≤106,1≤leveli​≤n).(xi,yi)(x_i,y_i)(xi​,yi​)表示第iii个客户的位置坐标levelilevel_ileveli​表示第iii个客户的优先级，保证所有客户优先级不同，客户和公司坐标不会重叠，
输出描述
输出最短总距离，结果四舍五入并保留一位小数，例如:9.09.09.0。
样例1
输入
3 2
1 1
3 1 1
1 2 2
3 2 3

输出
9.2

解释
箭头为最短距离的规划路径:公司 -> 1 -> 公司 -> 2 -> 3 -> 公司

样例2
输入
4 1
2 2
1 1 1
1 3 4
3 1 2
3 3 3

输出
11.3

解释
维修工背包容量是111，逐个按优先级为每个客户更换设备，到每个客户单程距离计算为2\sqrt{2}2​，往返一个客户距离是222\sqrt{2}22​，总路程为828\sqrt{2}82​ ，最短总距离四会五入后为11.311.311.3。

▶️

#### TextSol

video solution

题面描述:
维修工需要为 nnn 个客户更换设备，每个客户需要更换一个设备。维修工的背包最多可以装 kkk 个设备，若背包里有设备则可以直接前往下一个客户更换，否则需返回公司取设备。每个客户有一个优先级，数字越小表示优先级越高，维修工必须按照优先级为客户更换设备，最后再返回公司。输入包含公司的坐标和客户的坐标及优先级，要求计算维修工完成工作所需的最短总距离，并输出结果，四舍五入保留一位小数，例如 9.09.09.0。
思路：动态规划/记忆化搜索
由于可以走斜线，因此无论当前处于哪一个点，接下来要去哪一个点，都可以直接计算出开销。
定义f[i]f[i]f[i]表示处理完第iii个客户并回到起始点的最小开销。从iii回去起始点(x,y)(x,y)(x,y)的开销定义为costcostcost，由于我们最多持有kkk个装备，因此这kkk个装备最多分配给前kkk个客户，所以状态的转移也需要从前kkk个状态中进行。
因此有f[i]=min(f[i],cost+dist[(x,y)−>pj]+f[j−1])f[i]=min(f[i], cost+dist[(x,y)->p_j]+f[j-1])f[i]=min(f[i],cost+dist[(x,y)−>pj​]+f[j−1])，即我们在执行完第pj−1p_{j-1}pj−1​个客户的分配后回起始点取了一次装备，并连续完成了之后若干个客户（到第iii个客户为止）的分配。
题解
本题的核心在于利用动态规划来计算维修工为客户更换设备所需的最短总距离。我们定义一个数组 f[i]，表示在处理完第 iii 个客户后返回公司所需的最小开销。具体的动态规划思路如下：
1. 距离计算
我们首先需要定义一个函数 calc，该函数用于计算两点之间的欧几里得距离。通过使用勾股定理，我们可以直接计算公司位置与客户位置之间的直线距离。这是因为维修工可以走斜线，从而无论当前处于何处，下一步的移动成本都可以被准确计算。
2. 遍历客户
在动态规划过程中，我们遍历每个客户 i，并且对于每个客户 i，我们再往回查看最多 kkk 个客户的状态 j。如果 i 和 j 之间的客户数量超过 kkk，我们就停止该轮循环，因为超过 kkk 的客户无法在一次出行中完成。
在遍历中，我们需要不断更新 f[i] 的值，这样能确保在处理完第 iii 个客户后返回公司所需的最短距离被准确记录。
3. 初始化和输出
在初始化阶段，我们将 f[0] 设置为 0，表示在没有处理任何客户时，返回公司的开销为零。最后，我们输出 f[n]，即处理完所有客户并返回公司所需的最短距离，结果格式化为保留一位小数。
代码
java
import java.util.*;

public class Main {

static final long INF = (long) 1e15;

// 计算两点之间的距离
static double calc(int[] a, int[] b) {
return Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

int n = scanner.nextInt(); // 读取 n 的值
int k = scanner.nextInt(); // 读取 k 的值
int x = scanner.nextInt(); // 读取公司位置 x 坐标
int y = scanner.nextInt(); // 读取公司位置 y 坐标

int[][] p = new int[n + 1][2]; // 用于存储客户点的坐标

for (int i = 1; i <= n; ++i) {
int a = scanner.nextInt(); // 读取客户点 x 坐标
int b = scanner.nextInt(); // 读取客户点 y 坐标
int l = scanner.nextInt(); // 读取客户点的顺序编号
p[l][0] = a; // 保存客户点 x 坐标
p[l][1] = b; // 保存客户点 y 坐标
}

double[] f = new double[n + 1]; // 用于存储从公司到第i个点的最短时间
Arrays.fill(f, INF); // 将数组初始化为无穷大
f[0] = 0; // 初始化从公司出发的时间为0

// 动态规划
for (int i = 1; i <= n; ++i) {
// 计算从公司到第i个点的距离
double value = calc(new int[]{x, y}, p[i]);

// 往前看k个客户点
for (int j = i; j > 0; --j) {
if (i - j + 1 > k) {
break;
}
// 如果j < i , 计算从第j个点到j+1个点的距离
// 也就是更新在路上的时间
if (j < i) {
value += calc(p[j], p[j + 1]);
}
// 更新f[i] , 也就是从公司到第i个点的最短时间
// 具体的, 就是从公司到第j个点的时间 + 从第j个点到第i个点的时间 + 从最开始到第j个点的最短时间
f[i] = Math.min(f[i], value + calc(new int[]{x, y}, p[j]) + f[j - 1]);
}
}

System.out.printf("%.1f%n", f[n]); // 输出从公司到第n个点的最短时间，并保留一位小数
}
}

C++
#include <iostream>
#include <cmath>
#include <vector>
#include <iomanip>
#include <algorithm>

using namespace std;

const long long INF = 1e15;

// 计算两点之间的距离
double calc(pair<int, int> a, pair<int, int> b) {
return sqrt(pow(a.first - b.first, 2) + pow(a.second - b.second, 2));
}

int main() {
int n, k;
cin >> n >> k;

int x, y;
cin >> x >> y;

vector<pair<int, int>> p(n + 1);
for (int i = 1; i <= n; ++i) {
int a, b, l;
cin >> a >> b >> l;
p[l] = {a, b}; // 将坐标存储在对应的顺序位置上
}

vector<double> f(n + 1, INF);
f[0] = 0;

// 动态规划
for (int i = 1; i <= n; ++i) {
// 计算从公司到第i个点的距离
double value = calc({x, y}, p[i]);

// 往前看k个客户点
for (int j = i; j > 0; --j) {
if (i - j + 1 > k) {
break;
}
// 如果j < i , 计算从第j个点到j+1个点的距离
// 也就是更新在路上的时间
if (j < i) {
value += calc(p[j], p[j + 1]);
}
// 更新f[i] , 也就是从公司到第i个点的最短时间
// 具体的, 就是从公司到第j个点的时间 + 从第j个点到第i个点的时间 + 从最开始到第j个点的最短时间
f[i] = min(f[i], value + calc({x, y}, p[j]) + f[j - 1]);
}
}

cout << fixed << setprecision(1) << f[n] << endl;

return 0;
}

python
import math
import sys

def main():
import sys
import math

# 读取输入
n, k = map(int, input().split())
x, y = map(int, input().split())

# 初始化客户列表，索引从1到n，根据优先级排序
p = [None] * (n + 1)  # p[0] 不使用
for _ in range(n):
a, b, l = map(int, sys.stdin.readline().split())
p[l] = (a, b)  # 根据优先级 l 存储坐标

# 定义计算两点之间距离的函数
def calc(a, b):
return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)

INF = float('inf')
# 初始化动态规划数组，f[i] 表示前 i 个客户的最短总距离
f = [INF] * (n + 1)
f[0] = 0.0  # 起点为公司，距离为0

# 动态规划计算最短距离
for i in range(1, n + 1):
# 从公司到第i个客户的距离
value = calc((x, y), p[i])
# 往前看最多 k 个客户
for j in range(i, max(i - k, 0), -1):
if j < i:
# 累加从第j个客户到第j+1个客户的距离
value += calc(p[j], p[j + 1])
# 更新 f[i]，选择最小的总距离
# 总距离 = 前 j-1 个客户的最短距离 + 从公司到第j个客户的距离 + 当前批次的距离
f[i] = min(f[i], f[j - 1] + calc((x, y), p[j]) + value)

# 输出结果，保留一位小数
print(f"{f[n]:.1f}")

if __name__ == "__main__":
main()

---

### 第3题-小明的交换机（P2305）
- 链接：https://codefun2000.com/p/P2305

> 页面标题：#P2305. 第3题-小明的交换机

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明有nnn台交换机设备，用于搭建并行计算接入网络，给定长度为nnn的两个整数数组portportport和bandwidthbandwidthbandwidth，portportport[iii]代表第iii台交换机的端口数量,bandwidthbandwidthbandwidth[iii]表示iii台交换机单个端口的带宽(假设同一台交换机设备上各个端口的带宽相同)，需要从这 nnn 台交换机中选择最多kkk台(可以小于kkk)不同的交换机，使其组成的网络总带宽最大，整个网络总带宽定义为所选交换机的总端口数量乘以所选交换机中端口带宽的最小值，请你返回最多kkk台不同交换机的网络总带宽的最大值。
输入描述

第一行的输入是一个整数nnn，表示交换机的数量 1≤n≤1001≤n≤1001≤n≤100
第二行的输入是一个长度为nnn的整数数组portportport，表示nnn台交换机的端口数量， port[i]port[i]port[i]表示第iii台交换机的端口数量,20≤port[i]≤10020≤port[i]≤10020≤port[i]≤100
第三行的输入是一个长度为nnn的整数数组bandwidth bandwidthbandwidth，表示nnn台交换机的端口带宽，bandwidth[i]bandwidth[i]bandwidth[i]代表第i台交换机的端口带宽10≤bandwidth[i]≤10010 ≤bandwidth[i]≤10010≤bandwidth[i]≤100
第四行的输入是一个整数kkk，表示最多选择的不同交换机数量，1≤k≤n1≤k≤n1≤k≤n

输出描述
一个整数，即最多k台交换机的网络总带宽最大值
样例1
输入
6
20 100 30 10 50 80
50 40 30 90 70 20
2

输出
6000

说明
从666台交换机设备中最多选出222台交换机，选择下标为111(端口数量为：100100100，带宽为：$40)、下标为444(端口数量为：505050，带宽为：707070)的两台交换机，则总带宽为最大(100+50)∗min(40,70)=6000(100+50)*min(40,70)=6000(100+50)∗min(40,70)=6000
样例2
输入
5
100 20 50 50 80
100 10 20 20 20
3

输出
10000

说明
此时我们选择下标为000的交换机，得到最大的总带宽为100∗100=10000 100*100=10000100∗100=10000

▶️

#### TextSol

video solution

题面解释:
小塔有nnn台交换机设备，用于搭建并行计算接入网络。给定两个长度为nnn的整数数组portportport和bandwidthbandwidthbandwidth，其中port[i]port[i]port[i]表示第iii台交换机的端口数量，而bandwidth[i]bandwidth[i]bandwidth[i]表示第iii台交换机单个端口的带宽。需要从这nnn台交换机中选择最多kkk台不同的交换机，以使网络的总带宽最大化，定义为所选交换机的总端口数量乘以所选交换机中端口带宽的最小值。请你返回最多选择kkk台不同交换机的情况下，网络总带宽的最大值。输入包括交换机数量nnn、端口数量数组portportport、带宽数组bandwidthbandwidthbandwidth和最多选择的交换机数量kkk，输出为最大总带宽的整数值。
思想
为了最大化网络节点的总带宽，可以采用以下策略：最大化带宽和接口数量的乘积。总带宽的计算公式为：
总带宽=端口带宽×∑端口数目\text{总带宽} = \text{端口带宽} \times \sum \text{端口数目}
总带宽=端口带宽×∑端口数目
其中，端口带宽是由所有端口的交换机中最小的端口带宽决定的。因此，优化目标是选择端口带宽最小的交换机，并在这些交换机中选择端口数目最多的前 kkk 个交换机。
具体方法如下：

确定最小带宽：首先枚举所有交换机，将每个交换机的端口带宽视为最小带宽，并基于这一假设进行计算。
贪心策略：在所有带宽大于当前最小带宽的交换机中，贪心地选择前 k−1k-1k−1 个具有最大端口数的交换机，以最大化端口总数。这样做的理由是，较大的端口数可以显著提高总带宽。
排序选择：对所有交换机按照端口数量从大到小进行排序，然后从排序后的列表中选择前 k−1k-1k−1 个交换机。这种选择策略确保了优先选择具有更多端口的交换机，从而优化总带宽。

通过这种方法，可以有效地在给定数量的交换机中最大化网络的总带宽。
时间复杂度

输入部分：

输入交换机的数量nnn，以及每台交换机的端口数量和带宽。这个步骤的时间复杂度是 O(n)O(n)O(n)，因为我们需要读取每个交换机的两个属性。

排序：

对交换机按照端口数量进行排序，使用了sort函数，时间复杂度为 O(nlog⁡n)O(n \log n)O(nlogn)。

总带宽计算：

外层循环遍历每个交换机（nnn个），内层循环贪心选择满足条件的交换机。最坏情况下，内层循环也可能遍历所有nnn个交换机，因此内层循环的时间复杂度为 O(n)O(n)O(n)。
因此，这一部分的总时间复杂度为 O(n2)O(n^2)O(n2)，因为我们在外层循环中最多执行 nnn 次，每次执行内层循环的时间复杂度为 O(n)O(n)O(n)。

代码
python
class PP:
# 定义交换机类，包含端口数量（num）和端口带宽（wid）
def __init__(self, num, wid):
self.num = num
self.wid = wid

def main():
# 输入交换机的数量
n = int(input())

# 初始化一个空列表 p 来存储每个交换机的端口信息
p = [None] * (n + 1)

# 输入每个交换机的端口数目
num = list(map(int, input().split()))

# 输入每个交换机的端口带宽
width = list(map(int, input().split()))

# 将每个交换机的端口数目和带宽封装成 PP 对象，并存储到列表 p 中
for i in range(1, n + 1):
p[i] = PP(num[i-1], width[i-1])

# 输入要选择的交换机数量 k
k = int(input())

# 按照端口数从大到小排序交换机
p = sorted(p[1:], key=lambda x: x.num, reverse=True)

# 初始化最大带宽乘积为 0
ans = 0

# 遍历每个交换机，假设其端口带宽为最小带宽
for i in range(n):
# 当前交换机的端口数作为基础值
sum_num = p[i].num
cnt = 1  # 已选择的交换机数量

# 遍历剩余交换机，选择符合条件的交换机
for j in range(n):
# 如果当前交换机的带宽大于等于基准交换机带宽，且不重复选择相同的交换机
if p[j].wid >= p[i].wid and j != i:
sum_num += p[j].num  # 累加端口数
cnt += 1  # 更新已选择交换机的数量

# 如果已选择了 k 个交换机，则停止选择
if cnt == k:
break

# 计算当前组合的带宽乘积，并更新最大值
ans = max(ans, sum_num * p[i].wid)

# 输出最大带宽乘积
print(ans)

if __name__ == "__main__":
main()

c++
#include <bits/stdc++.h>
using namespace std;

// 定义交换机结构体，包含端口数量（num）和端口带宽（wid）
struct pp {
int num;  // 端口数量
int wid;  // 端口带宽
} p[105];  // 存储最多 105 个交换机的信息

int main() {
int n;
// 输入交换机的数量
cin >> n;

// 输入每个交换机的端口数目
for (int i = 1; i <= n; i++)
cin >> p[i].num;

// 输入每个交换机的端口带宽
for (int i = 1; i <= n; i++)
cin >> p[i].wid;

// 输入需要选择的交换机数量 k
int k;
cin >> k;

// 按照端口数量从大到小对交换机进行排序
sort(p + 1, p + n + 1, [&](pp a, pp b) {
return a.num > b.num;  // 比较端口数量
});

// 初始化最大带宽乘积为 0
int ans = 0;

// 遍历每个交换机，假设其端口带宽为当前最小带宽
for (int i = 1; i <= n; i++) {
int sum = p[i].num;  // 当前交换机的端口数作为基础值
int cnt = 1;  // 已选择的交换机数量初始为 1，包含当前交换机

// 贪心选择带宽满足条件的交换机
for (int j = 1; j <= n && cnt < k; j++) {
// 选择带宽大于等于当前交换机的带宽，且不重复选择相同的交换机
if (p[j].wid >= p[i].wid && j != i) {
sum += p[j].num;  // 累加满足条件的交换机的端口数
cnt++;  // 更新已选择的交换机数量
}
}

// 更新最大带宽乘积
ans = max(ans, sum * p[i].wid);  // 计算当前假设的总带宽，并更新最大值
}

// 输出最大带宽乘积
cout << ans << endl;

return 0;
}

java
import java.util.*;

// 定义交换机类，包含端口数量（num）和端口带宽（wid）
class PP {
int num;
int wid;

PP(int num, int wid) {
this.num = num;
this.wid = wid;
}
}

public class MaximizeBandwidth {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 输入交换机的数量
int n = sc.nextInt();
sc.nextLine();  // 处理换行符

// 输入每个交换机的端口数目
int[] num = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();

// 输入每个交换机的端口带宽
int[] width = Arrays.stream(sc.nextLine().split(" ")).mapToInt(Integer::parseInt).toArray();

// 创建交换机数组
PP[] p = new PP[n + 1];
for (int i = 1; i <= n; i++) {
p[i] = new PP(num[i - 1], width[i - 1]);
}

// 输入要选择的交换机数量 k
int k = sc.nextInt();

// 按照端口数量从大到小对交换机进行排序
Arrays.sort(p, 1, n + 1, (a, b) -> Integer.compare(b.num, a.num));

// 初始化最大带宽乘积为 0
int ans = 0;

// 遍历每个交换机，假设其端口带宽为最小带宽
for (int i = 1; i <= n; i++) {
int sumNum = p[i].num;  // 当前交换机的端口数作为基础值
int cnt = 1;  // 已选择的交换机数量

// 贪心选择带宽满足条件的交换机
for (int j = 1; j <= n && cnt < k; j++) {
// 选择带宽大于等于基准交换机带宽，且不重复选择相同的交换机
if (p[j].wid >= p[i].wid && j != i) {
sumNum += p[j].num;  // 累加端口数
cnt++;  // 更新已选择的交换机数量
}
}

// 更新最大带宽乘积
ans = Math.max(ans, sumNum * p[i].wid);
}

// 输出最大带宽乘积
System.out.println(ans);
sc.close();
}
}

---

### 第3题-基站的盈利问题（P2308）
- 链接：https://codefun2000.com/p/P2308

> 页面标题：#P2308. 第3题-基站的盈利问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有NNN个基站采用链式组网，按照从左到右编码为111到NNN编号。
已知定义“业务”概念为三元组(基站起始编号，基站结束编号，利润)，意味着需要占据基站起始编号到基站结束
编号的所有基站，打通信号流，可以获得对应利润。
现在外部存在多个“业务"需求待接纳，但基站使用具有排他性，也就是说一旦某一个业务占据某个基站，其他
业务不可以再使用此基站。
那么接纳哪些业务需求，可以使得利润最大化?
输入描述
第一行，输入NNN，表示有NNN个基站。NNN取值范围[1,10000][1,10000][1,10000]
第二行，输入MMM，表示有MMM组业务。,M取值范围[1,100000][1,100000][1,100000]
接下来MMM行：每行输入三个整数K1K1K1  K2K2K2  RRR，以空格隔开，表示起始基站编号，结束基站编号，利润。K1，K2＜N，K1＜K2K1，K2＜N，K1＜K2K1，K2＜N，K1＜K2，RRR取值范围[1,100][1,100][1,100]
输出描述
输出只有一个整数，表示获取的利润
样例1
输入
5
2
1 5 4
2 4 8

输出
8

说明
样例2
输入
5
2
1 5 4
2 4 1

输出
4

说明
1−51-51−5已经使用过，222到444不能再使用的
样例3
输入
20
6
1 6 1
3 10 2
10 12 3
11 12 2
12 15 2
13 18 1

输出
5

说明
我们可以这么选择业务：
333 101010 222；选择333到101010的基站，获利222
111111 121212 222；选择111111到121212的基站，获利222
131313 181818 111；选择131313到181818的基站，获利111
最终获利555
也可以选择
111 666 111
101010 121212 333
131313 181818 111
注意使用的基站不能重合

▶️

#### TextSol

video solution

题面解释:
在一个基站链式组网中，有 NNN 个基站，按照从左到右的顺序编号。现有多个“业务”需求，每个业务用三元组表示：起始基站编号、结束基站编号和利润。基站只能被一个业务占用，所选业务集合必须保证没有基站重复使用。目标是选择一组业务，使得总利润最大化。输入包含两个整数 NNN（基站数量，范围 [1,10000][1, 10000][1,10000]）和 MMM（业务数量，范围 [1,100000][1, 100000][1,100000]），接下来是 MMM 行，每行三个整数 K1K1K1、K2K2K2 和 RRR，表示起始基站编号、结束基站编号和利润，其中 K1,K2<NK1, K2 < NK1,K2<N 且 K1<K2K1 < K2K1<K2，利润 RRR 的范围为 [1,100][1, 100][1,100]。输出一个整数，表示能够获得的最大利润。
思路：动态规划
本题为LeetCode原题:1235. 规划兼职工作的化简版
对于处于位置K2K2K2处的一个可选基站，其占据位置为[K1,K2][K1,K2][K1,K2]，利润为RRR。那么如果要选择该基站，上一个基站必须处于K2K2K2之前。
定义f[i]f[i]f[i]表示终点在iii及以前的所有基站所能获得的最大利润，有：
f[i]=max{f[i−1],f[K1j−1]+Rj}f[i]=max\{f[i-1],f[K1_j-1]+R_j\}f[i]=max{f[i−1],f[K1j​−1]+Rj​}。
其中K2j==iK2_j==iK2j​==i。
动态规划思路
我们定义一个动态规划数组 f[i]f[i]f[i]，表示以基站 iii 为终点的所有业务所能获得的最大利润。根据题意，状态转移方程可以表示为：
f[i]=max⁡{f[i−1],f[K1j−1]+Rj}f[i] = \max\{f[i-1], f[K1_j-1] + R_j\}
f[i]=max{f[i−1],f[K1j​−1]+Rj​}
其中 K2j==iK2_j == iK2j​==i，即终点为 iii 的所有业务，K1jK1_jK1j​ 是该业务的起始基站编号，RjR_jRj​ 是该业务的利润。这个公式的含义是，我们在计算基站 iii 的最大利润时，有两个选择：要么不选择终点为 iii 的业务，这样利润就是 f[i−1]f[i-1]f[i−1]；要么选择终点为 iii 的某个业务，这时我们需要查看其起始位置的最大利润（即 f[K1j−1]f[K1_j-1]f[K1j​−1]）加上当前业务的利润 RjR_jRj​。
实现步骤

输入处理：

首先读取基站数量 NNN 和业务数量 MMM。
使用一个数组 a 来存储每个基站终点为 iii 的所有业务信息，包括起始位置和利润。

动态规划计算：

初始化动态规划数组 fff，对于每个基站 iii，初始值为 f[i−1]f[i-1]f[i−1]，表示不选择任何终点为 iii 的业务。
遍历所有终点为 iii 的业务，更新最大利润值。
通过 max 函数更新 f[i]f[i]f[i] 的值。

输出结果：

最终，f[n]f[n]f[n] 就是以第 NNN 个基站为终点的所有业务所能获得的最大利润。

代码
C++
#include <bits/stdc++.h>
using namespace std;

const int maxn=1e4+10;  // 定义最大可处理的基站数量
int n, m;  // n表示最大基站位置，m表示基站数量
vector<pair<int, int>> a[maxn];  // 用于存储每个终点位置的基站信息 (起点, 利润)
int f[maxn];  // 动态规划数组，存储终点为i的最大利润

int main() {
cin >> n >> m;  // 输入n和m
for (int i = 1; i <= m; ++i) {
int l, r, c;  // l为基站起点，r为终点，c为利润
cin >> l >> r >> c;  // 输入基站信息
a[r].push_back(make_pair(l, c));  // 按照终点r将基站信息存入a[r]
}

// 动态规划计算
for (int i = 1; i <= n; ++i) {
f[i] = f[i - 1];  // 不选择终点为i的基站，继承f[i-1]
for (auto x : a[i]) {  // 遍历所有终点为i的基站
f[i] = max(f[i], f[x.first - 1] + x.second);  // 更新最大利润
}
}

cout << f[n];  // 输出n位置的最大利润
return 0;
}

python
n = int(input())  # 输入n，表示最大基站位置
m = int(input())  # 输入m，表示基站数量
arr = [list(map(int, input().split())) for _ in range(m)]  # 输入每个基站的起点、终点和利润
arr.sort(key=lambda x: x[1])  # 按照基站的终点位置排序
g = [-1] * (n + 1)  # 动态规划数组，初始化为-1，表示未计算状态
g[0] = 0  # 基础状态，终点为0时，利润为0
now = 0  # 当前处理到的基站索引

# 动态规划计算
for i in range(1, n + 1):
g[i] = g[i - 1]  # 不选择终点为i的基站，继承g[i-1]
while now < m and arr[now][1] == i:  # 遍历所有终点为i的基站
x, y, v = arr[now]  # 读取基站的起点x，终点y，利润v
now += 1  # 处理下一个基站
g[y] = max(g[y], g[x - 1] + v)  # 更新最大利润

print(g[n])  # 输出n位置的最大利润

java
import java.util.Arrays;
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt(); // 输入最大基站位置n
int m = sc.nextInt(); // 输入基站数量m

int[][] arr = new int[m][3]; // 用于存储每个基站的起点、终点和利润

// 读取基站信息
for (int i = 0; i < m; i++) {
arr[i][0] = sc.nextInt(); // 读取基站的起点
arr[i][1] = sc.nextInt(); // 读取基站的终点
arr[i][2] = sc.nextInt(); // 读取基站的利润
}

// 按照终点对基站进行排序
Arrays.sort(arr, (a, b) -> Integer.compare(a[1], b[1]));

int[] g = new int[n + 1]; // 动态规划数组，存储到达每个位置的最大利润
Arrays.fill(g, -1); // 初始化为-1，表示未处理的状态
g[0] = 0; // 基础状态，终点为0时，利润为0

int now = 0; // 当前处理的基站索引
// 动态规划计算
for (int i = 1; i <= n; i++) {
g[i] = g[i - 1]; // 不选择终点为i的基站，继承g[i-1]
while (now < m && arr[now][1] == i) { // 遍历所有终点为i的基站
int x = arr[now][0]; // 基站起点
int y = arr[now][1]; // 基站终点
int v = arr[now][2]; // 基站利润
now++; // 处理下一个基站
g[y] = Math.max(g[y], g[x - 1] + v); // 更新最大利润
}
}

System.out.println(g[n]); // 输出n位置的最大利润
sc.close();
}
}

---

### 第3题-关灯（P2302）
- 链接：https://codefun2000.com/p/P2302

> 页面标题：#P2302. 第3题-关灯

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明正值班，突然发现他所在的屋子进水了，水面一直上涨，考虑到可能有电器暴露在水中，小明想通过尚未被水淹没的箱子达到电源处，关闭电源。假设电源和小明所处的位置都比较安全，不会被水淹没。已知屋子为矩形，可划分为大小相当的小方格，小明的位置，电源，箱子都正好在小方格的正中间，覆盖整个方格；小明每单位时间可以从一个小方格移动到相邻的处在同一行或者同一列的另一小方格。为了安全小明只能移动到没有被上涨的水面淹没的小方格，箱子的高度不一，所在方格被水淹没的时间取决于方格内箱子的高度
水面每单位时间上涨111，如果此时箱子的高度小于或者等于水面的高度，则被淹没。
请帮小明设计一条路线到达电源处，如果没有这样的路线，则小明应该待在原地。
输入描述
第一行：开始时水的深度
第二行：用空格隔开的两个数字，第一个为屋子的长，对应余下输入的行数，第二个为屋子的宽，对应余下输入各行和个数
从第三行开始，描述屋子内小方格的布局。用非000数字代表箱子的高度，000代表没有箱子，sss代表小明的位置，t代表电源位置
输出描述
第一行输出一个mmm , 代表路径长度
接下来mmm 行，每行一个坐标(xi,yi)(x_i,y_i)(xi​,yi​) 代表第iii步的位置
样例1
输入
0
4 4
s 1 3 5
2 3 2 4
2 4 4 5
3 5 5 t

输出
1
0 0

说明
无法安全到达电源位置，只能呆在原地sss所在位置
样例2
输入
0
4 4
s 1 2 5
2 3 2 4
2 4 4 5
3 5 7 t

输出
7
0 0
1 0
1 1
2 1
3 1
3 2
3 3

说明
输入：第一行表示开始水面深度为000，第二行表示屋子为4∗44*44∗4的方格；如果方格坐标从111开始，则小明在第111行第111列，电源在第444行第444列；
输出：输出了从小明所在位置sss到电源所在位置ttt以及路径上的箱子高度
注意:如果有多个方案，输出任意一个合法的移动方案即可。

▶️

#### TextSol

video solution

题面描述:
在这个问题中，小塔发现他的房间里进水了，水位不断上涨。他需要通过一些没有被水淹没的箱子移动，以安全地到达电源处。每个小方格的水位上升与箱子的高度有关，只有当水位低于箱子高度时，小塔才能通过该格。输入给出初始水深、房间的格局以及小塔和电源的位置，输出则是小塔从起点到电源的路径长度和每一步的位置坐标。如果无法到达电源，小塔则留在原地。通过这个问题，我们可以帮助小塔设计一条安全的路线，以确保他能顺利关闭电源。
思路:高维bfs
考虑记录状态:(x,y,step) 代表在位置x,y并且已经走了step步状态下是否合法。
fa[x][y][step]fa[x][y][step]fa[x][y][step] 记录这个状态下的上一步是哪里来的。
然后直接进行bfs,过程中注意放进队列之前判断step + init_h 以及 a[i][j]a[i][j]a[i][j] 之间的大小关系。
最后需要bfs输出路径
问题描述
小塔的房间为一个矩形网格，水位不断上涨。每个小方格可能放有箱子，不同高度的箱子会影响水位的淹没速度。小塔每单位时间只能移动到相邻的方格，并且只能在未被水淹没的方格中行走。我们的目标是帮助小塔找到一条从起点（标记为s）到终点（标记为t）的安全路径。如果没有这样的路径，则小塔需要留在原地。
状态记录
我们使用状态 (x, y, step) 来表示小塔在位置 (x, y)，并且已经走了 step 步。为了追踪路径，我们定义了一个三维数组 fa[x][y][step] 来记录在状态 (x, y, step) 下的上一步来自哪里。这有助于在找到终点后，能够回溯出完整的路径。
BFS算法实现

初始化：

读取初始水深、房间的大小以及地图的布局。
找到起点和终点的位置。
初始化队列，存储起点和初始高度，同时创建 fa 数组来记录状态。

方向数组：

定义四个方向（上、下、左、右）的移动方式。

BFS过程：

从队列中取出当前状态 (x, y, h)。
检查是否到达终点。如果到达，则记录结果并退出。
遍历四个可能的移动方向，计算新位置 (nx, ny) 及新高度 nh。
检查新位置是否越界、是否是起点或是否已经访问过。
如果新位置是一个箱子，则获取其高度；如果不是，则设为一个很大的数。
如果当前水位不够以通过该位置，则继续循环。
如果可以通过，记录状态并将新状态加入队列。

路径回溯：

如果没有找到路径，输出路径长度为 1，坐标为起点。
如果找到路径，从终点回溯到起点，收集路径上的每个坐标并输出。

代码
java
to be fill

python
# 读取初始高度
height = int(input())
# 读取地图的行数和列数
n, m = map(int, input().split())
# 读取地图数据
a = [input().split() for _ in range(n)]

# 初始化起点和终点
sx, sy = 0, 0
ex, ey = 0, 0

# 找到起点 's' 和终点 't' 的坐标
for i in range(n):
for j in range(m):
if a[i][j] == "s":
sx, sy = i, j  # 起点坐标
if a[i][j] == "t":
ex, ey = i, j  # 终点坐标

# 队列初始化，包含起点和初始高度
que = [(sx, sy, height)]
# fa 数组记录状态，fa[x][y][step] 记录状态下的上一步位置
fa = [[[-1 for _ in range(n * m)] for _ in range(m)] for _ in range(n)]

# 方向数组，表示上下左右四个方向
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]
ok = False  # 路径是否找到的标志
res_h = 0   # 记录找到的高度

# BFS 开始
while que:
x, y, h = que.pop(0)  # 从队列中取出当前状态
# 如果到达终点，记录结果并退出
if x == ex and y == ey:
res_h = h
ok = True
break
# 遍历四个方向
for i in range(4):
nx, ny, nh = x + dx[i], y + dy[i], h + 1  # 新位置和新高度
# 检查新位置是否越界或是起点，或是状态已访问
if nx < 0 or nx >= n or ny < 0 or ny >= m or a[nx][ny] == "s" or fa[nx][ny][nh] != -1:
continue
now = 0
# 如果新位置是数字，获取其高度，否则设为一个很大的数
if a[nx][ny].isdigit():
now = int(a[nx][ny])
else:
now = 10**9
# 如果当前高度不够，无法通过
if now <= nh:
continue
# 记录状态
fa[nx][ny][nh] = (x, y)
# 将新状态加入队列
que.append((nx, ny, nh))

# 如果未找到路径
if not ok:
print(1)  # 输出结果
print(sx, sy)  # 输出起点坐标
else:
ans = []  # 存储路径
x, y, h = ex, ey, res_h  # 从终点开始回溯
while x != sx or y != sy:  # 回溯到起点
ans.append((x, y))  # 记录路径
x, y = fa[x][y][h]  # 获取上一步的位置
h -= 1  # 高度减一
ans.append((sx, sy))  # 添加起点到路径
ans.reverse()  # 反转路径

# 输出路径长度和路径坐标
print(len(ans))
for x, y in ans:
print(x, y)

cpp
#include <iostream>
#include <vector>
#include <queue>
#include <tuple>
#include <algorithm>  // 添加这一行以使用 reverse 函数

using namespace std;

int main() {
// 读取初始高度
int height;
cin >> height;

// 读取地图的行数和列数
int n, m;
cin >> n >> m;

// 读取地图数据
vector<vector<string>> a(n, vector<string>(m));
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
cin >> a[i][j];
}
}

// 初始化起点和终点
int sx = -1, sy = -1, ex = -1, ey = -1;

// 找到起点 's' 和终点 't' 的坐标
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
if (a[i][j] == "s") {
sx = i;
sy = j;  // 起点坐标
}
if (a[i][j] == "t") {
ex = i;
ey = j;  // 终点坐标
}
}
}

// 检查是否找到了起点和终点
if (sx == -1 || sy == -1 || ex == -1 || ey == -1) {
cout << "Error: Start or end point not found." << endl;
return 1;
}

// 队列初始化，包含起点和初始高度
queue<tuple<int, int, int>> que;
que.push(make_tuple(sx, sy, height));

// fa 数组记录状态，fa[x][y][step] 记录状态下的上一步位置
vector<vector<vector<int>>> fa(n, vector<vector<int>>(m, vector<int>(n * m, -1)));

// 方向数组，表示上下左右四个方向
int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

bool ok = false;  // 路径是否找到的标志
int res_h = 0;    // 记录找到的高度

// BFS 开始
while (!que.empty()) {
auto [x, y, h] = que.front();  // 从队列中取出当前状态
que.pop();  // 出队

// 如果到达终点，记录结果并退出
if (x == ex && y == ey) {
res_h = h;
ok = true;
break;
}

// 遍历四个方向
for (int i = 0; i < 4; i++) {
int nx = x + dx[i], ny = y + dy[i], nh = h + 1;  // 新位置和新高度

// 检查新位置是否越界或是起点，或是状态已访问
if (nx < 0 || nx >= n || ny < 0 || ny >= m || a[nx][ny] == "s" || fa[nx][ny][nh] != -1) {
continue;
}

int now = 0;
// 如果新位置是数字，获取其高度，否则设为一个很大的数
if (isdigit(a[nx][ny][0])) {
now = stoi(a[nx][ny]);
} else {
now = 10 * 9; // 设为一个很大的数
}

// 如果当前高度不够，无法通过
if (now <= nh) {
continue;
}

// 记录状态
fa[nx][ny][nh] = x * m + y; // 记录上一步位置（转换为一维表示）
// 将新状态加入队列
que.push(make_tuple(nx, ny, nh));
}
}

// 如果未找到路径
if (!ok) {
cout << 1 << endl;  // 输出结果
cout << sx << " " << sy << endl;  // 输出起点坐标
} else {
vector<pair<int, int>> ans;  // 存储路径
int x = ex, y = ey, h = res_h;  // 从终点开始回溯
while (x != sx || y != sy) {  // 回溯到起点
ans.emplace_back(x, y);  // 记录路径
int prev = fa[x][y][h];   // 获取上一步的位置
x = prev / m; // 行坐标
y = prev % m; // 列坐标
h--;  // 高度减一
}
ans.emplace_back(sx, sy);  // 添加起点到路径

reverse(ans.begin(), ans.end());  // 反转路径

// 输出路径长度和路径坐标
cout << ans.size() << endl;
for (const auto &p : ans) {
cout << p.first << " " << p.second << endl;
}
}

return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第3题-逆转矩阵列表（P2296）
- 链接：https://codefun2000.com/p/P2296

> 页面标题：#P2296. 第3题-逆转矩阵列表

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一个N×NN×NN×N的矩阵，其中每个元素都是正整数，且111到N2N^2N2的正整数恰好名出现一次。
可以将这个短阵按照顺时针螺施的方式组成一个链表:从左上角即(1,1)(1,1)(1,1)号格子出发，沿直线走到右上角即(1,N)(1,N)(1,N)号格子，再沿直线走到右下角即(N，N)(N，N)(N，N)号格子，再沿直线走到左下角即(N,1)(N,1)(N,1)号格子，再沿直线走到左上角下方即(2,1)(2,1)(2,1)号格子，这就完成了最外面的圈；随后从(2,1)(2,1)(2,1)号格子走到(2,2)(2,2)(2,2)号格子，接着完成里面的圈，以此类推，直到结束。
同样地，也可以将其按照逆时针螺旋的方式组成一个链表:从左上角即(1,1)(1,1)(1,1)号格子出发，沿直线走到左下角即(N,1)(N,1)(N,1)号格子，再沿直线走到有下角即(N,N)(N,N)(N,N)号格子，再沿直线走到右上角即(1,N)(1,N)(1,N)号格子，再沿直线走到左上角右方即(1,2)(1,2)(1,2)号格子，这就完成了最外面的圈，随后从(1,2)(1,2)(1,2)号格子走到(2,2)(2,2)(2,2)号格子，接看完成里面的圈，以此类推，直到结束。
下图给出了333 阶和444 阶矩阵的顺时针链表和逆时针链表的示例。

给定短阵的顺时针链表，求相应的逆时针链表。
输入描述
第一行包含一个整数 NNN，第二行包含 N2N^2N2个整数，以空格分隔，表示顺时针链表中每个元素的值。
输出描述
含 N2N^2N2个整数，以空格分隔，表示逆时针链表的每个元素的值。
样例1
输入
3
1 2 3 6 9 8 7 4 5

输出
1 4 7 8 9 6 3 2 5

说明
该矩阵如下:
1 2 3
4 5 6
7 8 9
样例2
输入
4
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10

输出
1 5 9 13 14 15 16 12 8 4 3 2 6 10 11 7

说明
该矩阵如下：
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16

▶️

#### TextSol

video solution

原题来源
LeetCode 54.螺旋矩阵
题面解释:
在本题中，我们需要处理一个 ( N \times N ) 的矩阵，每个元素为正整数，且所有正整数从 ( 1 ) 到 ( N^2 ) 恰好出现一次。给定该矩阵的顺时针遍历的结果，要求输出对应的逆时针遍历结果。输入格式为第一行包含一个整数 ( N )，表示矩阵的大小；第二行输入 ( N^2 ) 个整数，表示顺时针链表中每个元素的值。输出格式为 ( N^2 ) 个整数，表示逆时针链表的元素，以空格分隔.
模拟
对于一个大小为n的矩阵，利用一个vis数组先把周围标记墙，从(1,1)开始顺时针(右下左上(循环))模拟走，走过的位置也标记为墙体，碰到墙则进行下一个方向例如(前面一格是墙则反向顺时针旋转90度)，一定能走完n*n的矩阵。还原矩阵，同理按逆时针模拟输出即可\\
整体时间复杂度o(n * n)
题解
在本题中，我们需要处理一个 ( N \times N ) 的矩阵，其中的每个元素都是正整数，且所有的正整数从 ( 1 ) 到 ( N^2 ) 恰好出现一次。我们首先根据给定的顺时针链表生成一个矩阵，然后输出该矩阵的逆时针遍历结果。
思路

初始化访问标记：首先我们定义一个 visited 数组，用来标记矩阵的访问状态。矩阵的边界视为墙体（已访问），内部位置初始为未访问。

顺时针填充矩阵：

从矩阵的左上角 (1,1) 开始，按顺时针方向（右、下、左、上）进行填充。
如果当前方向可以继续前进（即下一个位置未被访问），则继续向该方向前进。
如果碰到墙（已访问），则顺时针旋转90度，尝试下一个方向。

逆时针输出矩阵：

从填充后的矩阵的左上角开始，按逆时针方向（下、右、上、左）进行遍历输出。
同样地，判断下一个位置是否已访问，并适时改变方向。

时间复杂度：整个过程的时间复杂度为 ( O(N^2) )，因为每个位置都会被访问一次。

代码如下
cpp
#include <bits/stdc++.h>
using namespace std;

#define MAX_N 105

int n; // 矩阵的阶数
int seq[MAX_N * MAX_N]; // 顺时针链表中的元素值
int mat[MAX_N][MAX_N]; // 矩阵
int visited[MAX_N][MAX_N]; // 访问标记矩阵
int dxClock[4] = {0, 1, 0, -1}; // 顺时针行方向（右、下、左、上）
int dyClock[4] = {1, 0, -1, 0}; // 顺时针列方向
int dxCounter[4] = {1, 0, -1, 0}; // 逆时针行方向（下、右、上、左）
int dyCounter[4] = {0, 1, 0, -1}; // 逆时针列方向

// 初始化访问标记，将矩阵外边界设置为已访问
void initVisitedOuter() {
for (int i = 0; i <= n + 1; i++) {
for (int j = 0; j <= n + 1; j++) {
visited[i][j] = 1; // 设置矩阵边界为已访问
}
}
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
visited[i][j] = 0; // 矩阵内部未访问
}
}
}

// 顺时针递归填充矩阵
void fillClockwise(int x, int y, int dir, int idx) {
mat[x][y] = seq[idx]; // 填入顺时针链表中的值
visited[x][y] = 1; // 标记当前位置为已访问

int nx = x + dxClock[dir]; // 计算下一个位置的行坐标
int ny = y + dyClock[dir]; // 计算下一个位置的列坐标

if (visited[nx][ny] == 0) { // 如果下一个位置未访问，继续递归
fillClockwise(nx, ny, dir, idx + 1);
} else { // 否则换方向
dir = (dir + 1) % 4; // 顺时针旋转方向
nx = x + dxClock[dir]; // 更新下一个位置
ny = y + dyClock[dir];
if (visited[nx][ny] == 0) {
fillClockwise(nx, ny, dir, idx + 1);
}
}
}

// 逆时针读取矩阵并输出
void outputCounterClockwise(int x, int y, int dir, int idx) {
if (idx != 1) cout << ' '; // 在输出前加空格，避免开头多余空格
cout << mat[x][y]; // 输出当前矩阵位置的值
visited[x][y] = 1; // 标记当前位置为已访问

int nx = x + dxCounter[dir]; // 计算下一个位置的行坐标
int ny = y + dyCounter[dir]; // 计算下一个位置的列坐标

if (visited[nx][ny] == 0) { // 如果下一个位置未访问，继续递归
outputCounterClockwise(nx, ny, dir, idx + 1);
} else { // 否则换方向
dir = (dir + 1) % 4; // 逆时针旋转方向
nx = x + dxCounter[dir]; // 更新下一个位置
ny = y + dyCounter[dir];
if (visited[nx][ny] == 0) {
outputCounterClockwise(nx, ny, dir, idx + 1);
}
}
}

int main() {
ios::sync_with_stdio(0); // 加速输入输出
cin.tie(0); // 解除 cin 和 cout 的绑定

cin >> n; // 读取矩阵的大小
for (int i = 1; i <= n * n; i++) cin >> seq[i]; // 读取顺时针链表

initVisitedOuter(); // 初始化访问矩阵边界
fillClockwise(1, 1, 0, 1); // 从 (1, 1) 开始顺时针填充矩阵

initVisitedOuter(); // 重新初始化访问边界，用于逆时针读取
outputCounterClockwise(1, 1, 0, 1); // 从 (1, 1) 开始逆时针读取并输出

return 0; // 程序结束
}

python
import sys
sys.setrecursionlimit(100005)  # 增加递归深度以适应较大的矩阵

MAX_N = 105
n = 0
clockwise_values = [0] * (MAX_N * MAX_N)  # 顺时针链表中的元素值
matrix = [[0] * MAX_N for _ in range(MAX_N)]  # 矩阵
visited = [[0] * MAX_N for _ in range(MAX_N)]  # 访问标记矩阵
dx_clock = [0, 1, 0, -1]  # 顺时针方向行移动
dy_clock = [1, 0, -1, 0]  # 顺时针方向列移动
dx_counter = [1, 0, -1, 0]  # 逆时针方向行移动
dy_counter = [0, 1, 0, -1]  # 逆时针方向列移动

# 初始化访问标记，将矩阵内部设置为未访问
def reset_inner_visited():
global visited
for i in range(1, n + 1):
for j in range(1, n + 1):
visited[i][j] = 0

# 初始化访问标记，将矩阵外边界设置为已访问
def set_outer_boundary_visited():
global visited
for i in range(n + 2):
for j in range(n + 2):
visited[i][j] = 1

# 顺时针递归填充矩阵
def fill_clockwise(x, y, direction, idx):
matrix[x][y] = clockwise_values[idx]
visited[x][y] = 1

next_x, next_y = x + dx_clock[direction], y + dy_clock[direction]
if visited[next_x][next_y] == 0:
fill_clockwise(next_x, next_y, direction, idx + 1)
else:
# 换方向
direction = (direction + 1) % 4
next_x, next_y = x + dx_clock[direction], y + dy_clock[direction]
if visited[next_x][next_y] == 0:
fill_clockwise(next_x, next_y, direction, idx + 1)

# 逆时针读取矩阵并输出
def output_counter_clockwise(x, y, direction, idx):
if idx != 1:
print(' ', end='')
print(matrix[x][y], end='')

visited[x][y] = 1
next_x, next_y = x + dx_counter[direction], y + dy_counter[direction]
if visited[next_x][next_y] == 0:
output_counter_clockwise(next_x, next_y, direction, idx + 1)
else:
# 换方向
direction = (direction + 1) % 4
next_x, next_y = x + dx_counter[direction], y + dy_counter[direction]
if visited[next_x][next_y] == 0:
output_counter_clockwise(next_x, next_y, direction, idx + 1)

# 主程序入口
n = int(input())
clockwise_values = [0] + list(map(int, input().split()))  # 顺时针链表
set_outer_boundary_visited()  # 设置矩阵外边界已访问
reset_inner_visited()  # 重置内部为未访问
fill_clockwise(1, 1, 0, 1)  # 顺时针填充矩阵

set_outer_boundary_visited()  # 重新设置矩阵外边界
reset_inner_visited()  # 重置内部为未访问
output_counter_clockwise(1, 1, 0, 1)  # 逆时针输出矩阵

java
import java.util.Scanner;

public class Main {
static final int MAX_N = 105;
static int n; // 矩阵的阶数
static int[] clockwiseValues = new int[MAX_N * MAX_N]; // 顺时针链表中的值
static int[][] matrix = new int[MAX_N][MAX_N]; // 矩阵
static int[][] visited = new int[MAX_N][MAX_N]; // 访问标记矩阵
static int[] dxClock = {0, 1, 0, -1}; // 顺时针方向行移动
static int[] dyClock = {1, 0, -1, 0}; // 顺时针方向列移动
static int[] dxCounter = {1, 0, -1, 0}; // 逆时针方向行移动
static int[] dyCounter = {0, 1, 0, -1}; // 逆时针方向列移动

// 重置矩阵的内部访问标记为未访问
static void resetInnerVisited() {
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
visited[i][j] = 0;
}
}
}

// 初始化访问标记，将矩阵外边界设置为已访问
static void setOuterBoundaryVisited() {
for (int i = 0; i <= n + 1; i++) {
for (int j = 0; j <= n + 1; j++) {
visited[i][j] = 1;
}
}
}

// 顺时针递归填充矩阵
static void fillClockwise(int x, int y, int direction, int idx) {
matrix[x][y] = clockwiseValues[idx];
visited[x][y] = 1;
int nextX = x + dxClock[direction];
int nextY = y + dyClock[direction];

if (visited[nextX][nextY] == 0) {
fillClockwise(nextX, nextY, direction, idx + 1);
} else {
// 改变方向
direction = (direction + 1) % 4;
nextX = x + dxClock[direction];
nextY = y + dyClock[direction];
if (visited[nextX][nextY] == 0) {
fillClockwise(nextX, nextY, direction, idx + 1);
}
}
}

// 逆时针递归输出矩阵
static void outputCounterClockwise(int x, int y, int direction, int idx) {
if (idx != 1) System.out.print(' ');
System.out.print(matrix[x][y]);
visited[x][y] = 1;
int nextX = x + dxCounter[direction];
int nextY = y + dyCounter[direction];

if (visited[nextX][nextY] == 0) {
outputCounterClockwise(nextX, nextY, direction, idx + 1);
} else {
// 改变方向
direction = (direction + 1) % 4;
nextX = x + dxCounter[direction];
nextY = y + dyCounter[direction];
if (visited[nextX][nextY] == 0) {
outputCounterClockwise(nextX, nextY, direction, idx + 1);
}
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
n = scanner.nextInt();

for (int i = 1; i <= n * n; i++) {
clockwiseValues[i] = scanner.nextInt();
}

setOuterBoundaryVisited(); // 初始化矩阵外边界
resetInnerVisited(); // 重置矩阵内部未访问
fillClockwise(1, 1, 0, 1); // 顺时针填充矩阵

setOuterBoundaryVisited(); // 重新设置矩阵外边界
resetInnerVisited(); // 重置矩阵内部未访问
outputCounterClockwise(1, 1, 0, 1); // 逆时针输出矩阵
}
}

---

### 第3题-日志文件存储问题（P2299）
- 链接：https://codefun2000.com/p/P2299

> 页面标题：#P2299. 第3题-日志文件存储问题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一个日志管理系统，保存了NNN个进程的日志文件，每个进程有MMM个日志文件。系统记录了每个日志文件的文件大小和被下载的次数。现在需要把部分日志文件保存在容量为ccc的UUU盘中，请设计算法计算UUU盘存储的日志文件下载次数之和最大是多少。
注意，为了保证日志的完整性，每个进程至少要保存一个日志文件到UUU盘，如果无法实现，则返回−1-1−1，如果UUU盘容量足以存储，则返回所存储的日志文件被下载的次数之和。
输入描述
入参分为多行输入:

第111行输入的输入信息是N、M、CN、M、CN、M、C,用空格分割。
第222行开始是日志文件的信息，每行信息包含了所属进程序号、文件大小和被下载次数，用空格分割。

输出描述
UUU盘存储的日志文件被下载次数之和，每个进程至少要保存一个日志文件到UUU盘，如果无法实现，则返回−1-1−1。
样例1
输入
1 2 10
0 5 1
0 5 2

输出
3

说明
有111个进程，每个进程有222个日志文件，UUU盘容量是101010。第一个进程的第一个文件大小是555，下载次数是111;第一个进程的第二个文件大小是555，下载次数是222。UUU盘能存储这两个文件，下载次数之和最多是333次。
样例2
输入
2 2 10
0 5 1
0 5 2
1 6 1
1 6 2

输出
-1

说明
有222个进程，每个进程有222个日志文件，UUU盘容量是101010。第一个进程的第一个文件大小是555，下载次数是111;第一个进程的第二个文件大小是555，下载次数是222。第二个进程的第一个文件大小是666，下载次数是111;第二个进程的第二个文件大小是666，下载次数是222。U盘容灾无法确保每个进程至少存入一个文件，返回−1-1−1。

▶️

#### TextSol

video solution

题目大意
一个拥有一定容量的背包，有n组物品，每组物品有容量和价值。每组里至少选择一个，问能选出的最大价值。
思路
我们可以先考虑对于每一组物品，我们给他们分配多少的容量。这个问题可以分两步走:
step1:整体分配
找到一个长度为n(分组个数)的sz序列，使得这个序列的和<=c，且每个元素 >= 1。
sz1,sz2,...,sznsz_1 , sz_2 , ... , sz_n
sz1​,sz2​,...,szn​
这里szisz_iszi​ 是给第iii组分配的容量大小。
step2 :单组最优解
这里容易发现，如果对一个分组，我们已经确定他的容量为szisz_iszi​了，那么对这一组来说，就是一个01背包模型。
回到step1:这个问题本身也是一个动态规划问题。dp[i][j]dp[i][j]dp[i][j] 代表考虑了前i个分组，并且已经用了jjj容量的最优解。转移为:
dp[i][j]=max(dp[i−1][j−k]+f[i][k])dp[i][j] = max(dp[i - 1][j - k] + f[i][k])dp[i][j]=max(dp[i−1][j−k]+f[i][k]) , k枚举从1到j - 1。 f[i][k]f[i][k]f[i][k]代表给第i个分组分配kkk容量情况下的最优解。
样例解释
拿样例2来说，我们先对每个分组做01背包，得到的结果如下：
dp_of_0 = {0,-1,-1,-1,-1,2,-1,-1,-1,-1,3}
dp_of_1 = {0,-1,-1,-1,-1,-1,2,-1,-1,-1,-1}
那么第一组的物品变成:(sz = 5 , value = 2) , (sz = 10 , value = 3)
第二组的物品变成:(sz = 6 , value = 2)
接下来我们对这些物品再做一遍01背包。但是过程中需要保证每个分组至少有一个进程被选中。
这个问题转化为：找到一个长度为n(分组个数)的sz序列，使得这个序列的和<=c，且这个序列的value和最大，且每个元素 >= 1。
对于样例2，这个序列显然找不到。因为第一组的物品的sz序列为5,10，第二组的物品的sz序列为6。min(5,10)+min(6)=11>c。
也就是说从每个分组去抽选最小sz都无法满足条件。
那么这个问题同样可以用01背包解决。我们设f[i]表示总共大小为i的时候的最大value和。
转移方程为f[i] = max(f[i],f[i-j]+dp_of_j)。其中j为第j个分组的大小。过程中需要保证j >= 1 , <=  i ，因为需要保证j因为每个分组至少有一个进程被选中
代码
Python
n , m , c = map(int, input().split())
a = {}
# 读入数据
for _ in range(n):
for _ in range(m):
idx , sz , value = map(int, input().split())
if idx not in a:
a[idx] = []
a[idx].append((sz , value))
# 先对每个分组进行01背包
dp = {}
for idx in a:
dp[idx] = [-1] * (c + 1)
dp[idx][0] = 0
for sz , value in a[idx]:
for i in range(c , sz - 1 , -1):
if dp[idx][i - sz] != -1:
dp[idx][i] = max(dp[idx][i] , dp[idx][i - sz] + value)

# 01背包结束，开始把dp的结果当作物品继续进行01背包
f = [-1] * (c + 1)
# 一开始f[0] 合法，是因为需要让第一个分组能够成功转移
# 大家可以考虑下如果一开始f[0] = -1 , 对于第一个分组的转移会有什么影响?
f[0] = 0
for idx in a:
# 过程中的tmp[0]却是不合法的了(不再像一开始一样f[0] = 0了)，
# 这是因为之前已经有考虑过至少一个分组了
# 因为假设tmp[0] = 0,那么就是假设前面若干组都可以不选哪怕一
# 个进程,这个是违反题意的
tmp = [-1] * (c + 1)
# i 为总共大小
for i in range(c + 1):
# j是当前分组分配的大小
# j从1开始是为了让当前分组至少有选进程
for j in range(1 , i + 1):
if f[i - j] != -1 and dp[idx][j] != -1:
tmp[i] = max(tmp[i] , f[i - j] + dp[idx][j])
f = tmp.copy()
print(max(f))

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读入 n, m, c
int n = sc.nextInt();
int m = sc.nextInt();
int c = sc.nextInt();

// 使用 HashMap 作为哈希表
HashMap<Integer, List<int[]>> a = new HashMap<>();

// 读入数据
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int idx = sc.nextInt();
int sz = sc.nextInt();
int value = sc.nextInt();
a.putIfAbsent(idx, new ArrayList<>());
a.get(idx).add(new int[]{sz, value});
}
}

// 先对每个分组进行01背包
HashMap<Integer, int[]> dp = new HashMap<>();  // 使用HashMap存储每个分组的dp结果

for (Map.Entry<Integer, List<int[]>> entry : a.entrySet()) {
int idx = entry.getKey();
dp.put(idx, new int[c + 1]);
Arrays.fill(dp.get(idx), -1);
dp.get(idx)[0] = 0;  // 初始时，大小为0时价值为0

for (int[] item : entry.getValue()) {
int sz = item[0];
int value = item[1];
// 从后往前遍历，确保01背包的更新
for (int i = c; i >= sz; i--) {
if (dp.get(idx)[i - sz] != -1) {
dp.get(idx)[i] = Math.max(dp.get(idx)[i], dp.get(idx)[i - sz] + value);
}
}
}
}

// 01背包结束，开始把 dp 的结果当作物品继续进行01背包
int[] f = new int[c + 1];
Arrays.fill(f, -1);
f[0] = 0;  // 一开始 f[0] 合法，是因为需要让第一个分组能够成功转移

for (Map.Entry<Integer, List<int[]>> entry : a.entrySet()) {
int idx = entry.getKey();
int[] tmp = new int[c + 1];
Arrays.fill(tmp, -1);

// i 为总共大小
for (int i = 0; i <= c; i++) {
// j 是当前分组分配的大小
for (int j = 1; j <= i; j++) {
if (f[i - j] != -1 && dp.get(idx)[j] != -1) {
tmp[i] = Math.max(tmp[i], f[i - j] + dp.get(idx)[j]);
}
}
}
f = tmp.clone();  // 更新 f 数组
}

// 输出结果
int result = Arrays.stream(f).max().getAsInt();
System.out.println(result);
}
}

C++
#include <iostream>
#include <unordered_map>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
int n, m, c;
cin >> n >> m >> c;

unordered_map<int, vector<pair<int, int>>> a;  // 使用unordered_map实现哈希表

// 读入数据
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
int idx, sz, value;
cin >> idx >> sz >> value;
a[idx].emplace_back(sz, value);  // 把物品信息存入哈希表
}
}

// 先对每个分组进行01背包
unordered_map<int, vector<int>> dp;  // 使用unordered_map存储每个分组的dp结果

for (auto &entry : a) {
int idx = entry.first;
dp[idx] = vector<int>(c + 1, -1);
dp[idx][0] = 0;  // 初始时，大小为0时价值为0

for (auto &item : entry.second) {
int sz = item.first, value = item.second;
// 从后往前遍历，确保01背包的更新
for (int i = c; i >= sz; --i) {
if (dp[idx][i - sz] != -1) {
dp[idx][i] = max(dp[idx][i], dp[idx][i - sz] + value);
}
}
}
}

// 01背包结束，开始把 dp 的结果当作物品继续进行01背包
vector<int> f(c + 1, -1);
f[0] = 0;  // 一开始f[0] 合法，是因为需要让第一个分组能够成功转移

for (auto &entry : a) {
int idx = entry.first;
vector<int> tmp(c + 1, -1);

// i 为总共大小
for (int i = 0; i <= c; ++i) {
// j是当前分组分配的大小
for (int j = 1; j <= i; ++j) {
if (f[i - j] != -1 && dp[idx][j] != -1) {
tmp[i] = max(tmp[i], f[i - j] + dp[idx][j]);
}
}
}
f = tmp;
}

// 输出结果
cout << *max_element(f.begin(), f.end()) << endl;
return 0;
}

---

### 第3题-磁盘的写入策略（P2290）
- 链接：https://codefun2000.com/p/P2290

> 页面标题：#P2290. 第3题-磁盘的写入策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

存储软件负责编程按照某写入策略，每次可向单块磁盘写入4KB4KB4KB数据，每写入nnn次可随机分配一次写入策略，存储软件的写入策略分为333种：
策略一： 轮循写入：比如存在333块硬盘000、111、222，
当n=2n=2n=2，采用该策略写入数据时，写入顺序为000->111；
当n=5n=5n=5，采用该策略写入数据时，写入顺序为000->111->222->000->111。
策略二： 优先写入剩余空间高的磁盘（剩余空间相同时，先写入序号小的硬盘），比如存在333块硬盘000、111、222，空间容量分别为12KB12KB12KB、16KB16KB16KB、24KB24KB24KB，
当n=2n=2n=2，采用该策略写入数据时，写入顺序为222->222，
当n=5n=5n=5，采用该策略写入数据时，写入顺序为222->222->111->222->000。
策略三： 按比例轮循写入：比如存在333块硬盘000、111、222，
当n=3n=3n=3，采用该策略写入数据时，数据写入顺序为000->111->111；
当n=6n=6n=6，采用该策略写入数据时，数据写入顺序为000->111->111->222->222->222。
切换写入策略时，可切换不同的策略也可以和上次策略保持一致，切换策略后不继承上次写入策略的执行结果，如：333块硬盘000、111、222，写入比例为1:1:21:1:21:1:2，待写入的数据量有24KB24KB24KB，
当n=2n=2n=2，一直通过策略111写入数据，写入顺序为（策略111）000->111->（策略111）000->111->（策略111）000->111；
当n=2n=2n=2，一直通过策略333写入数据，写入顺序为（策略333）000->111->（策略333）000->111->（策略333）000->111；
当n=5n=5n=5，一直通过策略111写入数据，写入顺序为（策略111）000->111->222->000->111->（策略111）000；
当n=5n=5n=5，一直通过策略333写入数据，写入顺序为（策略333）000->111->222->222->000->（策略333）000。
现在有一批数据要写入初始状态为空的硬盘，存在几种写入策略分配使最后硬盘空间的占用率（硬盘空间的占用率=硬盘写入的数据量/硬盘的总容量）保持均衡。
注：
1.如果不存在合适的写入策略分配使最后硬盘空间的占用率保持均衡，则返回000；
2.如果存在合适的写入策略，最终的磁盘空间占用率一定是整除的结果，精度>0.000001>0.000001>0.000001。
3.不管是否写入成功，都算一次。例如:
策略是轮循写入，n = 3 , 磁盘是0 , 1 , 2 . 但是1,2都满了。程序还是0,1,2的写，失败了也算数。而不是0.跳过1,2，写0，再跳过1,2，再写0!
输入描述
磁盘的个数[1,200][1,200][1,200]
每个磁盘的容量（单位KBKBKB，空间是444的倍数）[1,10000][1,10000][1,10000]
磁盘的写入比例[1,1000][1,1000][1,1000]
待写入的总数据量（单位KBKBKB，总数据量是444的倍数）[1,1000][1,1000][1,1000]
每nnn次切换一次写入策略[1,1000][1,1000][1,1000]
输出描述
存在几种写入策略分配
样例1
输入
3
64 64 64
1 1 1
12
3

输出
3

说明
总共有3块硬盘，每块硬盘有64KB容量，三块硬盘的
1:1，待写入12KB数据，每3次切换一次写入策略，共
略分配使最后的硬盘空间的占用率保持平衡。
方式1：策略1
方式2：策略2
方式3：策略3
采用3种方式均能保持写入后3块硬盘的空间占用率保
4/64=0.0625
样例2
输入
3
128 64 32
4 2 1
56
7

输出
1

说明

▶️

#### TextSol

video solution

题面解释:
在这道题中，给定若干磁盘，每个磁盘具有一定的容量，数据需要按照三种可能的写入策略（轮循写入、优先剩余空间写入、按比例轮循写入）写入到磁盘中。题目要求根据输入的写入策略切换频率、写入数据量和写入比例，判断有多少种写入策略可以使得所有磁盘的空间占用率保持均衡。如果有多种策略满足条件，则输出这些策略的数量；如果没有满足条件的策略，则返回0。
思路
dfs+模拟，对于目前的这次选择什么策略，考虑dfs去遍历每一种策略，第一种策略也就是按轮循写入(1 2 3 1 2 3....),第二组是每一次都选择目前剩余容量高的，第三种则是按比例，看最后看硬盘空间的占用率是不是保持均衡即可
问题分析
题目要求我们模拟写入数据到多块硬盘的过程，并且需要保证写入后的硬盘占用率尽量保持均衡。为了实现这一点，我们可以通过深度优先搜索（DFS）遍历不同的写入策略组合，找到所有可能使占用率均衡的方案。题目中给出的三种写入策略分别为：

轮循写入：依次将数据写入不同的磁盘，直到数据写完或者空间不足。
优先写入剩余空间大的磁盘：每次写入时选择剩余空间最大的磁盘进行写入。
按比例写入：根据磁盘的容量比例按比例分配写入数据。

我们的目标是通过这些策略的组合来写入指定的数据量，最终使各个磁盘的空间占用率保持均衡。我们通过深度优先搜索的方式，遍历所有可能的写入策略组合，判断每种组合是否可以使占用率保持均衡。
解题思路

深度优先搜索（DFS）：我们使用DFS遍历不同的写入策略组合，每次可以选择三种写入策略中的一种。每当数据写入完成后，判断当前各个磁盘的占用率是否均衡。如果均衡则计数。
写入策略的模拟：对于每种写入策略，我们分别实现了轮循写入、优先写入和按比例写入的模拟。每种策略都按照固定规则写入数据，更新磁盘的剩余空间。
占用率的检查：在每次DFS的终点，我们检查所有磁盘的占用率是否相等。占用率定义为磁盘写入的数据量除以磁盘的总容量。如果所有磁盘的占用率都相等，则认为该写入策略组合是有效的。
分数化简：为了方便比较占用率是否相等，我们将占用率分数化简为最简分数进行比较。

代码如下
Python
import math
m = int(input())
size = list(map(int, input().split()))
rate = list(map(int, input().split()))
tot_wirte_size = int(input())
n = int(input())
ans = 0
# 循环写入
def circle_write (size , n , m):
res_size = size.copy()
i = 0
cnt = 0
while n > 0:
if res_size[i] >= 4:
res_size[i] -= 4
cnt += 1 # 只有实际写入了才算一次
n -= 1
i = (i + 1) % m
return res_size , cnt
# 优先写入
def priority_write (size , n):
res_size = size.copy()
cnt = 0
while n > 0:
# 优先写入最大的硬盘
i = res_size.index(max(res_size))
if res_size[i] >= 4:
res_size[i] -= 4
cnt += 1
n -= 1
return res_size , cnt
# 按比例写入
def rate_write (size , n , m , rate):
res_size = size.copy()
cnt = 0
i = 0
while n > 0:
# 够写rate[i]次,直接写入
if res_size[i] >= 4 * rate[i]:
res_size[i] -= 4 * rate[i]
cnt += rate[i]
else:
# 不够写rate[i]次,那么就写入到最后一次
res_size[i] %= 4
cnt += res_size[i] // 4
n -= rate[i]
i = (i + 1) % m
return res_size , cnt

# 使用math.gcd得到分子/分母的最简形式
def get_simple (a , b):
return [a // math.gcd(a , b) , b // math.gcd(a , b)]

# 检查磁盘占用率是否全部相等
def check (final_size , n , m):
global size
# 计算磁盘占用率
occ_rate = []
for i in range(m):
# 计算分子/分母的最简形式,这样就不会有浮点数误差了
occ_rate.append(get_simple(size[i] - final_size[i] , size[i]))
# 检查是否相等
for i in range(1 , m):
if occ_rate[i] != occ_rate[0]:
return False
return True

way = []
def dfs (size , rest_wirte_time):
global n , rate , m , ans
if rest_wirte_time == 0:
if check(size , n , m):
ans += 1
#print(way , "gg")
return
# 分别计算三种方式的结果

size_cir , cnt = circle_write(size , min(rest_wirte_time , n) , m)
# 如果前后硬盘的状态不相等,代表这个策略是有效的,那么就递归继续执行了
if size != size_cir:
dfs(size_cir , rest_wirte_time - cnt)

size_pri , cnt = priority_write(size , min(rest_wirte_time , n))
if size != size_pri:
dfs(size_pri , rest_wirte_time - cnt)

size_rat , cnt = rate_write(size , min(rest_wirte_time , n) , m , rate)
if size != size_rat:
dfs(size_rat , rest_wirte_time - cnt)

dfs(size , tot_wirte_size // 4)
print(ans)

cpp
#include <bits/stdc++.h>
using namespace std;

// 使用 std::gcd 得到分子/分母的最简形式
pair<int, int> get_simple(int a, int b) {
if (b == 0) {
return {0, 1}; // 定义 0/1 当分母为 0
}
int g = __gcd(a, b);
return {a / g, b / g}; // 分数化简
}

// 检查磁盘占用率是否全部相等
bool check(const vector<int>& final_size, const vector<int>& original_size, int m) {
vector<pair<int, int>> occ_rate(m);
for (int i = 0; i < m; i++) {
int a = original_size[i] - final_size[i]; // 计算每个磁盘的已写入数据量
int b = original_size[i]; // 磁盘的总容量
if (b == 0) { // 处理特殊情况：当容量为0时
if (a != 0) return false; // 如果有数据写入却容量为0，返回不均衡
occ_rate[i] = {0, 1}; // 定义占用率为 0
} else {
occ_rate[i] = get_simple(a, b); // 计算并化简占用率
}
}
// 比较所有磁盘的占用率是否相等
for (int i = 1; i < m; i++) {
if (occ_rate[i] != occ_rate[0]) {
return false; // 只要有不相等的占用率，返回不均衡
}
}
return true; // 所有占用率相等，返回均衡
}

// 循环写入策略
vector<int> circle_write(const vector<int>& size, int n, int m, int& cnt) {
vector<int> res_size = size;
int i = 0;
cnt = 0; // 初始化写入计数
while (n > 0) { // 每次写入 4KB 数据
if (res_size[i] >= 4) { // 如果当前磁盘有足够空间写入 4KB
res_size[i] -= 4;
cnt += 1; // 记录成功写入的次数
}
n -= 1; // 写入次数减少
i = (i + 1) % m; // 轮循到下一个磁盘
}
return res_size;
}

// 优先写入策略
vector<int> priority_write(const vector<int>& size, int n, int& cnt) {
vector<int> res_size = size;
cnt = 0; // 初始化写入计数
while (n > 0) {
// 找到剩余空间最大的磁盘
int max_val = *max_element(res_size.begin(), res_size.end());
auto max_it = find(res_size.begin(), res_size.end(), max_val);
int i = distance(res_size.begin(), max_it);
if (res_size[i] >= 4) { // 如果当前磁盘有足够空间写入 4KB
res_size[i] -= 4;
cnt += 1; // 记录成功写入的次数
}
n -= 1; // 写入次数减少
}
return res_size;
}

// 按比例写入策略
vector<int> rate_write(const vector<int>& size, int n, int m, const vector<int>& rate, int& cnt) {
vector<int> res_size = size;
cnt = 0; // 初始化写入计数
int i = 0;
while (n > 0) {
if (res_size[i] >= 4 * rate[i]) { // 按比例写入
res_size[i] -= 4 * rate[i];
cnt += rate[i];
} else { // 如果不够按比例写入
res_size[i] %= 4;
cnt += res_size[i] / 4;
}
n -= rate[i]; // 更新写入次数
i = (i + 1) % m; // 轮循下一个磁盘
}
return res_size;
}

// 深度优先搜索，遍历所有写入策略组合
void dfs(vector<int>& size, int rest_write_time, int& ans, int n, const vector<int>& rate, int m, const vector<int>& original_size) {
if (rest_write_time == 0) { // 写入结束时
if (check(size, original_size, m)) { // 检查占用率是否均衡
ans += 1; // 如果均衡，方案数加 1
}
return;
}

// 尝试轮循写入策略
int cnt_cir = 0;
int write_times_cir = min(rest_write_time, n); // 最多写入 n 次
vector<int> size_cir = circle_write(size, write_times_cir, m, cnt_cir);
if (size != size_cir) { // 如果写入后状态变化
dfs(size_cir, rest_write_time - cnt_cir, ans, n, rate, m, original_size); // 继续搜索
}

// 尝试优先写入策略
int cnt_pri = 0;
int write_times_pri = min(rest_write_time, n); // 最多写入 n 次
vector<int> size_pri = priority_write(size, write_times_pri, cnt_pri);
if (size != size_pri) { // 如果写入后状态变化
dfs(size_pri, rest_write_time - cnt_pri, ans, n, rate, m, original_size); // 继续搜索
}

// 尝试按比例写入策略
int cnt_rat = 0;
int write_times_rat = min(rest_write_time, n); // 最多写入 n 次
vector<int> size_rat = rate_write(size, write_times_rat, m, rate, cnt_rat);
if (size != size_rat) { // 如果写入后状态变化
dfs(size_rat, rest_write_time - cnt_rat, ans, n, rate, m, original_size); // 继续搜索
}
}

int main(){
ios::sync_with_stdio(false); // 关闭同步，提高IO速度
cin.tie(NULL);

int m;
cin >> m; // 输入磁盘数量
vector<int> size(m);
for(int i = 0; i < m; i++) cin >> size[i]; // 输入每个磁盘的容量

vector<int> rate(m);
for(int i = 0; i < m; i++) cin >> rate[i]; // 输入写入比例

int tot_write_size;
cin >> tot_write_size; // 输入总写入数据量

int n;
cin >> n; // 输入每次切换策略的次数

int ans = 0;
vector<int> original_size = size; // 保存初始状态的磁盘容量
int rest_write_time = tot_write_size / 4; // 计算需要写入的次数

dfs(size, rest_write_time, ans, n, rate, m, original_size); // 开始DFS搜索
cout << ans << "\n"; // 输出满足条件的方案数量

return 0;
}

Java
import java.io.*;
import java.util.*;

public class Main {

// 辅助类，用于保存写入操作的结果
static class Result {
List<Integer> size;
int cnt;
Result(List<Integer> size, int cnt){
this.size = size;
this.cnt = cnt;
}
}

// 辅助类，用于表示简化后的分数
static class SimpleFraction {
int numerator; // 分子
int denominator; // 分母
SimpleFraction(int numerator, int denominator){
this.numerator = numerator;
this.denominator = denominator;
}

@Override
public boolean equals(Object o){
if(this == o) return true;
if(o == null || getClass() != o.getClass()) return false;
SimpleFraction that = (SimpleFraction) o;
return numerator == that.numerator && denominator == that.denominator;
}

@Override
public int hashCode(){
return Objects.hash(numerator, denominator);
}
}

// 获取 a/b 的最简形式
static SimpleFraction get_simple(int a, int b){
if(b == 0){
if(a == 0){
return new SimpleFraction(0, 1);
}
else{
// 未定义的占用率；在 check 函数中处理这种情况
return new SimpleFraction(0, 1);
}
}
int g = gcd(a, b);
return new SimpleFraction(a / g, b / g);
}

// 检查所有磁盘占用率是否相等
static boolean check(List<Integer> final_size, List<Integer> original_size, int m){
List<SimpleFraction> occ_rate = new ArrayList<>();
for(int i = 0; i < m; i++){
int a = original_size.get(i) - final_size.get(i);
int b = original_size.get(i);
if(b == 0){
if(a != 0){
return false;
}
else{
occ_rate.add(new SimpleFraction(0, 1));
}
}
else{
occ_rate.add(get_simple(a, b));
}
}
// 与第一个占用率进行比较
for(int i = 1; i < m; i++){
if(!occ_rate.get(i).equals(occ_rate.get(0))){
return false;
}
}
return true;
}

// 循环写入策略
static Result circle_write(List<Integer> size, int n, int m){
List<Integer> res_size = new ArrayList<>(size);
int i = 0;
int cnt = 0; // 初始化写入计数
while(n > 0){
if(res_size.get(i) >= 4){
res_size.set(i, res_size.get(i) - 4);
cnt += 1;
}
n -= 1;
i = (i + 1) % m;
}
return new Result(res_size, cnt);
}

// 优先写入策略
static Result priority_write(List<Integer> size, int n){
List<Integer> res_size = new ArrayList<>(size);
int cnt = 0; // 初始化写入计数
while(n > 0){
// 找到最大元素的第一个出现位置
int max_val = Collections.max(res_size);
int i = res_size.indexOf(max_val);
if(res_size.get(i) >= 4){
res_size.set(i, res_size.get(i) - 4);
cnt += 1;
}
n -= 1;
}
return new Result(res_size, cnt);
}

// 按比例写入策略
static Result rate_write(List<Integer> size, int n, int m, List<Integer> rate){
List<Integer> res_size = new ArrayList<>(size);
int cnt = 0; // 初始化写入计数
int i = 0;
while(n > 0){
// 够写 rate[i] 次，直接写入
if(res_size.get(i) >= 4 * rate.get(i)){
res_size.set(i, res_size.get(i) - 4 * rate.get(i));
cnt += rate.get(i);
}
else{
// 不够写 rate[i] 次，则写入到最后一次
res_size.set(i, res_size.get(i) % 4);
cnt += res_size.get(i) / 4;
}
n -= rate.get(i);
i = (i + 1) % m;
}
return new Result(res_size, cnt);
}

// 深度优先搜索
static void dfs(List<Integer> size, int rest_write_time, int[] ans, int n, List<Integer> rate, int m, List<Integer> original_size){
if(rest_write_time == 0){
if(check(size, original_size, m)){
ans[0] += 1;
}
return;
}

// 循环写入
int write_times_cir = Math.min(rest_write_time, n);
Result size_cir_pair = circle_write(size, write_times_cir, m);
List<Integer> size_cir = size_cir_pair.size;
int cnt_cir = size_cir_pair.cnt;
if(!size.equals(size_cir)){
dfs(size_cir, rest_write_time - cnt_cir, ans, n, rate, m, original_size);
}

// 优先写入
int write_times_pri = Math.min(rest_write_time, n);
Result size_pri_pair = priority_write(size, write_times_pri);
List<Integer> size_pri = size_pri_pair.size;
int cnt_pri = size_pri_pair.cnt;
if(!size.equals(size_pri)){
dfs(size_pri, rest_write_time - cnt_pri, ans, n, rate, m, original_size);
}

// 按比例写入
int write_times_rat = Math.min(rest_write_time, n);
Result size_rat_pair = rate_write(size, write_times_rat, m, rate);
List<Integer> size_rat = size_rat_pair.size;
int cnt_rat = size_rat_pair.cnt;
if(!size.equals(size_rat)){
dfs(size_rat, rest_write_time - cnt_rat, ans, n, rate, m, original_size);
}
}

// 计算最大公约数
static int gcd(int a, int b){
if(b == 0) return a;
return gcd(b, a % b);
}

public static void main(String[] args){
// 快速输入
Scanner sc = new Scanner(System.in);

int m = sc.nextInt();
List<Integer> size = new ArrayList<>();
for(int i = 0; i < m; i++) size.add(sc.nextInt());
List<Integer> rate = new ArrayList<>();
for(int i = 0; i < m; i++) rate.add(sc.nextInt());
int tot_write_size = sc.nextInt();
int n = sc.nextInt();

int[] ans = new int[1];
ans[0] = 0;
List<Integer> original_size = new ArrayList<>(size);
int rest_write_time = tot_write_size / 4;
dfs(size, rest_write_time, ans, n, rate, m, original_size);
System.out.println(ans[0]);
}
}

小明的提醒:
本题数据范围有误导性！本题在笔试过程中使用dfs回溯法就能过所有数据，所以官方后台数据应该都是在很小的范围内。

---

### 第3题-评估最大工作量（P2293）
- 链接：https://codefun2000.com/p/P2293

> 页面标题：#P2293. 第3题-评估最大工作量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某团队来了一个大项目，该项目已知有nnn个需求，每个需求工作量分别需要t1、t2、t3.......tnt_1、t_2、t_3.......t_nt1​、t2​、t3​.......tn​人天，由于该项目需求过多，负责人小明决定先给出TTT人天预算完成部分需求。对于单个需求，每个任务要么不做，要么全部完成，必须耗时tititi人天完成，现在小明想知道TTT人天的预算最多能做多少人天的需求。
输入描述
输入共两行
首行是222个整数，以空格隔开，分别是nnn和TTT，nnn代表需求总数，TTT代表工作量评估不超过TTT人天
次行有nnn个整数，以空格隔开，分别是t1、t2、t3....tnt_1、t_2、t_3....t_nt1​、t2​、t3​....tn​，代表每个需求所需工作量，单位是人天
数据范围:1≤n≤40;1≤ti≤109;1≤T≤1091≤n≤40;1≤ti≤10^9;1≤T≤10^91≤n≤40;1≤ti≤109;1≤T≤109
输出描述
一个整数AnsAnsAns，代表TTT人天的预算最多能做AnsAnsAns人天的需求
样例1
输入
5 17
2 3 5 11 7

输出
17

说明
该项目有555个需求，工作量评估不超过171717人天，每个需求工作量分别需要222人天、333人天、555人天、111111人天、777人天;
小明选择需求111、需求222、需求333、需求555，所需工作量总和是2+3+5+7=172+3+5+7=172+3+5+7=17
样例2
输入
6 100
1 2 7 5 8 10

输出
33

说明
该项目有666个需求，工作量评估不超过100100100人天，每个需求工作量分别需要111人天、222人天、777人天、666人天、888人天、101010人天;
小明选择全部需求，所需工作量总和是1+2+7+5+8+10=331+2+7+5+8+10=331+2+7+5+8+10=33
样例3
输入
6 100
101 102 103 104 105 106

输出
0

说明
该项目有666个需求，工作量评估不超过100100100人天，每个需求工作量分别需要101101101人天、102102102人天、103103103人天、104104104人天、105105105人天、106106106人天;
小明无论选择哪个需求都超过了100100100人天，所需工作量总和最大是000人天

▶️

#### TextSol

video solution

题面解释:
小塔的团队面临一个大项目，包含nnn个需求，每个需求需要不同的人天工作量。团队的工作量预算为TTT人天，目标是选择一些需求，使得在不超过TTT人天的前提下，所选需求的工作量总和最大。每个需求要么全部完成，要么不做。输入包含两行，第一行是两个整数nnn和TTT，第二行是nnn个整数，表示每个需求的工作量。输出一个整数，表示在预算内可以完成的最大工作量。
题解
该题可以使用状态压缩动态规划（DP）或深度优先搜索（DFS）结合二分查找来解决。由于背包容量可达到 10^9，而物品数量 n 为 40，使用普通的 01 背包算法显然不可行，因为 2^40 的复杂度会爆炸。因此，我们可以将物品分成两个组，每组最多有 20 个物品，这样总的复杂度将减少到 2^20，大约在 100 万级别，仍然可以接受。
具体思路如下：
1.对于每个组，使用状态压缩 DP 或 DFS 计算出所有可能的组合（重量和价值）。\\
2.枚举第一个组的每个组合 x，然后利用二分查找找到第二组中最接近 T - x 的组合 y。\\
3.更新答案为 ans = max(ans, x + y)。\\
整体时间复杂度为 O((2^(n/2)) log(2^(n/2)))，这样就能高效地解决问题。
这样做的好处是大幅降低了复杂度，同时利用二分查找加速了查找过程，使得计算更为高效。

分组与组合生成：

将需求分成两组，分别为a和b。
使用深度优先搜索（DFS）生成每组的所有组合的工作量。

组合搜索：

遍历第一组的每个组合x，然后在第二组中利用二分查找找到不超过T - x的最大组合y。
更新答案为ans = max(ans, x + y)。

效率优化：

通过对第二组的组合数组进行排序，并使用upper_bound进行快速查找，可以显著提高查找效率。

整体时间复杂度为O((2n/2)log⁡(2n/2))O((2^{n/2}) \log(2^{n/2}))O((2n/2)log(2n/2))，使得计算过程更加高效。
解释

数据输入：程序首先读取需求数量和预算，然后分别读取两组需求的工作量。
DFS组合生成：通过递归的方式生成每组需求的所有组合并存储。
组合查找：利用二分查找寻找在预算内的最大组合，最终输出满足条件的最大工作量。

代码如下
cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

int n, t; // n为需求数量，t为工作量预算
int a[25], b[25]; // 分别存储两组需求的工作量
int x1, x2; // x1和x2为两组需求的数量
vector<int> v1, v2; // 用于存储组合的工作量
int cnt1 = 0, cnt2 = 0; // 记录组合数量

// 深度优先搜索（DFS）生成第一组的组合
void dfs1(int x, int sum) {
if (x == x1 + 1) { // 当所有物品都考虑完毕
v1.push_back(sum); // 将当前组合的工作量加入结果集
return;
}
dfs1(x + 1, sum + a[x]); // 选择当前物品
dfs1(x + 1, sum);        // 不选择当前物品
}

// 深度优先搜索（DFS）生成第二组的组合
void dfs2(int x, int sum) {
if (x == x2 + 1) { // 当所有物品都考虑完毕
v2.push_back(sum); // 将当前组合的工作量加入结果集
return;
}
dfs2(x + 1, sum + b[x]); // 选择当前物品
dfs2(x + 1, sum);        // 不选择当前物品
}

signed main() {
cin >> n >> t; // 输入需求数量和预算
x1 = n / 2; // 第一组物品数量
x2 = (n + 1) / 2; // 第二组物品数量

for (int i = 1; i <= x1; i++) {
cin >> a[i]; // 输入第一组的工作量
}
for (int i = 1; i <= x2; i++) {
cin >> b[i]; // 输入第二组的工作量
}

// 生成两组的所有组合
dfs1(1, 0);
dfs2(1, 0);

// 对组合数组进行排序
sort(v1.begin(), v1.end());
sort(v2.begin(), v2.end());

v2.push_back(1e18); // 添加一个极大值以方便查找

int mx = 0; // 记录最大值
for (int i = 0; i < v1.size(); i++) {
if (v1[i] > t) break; // 超过预算限制则停止
int w = t - v1[i]; // 计算剩余的预算
int x = upper_bound(v2.begin(), v2.end(), w) - v2.begin(); // 找到不超过 w 的最大值
x--; // 获取最大值的索引
mx = max(mx, v1[i] + v2[x]); // 更新最大值
}

cout << mx << '\n'; // 输出结果
return 0;
}

python
def dfs1(x, sum):
if x == x1 + 1:
v1.append(sum)
return
dfs1(x + 1, sum + a[x - 1])  # 将 a[x] 改为 a[x - 1]
dfs1(x + 1, sum)

def dfs2(x, sum):
if x == x2 + 1:
v2.append(sum)
return
dfs2(x + 1, sum + b[x - 1])  # 将 b[x] 改为 b[x - 1]
dfs2(x + 1, sum)

n, t = map(int, input().split())
arr = list(map(int, input().split()))
x1 = n // 2
x2 = (n + 1) // 2
a = arr[:x1]  # 保持从 0 开始
b = arr[x1:]  # 保持从 0 开始

v1, v2 = [], []
dfs1(1, 0)
dfs2(1, 0)

v1.sort()
v2.sort()
v2.append(float('inf'))

mx = 0
for i in range(len(v1)):
if v1[i] > t:
break
w = t - v1[i]
x = next((j for j in range(len(v2)) if v2[j] > w), len(v2)) - 1
mx = max(mx, v1[i] + v2[x])

print(mx)

java
import java.util.*;

public class Main {
static int n, t;
static int[] a = new int[25];
static int[] b = new int[25];
static int x1, x2;
static List<Long> v1 = new ArrayList<>();
static List<Long> v2 = new ArrayList<>();

static void dfs1(int x, long sum) {
if (x == x1 + 1) {
v1.add(sum);
return;
}
dfs1(x + 1, sum + a[x]);
dfs1(x + 1, sum);
}

static void dfs2(int x, long sum) {
if (x == x2 + 1) {
v2.add(sum);
return;
}
dfs2(x + 1, sum + b[x]);
dfs2(x + 1, sum);
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
t = sc.nextInt();
x1 = n / 2;
x2 = (n + 1) / 2;

for (int i = 1; i <= x1; i++) {
a[i] = sc.nextInt();
}
for (int i = 1; i <= x2; i++) {
b[i] = sc.nextInt();
}

dfs1(1, 0);
dfs2(1, 0);

Collections.sort(v1);
Collections.sort(v2);
v2.add(Long.MAX_VALUE);

long mx = 0;
for (long value : v1) {
if (value > t) {
break;
}
long w = t - value;
int x = Collections.binarySearch(v2, w);
if (x < 0) {
x = -(x + 1) - 1;
}
mx = Math.max(mx, value + v2.get(x));
}

System.out.println(mx);
}
}

---

### 第3题-病毒的传播（P2287）
- 链接：https://codefun2000.com/p/P2287

> 页面标题：#P2287. 第3题-病毒的传播

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

最近病毒肆虐，科学家为了研究病毒的传播轨迹，需要设计一套简易的传播模型。
在一张M∗NM*NM∗N地图中，包含墙体，空地，已感染的人(不戴口罩)，已感染的人(戴口罩)，未感染的人(不戴口罩)，未感染的人(戴口罩)。科学家会设置一些危险系数，以及感染阈值。然后观察未感染人群大概多少天以后会被感染。
位置含义的编码如下:

危险系数:为感染的人对周围的位置造成的风险(戴口罩和不戴口罩数值不同)，每过一格，危险系数就减111。遇到墙体则不再进行传播。一个位置上如果出现多个传染源传播的危险系数，则危险系数使用多个危险系数的最大值。
感染阈值:为该位置的人被感染的门限(戴口罩和不戴口罩数值不同)，当危险系数大于等于感染阈值，则该位置的人就会被传染。
注意:
111.判断当前位置是否感染只有一个条件，就是当前位置上的危险系数是否大于等于当前位置上的人的感染阈值。是否带口罩会影响危险系数和感染阈值的大小，从而间接的影响该位置的人是否会被感染。
222.未感染的人在感染后会在第二天变成已感染的人，比如未感染的人(戴口罩) 如果在第333天发现自己的感染阈值小于危险系数(也就是会被感染)，那么在第444天该位置就会变成已感染的人(戴口罩).所以在第444天以后需要将该位置以及周围的危险系数刷新，这就有可能会感染其他更多的人。
输入描述
第一行: M,N,a1,a2,b1,b2M, N, a1, a2,b1, b2M,N,a1,a2,b1,b2用空格隔开，参数具体含义如下:

第二行到第M+2M+2M+2行:MMM行NNN列地图数据信息
输出描述
输出MMM行NNN列数据信息，每个位置需要输出的内容如下:

该位置没有人(空地或者墙壁)的话则返回−1-1−1
该位置的人初始态时就被感染了的话，则填000
该位置的人初始没有被感染，但是最终被感染，则填被感染的天数
该位置的人没有被感染，则返回−1-1−1

样例1
输入
3 4 7 10 6 2
0 0 0 0
2 0 1 5
0 0 0 0

输出
-1 -1 -1 -1
0 -1 -1 -1
-1 -1 -1 -1

说明
该用例中，初始地图中，第222行第111列处存在一个已感染并且不戴口罩的人，根据危险系数的配置信息，危险系数(不戴口罩)为101010，所以该位置的危险系数为101010，计算所有位置的危险系数如下:

可以看到因为墙的原因，第222行第444列位置上的危险系数为555，该位置上的人戴了口罩，该位置上的人感染阈值为666，则该人不会被感染。
样例2
输入
3 4 7 10 6 2
0 0 0 0
2 0 1 5
0 0 0 5

输出
-1 -1 -1 -1
0 -1 -1 2
-1 -1 -1 1

说明
该样例中，初始地图中，第222行第111列处存在一个已感染并且不戴口罩的人，根据危险系数的配置信息，危险系数(不戴口罩)为101010，所以该位置的危险系数为101010，计算所有位置的危险系数如下：

第222行第444列位置上的危险系数为555，该位置上的人戴了口罩，该位置上的人感染阈值为666，则该人在第一天不会被感染，
第333行第444列位置上的危险系数为666，该位置上的人戴了口罩，该位置上的人感染阈值为666，则该人在第一天会被感染。感染后该人会变成已感染的人(戴口罩)
第一天以后地图更新如下:
0 0 0 00\ 0\ 0\ 00 0 0 0
2 0 1 52\ 0\ 1\ 52 0 1 5
0 0 0 30\ 0\ 0\ 30 0 0 3
这时再计算第二天的危险系数，根据危险系数的配置信息，危险系数(戴口罩)为777，所以第333行第444列位置的危险系数为777，所有位置需要计算危险系数的最大值，如下图:

第二天，第222行第444列位置上的危险系数从555提升到了666，而该位置上的人感染阈值为666，则该位置的人会在第二天被感染。
最终结果如下:
−1 −1 −1 −1-1\ -1\ -1\ -1−1 −1 −1 −1
0 −1 −1 20\ -1\ -1\  20 −1 −1 2
−1 −1 −1 1-1\ -1\ -1\ 1−1 −1 −1 1

▶️

#### TextSol

video solution

题面解释:
在一个M∗NM*NM∗N的地图中，包含墙体、空地、已感染和未感染的人（分别戴或不戴口罩）。病毒的传播模型需要根据感染者的危险系数（戴口罩与否影响系数大小）来计算传播轨迹，危险系数会随距离衰减，且被墙体阻隔。未感染的人若所处位置的危险系数大于等于其感染阈值，则会在第二天被感染，并影响周围区域。输入包括地图尺寸MMM和NNN，以及戴口罩和不戴口罩的危险系数和感染阈值，接着是地图数据。输出为每个格子的状态：如果是空地或墙体，输出−1-1−1；如果初始已感染，输出000；如果被感染，输出被感染的天数；否则输出−1-1−1。
多轮 多源bfs
我们不难发现，整个过程就是，每天会有若干个新增的感染人数。每次对新增的感染人数，我们更新危险系数矩阵。然后对于更新后的危险系数矩阵，我们再检查新增感染，如此往复。
所以思路是：
1.最开始将第0天就感染的人放入一个队列，我们称作增广队列。
2.对增广队列进行一个bfs过程，每次取出与队头属于同一天被感染的人
3.对这些人，进行一个多源bfs:同时放入感染队列，以bfs的形式更新危险系数矩阵。
4.结束完3之后，对于新的危险系数矩阵，我们再次进行检查新增感染人数，然后再次放入增广队列。
基本思路：

初始状态的处理：

我们首先遍历整个地图，找到所有初始已感染的格子（包括戴口罩和不戴口罩的已感染人群），将这些感染源加入一个队列（增广队列），并初始化它们的危险系数矩阵。
对于墙体、空地等不参与传播的格子，我们直接设置输出为-1，表示这些格子不会被感染。

BFS搜索过程：

在每一天，我们从增广队列中取出所有的感染源，并从这些感染源出发，通过BFS来传播危险系数。每次传播时，考虑四个方向（上、下、左、右），并根据不同的格子状态（墙体、空地、是否戴口罩）来更新周围的危险系数。
对于一个未感染的人，如果他所在位置的危险系数超过了其感染阈值，则该人会在第二天被感染。

多源BFS的实现：

当我们找到一个新的感染源时，立刻将其加入队列，并再次进行BFS，更新整个危险系数矩阵，确保病毒从多个感染源同时向外传播。

停止条件：

当队列为空，即所有可能被感染的人都已传播完毕，或者无法再传播时，停止模拟，输出结果。

输出结果：

对于每个格子，如果它最终没有被感染，输出-1；如果被感染，则输出感染发生的天数；对于初始感染的格子，输出0。

代码如下
cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX = 105;
int r, c, d1, d2, t1, t2;
int grid[MAX][MAX], danger[MAX][MAX], res[MAX][MAX];
int dx[4] = {1, -1, 0, 0};  // 四个方向：上、下、左、右
int dy[4] = {0, 0, 1, -1};  // 对应的Y轴变化

// 定义节点结构体，用于存储坐标
struct Node {
int x, y;
};

// 执行广度优先搜索
vector<Node> bfs(queue<Node> &q) {
vector<Node> newInfected; // 用于存储新增感染的人
while (!q.empty()) {  // 当队列不为空时，执行BFS
Node cur = q.front(); // 取出当前队列的队头
q.pop(); // 从队列中删除当前节点
int x = cur.x, y = cur.y;

// 对四个方向进行BFS
for (int i = 0; i < 4; i++) {
int nx = x + dx[i], ny = y + dy[i];

// 检查边界条件和是否可以传播（不是墙、空地且传播危险系数减1）
if (nx >= 0 && nx < r && ny >= 0 && ny < c && grid[nx][ny] != 1 && danger[nx][ny] < danger[x][y] - 1) {
danger[nx][ny] = danger[x][y] - 1; // 更新新的危险系数

// 判断是否会感染人：未感染人被危险系数超过阈值感染
if ((danger[nx][ny] >= t1 && grid[nx][ny] == 5) ||  // 未感染戴口罩
(danger[nx][ny] >= t2 && grid[nx][ny] == 4)) {  // 未感染不戴口罩
newInfected.push_back({nx, ny});  // 将感染的人加入新增感染列表
}

q.push({nx, ny});  // 将该位置放入队列继续传播
}
}
}
return newInfected; // 返回新增感染列表
}

int main() {
cin >> r >> c >> d1 >> d2 >> t1 >> t2; // 读取输入参数
queue<Node> q;  // 初始化增广队列

// 初始化输入数据
for (int i = 0; i < r; i++) {
for (int j = 0; j < c; j++) {
cin >> grid[i][j];  // 读取地图数据
if (grid[i][j] == 2 || grid[i][j] == 3) {  // 初始已感染的人
danger[i][j] = (grid[i][j] == 3) ? d1 : d2;  // 根据是否戴口罩设置初始危险系数
q.push({i, j});  // 加入队列
res[i][j] = 0;  // 这些人已经感染，设置结果为0
} else {
res[i][j] = -1;  // 对于墙、空地等，设置为-1
}
}
}

int days = 0;  // 记录天数
while (!q.empty()) {
days++;  // 每次BFS过程代表经过一天
vector<Node> newInfected = bfs(q);  // 进行BFS，返回新增感染的人

// 处理新增感染者
for (Node n : newInfected) {
int x = n.x, y = n.y;
res[x][y] = days;  // 设置感染天数

// 根据类型更新危险系数
if ((grid[x][y] == 4 && danger[x][y] < d2) ||  // 更新不戴口罩感染者的危险系数
(grid[x][y] == 5 && danger[x][y] < d1)) {  // 更新戴口罩感染者的危险系数
danger[x][y] = (grid[x][y] == 4) ? d2 : d1;  // 更新该位置危险系数
q.push({x, y});  // 加入队列
}

grid[x][y] -= 2;  // 更新地图，将未感染的状态变为已感染
}
}

// 输出最终结果
for (int i = 0; i < r; i++) {
for (int j = 0; j < c; j++) {
cout << res[i][j] << " ";  // 输出每个格子的结果
}
cout << endl;
}
return 0;
}

Python
M , N , a1 , a2 , b1 , b2 = map(int, input().split())

mp = [list(map(int, input().split())) for i in range(M)]

#危险系数
danger = [[0 for i in range(N)] for j in range(M)]

res = [[-1 for i in range(N)] for j in range(M)]

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]
# 传播危险系数函数
def spread(start_points):
global danger , mp
q = []
for x , y in start_points:
q.append((x, y))
# 不带口罩
if mp[x][y] == 2 or mp[x][y] == 4:
danger[x][y] = a2
elif mp[x][y] == 3 or mp[x][y] == 5:
danger[x][y] = a1
while q:
x, y = q.pop(0)
for i in range(4):
tx = x + dx[i]
ty = y + dy[i]
if tx >= 0 and tx < M and ty >= 0 and ty < N and mp[tx][ty] != 1 and danger[tx][ty] < danger[x][y] - 1:
danger[tx][ty] = danger[x][y] - 1
q.append((tx, ty))

q = []
for i in range(M):
for j in range(N):
if mp[i][j] == 2:
q.append((i, j , 0))
res[i][j] = 0
elif mp[i][j] == 3:
q.append((i, j , 0))
res[i][j] = 0
while q:
x , y , day = q.pop(0)
# 由于一个点一个点的bfs会导致超时，所以我们一次性拿出所有的day相同的点，然后一次性处理：多源bfs
arr = [[x , y]]
while q and q[0][2] == day:
x , y , _  = q.pop(0)
arr.append([x , y])
# 传播危险系数(更新danger矩阵)
spread(arr)
# 检查是否有新人被感染
for i in range(M):
for j in range(N):
# 感染阈值
infect_num = 0
if mp[i][j] == 4:
infect_num = b2
elif mp[i][j] == 5:
infect_num = b1
# 有人并且该位置尚未被计算
if infect_num != 0 and res[i][j] == -1:
if danger[i][j] >= infect_num:
q.append((i , j , day + 1))
res[i][j] = day + 1

# 输出答案
for i in range(M):
for j in range(N):
print(res[i][j], end = " ")
print()

Java
import java.util.*;

public class Main {
static int[][] grid;
static int[][] danger;
static int[][] res;
// static final int MX = 105;
static int m,n, a1, a2, b1, b2;
static final int[][] DIRECTIONS = new int[][]{
{1, 0}, {-1, 0}, {0, 1}, {0, -1}
};

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
// 读入行列
m = in.nextInt();
n = in.nextInt();
grid = new int[m][n];
danger = new int[m][n];
res = new int[m][n];
// 读入危险系数
a1 = in.nextInt();
a2 = in.nextInt();
b1 = in.nextInt();
b2 = in.nextInt();
//in.nextLine();
Deque<int[]> dQueue = new LinkedList<>();
Deque<int[]> hQueue = new LinkedList<>();
// 初始化
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
grid[i][j] = in.nextInt();
// 已感染 进入已感染队列
if (grid[i][j] == 2 || grid[i][j] == 3) {
danger[i][j] = (grid[i][j]==3)? a1:a2;
res[i][j] = 0;
dQueue.addLast(new int[]{i, j});
}else{
res[i][j] = -1;
}
// 没感染 加到健康队列
if (grid[i][j]==4 || grid[i][j]==5){
hQueue.addLast(new int[]{i,j});
}
}
}
// 更新危险系数
update(dQueue);
int pre = 0;             // 上一轮健康队列长度
int now = hQueue.size(); // 当前健康队列长度
int daysCount = 0;
// bfs pre!=now说明有新的感染，如果一直没有新的感染说明所有可能被感染的人已经被感染。循环终止
while (pre!=now) {
daysCount++;
pre = now;
for(int i=0;i<pre;i++){
int[] cur_pos = hQueue.pollFirst();
int x = cur_pos[0];
int y = cur_pos[1];
// 检查本轮是否会由于上一轮的状态被感染
if(grid[x][y] == 4){
if(danger[x][y]>=b2){
res[x][y] = daysCount;
// 感染后更新健康情况
if(danger[x][y]<a2){
danger[x][y] = a2;
dQueue.addLast(new int[]{x,y});
}
}
// 未感染
else {
hQueue.addLast(new int[]{x,y});
}
}else if(grid[x][y]==5){
if(danger[x][y]>=b1){
res[x][y] = daysCount;
if(danger[x][y]<a1){
danger[x][y] = a1;
dQueue.addLast(new int[]{x,y});
}
}else {
hQueue.addLast(new int[]{x,y});
}
}
}
// 每层遍历完 更新一次危险系数
update(dQueue);
now = hQueue.size();
}

// 输出结果
for(int i=0;i<m;i++){
for(int j=0;j<n;j++){
System.out.print(res[i][j]+" ");
}
System.out.println();
}
}

public static void update(Deque<int[]> queue){
while(!queue.isEmpty()){
int size = queue.size();
for(int i=0;i<size;i++){
int[] cur_pos = queue.pollFirst();
int x = cur_pos[0];
int y = cur_pos[1];
for(int[] d: DIRECTIONS){
int dx = x+d[0];
int dy = y+d[1];
// 位置合法
if(dx>=0 && dx<grid.length && dy>=0 && dy<grid[0].length && grid[dx][dy]!=1){
// 更新危险系数
if (danger[x][y]-1>danger[dx][dy]){
danger[dx][dy] = danger[x][y]-1;
queue.addLast(new int[]{dx,dy});
}
}
}

}
}
}
}

---

### 第3题-狩猎大比拼（P2281）
- 链接：https://codefun2000.com/p/P2281

> 页面标题：#P2281. 第3题-狩猎大比拼

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有若干名猎人来到草原狩猎，每名猎人在狩猎开始前需要灵活搭配技能用于击杀猎物，每个技能由十六进制数[0,F0,F0,F]中的某个数来表达，每个猎人都必须选择888种不重复的技能。草原上有各种各样的猎物，并且具备一些弱点，弱点也由十六进制数[0,F0,F0,F]中的某个数字表达。猎人能击杀某种猎物的前提是同时满足:
1.猎人的技能可以覆盖猎物的所有弱点。
2.猎人的技能至少包含[A,FA,FA,F]中的其中一个技能。
3.猎人最后一个技能需要至少命中猎物的任意一个弱点。
每种猎物的数量可以认为是无限的，但是每种猎物只能被同一名猎人击杀一次，请帮忙计算每个猎人可击杀的猎物种类数量，击杀猎物总数最多的猎人将获得赏金猎人的称号
输入描述
111.第一行为猎人和猎物种类的数量，依次用空格隔开，第二行为每名猎人选择的技能，不同猎人的技能之间用空格隔开，第三行为所有的猎物，不同猎物之间的弱点用空格隔开。
222.输入的猎人数量在[1,10001,10001,1000]。
333.输入的猎物数量在[1,2000001,2000001,200000]。
444.每个猎人的技能数量固定为888，并且不包含重复技能。
555.每种猎物的弱点数量范围在[1,601,601,60]，可能包含重复的弱点。
6.十六进制数[0,F0,F0,F]中的字母均为大写。
输出描述
给定一个已完成技能搭配的猎人数组和猎物数组，请返回一个数组，数组中的每个元素是对应猎人最多可击杀的猎物数量。
样例1
输入
3 5
028F415A 2340789E 043BCD12
0222F44A 44C 8848A 002B2 F4415CA

输出
2 0 1

说明
第111名猎人具备的技能为028F415A028F415A028F415A，最后111个技能可以命中第1、3、51、3、51、3、5种猎物，但是不具备命中第555种猎物的CCC弱点，只能击杀第111和第333种猎物，因此可击杀的猎物数量为222。
第222名猎人具备的技能为2340789E2340789E2340789E，没有任何猎物包含EEE这个弱点，因此可击杀的猎物数量为000。
第333名英雄具备的技能为043BCD12043BCD12043BCD12，虽然这些技能可以覆盖第2、42、42、4种猎物，但是最后111个技能无法命中第222种猎物的弱点，只能击杀第444种猎物，因此可击杀的猎物数量为111。
样例2
输入
2 3
7519FCB0 01234567
25351727 A0 19C00

输出
1 0

说明
第111名猎人可以击杀第333种猎物。
第222名猎人虽然技能可以覆盖第111种猎物，并且最后一个技能777可以命中猎物的弱点，但是不包含[A,FA,FA,F]中的任一技能，因此不能击杀猎物，可击杀的猎物数量为000。

▶️

#### TextSol

video solution

前置知识:
二进制枚举操作:https://oi-wiki.org/math/binary-set/
不知道这个知识点，接下来的方法将举步维艰。
题目大意
给定若干猎人和猎物，每名猎人有8种技能，每种猎物有若干弱点。猎人要击杀猎物需满足：技能覆盖所有弱点，技能中包含A~F其中一个，且最后一个技能能命中任意一个弱点。计算每个猎人能击杀的猎物数量。
思路
技能和弱点的二进制掩码表示:
每个猎人的技能和每个猎物的弱点都可以用16位二进制数表示。将技能或弱点中的每个十六进制字符映射为相应的二进制位。例如，0代表第1位，F代表第16位。这样，猎人8个技能的组合和猎物的弱点都可以转换为二进制掩码。\\
条件检查:\\
覆盖弱点：猎人技能必须覆盖猎物的所有弱点。可以通过skills_mask & weakness_mask == weakness_mask来判断。
包含A或F的技能：通过skills_mask & AF_mask来检查猎人的技能中是否包含A或F。
最后一个技能命中弱点：通过last_skill & weakness_mask != 0来判断猎人的最后一个技能是否能命中猎物的任意一个弱点。\\
实现步骤:\\
1.首先，将猎人的技能和猎物的弱点转换为二进制掩码。\\
2.对每个猎人，遍历所有猎物，依次检查猎人是否满足所有条件，并记录每个猎人能够击杀的猎物数量。
3.最终输出每个猎人可击杀的猎物种类数。
\\
复杂度分析:每个猎人的技能固定为8个，不会重复，因此子集枚举的复杂度为 2^8，总时间复杂度0(2^8×n+m*60)
关键条件
为了成功击杀猎物，猎人需要满足以下条件：

技能覆盖：猎人的技能必须覆盖猎物的所有弱点。通过二进制位运算，可以判断猎人的技能掩码是否包含猎物的弱点掩码。
包含特定技能：猎人的技能中至少要有一个技能在[A, F]范围内，确保猎人具备一定的强力技能。
最后技能命中：猎人最后选择的技能必须能够命中猎物的至少一个弱点，确保猎人的攻击有效。

实现步骤

掩码表示：利用二进制掩码来表示技能和弱点。将每个十六进制字符映射到二进制位上，0代表第一位，F代表第16位。
遍历猎物弱点：构建一个数组 preyWeaknessCount 来记录每种弱点组合的猎物数量。每读取一个猎物的弱点，更新对应的掩码。
处理猎人技能：对于每个猎人：

将猎人的技能转换为掩码。
检查猎人的技能是否包含[A, F]的技能。
计算猎人能击杀的猎物数量：

通过遍历所有可能的技能组合（子集）来检查猎人技能是否覆盖猎物的弱点，并且最后技能能否命中。

输出结果：最终输出每个猎人可击杀的猎物数量。

复杂度分析

每位猎人有8种技能，因此其子集的总数为 (2^8 = 256)。
对于每种猎物，其弱点数量范围为1到60，因此总的时间复杂度为 (O(2^8 \times n + m \times 60))，其中n为猎人数量，m为猎物数量。这种复杂度在给定的限制下是可接受的。

代码如下
cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
int hunters, preys;  // 猎人数量和猎物数量
cin >> hunters >> preys;

// 读取每个猎人的技能，存储在一个字符串向量中
vector<string> hunterSkills(hunters);
for (int i = 0; i < hunters; i++) {
cin >> hunterSkills[i];  // 读取每个猎人的8个技能
}

// 用来记录每种弱点组合的猎物数量，最大可能的弱点掩码为65536
vector<int> preyWeaknessCount(65536, 0);

// 处理每个猎物的弱点
while (preys-- > 0) {
string weakness;  // 存储当前猎物的弱点
cin >> weakness;
int weaknessMask = 0;  // 用来记录猎物弱点的掩码
for (char w : weakness) {
// 将每个弱点字符转换成十六进制表示的位掩码
int v = isdigit(w) ? w - '0' : w - 'A' + 10;  // 计算弱点的位
weaknessMask |= (1 << v);  // 设置对应位为1
}
preyWeaknessCount[weaknessMask]++;  // 记录该弱点组合的猎物数量
}

// 用来存储每个猎人能击杀的猎物数量
vector<int> killCount;

// 处理每个猎人的技能
for (const string& skills : hunterSkills) {
bool ok = false;  // 用于检测是否拥有 [A-F] 的技能
int skillMask = 0;  // 用来记录猎人的技能掩码

// 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if (!isdigit(skills.back())) {
ok = true;
}

// 检查猎人的技能，并将技能转换成位掩码
for (int i = 0; i + 1 < skills.length(); i++) {
char skill = skills[i];
if (isdigit(skill)) {
skillMask |= (1 << (skill - '0'));  // 数字技能
} else {
skillMask |= (1 << (skill - 'A' + 10));  // [A-F] 技能
ok = true;  // 拥有 [A-F] 技能
}
}

// 猎人最后一个技能对应的掩码
int lastSkill = isdigit(skills.back()) ? skills.back() - '0' : skills.back() - 'A' + 10;
int lastSkillMask = (1 << lastSkill);  // 计算最后一个技能的位掩码

int preyCanKill = 0;  // 当前猎人可以击杀的猎物数量

// 如果猎人有 [A-F] 的技能，遍历子集枚举
if (ok) {
for (int mask = skillMask; ; mask = (mask - 1) & skillMask) {
// 判断当前猎物是否可以被击杀，检查技能是否覆盖弱点
preyCanKill += preyWeaknessCount[mask | lastSkillMask];
if (mask == 0) break;  // 完成所有子集枚举
}
}

// 记录每个猎人可以击杀的猎物数量
killCount.push_back(preyCanKill);
}

// 输出每个猎人可以击杀的猎物数量
for (int count : killCount) {
cout << count << " ";  // 输出每位猎人可击杀的猎物数量
}
cout << endl;

return 0;
}

java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取n和m
int hunters = sc.nextInt();
int preys = sc.nextInt();
sc.nextLine(); // 读取剩余的换行符

// 读取n个猎人的技能
String[] hunterSkills = sc.nextLine().split(" ");

// 用来记录每种弱点组合的猎物数量
int[] preyWeaknessCount = new int[65536];

// 读取m个猎物的弱点
String[] preyWeaknesses = sc.nextLine().split(" ");

// 处理每个猎物的弱点
for (String weakness : preyWeaknesses) {
int weaknessMask = 0;  // 用来记录弱点的掩码
for (char w : weakness.toCharArray()) {
// 将每个弱点字符转换成十六进制表示的位掩码
int v = Character.isDigit(w) ? w - '0' : w - 'A' + 10;
weaknessMask |= (1 << v);
}
preyWeaknessCount[weaknessMask]++;  // 记录该弱点组合的猎物数量
}

// 用来存储每个猎人能击杀的猎物数量
List<Integer> killCount = new ArrayList<>();

// 处理每个猎人的技能
for (String skills : hunterSkills) {
boolean ok = false;  // 用于检测是否拥有 [A-F] 的技能
int skillMask = 0;  // 用来记录猎人的技能掩码

// 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if (!Character.isDigit(skills.charAt(7))) {
ok = true;
}

// 检查猎人的技能，并将技能转换成位掩码
for (int i = 0; i + 1 < skills.length(); i++) {
char skill = skills.charAt(i);
if (Character.isDigit(skill)) {
skillMask |= (1 << (skill - '0'));  // 数字技能
} else {
skillMask |= (1 << (skill - 'A' + 10));  // [A-F] 技能
ok = true;  // 拥有 [A-F] 技能
}
}

// 猎人最后一个技能对应的掩码
int lastSkill = Character.isDigit(skills.charAt(7)) ? skills.charAt(7) - '0' : skills.charAt(7) - 'A' + 10;
int lastSkillMask = (1 << lastSkill);

int preyCanKill = 0;  // 当前猎人可以击杀的猎物数量

// 如果猎人有 [A-F] 的技能，遍历子集枚举
if (ok) {
for (int mask = skillMask; ; mask = (mask - 1) & skillMask) {
preyCanKill += preyWeaknessCount[mask | lastSkillMask];  // 判断当前猎物是否可以击杀
if (mask == 0) break;  // 完成所有子集枚举
}
}

// 记录每个猎人可以击杀的猎物数量
killCount.add(preyCanKill);
}

// 输出每个猎人可以击杀的猎物数量
for (int count : killCount) {
System.out.print(count + " ");
}
System.out.println();
}
}

python
def main():
# 读取 n 和 m
n, m = map(int, input().split())

# 读取 n 个猎人的技能
hunter_skills = input().split()

# 用来记录每种弱点组合的猎物数量
prey_weakness_count = [0] * 65536

# 读取 m 个猎物的弱点
prey_weaknesses = input().split()

# 处理每个猎物的弱点
for weakness in prey_weaknesses:
weakness_mask = 0  # 用来记录弱点的掩码
for w in weakness:
# 将每个弱点字符转换成十六进制表示的位掩码
v = int(w, 16)
weakness_mask |= (1 << v)
prey_weakness_count[weakness_mask] += 1  # 记录该弱点组合的猎物数量

# 用来存储每个猎人能击杀的猎物数量
kill_count = []

# 处理每个猎人的技能
for skills in hunter_skills:
ok = False  # 用于检测是否拥有 [A-F] 的技能
skill_mask = 0  # 用来记录猎人的技能掩码

# 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if not skills[-1].isdigit():
ok = True

# 检查猎人的技能，并将技能转换成位掩码
for i in range(7):
skill = skills[i]
if skill.isdigit():
skill_mask |= (1 << (ord(skill) - ord('0')))  # 数字技能
else:
skill_mask |= (1 << (ord(skill) - ord('A') + 10))  # [A-F] 技能
ok = True  # 拥有 [A-F] 技能

# 猎人最后一个技能对应的掩码
last_skill = int(skills[-1], 16)
last_skill_mask = (1 << last_skill)

prey_can_kill = 0  # 当前猎人可以击杀的猎物数量

# 如果猎人有 [A-F] 的技能，遍历子集枚举
if ok:
mask = skill_mask
while True:
prey_can_kill += prey_weakness_count[mask | last_skill_mask]  # 判断当前猎物是否可以击杀
if mask == 0:
break
mask = (mask - 1) & skill_mask  # 完成所有子集枚举

# 记录每个猎人可以击杀的猎物数量
kill_count.append(prey_can_kill)

# 输出每个猎人可以击杀的猎物数量
print(" ".join(map(str, kill_count)))

if __name__ == "__main__":
main()

---

### 第3题-磁盘的写入策略（P2284）
- 链接：https://codefun2000.com/p/P2284

> 页面标题：#P2284. 第3题-磁盘的写入策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

存储软件负责编程按照某写入策略，每次可向单块磁盘写入4KB4KB4KB数据，每写入nnn次可随机分配一次写入策略，存储软件的写入策略分为333种：
策略一： 轮循写入：比如存在333块硬盘000、111、222，
当n=2n=2n=2，采用该策略写入数据时，写入顺序为000->111；
当n=5n=5n=5，采用该策略写入数据时，写入顺序为000->111->222->000->111。
策略二： 优先写入剩余空间高的磁盘（剩余空间相同时，先写入序号小的硬盘），比如存在333块硬盘000、111、222，空间容量分别为12KB12KB12KB、16KB16KB16KB、24KB24KB24KB，
当n=2n=2n=2，采用该策略写入数据时，写入顺序为222->222，
当n=5n=5n=5，采用该策略写入数据时，写入顺序为222->222->111->222->000。
策略三： 按比例轮循写入：比如存在333块硬盘000、111、222，写入比例为1:2:31:2:31:2:3
当n=3n=3n=3，采用该策略写入数据时，数据写入顺序为000->111->111；
当n=6n=6n=6，采用该策略写入数据时，数据写入顺序为000->111->111->222->222->222。
切换写入策略时，可切换不同的策略也可以和上次策略保持一致，切换策略后不继承上次写入策略的执行结果，如：333块硬盘000、111、222，写入比例为1:1:21:1:21:1:2，待写入的数据量有24KB24KB24KB，
当n=2n=2n=2，一直通过策略111写入数据，写入顺序为（策略111）000->111->（策略111）000->111->（策略111）000->111；
当n=2n=2n=2，一直通过策略333写入数据，写入顺序为（策略333）000->111->（策略333）000->111->（策略333）000->111；
当n=5n=5n=5，一直通过策略111写入数据，写入顺序为（策略111）000->111->222->000->111->（策略111）000；
当n=5n=5n=5，一直通过策略333写入数据，写入顺序为（策略333）000->111->222->222->000->（策略333）000。
现在有一批数据要写入初始状态为空的硬盘，存在几种写入策略分配使最后硬盘空间的占用率（硬盘空间的占用率=硬盘写入的数据量/硬盘的总容量）保持均衡。
注：
1.如果不存在合适的写入策略分配使最后硬盘空间的占用率保持均衡，则返回000；
2.如果存在合适的写入策略，最终的磁盘空间占用率一定是整除的结果，精度>0.000001>0.000001>0.000001。
输入描述
磁盘的个数[1,200][1,200][1,200]
每个磁盘的容量（单位KBKBKB，空间是444的倍数）[1,10000][1,10000][1,10000]
磁盘的写入比例[1,1000][1,1000][1,1000]
待写入的总数据量（单位KBKBKB，总数据量是444的倍数）[1,1000][1,1000][1,1000]
每nnn次切换一次写入策略[1,1000][1,1000][1,1000]
输出描述
存在几种写入策略分配
样例1
输入
3
64 64 64
1 1 1
12
3

输出
3

说明
总共有333块硬盘，每块硬盘有64KB64KB64KB容量，三块硬盘的写入权重比为1:1:11:1:11:1:1，待写入12KB12KB12KB数据，每333次切换一次写入策略，共存在3种写入策略分配使最后的硬盘空间的占用率保持平衡。
方式1：策略1
方式2：策略2
方式3：策略3
采用3种方式均能保持写入后3块硬盘的空间占用率保持一致，均为4/64=0.06254/64=0.06254/64=0.0625
样例2
输入
3
128 64 32
1 1 1
4
3

输出
0

说明
总共有333块硬盘，每块硬盘分别有128KB、64KB、32KB128KB、64KB、32KB128KB、64KB、32KB容量，三块硬盘的写入比例比为1:1:11:1:11:1:1，待写入4KB4KB4KB数据，每333次切换一次写入策略，不存在写入策略分配使最后硬盘空间的占用率保持均衡，因此返回000。
样例3
输入
3
128 128 128
1 1 1
24
3

输出
9

说明
总共有333块硬盘，每块硬盘有128KB128KB128KB容量，三块硬盘的写入权重比为1:1:11:1:11:1:1，待写入24KB24KB24KB数据，每333次切换一次写入策略，共存在999种写入策略分配使最后的硬盘空间的占用率保持均衡。
方式111:策略111->策略111
方式222:策略111->策略222
方式333:策略111->策略333
方式444:策略222->策略111
方式555:策略222->策略222
方式666:策略222->策略333
方式777:策略333->策略111
方式888:策略333->策略222
方式999: 策略333->策略333
采用999种方式均能保持写入后333块硬盘的空间占用率保持一致，均为8/128=0.06258/128=0.06258/128=0.0625。

▶️

#### TextSol

video solution

题面解释
给定若干块磁盘，每块磁盘有不同的容量，按照某种写入比例，向这些磁盘写入一定量的数据。写入过程可以根据不同的策略，每隔几次切换一次策略。目标是找到使得所有磁盘的空间占用率保持均衡的写入策略组合数量。若不存在这样的组合，则返回0。
输入包括：磁盘数量、每块磁盘的容量、写入比例、待写入的数据量以及每几次切换一次写入策略。输出是存在多少种写入策略组合能够使磁盘的空间占用率保持均衡。
思路
dfs+模拟，对于目前的这次选择什么策略，考虑dfs去遍历每一种策略，第一种策略也就是按轮循写入(1 2 3 1 2 3....),第二组是每一次都选择目前剩余容量高的，第三种则是按比例，看最后看硬盘空间的占用率是不是保持均衡即可
题目理解
给定若干块磁盘，每块磁盘有不同的容量，并按照一定的写入比例，向这些磁盘写入一定量的数据。每隔几次写入后可以切换写入策略，我们需要找到使得所有磁盘的空间占用率保持均衡的写入策略组合数量。题目要求通过三种策略进行写入：

轮循写入策略：按照轮流顺序依次写入各个磁盘（比如，磁盘 0 -> 1 -> 2 -> 0 -> 1）。
优先剩余空间多的磁盘写入策略：每次优先选择剩余空间最多的磁盘进行写入，如果容量相同，则选择序号较小的磁盘。
按比例写入策略：根据给定的比例，将数据按比例写入各个磁盘。

思路

模拟三种写入策略：

轮循写入：按照顺序写入，依次从第一个磁盘写到最后一个磁盘，再循环写回第一个磁盘。
优先剩余空间多的磁盘：每次选择剩余空间最大的磁盘进行写入。
按比例写入：按照给定的比例，向各个磁盘分配写入的数据。

DFS（深度优先搜索）：

使用DFS去模拟每一次的写入选择，每次根据当前的剩余写入次数，遍历三种写入策略。
在搜索结束时，检查所有磁盘的占用率是否均衡。如果均衡，计数加1。

判断磁盘空间占用率是否均衡：

通过计算每个磁盘已写入的数据量与其总容量的比例，并用最简分数形式表示。如果所有磁盘的占用率相同，则认为占用率均衡。

关键函数说明

get_simple(int a, int b)：

计算两个整数的最简分数形式。用于判断磁盘空间占用率是否相等。

check(const vector<int>& final_size, const vector<int>& original_size, int m)：

检查所有磁盘的最终占用率是否相等。如果相等，则返回true。

circle_write、priority_write、rate_write：

这三个函数分别实现了三种写入策略的模拟，每个函数都会根据不同的策略进行写入并返回更新后的磁盘剩余空间。

dfs：

通过DFS遍历每种写入策略，在每次选择不同的策略后递归处理剩余的写入操作，最终判断是否能达到占用率均衡的情况。

代码如下
Python
import math
m = int(input())
size = list(map(int, input().split()))
rate = list(map(int, input().split()))
tot_wirte_size = int(input())
n = int(input())
ans = 0
# 循环写入
def circle_write (size , n , m):
res_size = size.copy()
i = 0
cnt = 0
while n > 0:
if res_size[i] >= 4:
res_size[i] -= 4
cnt += 1 # 只有实际写入了才算一次
n -= 1
i = (i + 1) % m
return res_size , cnt
# 优先写入
def priority_write (size , n):
res_size = size.copy()
cnt = 0
while n > 0:
# 优先写入最大的硬盘
i = res_size.index(max(res_size))
if res_size[i] >= 4:
res_size[i] -= 4
cnt += 1
n -= 1
return res_size , cnt
# 按比例写入
def rate_write (size , n , m , rate):
res_size = size.copy()
cnt = 0
i = 0
while n > 0:
# 够写rate[i]次,直接写入
if res_size[i] >= 4 * rate[i]:
res_size[i] -= 4 * rate[i]
cnt += rate[i]
else:
# 不够写rate[i]次,那么就写入到最后一次
res_size[i] %= 4
cnt += res_size[i] // 4
n -= rate[i]
i = (i + 1) % m
return res_size , cnt

# 使用math.gcd得到分子/分母的最简形式
def get_simple (a , b):
return [a // math.gcd(a , b) , b // math.gcd(a , b)]

# 检查磁盘占用率是否全部相等
def check (final_size , n , m):
global size
# 计算磁盘占用率
occ_rate = []
for i in range(m):
# 计算分子/分母的最简形式,这样就不会有浮点数误差了
occ_rate.append(get_simple(size[i] - final_size[i] , size[i]))
# 检查是否相等
for i in range(1 , m):
if occ_rate[i] != occ_rate[0]:
return False
return True

way = []
def dfs (size , rest_wirte_time):
global n , rate , m , ans
if rest_wirte_time == 0:
if check(size , n , m):
ans += 1
#print(way , "gg")
return
# 分别计算三种方式的结果

size_cir , cnt = circle_write(size , min(rest_wirte_time , n) , m)
# 如果前后硬盘的状态不相等,代表这个策略是有效的,那么就递归继续执行了
if size != size_cir:
dfs(size_cir , rest_wirte_time - cnt)

size_pri , cnt = priority_write(size , min(rest_wirte_time , n))
if size != size_pri:
dfs(size_pri , rest_wirte_time - cnt)

size_rat , cnt = rate_write(size , min(rest_wirte_time , n) , m , rate)
if size != size_rat:
dfs(size_rat , rest_wirte_time - cnt)

dfs(size , tot_wirte_size // 4)
print(ans)

cpp
#include <bits/stdc++.h>
using namespace std;

// 使用 std::gcd 得到分子/分母的最简形式
pair<int, int> get_simple(int a, int b) {
if (b == 0) {
return {0, 1}; // 定义 0/1 当分母为 0
}
int g = __gcd(a, b);
return {a / g, b / g};
}

// 检查磁盘占用率是否全部相等
bool check(const vector<int>& final_size, const vector<int>& original_size, int m) {
vector<pair<int, int>> occ_rate(m);
for (int i = 0; i < m; i++) {
int a = original_size[i] - final_size[i];
int b = original_size[i];
if (b == 0) {
if (a != 0)
return false;
else {
occ_rate[i] = {0, 1};
}
}
else {
occ_rate[i] = get_simple(a, b);
}
}
for (int i = 1; i < m; i++) {
if (occ_rate[i] != occ_rate[0]) {
return false;
}
}
return true;
}

// 循环写入
vector<int> circle_write(const vector<int>& size, int n, int m, int& cnt) {
vector<int> res_size = size;
int i = 0;
cnt = 0; // 初始化写入计数
while (n > 0) {
if (res_size[i] >= 4) {
res_size[i] -= 4;
cnt += 1;
}
n -= 1;
i = (i + 1) % m;
}
return res_size;
}

// 优先写入
vector<int> priority_write(const vector<int>& size, int n, int& cnt) {
vector<int> res_size = size;
cnt = 0; // 初始化写入计数
while (n > 0) {
// 找到第一个最大元素的索引（从左到右）
int max_val = *max_element(res_size.begin(), res_size.end());
auto max_it = find(res_size.begin(), res_size.end(), max_val);
int i = distance(res_size.begin(), max_it);
if (res_size[i] >= 4) {
res_size[i] -= 4;
cnt += 1;
}
n -= 1;
}
return res_size;
}

// 按比例写入
vector<int> rate_write(const vector<int>& size, int n, int m, const vector<int>& rate, int& cnt) {
vector<int> res_size = size;
cnt = 0; // 初始化写入计数
int i = 0;
while (n > 0) {
// 够写 rate[i] 次, 直接写入
if (res_size[i] >= 4 * rate[i]) {
res_size[i] -= 4 * rate[i];
cnt += rate[i];
}
else {
// 不够写 rate[i] 次, 那么就写入到最后一次
res_size[i] %= 4;
cnt += res_size[i] / 4;
}
n -= rate[i];
i = (i + 1) % m;
}
return res_size;
}

// 深度优先搜索
void dfs(vector<int>& size, int rest_write_time, int& ans, int n, const vector<int>& rate, int m, const vector<int>& original_size) {
if (rest_write_time == 0) {
if (check(size, original_size, m)) {
ans += 1;
}
return;
}

// 循环写入
int cnt_cir = 0;
int write_times_cir = min(rest_write_time, n);
vector<int> size_cir = circle_write(size, write_times_cir, m, cnt_cir);
if (size != size_cir) {
dfs(size_cir, rest_write_time - cnt_cir, ans, n, rate, m, original_size);
}

// 优先写入
int cnt_pri = 0;
int write_times_pri = min(rest_write_time, n);
vector<int> size_pri = priority_write(size, write_times_pri, cnt_pri);
if (size != size_pri) {
dfs(size_pri, rest_write_time - cnt_pri, ans, n, rate, m, original_size);
}

// 按比例写入
int cnt_rat = 0;
int write_times_rat = min(rest_write_time, n);
vector<int> size_rat = rate_write(size, write_times_rat, m, rate, cnt_rat);
if (size != size_rat) {
dfs(size_rat, rest_write_time - cnt_rat, ans, n, rate, m, original_size);
}
}

int main(){
ios::sync_with_stdio(false);
cin.tie(NULL);

int m;
cin >> m;
vector<int> size(m);
for(int i=0; i<m; i++) cin >> size[i];

vector<int> rate(m);
for(int i=0; i<m; i++) cin >> rate[i];

int tot_write_size;
cin >> tot_write_size;

int n;
cin >> n;

int ans = 0;
vector<int> original_size = size; // 保存原始大小
int rest_write_time = tot_write_size / 4;

dfs(size, rest_write_time, ans, n, rate, m, original_size);
cout << ans << "\n";

return 0;
}

Java
import java.io.*;
import java.util.*;

public class Main {

// 辅助类，用于保存写入操作的结果
static class Result {
List<Integer> size;
int cnt;
Result(List<Integer> size, int cnt){
this.size = size;
this.cnt = cnt;
}
}

// 辅助类，用于表示简化后的分数
static class SimpleFraction {
int numerator; // 分子
int denominator; // 分母
SimpleFraction(int numerator, int denominator){
this.numerator = numerator;
this.denominator = denominator;
}

@Override
public boolean equals(Object o){
if(this == o) return true;
if(o == null || getClass() != o.getClass()) return false;
SimpleFraction that = (SimpleFraction) o;
return numerator == that.numerator && denominator == that.denominator;
}

@Override
public int hashCode(){
return Objects.hash(numerator, denominator);
}
}

// 获取 a/b 的最简形式
static SimpleFraction get_simple(int a, int b){
if(b == 0){
if(a == 0){
return new SimpleFraction(0, 1);
}
else{
// 未定义的占用率；在 check 函数中处理这种情况
return new SimpleFraction(0, 1);
}
}
int g = gcd(a, b);
return new SimpleFraction(a / g, b / g);
}

// 检查所有磁盘占用率是否相等
static boolean check(List<Integer> final_size, List<Integer> original_size, int m){
List<SimpleFraction> occ_rate = new ArrayList<>();
for(int i = 0; i < m; i++){
int a = original_size.get(i) - final_size.get(i);
int b = original_size.get(i);
if(b == 0){
if(a != 0){
return false;
}
else{
occ_rate.add(new SimpleFraction(0, 1));
}
}
else{
occ_rate.add(get_simple(a, b));
}
}
// 与第一个占用率进行比较
for(int i = 1; i < m; i++){
if(!occ_rate.get(i).equals(occ_rate.get(0))){
return false;
}
}
return true;
}

// 循环写入策略
static Result circle_write(List<Integer> size, int n, int m){
List<Integer> res_size = new ArrayList<>(size);
int i = 0;
int cnt = 0; // 初始化写入计数
while(n > 0){
if(res_size.get(i) >= 4){
res_size.set(i, res_size.get(i) - 4);
cnt += 1;
}
n -= 1;
i = (i + 1) % m;
}
return new Result(res_size, cnt);
}

// 优先写入策略
static Result priority_write(List<Integer> size, int n){
List<Integer> res_size = new ArrayList<>(size);
int cnt = 0; // 初始化写入计数
while(n > 0){
// 找到最大元素的第一个出现位置
int max_val = Collections.max(res_size);
int i = res_size.indexOf(max_val);
if(res_size.get(i) >= 4){
res_size.set(i, res_size.get(i) - 4);
cnt += 1;
}
n -= 1;
}
return new Result(res_size, cnt);
}

// 按比例写入策略
static Result rate_write(List<Integer> size, int n, int m, List<Integer> rate){
List<Integer> res_size = new ArrayList<>(size);
int cnt = 0; // 初始化写入计数
int i = 0;
while(n > 0){
// 够写 rate[i] 次，直接写入
if(res_size.get(i) >= 4 * rate.get(i)){
res_size.set(i, res_size.get(i) - 4 * rate.get(i));
cnt += rate.get(i);
}
else{
// 不够写 rate[i] 次，则写入到最后一次
res_size.set(i, res_size.get(i) % 4);
cnt += res_size.get(i) / 4;
}
n -= rate.get(i);
i = (i + 1) % m;
}
return new Result(res_size, cnt);
}

// 深度优先搜索
static void dfs(List<Integer> size, int rest_write_time, int[] ans, int n, List<Integer> rate, int m, List<Integer> original_size){
if(rest_write_time == 0){
if(check(size, original_size, m)){
ans[0] += 1;
}
return;
}

// 循环写入
int write_times_cir = Math.min(rest_write_time, n);
Result size_cir_pair = circle_write(size, write_times_cir, m);
List<Integer> size_cir = size_cir_pair.size;
int cnt_cir = size_cir_pair.cnt;
if(!size.equals(size_cir)){
dfs(size_cir, rest_write_time - cnt_cir, ans, n, rate, m, original_size);
}

// 优先写入
int write_times_pri = Math.min(rest_write_time, n);
Result size_pri_pair = priority_write(size, write_times_pri);
List<Integer> size_pri = size_pri_pair.size;
int cnt_pri = size_pri_pair.cnt;
if(!size.equals(size_pri)){
dfs(size_pri, rest_write_time - cnt_pri, ans, n, rate, m, original_size);
}

// 按比例写入
int write_times_rat = Math.min(rest_write_time, n);
Result size_rat_pair = rate_write(size, write_times_rat, m, rate);
List<Integer> size_rat = size_rat_pair.size;
int cnt_rat = size_rat_pair.cnt;
if(!size.equals(size_rat)){
dfs(size_rat, rest_write_time - cnt_rat, ans, n, rate, m, original_size);
}
}

// 计算最大公约数
static int gcd(int a, int b){
if(b == 0) return a;
return gcd(b, a % b);
}

public static void main(String[] args){
// 快速输入
Scanner sc = new Scanner(System.in);

int m = sc.nextInt();
List<Integer> size = new ArrayList<>();
for(int i = 0; i < m; i++) size.add(sc.nextInt());
List<Integer> rate = new ArrayList<>();
for(int i = 0; i < m; i++) rate.add(sc.nextInt());
int tot_write_size = sc.nextInt();
int n = sc.nextInt();

int[] ans = new int[1];
ans[0] = 0;
List<Integer> original_size = new ArrayList<>(size);
int rest_write_time = tot_write_size / 4;
dfs(size, rest_write_time, ans, n, rate, m, original_size);
System.out.println(ans[0]);
}
}

---

### 第3题-寻找重复目录（P2278）
- 链接：https://codefun2000.com/p/P2278

> 页面标题：#P2278. 第3题-寻找重复目录

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某文件系统中存在一些重复的文件夹，需要找出来并删除。
重复文件夹的定义：如果存在两个（或以上）的文件夹，包含非空且相同的子文件夹，且子文件夹的结构也相同，则认为这些文件夹是重复文件夹。重复文件夹可以属于不同的文件层级。
例如，存在如下文件夹结构：
/a/x/y//a/x/y//a/x/y/
/a/z//a/z//a/z/
/b/x/y//b/x/y//b/x/y/
/b/z//b/z//b/z/
则文件夹 /a//a//a/ 和 /b//b//b/ 为重复文件夹。
如果再新增一个 /b/w//b/w//b/w/ 文件夹，则 /a//a//a/ 和 /b//b//b/ 不再是重复文件夹，但 /a/x//a/x//a/x/ 和 /b/x//b/x//b/x/ 仍为重复文件夹，/a/z//a/z//a/z/ 和 /b/z//b/z//b/z/ 不算作重复文件夹，因为 zzz 目录下是空的。
给你一组数组 pathspathspaths ，表示系统中所有存在的文件夹结构，请找出所有的重复文件夹。
如果重复文件夹之间存在父子关系，只返回父文件夹即可（即如果 /a//a//a/ 和 /a/x//a/x//a/x/ 均为重复文件夹，只返回 /a//a//a/ 即可），并按字典序返回。
如果不存在重复目录，返回字符串 NotFoundNotFoundNotFound。
输入描述
输入由多行组成，第一行表示 pathspathspaths 中的元素个数 nnn，第222~n+1n+1n+1行为 nnn 个路径名。
每个路径以 "/" 开头和结尾，中间每个层级以 "/" 分隔。
1≤paths.length≤2×1041≤paths.length≤2×10^41≤paths.length≤2×104
pathspathspaths 中每个路径的层数 ≤500≤500≤500
1≤1≤1≤ 每层文件夹名称的长度 ≤10≤10≤10
paths[i]paths[i]paths[i]由小写英文字母和 / 组成，
pathspathspaths 中的路径不存在重复。
输出描述
返回所有重复文件夹的路径名，每行一个，路径的格式与输入格式一致，各个路径的顺序按字母升序排列。
样例1
输入
4
/a/x/y/
/a/z/
/b/x/y/
/b/z/

输出
/a/
/b/

样例2
输入
5
/a/x/y/
/a/z/
/b/x/y/
/b/z/
/b/w/

输出
/a/x/
/b/x/

样例3
输入
4
/a/x/y/
/a/z/
/b/z/
/b/w/

输出
NotFound

样例4 (小明补充的，实际没有)
输入
11
/a/
/a/b/
/a/d/
/a/b/a/
/a/b/c/
/a/c/a/
/a/c/c/
/a/d/f/
/a/d/d/
/a/e/f/
/a/e/d/

输出
/a/b/
/a/c/
/a/d/
/a/e/

▶️

#### TextSol

video solution

题面解释:
在某文件系统中，存在一些重复的文件夹，重复文件夹的定义为：如果两个或多个文件夹包含相同的非空子文件夹，并且这些子文件夹的结构也相同，则这些文件夹被认为是重复的。输入由多行组成，第一行是文件夹路径的数量 nnn，接下来的 nnn 行是各个文件夹的路径。路径以 "/" 开头和结尾，中间每层由 "/" 分隔。输出所有重复文件夹的父路径，按字典升序排列；如果不存在重复的文件夹，则输出“NotFound”。
思路:序列化唯一表示树
问题本质为：构建出文件目录树后，询问有多少个子树，忽略根节点以后，他们的子树完全相等。
一个朴素的思路是枚举所有子树，然后进行递归check。
但是这个方法的时间复杂度过高O(n3)O(n^3)O(n3)，需要优化，考虑对每个子树进行一个序列化表示 + 哈希。然后再枚举子树 + 哈希值判定。
伪代码如下
# 定义函数 is_the_same，用于判断两个子树 node1 和 node2 是否相同
def is_the_same(node1, node2):
# 对 node1 和 node2 的子节点分别进行排序，确保子节点的顺序一致
sorted_son_node1 = sorted(node1.son)  # 将 node1 的子节点按名称排序
sorted_son_node2 = sorted(node2.son)  # 将 node2 的子节点按名称排序

# 如果两个节点的子节点数量不同，直接返回 False，说明不是相同子树
if len(sorted_son_node1) != len(sorted_son_node2):
return False

# 逐个比较每一对排序后的子节点
for i in range(len(sorted_son_node1)):
# 如果当前子节点的名称不同，返回 False，说明子树不同
if sorted_son_node1[i].name != sorted_son_node2[i].name:
return False

# 递归比较当前子节点的子树是否相同，如果有任意一个子树不相同，返回 False
if is_the_same(sorted_son_node1[i], sorted_son_node2[i]) == False:
return False

# 如果所有子节点都相同且对应子树也相同，返回 True，表示两棵树相同
return True

# 双重循环枚举树中所有节点的组合
for i in node:
for j in node:
# 调用 is_the_same 函数比较节点 i 和 j 的子树是否相同
if not is_the_same(i, j):
record(i)
record(j)

return record.set()

题解
本题的核心在于构建一个文件目录树，并找出其中重复的子树。重复子树的定义为：如果某个子树结构完全相同，并且含有相同的子文件夹（忽略根节点），则这些子树被认为是重复的。为了有效检测这些重复的子树，我们采用以下步骤：

树节点定义：使用 TreeNode 结构体来表示每个文件夹，存储子文件夹的信息，包括路径和是否为重复子树的标志。

序列化树结构：通过递归遍历树的方式，将每个子树序列化为一个唯一的字符串表示。这一过程中，我们将子节点的序列化结果排序并组合，以确保相同结构的子树能生成相同的字符串。

重复检测：使用哈希表存储已序列化的子树。如果再次遇到相同的序列化结果，则标记这些树节点为重复的。

结果收集：遍历整棵树，找到所有标记为重复的子树，并将其父节点路径收集到结果中。

输出结果：对结果进行排序，并输出每个重复子树的父路径。如果没有重复子树，则输出“NotFound”。

具体步骤:
1.构建文件目录树：通过读取输入的路径信息，将其分层解析并逐级添加到树节点中，每个路径的层级信息通过 / 分割，并逐级构建树节点。
2.子树的序列化表示：对于每个节点，通过递归的方式序列化其所有子节点，将该节点的结构和内容唯一表示成一个字符串。子节点的序列化结果会拼接并排序，保证相同结构的子树在不同位置也能得到相同的序列化字符串。
3.利用哈希表检测重复子树：每棵子树的序列化字符串作为哈希表的键值，若相同的序列化字符串已经出现，则将该子树标记为重复，并记录其父节点路径。
4.输出所有重复子树的父节点路径：遍历整棵树，查找被标记为重复的子树，记录其父节点路径，若没有重复子树则输出 "NotFound"，否则按字典序输出所有父节点路径。
代码
cpp
#include <iostream>   // 用于输入输出
#include <unordered_map>  // 哈希表
#include <vector>     // 动态数组
#include <string>     // 字符串操作
#include <algorithm>  // sort排序函数

using namespace std;

// 树节点结构体
struct TreeNode {
unordered_map<string, TreeNode*> children; // 存储子节点
string path;   // 当前节点路径
bool isDuplicate;  // 标记是否为重复子树

// 构造函数初始化
TreeNode() : isDuplicate(false) {}
};

// 存储序列化子树的哈希表，用于检测重复
unordered_map<string, TreeNode*> duplicates;

// 序列化树结构，将其转为唯一字符串表示
string serialize(TreeNode* root) {
if (root->children.empty()) return "#";  // 如果没有子节点，返回 "#"

vector<string> paths; // 存储所有子节点的序列化结果

// 遍历所有子节点并进行序列化
for (const auto& child : root->children) {
paths.push_back(child.first + "(" + serialize(child.second) + ")");
}

sort(paths.begin(), paths.end());  // 排序确保结构唯一性

string serialized; // 存储最终的序列化字符串
for (const auto& p : paths) {
serialized += p;  // 组合所有子节点的序列化字符串
}

// 检测是否已有相同结构的子树
if (duplicates.count(serialized)) {
duplicates[serialized]->isDuplicate = true;  // 标记为重复
root->isDuplicate = true;  // 当前节点也标记为重复
} else {
duplicates[serialized] = root;  // 存储序列化结果
}
return serialized; // 返回序列化字符串
}

// 查找所有重复子树的父节点路径
void findParentDuplicates(TreeNode* root, vector<string>& result) {
if (root->isDuplicate) {  // 如果当前节点是重复子树，加入结果
result.push_back(root->path); // 添加父节点路径到结果
return;
}
// 递归检查所有子节点
for (const auto& child : root->children) {
findParentDuplicates(child.second, result);
}
}

int main() {
int n;
cin >> n;  // 输入路径数量

TreeNode* root = new TreeNode();  // 初始化根节点

// 构建树结构
for (int i = 0; i < n; ++i) {
string path;
cin >> path;  // 输入每条路径
TreeNode* curr = root; // 当前节点指向根节点
size_t pos = 1; // 路径的开始位置，跳过第一个 '/'

// 根据路径层级逐级创建树节点
while (pos < path.size()) {
size_t nextPos = path.find('/', pos); // 找到下一个 '/'
string dir = path.substr(pos, nextPos - pos); // 提取当前文件夹名称
if (!curr->children.count(dir)) {  // 如果节点不存在，则创建
curr->children[dir] = new TreeNode();
curr->children[dir]->path = path.substr(0,
nextPos == string::npos ? path.size() : nextPos);
}
curr = curr->children[dir];  // 进入下一层节点
pos = nextPos == string::npos ? path.size() : nextPos + 1; // 更新位置
}
}

serialize(root);  // 序列化整棵树
vector<string> result; // 存储重复子树的父节点路径
findParentDuplicates(root, result);  // 查找重复子树的父节点

sort(result.begin(), result.end());  // 结果排序
if (result.empty()) {
cout << "NotFound" << endl;  // 无重复子树
} else {
for (const auto& r : result) {
cout << r << "/" << endl;  // 输出重复子树的父节点路径
}
}

return 0; // 程序结束
}

python
# 导入 defaultdict 来构建树形结构
from collections import defaultdict

# 读取输入路径的数量
n = int(input())

# 定义一个 Node 类表示文件夹节点
class Node:
def __init__(self):
self.name = ""  # 当前文件夹的名称
# to 表示从当前节点到其子节点的字典，键是文件夹名，值是 Node 对象，子文件夹存储于此
self.to = defaultdict(Node)
# is_duplicate 标志当前节点是否是重复文件夹
self.is_duplicate = False

# 初始化根节点，根目录用 "root" 作为名称
root = Node()
root.name = "root"

# 创建一个字典 book，用于存储子树结构的序列化字符串
book = defaultdict(str)

# 构建文件夹结构树
for _ in range(n):
# 读取路径并分割，去掉前后的空元素 '/'，只保留中间的部分
paths = input().split("/")
paths = paths[1:-1]  # 删除第一个空元素和最后一个空元素
now = root  # 从根节点开始插入文件夹路径
for path in paths:
# 如果当前子文件夹不存在，创建新的节点
if path not in now.to:
now.to[path] = Node()  # 新节点
now.to[path].name = path  # 设置新节点的名字
# 继续深入到子文件夹
now = now.to[path]

# 序列化文件夹树结构函数，用于比较文件夹结构是否相同
def serialize(root):
ser_arr = []  # 存储当前节点下所有子树的序列化字符串
# 遍历当前节点的子节点
for v in root.to:
# 递归获取子节点的序列化字符串
ser_arr.append(serialize(root.to[v]))
ser_arr.sort()  # 将子树按字典序排序，保证同一结构的文件夹顺序一致
ser_str = ""  # 初始化序列化字符串
# 拼接所有子文件夹的序列化结果
for s in ser_arr:
ser_str += s

# 如果当前节点有子文件夹
if ser_str != "":
# 检查当前序列化结果是否已经存在
if ser_str in book:
# 如果存在相同的子树结构，标记该节点及其之前记录的节点为重复
book[ser_str].is_duplicate = True
root.is_duplicate = True
else:
# 如果不存在相同的子树结构，记录当前序列化结果
book[ser_str] = root
# 返回当前节点的序列化形式 "文件夹名称(子文件夹序列化)"
return root.name + "(" + ser_str + ")"

# 保存重复文件夹路径的结果列表
res = []

# 查找并标记重复文件夹的函数
def find_duplicate(root, path):
global res
# 如果不是根目录，将当前路径加入 path
if root.name != "root":
path += root.name + "/"
# 如果当前节点是重复文件夹，保存路径并返回
if root.is_duplicate:
res.append(path)
return
# 递归检查当前节点的子文件夹
for v in root.to:
find_duplicate(root.to[v], path)

# 序列化整个文件夹树，从根开始
serialize(root)
# 从根节点开始查找所有重复的文件夹，并记录其路径
find_duplicate(root, "/")

# 按字典序排序结果
res.sort()

# 如果找到重复文件夹，按行输出结果，否则输出 "NotFound"
if len(res) != 0:
print("\n".join(res))
else:
print("NotFound")

java
import java.util.*;

// 用于表示树的节点
class TreeNode {
Map<String, TreeNode> children; // 存储子节点
String path; // 当前节点路径
boolean isDuplicate; // 标记是否为重复子树

TreeNode() {
children = new HashMap<>();
isDuplicate = false;
}
}
public class Main{

// 存储序列化子树，检测重复
static Map<String, TreeNode> duplicates = new HashMap<>();

// 序列化树结构，将其转为唯一字符串表示
public static String serialize(TreeNode root) {
if (root.children.isEmpty()) return "#"; // 如果没有子节点，返回 "#"

List<String> paths = new ArrayList<>();
// 遍历所有子节点
for (Map.Entry<String, TreeNode> child : root.children.entrySet()) {
paths.add(child.getKey() + "(" + serialize(child.getValue()) + ")");
}
Collections.sort(paths); // 排序确保结构唯一性

StringBuilder serialized = new StringBuilder();
for (String p : paths) {
serialized.append(p); // 组合所有子节点的序列化字符串
}

// 检测是否已有相同结构的子树
if (duplicates.containsKey(serialized.toString())) {
duplicates.get(serialized.toString()).isDuplicate = true; // 标记为重复
root.isDuplicate = true;
} else {
duplicates.put(serialized.toString(), root); // 存储序列化结果
}
return serialized.toString();
}

// 查找所有重复子树的父节点路径
public static void findParentDuplicates(TreeNode root, List<String> result) {
if (root.isDuplicate) { // 如果是重复子树，加入结果
result.add(root.path);
return;
}
// 递归检查所有子节点
for (TreeNode child : root.children.values()) {
findParentDuplicates(child, result);
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt(); // 输入路径数量

TreeNode root = new TreeNode(); // 初始化根节点

// 构建树结构
for (int i = 0; i < n; ++i) {
String path = scanner.next(); // 输入每条路径
TreeNode curr = root;
int pos = 1;

// 根据路径层级逐级创建树节点
while (pos < path.length()) {
int nextPos = path.indexOf('/', pos);
String dir = path.substring(pos, nextPos == -1 ? path.length() : nextPos);
if (!curr.children.containsKey(dir)) { // 如果节点不存在，则创建
curr.children.put(dir, new TreeNode());
curr.children.get(dir).path = path.substring(0, nextPos == -1 ? path.length() : nextPos);
}
curr = curr.children.get(dir); // 进入下一层节点
pos = nextPos == -1 ? path.length() : nextPos + 1;
}
}

String serializedTree = serialize(root); // 序列化整棵树
List<String> result = new ArrayList<>();
findParentDuplicates(root, result); // 查找重复子树的父节点

Collections.sort(result); // 结果排序

if (result.isEmpty()) {
System.out.println("NotFound"); // 无重复子树
} else {
for (String r : result) {
System.out.println(r + "/"); // 输出重复子树的父节点路径
}
}
scanner.close();
}

}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第3题-最小换序代价（P2272）
- 链接：https://codefun2000.com/p/P2272

> 页面标题：#P2272. 第3题-最小换序代价

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定 222 个长度为均为 nnn 的整数数组 nums1nums1nums1 和 nums2nums2nums2 ，每次操作可以交换数组 nums2nums2nums2 中任意 222 个元素，其代价为两个下标的和。
目标是对于所有的下标 iii 。0<=i<n0<=i<n0<=i<n ，nnn 为数组的长度，都满足nums1[i]≠nums2[i]nums1[i] \neq nums2[i]nums1[i]=nums2[i]。
返回满足目标的最小代价和，如果达不成目标，返回 −1-1−1 。
输入描述
输入格式:
第一行输入整数数组的长度 nnn
第二行输入长度为 nnn 的整数数组 nums1nums1nums1
第二行输入长度为 nnn 的整数数组 nums2nums2nums2
1<=n<=1051 <=n <= 10^51<=n<=105
1<=nums1[i],nums2[i]<=1051 <= nums1[i],nums2[i]<=10^51<=nums1[i],nums2[i]<=105
输出描述
样例1
输入
4
1 2 3 4
1 2 3 4

输出
6

说明
其中代价和最小的一种方法为:
交换下标为 000 和 111 的两个值，代价为 0+1=10+1=10+1=1 ，现在 nums1=[2,1,3,4]nums1=[2,1,3,4]nums1=[2,1,3,4] 。
交换下标为 222 和 333 的两个值，代价为 2+3=52+3=52+3=5 ，现在 nums1=[2,1,4,3]nums1=[2,1,4,3]nums1=[2,1,4,3]。
总代价为 666 。
样例2
输入
3
2 1 1
1 1 2

输出
-1

说明
无论怎么操作，都无法要求。所以返回 −1-1−1 。

▶️

#### TextSol

video solution

题面描述:
给定两个长度为 nnn 的整数数组 nums1nums1nums1 和 nums2nums2nums2，可以通过交换数组 nums2nums2nums2 中任意两个元素来使得所有下标 iii 满足 nums1[i]=nums2[i]nums1[i] = nums2[i]nums1[i]=nums2[i]，每次交换的代价为两个被交换元素下标的和。目标是计算使两个数组在对应位置相等的最小代价和，如果无法通过交换使两个数组相等，则返回 −1-1−1。输入格式为：第一行输入整数 nnn，表示数组的长度；第二行和第三行分别输入长度为 nnn 的数组 nums1nums1nums1 和 nums2nums2nums2。输出格式为满足要求的最小代价和，或无法满足时输出 −1-1−1。
思路:
记需要交换的总对数为 swapCount，其中要交换的数的众数为 modeValue，众数个数为 modeCount，我们分两种情况讨论：

如果 modeCount <= swapCount / 2，即众数个数为总数的一半：

如果 swapCount 为偶数，那么可以直接内部两两交换即可。
如果 swapCount 为奇数，记为 2*k + 1，那么最极端的情况也是 k 个 a，k 个 b，1 个 c，这样才能拼成一个奇数且满足众数个数不超过总数一半。
那么让 k - 1 个 a 和 k - 1 个 b 交换，剩下一个 a、b 和 c，那么至少有两个数可以和 nums1[0] 交换，剩下两个交换即可，依然可以内部解决。

如果 modeCount > swapCount / 2，只需从前往后找不相等且不等于众数的数与众数交换，最后应满足 modeCount <= swapCount / 2。如不能满足则输出 -1。

代码详解

变量定义：

swapCount：需要交换的元素总个数，即满足 nums1[i] == nums2[i] 的那些元素。
modeCount：记录当前众数的数量。
modeValue：当前的众数，即出现最多的数。

第一遍遍历数组：

统计哪些元素需要被交换（即 nums1[i] == nums2[i] 的那些元素）。
更新这些元素的出现次数，并确定当前的众数和众数的数量。

第二遍遍历数组：

如果众数的数量超过了总交换数的一半，需要逐步处理不等于众数的元素，尝试与众数进行交换，直到众数的个数不再超过总数的一半。

输出结果：

如果通过交换不能满足要求（即 modeCount > swapCount / 2），则输出 -1。
否则，输出最小的交换代价 totalCost。

cpp
#include <bits/stdc++.h>
using namespace std;

const int MAX_SIZE = 1e5 + 10;
int nums1[MAX_SIZE], nums2[MAX_SIZE];
int swapCount; // 需要交换的元素总数
int modeCount; // 众数的个数
int countMap[MAX_SIZE]; // 记录每个数的个数
int modeValue; // 众数的值

signed main() {
int n;
cin >> n; // 输入数组的长度
for (int i = 0; i < n; i++) cin >> nums1[i]; // 输入第一个数组
for (int i = 0; i < n; i++) cin >> nums2[i]; // 输入第二个数组

int totalCost = 0; // 记录总交换代价

// 统计冲突的元素
for (int i = 0; i < n; i++) {
if (nums1[i] == nums2[i]) {
totalCost += i; // 当前索引的代价
++swapCount; // 需要交换的总数增加
++countMap[nums1[i]]; // 统计当前元素的个数

// 更新众数和众数个数
int currentValue = nums1[i];
if (countMap[currentValue] > modeCount) {
modeCount = countMap[currentValue];
modeValue = currentValue;
}
}
}

// 处理冲突的元素
for (int i = 0; i < n && modeCount * 2 > swapCount; i++) {
int a = nums1[i], b = nums2[i];
// 交换众数与其他不同的元素
if (a != b && a != modeValue && b != modeValue) {
totalCost += i; // 计算交换代价
++swapCount; // 需要交换的总数增加
}
}

// 判断是否能满足条件
if (modeCount * 2 > swapCount) {
cout << -1 << endl; // 无法满足条件
} else {
cout << totalCost << endl; // 输出总交换代价
}

return 0;
}

python
# 定义常量和初始化数组
MAX_SIZE = int(1e5 + 10)
nums1 = [0] * MAX_SIZE
nums2 = [0] * MAX_SIZE
swapCount = 0  # 需要交换的数的总个数
modeCount = 0   # 记录当前众数的个数
countMap = [0] * MAX_SIZE  # 记录每个数的出现次数
modeValue = 0  # 当前的众数

# 输入数组长度和元素
n = int(input())
nums1 = list(map(int, input().split()))
nums2 = list(map(int, input().split()))

totalCost = 0  # 记录总交换代价

# 第一遍遍历数组，统计需要交换的元素
for i in range(n):
if nums1[i] == nums2[i]:
totalCost += i  # 计算交换代价
swapCount += 1  # 交换总数增加
countMap[nums1[i]] += 1  # 记录当前元素的出现次数
currentValue = nums1[i]  # 当前元素值

# 更新众数和众数的个数
if countMap[currentValue] > modeCount:
modeCount = countMap[currentValue]
modeValue = currentValue

# 第二遍遍历数组，处理众数
for i in range(n):
if modeCount * 2 <= swapCount:
break  # 如果众数个数不超过总数的一半，结束处理

a = nums1[i]
b = nums2[i]

# 交换不等于众数的元素
if a != b and a != modeValue and b != modeValue:
totalCost += i  # 计算交换代价
swapCount += 1  # 交换总数增加

# 输出结果
if modeCount * 2 > swapCount:
print(-1)  # 无法满足条件
else:
print(totalCost)  # 输出总交换代价

java
import java.util.Scanner;

public class Main {
public static final int MAX_SIZE = (int) 1e5 + 10;
public static int[] nums1 = new int[MAX_SIZE];
public static int[] nums2 = new int[MAX_SIZE];
public static int swapCount = 0; // 需要交换的元素总个数
public static int modeCount = 0; // 当前众数的个数
public static int[] countMap = new int[MAX_SIZE]; // 记录每个数的出现次数
public static int modeValue = 0; // 当前的众数

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt(); // 输入数组长度

// 输入第一个数组
for (int i = 0; i < n; i++) {
nums1[i] = sc.nextInt();
}
// 输入第二个数组
for (int i = 0; i < n; i++) {
nums2[i] = sc.nextInt();
}

int totalCost = 0; // 记录总交换代价

// 第一遍遍历数组，统计需要交换的元素
for (int i = 0; i < n; i++) {
if (nums1[i] == nums2[i]) {
totalCost += i; // 计算交换代价
swapCount++; // 交换总数增加
countMap[nums1[i]]++; // 记录当前元素的出现次数
int currentValue = nums1[i]; // 当前元素值

// 更新众数和众数的个数
if (countMap[currentValue] > modeCount) {
modeCount = countMap[currentValue];
modeValue = currentValue;
}
}
}

// 第二遍遍历数组，处理众数
for (int i = 0; i < n && modeCount * 2 > swapCount; i++) {
int a = nums1[i];
int b = nums2[i];
// 交换不等于众数的元素
if (a != b && a != modeValue && b != modeValue) {
totalCost += i; // 计算交换代价
swapCount++; // 交换总数增加
}
}

// 输出结果
if (modeCount * 2 > swapCount) {
System.out.println(-1); // 无法满足条件
} else {
System.out.println(totalCost); // 输出总交换代价
}

sc.close(); // 关闭输入流
}
}

---

### 第3题-狩猎大比拼（P2275）
- 链接：https://codefun2000.com/p/P2275

> 页面标题：#P2275. 第3题-狩猎大比拼

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有若干名猎人来到草原狩猎，每名猎人在狩猎开始前需要灵活搭配技能用于击杀猎物，每个技能由十六进制数[0,F0,F0,F]中的某个数来表达，每个猎人都必须选择888种不重复的技能。草原上有各种各样的猎物，并且具备一些弱点，弱点也由十六进制数[0,F0,F0,F]中的某个数字表达。猎人能击杀某种猎物的前提是同时满足:
1.猎人的技能可以覆盖猎物的所有弱点。
2.猎人的技能至少包含[A,FA,FA,F]中的其中一个技能。
3.猎人最后一个技能需要至少命中猎物的任意一个弱点。
每种猎物的数量可以认为是无限的，但是每种猎物只能被同一名猎人击杀一次，请帮忙计算每个猎人可击杀的猎物种类数量，击杀猎物总数最多的猎人将获得赏金猎人的称号
输入描述
111.第一行为猎人和猎物种类的数量，依次用空格隔开，第二行为每名猎人选择的技能，不同猎人的技能之间用空格隔开，第三行为所有的猎物，不同猎物之间的弱点用空格隔开。
222.输入的猎人数量在[1,10001,10001,1000]。
333.输入的猎物数量在[1,2000001,2000001,200000]。
444.每个猎人的技能数量固定为888，并且不包含重复技能。
555.每种猎物的弱点数量范围在[1,601,601,60]，可能包含重复的弱点。
6.十六进制数[0,F0,F0,F]中的字母均为大写。
输出描述
给定一个已完成技能搭配的猎人数组和猎物数组，请返回一个数组，数组中的每个元素是对应猎人最多可击杀的猎物数量。
样例1
输入
3 5
028F415A 2340789E 043BCD12
0222F44A 44C 8848A 002B2 F4415CA

输出
2 0 1

说明
第111名猎人具备的技能为028F415A028F415A028F415A，最后111个技能可以命中第1、3、51、3、51、3、5种猎物，但是不具备命中第555种猎物的CCC弱点，只能击杀第111和第333种猎物，因此可击杀的猎物数量为222。
第222名猎人具备的技能为2340789E2340789E2340789E，没有任何猎物包含EEE这个弱点，因此可击杀的猎物数量为000。
第333名英雄具备的技能为043BCD12043BCD12043BCD12，虽然这些技能可以覆盖第2、42、42、4种猎物，但是最后111个技能无法命中第222种猎物的弱点，只能击杀第444种猎物，因此可击杀的猎物数量为111。
样例2
输入
2 3
7519FCB0 01234567
25351727 A0 19C00

输出
1 0

说明
第111名猎人可以击杀第222种猎物。
第222名猎人虽然技能可以覆盖第111种猎物，并且最后一个技能777可以命中猎物的弱点，但是不包含[A,FA,FA,F]中的任一技能，因此不能击杀猎物，可击杀的猎物数量为000。
样例3
输入
3 3
027BAB5C 12307ABC 043BCD1A
ABC0 0ABC 4ABC0

输出
2 2 3

说明
第111名猎人可以击杀第111种和第222种猎物，因此可击杀的猎物数量为222。
第222名猎人可以击杀第111种和第222种猎物，因此可击杀的猎物数量为222。
第333名猎人可以击杀333种猎物，因此可击杀的猎物数量为333

▶️

#### TextSol

video solution

前置知识:
二进制枚举操作:https://oi-wiki.org/math/binary-set/
不知道这个知识点，接下来的方法将举步维艰。
题目大意
给定若干猎人和猎物，每名猎人有8种技能，每种猎物有若干弱点。猎人要击杀猎物需满足：技能覆盖所有弱点，技能中包含A~F其中一个，且最后一个技能能命中任意一个弱点。计算每个猎人能击杀的猎物数量。
思路
技能和弱点的二进制掩码表示:
每个猎人的技能和每个猎物的弱点都可以用16位二进制数表示。将技能或弱点中的每个十六进制字符映射为相应的二进制位。例如，0代表第1位，F代表第16位。这样，猎人8个技能的组合和猎物的弱点都可以转换为二进制掩码。\\
条件检查:\\
覆盖弱点：猎人技能必须覆盖猎物的所有弱点。可以通过skills_mask & weakness_mask == weakness_mask来判断。
包含A或F的技能：通过skills_mask & AF_mask来检查猎人的技能中是否包含A或F。
最后一个技能命中弱点：通过last_skill & weakness_mask != 0来判断猎人的最后一个技能是否能命中猎物的任意一个弱点。\\
实现步骤:\\
1.首先，将猎人的技能和猎物的弱点转换为二进制掩码。\\
2.对每个猎人，遍历所有猎物，依次检查猎人是否满足所有条件，并记录每个猎人能够击杀的猎物数量。
3.最终输出每个猎人可击杀的猎物种类数。
\\
复杂度分析:每个猎人的技能固定为8个，不会重复，因此子集枚举的复杂度为 2^8，总时间复杂度0(2^8×n+m*60)
关键条件
为了成功击杀猎物，猎人需要满足以下条件：

技能覆盖：猎人的技能必须覆盖猎物的所有弱点。通过二进制位运算，可以判断猎人的技能掩码是否包含猎物的弱点掩码。
包含特定技能：猎人的技能中至少要有一个技能在[A, F]范围内，确保猎人具备一定的强力技能。
最后技能命中：猎人最后选择的技能必须能够命中猎物的至少一个弱点，确保猎人的攻击有效。

实现步骤

掩码表示：利用二进制掩码来表示技能和弱点。将每个十六进制字符映射到二进制位上，0代表第一位，F代表第16位。
遍历猎物弱点：构建一个数组 preyWeaknessCount 来记录每种弱点组合的猎物数量。每读取一个猎物的弱点，更新对应的掩码。
处理猎人技能：对于每个猎人：

将猎人的技能转换为掩码。
检查猎人的技能是否包含[A, F]的技能。
计算猎人能击杀的猎物数量：

通过遍历所有可能的技能组合（子集）来检查猎人技能是否覆盖猎物的弱点，并且最后技能能否命中。

输出结果：最终输出每个猎人可击杀的猎物数量。

复杂度分析

每位猎人有8种技能，因此其子集的总数为 (2^8 = 256)。
对于每种猎物，其弱点数量范围为1到60，因此总的时间复杂度为 (O(2^8 \times n + m \times 60))，其中n为猎人数量，m为猎物数量。这种复杂度在给定的限制下是可接受的。

代码如下
cpp
#include <iostream>
#include <vector>
#include <string>

using namespace std;

int main() {
int hunters, preys;  // 猎人数量和猎物数量
cin >> hunters >> preys;

// 读取每个猎人的技能，存储在一个字符串向量中
vector<string> hunterSkills(hunters);
for (int i = 0; i < hunters; i++) {
cin >> hunterSkills[i];  // 读取每个猎人的8个技能
}

// 用来记录每种弱点组合的猎物数量，最大可能的弱点掩码为65536
vector<int> preyWeaknessCount(65536, 0);

// 处理每个猎物的弱点
while (preys-- > 0) {
string weakness;  // 存储当前猎物的弱点
cin >> weakness;
int weaknessMask = 0;  // 用来记录猎物弱点的掩码
for (char w : weakness) {
// 将每个弱点字符转换成十六进制表示的位掩码
int v = isdigit(w) ? w - '0' : w - 'A' + 10;  // 计算弱点的位
weaknessMask |= (1 << v);  // 设置对应位为1
}
preyWeaknessCount[weaknessMask]++;  // 记录该弱点组合的猎物数量
}

// 用来存储每个猎人能击杀的猎物数量
vector<int> killCount;

// 处理每个猎人的技能
for (const string& skills : hunterSkills) {
bool ok = false;  // 用于检测是否拥有 [A-F] 的技能
int skillMask = 0;  // 用来记录猎人的技能掩码

// 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if (!isdigit(skills.back())) {
ok = true;
}

// 检查猎人的技能，并将技能转换成位掩码
for (int i = 0; i + 1 < skills.length(); i++) {
char skill = skills[i];
if (isdigit(skill)) {
skillMask |= (1 << (skill - '0'));  // 数字技能
} else {
skillMask |= (1 << (skill - 'A' + 10));  // [A-F] 技能
ok = true;  // 拥有 [A-F] 技能
}
}

// 猎人最后一个技能对应的掩码
int lastSkill = isdigit(skills.back()) ? skills.back() - '0' : skills.back() - 'A' + 10;
int lastSkillMask = (1 << lastSkill);  // 计算最后一个技能的位掩码

int preyCanKill = 0;  // 当前猎人可以击杀的猎物数量

// 如果猎人有 [A-F] 的技能，遍历子集枚举
if (ok) {
for (int mask = skillMask; ; mask = (mask - 1) & skillMask) {
// 判断当前猎物是否可以被击杀，检查技能是否覆盖弱点
preyCanKill += preyWeaknessCount[mask | lastSkillMask];
if (mask == 0) break;  // 完成所有子集枚举
}
}

// 记录每个猎人可以击杀的猎物数量
killCount.push_back(preyCanKill);
}

// 输出每个猎人可以击杀的猎物数量
for (int count : killCount) {
cout << count << " ";  // 输出每位猎人可击杀的猎物数量
}
cout << endl;

return 0;
}

java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取n和m
int hunters = sc.nextInt();
int preys = sc.nextInt();
sc.nextLine(); // 读取剩余的换行符

// 读取n个猎人的技能
String[] hunterSkills = sc.nextLine().split(" ");

// 用来记录每种弱点组合的猎物数量
int[] preyWeaknessCount = new int[65536];

// 读取m个猎物的弱点
String[] preyWeaknesses = sc.nextLine().split(" ");

// 处理每个猎物的弱点
for (String weakness : preyWeaknesses) {
int weaknessMask = 0;  // 用来记录弱点的掩码
for (char w : weakness.toCharArray()) {
// 将每个弱点字符转换成十六进制表示的位掩码
int v = Character.isDigit(w) ? w - '0' : w - 'A' + 10;
weaknessMask |= (1 << v);
}
preyWeaknessCount[weaknessMask]++;  // 记录该弱点组合的猎物数量
}

// 用来存储每个猎人能击杀的猎物数量
List<Integer> killCount = new ArrayList<>();

// 处理每个猎人的技能
for (String skills : hunterSkills) {
boolean ok = false;  // 用于检测是否拥有 [A-F] 的技能
int skillMask = 0;  // 用来记录猎人的技能掩码

// 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if (!Character.isDigit(skills.charAt(7))) {
ok = true;
}

// 检查猎人的技能，并将技能转换成位掩码
for (int i = 0; i + 1 < skills.length(); i++) {
char skill = skills.charAt(i);
if (Character.isDigit(skill)) {
skillMask |= (1 << (skill - '0'));  // 数字技能
} else {
skillMask |= (1 << (skill - 'A' + 10));  // [A-F] 技能
ok = true;  // 拥有 [A-F] 技能
}
}

// 猎人最后一个技能对应的掩码
int lastSkill = Character.isDigit(skills.charAt(7)) ? skills.charAt(7) - '0' : skills.charAt(7) - 'A' + 10;
int lastSkillMask = (1 << lastSkill);

int preyCanKill = 0;  // 当前猎人可以击杀的猎物数量

// 如果猎人有 [A-F] 的技能，遍历子集枚举
if (ok) {
for (int mask = skillMask; ; mask = (mask - 1) & skillMask) {
preyCanKill += preyWeaknessCount[mask | lastSkillMask];  // 判断当前猎物是否可以击杀
if (mask == 0) break;  // 完成所有子集枚举
}
}

// 记录每个猎人可以击杀的猎物数量
killCount.add(preyCanKill);
}

// 输出每个猎人可以击杀的猎物数量
for (int count : killCount) {
System.out.print(count + " ");
}
System.out.println();
}
}

python
def main():
# 读取 n 和 m
n, m = map(int, input().split())

# 读取 n 个猎人的技能
hunter_skills = input().split()

# 用来记录每种弱点组合的猎物数量
prey_weakness_count = [0] * 65536

# 读取 m 个猎物的弱点
prey_weaknesses = input().split()

# 处理每个猎物的弱点
for weakness in prey_weaknesses:
weakness_mask = 0  # 用来记录弱点的掩码
for w in weakness:
# 将每个弱点字符转换成十六进制表示的位掩码
v = int(w, 16)
weakness_mask |= (1 << v)
prey_weakness_count[weakness_mask] += 1  # 记录该弱点组合的猎物数量

# 用来存储每个猎人能击杀的猎物数量
kill_count = []

# 处理每个猎人的技能
for skills in hunter_skills:
ok = False  # 用于检测是否拥有 [A-F] 的技能
skill_mask = 0  # 用来记录猎人的技能掩码

# 如果猎人最后一个技能不是数字，直接标记 ok 为 true
if not skills[-1].isdigit():
ok = True

# 检查猎人的技能，并将技能转换成位掩码
for i in range(7):
skill = skills[i]
if skill.isdigit():
skill_mask |= (1 << (ord(skill) - ord('0')))  # 数字技能
else:
skill_mask |= (1 << (ord(skill) - ord('A') + 10))  # [A-F] 技能
ok = True  # 拥有 [A-F] 技能

# 猎人最后一个技能对应的掩码
last_skill = int(skills[-1], 16)
last_skill_mask = (1 << last_skill)

prey_can_kill = 0  # 当前猎人可以击杀的猎物数量

# 如果猎人有 [A-F] 的技能，遍历子集枚举
if ok:
mask = skill_mask
while True:
prey_can_kill += prey_weakness_count[mask | last_skill_mask]  # 判断当前猎物是否可以击杀
if mask == 0:
break
mask = (mask - 1) & skill_mask  # 完成所有子集枚举

# 记录每个猎人可以击杀的猎物数量
kill_count.append(prey_can_kill)

# 输出每个猎人可以击杀的猎物数量
print(" ".join(map(str, kill_count)))

if __name__ == "__main__":
main()

---

### 第3题-防火墙规则匹配（P2269）
- 链接：https://codefun2000.com/p/P2269

> 页面标题：#P2269. 第3题-防火墙规则匹配

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

iptablesiptablesiptables是LinuxLinuxLinux系统的网络访问控制模块，管理员可通过iptablesiptablesiptables配置允许从哪些来源IPIPIP或IPIPIP段访问666个tinuxtinuxtinux主机。
iptablesiptablesiptables支持设置多个规则链，每个规则链中可以包含若干条访问控制规则。当系统收到一个网络报文时，会基于系统配置的访问控制规则来决定是接受还是拒绝这个报文。
请开发一个简化版iptablesiptablesiptables，现给定一系列规则操作命令和查询命令，
请依次输出其中查询命令的IPIPIP匹配结果。
规则操作命令有两种格式:

op chain_name ip_or_cidr action.op有三种:

III表示InsertInsertInsert，在对应的规则链开始处插入一条规则，
AAA表示AppendAppendAppend，在对应的规则链结尾处追加一条规则,
DDD表示从chain_name对应的链中删除一条规则;
actionactionaction字段AAA表示AcceptAcceptAccept，RRR表示RejectRejectReject

op chain_name1 ip_or_cidr_G chain_name2.表示当匹配到此规则后跳转到chain_name2继续匹配，GGG表示GotoGotoGoto。

其中ip_or_cidr字段可以是单个IPV4IPV4IPV4地址，也可以是CIDRCIDRCIDR格式的IPV4IPV4IPV4地址段。
CIDRCIDRCIDR示例:10.1.0.0/24 表示10.1.0.0到10.1.0.25s这个IP段。
对于一个CDRa.b.c.d/a，如果一个IP地址的前n个bit与a.b.c.d的前n个bit相同，那么这个P属于a.b.c.d/这个IP段。
查询命令的格式:
M ip 查询此IPIPIP是否被允许访问，MMM表示MatchMatchMatch。输入用例保证一定有一条c0c0c0规则链，每一个MMM操作都从c0c0c0链开始依次对每一条规则进行匹配，
输出匹配到的第一条规则的actionactionaction(AAA或RRR)。如果没有匹配到任何规则，输出UUU(表示UnknownUnknownUnknown)。只支持通过IPIPIP查询，不支持CIDRCIDRCIDR格式。
输入描述
第一行:一个整数NNN(2<=N<=1000002<=N<=1000002<=N<=100000)，表示总的规则操作命令和查询命令的总数。
接下来NNN行为规则操作命令或查询命令。
输出描述
对于每一个MMM操作，输出规则匹配后的actionactionaction字段 (A、RA、RA、R或UUU)
样例1
输入
11
A c0 192.168.1.0/24 R
I c0 192.168.1.1 A
A c0 10.1.0.0/24 G c2
A c1 0.0.0.0/0 R
A c2 10.1.0.3 R
A c2 10.1.0.0/24 A
M 192.168.1.1
M 192.168.1.10
D c0 192.168.1.0/24 R
M 192.168.1.10
M 10.1.0.3

输出
ARUR

说明
一共11条配置或查询操作。
规则链c0c0c0中包含333条规则，c1c1c1中包含111条规则，c2c2c2中包含222条规则。
然后查询192.168.1.1192.168.1.1192.168.1.1，匹配到了cOcOcO链中的I c0192.168.1.1 A,输出AAA;
查询192.168.1.10192.168.1.10192.168.1.10，匹配到了c0c0c0中的A c0 192.168.1.0/24 RA\ c0\ 192.168.1.0/24\ RA c0 192.168.1.0/24 R，输出RRR;
接下来删除了c0c0c0中的192.168.1.0/24 R192.168.1.0/24\ R192.168.1.0/24 R规则，再查询192.168.1.10192.168.1.10192.168.1.10时已没有任何规则可匹配，输出UUU;
又查询10.1.0.310.1.0.310.1.0.3，先匹配到了c0c0c0中的第333条规则，发现要goto c2goto\ c2goto c2，于是匹配到了c2c2c2中的10.1.0.3 R10.1.0.3\ R10.1.0.3 R规则，输出RRR。
样例2
输入
2
A c0 192.168.1.0/24 R
M 192.168.1.20

输出
R

说明
一共222条配置或查询操作。
规则链c0c0c0中包含111条规则，拒绝来自192.168.1.0/24192.168.1.0/24192.168.1.0/24的IP。
192.168.1.20192.168.1.20192.168.1.20属于192.168.1.0/24192.168.1.0/24192.168.1.0/24 这个IPIPIP段，因此输出RRR。

#### TextSol

题面描述
本题是实现一个简化版的 iptables，用于管理 Linux 系统的网络访问控制。通过一系列操作命令，管理员可以定义规则链，并根据这些规则链对IP或CIDR地址进行访问控制。题目要求处理插入、追加、删除规则的操作，并对IP查询进行匹配，输出查询结果。
给定输入包括规则操作和查询命令，要求我们从一个默认规则链 c0 开始匹配 IP 地址，返回匹配的规则结果（Accept 或 Reject），或输出 Unknown 表示没有匹配的规则。
思路
题目核心是处理网络访问规则链，模拟 iptables 的规则匹配机制。主要涉及三种操作：插入、追加和删除规则，以及查询某个IP是否被允许访问。使用链表存储规则链，并且每次根据输入动态更新。
具体分析
1.数据结构设计：
使用一个字典 chains，键为链的名字，值为该链上的规则列表，每条规则由一个三元组 (action, net, mask) 表示：
action: 表示该规则是 Accept 或 Reject。
net: IP 地址段的整数表示。
mask: 子网掩码长度。
另一个关键部分是处理 CIDR 地址段和具体 IPv4 地址的匹配，通过比特操作来判断某个IP是否在某个网段内。
2.IP和CIDR处理：
IP地址用整数表示，方便后续与子网掩码进行位运算。
CIDR格式的网段如 192.168.1.0/24 可以通过IP地址的前24位和网段掩码进行匹配。
具体实现中，将IP地址和掩码转换为整数，并通过与操作和位移实现匹配。
3.规则的插入、追加、删除：
插入：将规则插入到规则链的开头。
追加：将规则追加到规则链末尾。
删除：从链中找到对应规则并删除。
4.查询操作的实现：
从默认链 c0 开始查询，根据输入的IP逐条匹配链中的规则。
如果遇到 Goto 操作，跳转到指定的规则链继续匹配。
如果找到第一个匹配的规则，立即返回其结果（Accept 或 Reject）。如果所有规则都不匹配，则返回 Unknown。
DFS函数详解
查询IP是否被允许访问时，使用深度优先搜索（DFS）遍历规则链：
每次匹配时，从链 c0 开始，根据规则依次检查IP是否在某个CIDR网段内。
如果匹配到跳转规则（Goto），则递归进入新的规则链。
如果匹配到 Accept 或 Reject，立即返回结果，结束递归。
若没有规则匹配到，返回 Unknown
代码如下
python
from collections import defaultdict

# 将IPv4地址转换为32位整数
# 例如 '192.168.1.1' 会被转换为一个32位整数，以便后续处理
def ip_to_int(ip):
parts = list(map(int, ip.split('.')))  # 将IP地址拆分为四个部分
# 通过位运算将这四部分拼接为一个32位整数
return (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3]

# 解析CIDR格式的网络地址，返回(网络地址整数, 掩码长度)
# 例如 '192.168.1.0/24' 会被转换为对应的网络地址和子网掩码长度
def parse_cidr(cidr):
ip, mask = cidr.split('/')  # 将CIDR分为IP部分和掩码部分
mask = int(mask)  # 掩码长度转换为整数
ip_int = ip_to_int(ip)  # 将IP部分转换为32位整数
# 通过位运算计算网络地址
net = ip_int & (~((1 << (32 - mask)) - 1))
return (net, mask)  # 返回网络地址和掩码长度

def main():
N = int(input())  # 读取总的命令数量
chains = defaultdict(list)  # 使用字典保存每个规则链，链名作为键，链上的规则列表作为值
outputs = []  # 保存查询结果的输出列表

# 处理每条规则操作命令或查询命令
for _ in range(N):
line = input().strip()  # 读取并去掉命令行中的多余空格
tokens = line.split()  # 将命令按空格分割成若干部分
op = tokens[0].upper()  # 操作类型（I: 插入，A: 追加，D: 删除，M: 查询）

if op in {'I', 'A'}:  # 插入或追加规则
chain_name, ip_or_cidr, action = tokens[1:4]  # 规则链名称，IP或CIDR，操作（A或R）

if action == 'G':  # 如果规则是Goto（跳转到其他规则链）
target_chain = tokens[4]  # 跳转的目标规则链
# 处理CIDR或单个IP
net, mask = parse_cidr(ip_or_cidr) if '/' in ip_or_cidr else (ip_to_int(ip_or_cidr), 32)
rule = ('G', net, mask, target_chain)  # 构造Goto规则
else:  # 普通的Accept或Reject规则
net, mask = parse_cidr(ip_or_cidr) if '/' in ip_or_cidr else (ip_to_int(ip_or_cidr), 32)
rule = (action, net, mask)  # 构造Accept或Reject规则

if op == 'I':  # 插入规则到链的开头
chains[chain_name].insert(0, rule)
else:  # 追加规则到链的末尾
chains[chain_name].append(rule)

elif op == 'D':  # 删除规则
chain_name, ip_or_cidr, action = tokens[1:4]  # 获取链名，IP或CIDR，操作（A或R）
net, mask = parse_cidr(ip_or_cidr) if '/' in ip_or_cidr else (ip_to_int(ip_or_cidr), 32)
# 删除规则链中与指定规则匹配的规则
rules = chains[chain_name]
chains[chain_name] = [r for r in rules if not (r[0] == action and r[1] == net and r[2] == mask)]

elif op == 'M':  # 查询命令
ip_str = tokens[1]  # 获取要查询的IP
ip = ip_to_int(ip_str)  # 将IP转换为32位整数
stack = ['c0']  # 从默认链 'c0' 开始查询
result = 'U'  # 如果未找到匹配规则，结果默认设为 'U'（Unknown）
visited_chains = set()  # 记录已经访问过的规则链，避免循环跳转

# 深度优先搜索规则链
while stack:
current_chain = stack.pop()  # 取出当前要查询的规则链
if current_chain in visited_chains:  # 如果该链已经访问过，跳过
continue
visited_chains.add(current_chain)  # 标记该链为已访问
rules = chains[current_chain]  # 获取当前规则链上的所有规则

# 遍历该规则链上的所有规则
for rule in rules:
# 检查当前IP是否符合该规则的网络地址范围
if rule[1] <= ip <= (rule[1] + ((1 << (32 - rule[2])) - 1)):
if rule[0] in ('A', 'R'):  # 如果是Accept或Reject规则
result = rule[0]  # 记录匹配的结果
stack = []  # 清空堆栈，结束查询
break
elif rule[0] == 'G':  # 如果是Goto规则
stack.append(rule[3])  # 将目标链名加入堆栈，继续查询
break
outputs.append(result)  # 将查询结果加入输出列表

print(''.join(outputs))  # 最后输出所有查询结果

if __name__ == "__main__":
main()

cpp
#include <bits/stdc++.h>
using namespace std;

// 将IPv4地址转换为32位整数
unsigned int ip_to_int(const string& ip) {
unsigned int parts[4];
sscanf(ip.c_str(), "%u.%u.%u.%u", &parts[0], &parts[1], &parts[2], &parts[3]);
return (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8) | parts[3];
}

// 解析CIDR格式的网络地址，返回网络地址和掩码长度
pair<unsigned int, int> parse_cidr(const string& cidr) {
size_t pos = cidr.find('/');
string ip = cidr.substr(0, pos);
int mask = stoi(cidr.substr(pos + 1));
unsigned int ip_int = ip_to_int(ip);
unsigned int net = ip_int & (~((1u << (32 - mask)) - 1));
return {net, mask};
}

int main(){
ios::sync_with_stdio(false);
cin.tie(0);

int N;
cin >> N;
// 定义规则结构
struct Rule {
char type; // 'A', 'R', 'G'
unsigned int net;
int mask;
string target; // 仅G类型有
};

unordered_map<string, vector<Rule>> chains;
string line;
getline(cin, line); // 读取剩余的换行符

string outputs = "";

for(int i = 0; i < N; ++i){
getline(cin, line);
if(line.empty()) { i--; continue; }
stringstream ss(line);
string op;
ss >> op;
char operation = toupper(op[0]);

if(operation == 'I' || operation == 'A'){
string chain_name, ip_or_cidr, action;
ss >> chain_name >> ip_or_cidr >> action;
Rule rule;
rule.type = action[0];
if(ip_or_cidr.find('/') != string::npos){
auto parsed = parse_cidr(ip_or_cidr);
rule.net = parsed.first;
rule.mask = parsed.second;
}
else{
rule.net = ip_to_int(ip_or_cidr);
rule.mask = 32;
}
if(rule.type == 'G'){
string target_chain;
ss >> target_chain;
rule.target = target_chain;
}
if(operation == 'I'){
chains[chain_name].insert(chains[chain_name].begin(), rule);
}
else{
chains[chain_name].push_back(rule);
}
}
else if(operation == 'D'){
string chain_name, ip_or_cidr, action;
ss >> chain_name >> ip_or_cidr >> action;
unsigned int net;
int mask;
if(ip_or_cidr.find('/') != string::npos){
auto parsed = parse_cidr(ip_or_cidr);
net = parsed.first;
mask = parsed.second;
}
else{
net = ip_to_int(ip_or_cidr);
mask = 32;
}
char act = action[0];
auto &rules = chains[chain_name];
rules.erase(
remove_if(rules.begin(), rules.end(), [&](const Rule& r) {
if(r.type != act) return false;
if(r.net != net) return false;
if(r.mask != mask) return false;
return true;
}),
rules.end()
);
}
else if(operation == 'M'){
string ip_str;
ss >> ip_str;
unsigned int ip = ip_to_int(ip_str);
stack<string> stk;
stk.push("c0");
char result = 'U';
unordered_set<string> visited;

while(!stk.empty()){
string current_chain = stk.top(); stk.pop();
if(visited.find(current_chain) != visited.end()) continue;
visited.insert(current_chain);
if(chains.find(current_chain) == chains.end()) continue;
for(auto &rule : chains[current_chain]){
unsigned int start = rule.net;
unsigned int end = rule.net + ((1u << (32 - rule.mask)) - 1);
if(ip >= start && ip <= end){
if(rule.type == 'A' || rule.type == 'R'){
result = rule.type;
stk = stack<string>(); // 清空堆栈，结束查询
break;
}
else if(rule.type == 'G'){
stk.push(rule.target);
break;
}
}
}
}
outputs += result;
}
}
cout << outputs;
}

java
import java.util.*;
import java.io.*;

public class Main {
// 将IPv4地址转换为32位整数
static long ipToInt(String ip) {
String[] parts = ip.split("\\.");
long res = 0;
for(String part : parts){
res = (res << 8) | Long.parseLong(part);
}
return res;
}

// 解析CIDR格式的网络地址，返回网络地址和掩码长度
static Pair<Long, Integer> parseCidr(String cidr) {
String[] parts = cidr.split("/");
String ip = parts[0];
int mask = Integer.parseInt(parts[1]);
long ipInt = ipToInt(ip);
long net = ipInt & (~((1L << (32 - mask)) - 1));
return new Pair<>(net, mask);
}

public static void main(String[] args) throws IOException{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
// 定义规则结构
class Rule {
char type; // 'A', 'R', 'G'
long net;
int mask;
String target; // 仅G类型有

Rule(char type, long net, int mask, String target){
this.type = type;
this.net = net;
this.mask = mask;
this.target = target;
}
}

Map<String, List<Rule>> chains = new HashMap<>();
StringBuilder outputs = new StringBuilder();

for(int i = 0; i < N; ++i){
String line = br.readLine();
if(line == null || line.isEmpty()){
i--;
continue;
}
String[] tokens = line.trim().split("\\s+");
char op = Character.toUpperCase(tokens[0].charAt(0));

if(op == 'I' || op == 'A'){
String chainName = tokens[1];
String ipOrCidr = tokens[2];
String action = tokens[3];
char actionType = action.charAt(0);
long net;
int mask;
if(ipOrCidr.contains("/")){
Pair<Long, Integer> parsed = parseCidr(ipOrCidr);
net = parsed.first;
mask = parsed.second;
}
else{
net = ipToInt(ipOrCidr);
mask = 32;
}
Rule rule;
if(actionType == 'G'){
String targetChain = tokens[4];
rule = new Rule(actionType, net, mask, targetChain);
}
else{
rule = new Rule(actionType, net, mask, null);
}
chains.putIfAbsent(chainName, new ArrayList<>());
if(op == 'I'){
chains.get(chainName).add(0, rule);
}
else{
chains.get(chainName).add(rule);
}
}
else if(op == 'D'){
String chainName = tokens[1];
String ipOrCidr = tokens[2];
String action = tokens[3];
char act = action.charAt(0);
long net;
int mask;
if(ipOrCidr.contains("/")){
Pair<Long, Integer> parsed = parseCidr(ipOrCidr);
net = parsed.first;
mask = parsed.second;
}
else{
net = ipToInt(ipOrCidr);
mask = 32;
}
if(chains.containsKey(chainName)){
List<Rule> rules = chains.get(chainName);
rules.removeIf(r -> r.type == act && r.net == net && r.mask == mask);
}
}
else if(op == 'M'){
String ipStr = tokens[1];
long ip = ipToInt(ipStr);
Stack<String> stack = new Stack<>();
stack.push("c0");
char result = 'U';
Set<String> visited = new HashSet<>();

while(!stack.isEmpty()){
String currentChain = stack.pop();
if(visited.contains(currentChain)) continue;
visited.add(currentChain);
if(!chains.containsKey(currentChain)) continue;
List<Rule> rules = chains.get(currentChain);
for(Rule rule : rules){
long start = rule.net;
long end = rule.net + ((1L << (32 - rule.mask)) - 1);
if(ip >= start && ip <= end){
if(rule.type == 'A' || rule.type == 'R'){
result = rule.type;
stack.clear();
break;
}
else if(rule.type == 'G'){
stack.push(rule.target);
break;
}
}
}
}
outputs.append(result);
}
}
System.out.println(outputs.toString());
}

// 简单的Pair类
static class Pair<F, S>{
F first;
S second;
Pair(F first, S second){
this.first = first;
this.second = second;
}
}
}

---

### 第3题-服务器训练任务调度（P2266）
- 链接：https://codefun2000.com/p/P2266

> 页面标题：#P2266. 第3题-服务器训练任务调度

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

团队申请了一组服务器,用于机器学习训练，为了充分利用资源，需要你来完成任务调度算法的实现。
一台服务器同一时间只能执行一个训练任务，每个训练任务有训练时间和优先级。
当空闲服务器不足时，优先执行高优先级的训练任务;如果多个训练任务的优先级相同，优先执行训练时间长的任务。
当空闲服务器充足时，可以同时执行不同优先级的训练任务。
所有任务在开始时刻(零时刻)一次性提交完毕，等待调度。任务一旦开始就不能暂停或更换服务器，直到任务结束。
现在需要根据服务器和训练任务，计算完成所有训练任务的总时间。
输入描述
第一行一个整数MMM，表示空闲服务器的数量，1<=M<=1031<=M<=10^31<=M<=103
第二行一个整数NNN，表示训练任务的数量,1<=N<=1051<=N<=10^51<=N<=105
从第三行开始连续NNN行，每行两个整数和PPP，分别表示对应任务的训练时间和优先级，1≤T≤1071≤T≤10^71≤T≤107,1≤P≤101≤P≤101≤P≤10。
优先级PPP数值越小，表示优先级越高。
不需要考虑非法输入。
输出描述
完成所有训练任务的总时间
样例1
输入
2
4
1 1
2 1
2 2
4 2

输出
5

说明
222台服务器444个训练任务，为方便描述，假设2台服务器编号分别为A、BA、BA、B。
1、起始时刻为000，先同时执行两个优先级均为111的训练任务。AAA执行任务T=1,F=1T=1,F=1T=1,F=1;BBB执行任务-2，-1
2、在时刻111，AAA的任务执行完毕，继续执行优先级为222，并且执行时间较长的任务T=4,P=2T=4,P=2T=4,P=2
3、在时刻222，BBB的任务执行完毕，执行剩余的一个任务T=2,P=2T=2,P=2T=2,P=2。
4、在时刻444，BBB的任务执行完毕，没有未执行的任务。
5、在时刻555，AAA的任务执行完毕，没有未执行的任务。
训练完成的时刻即需要的总时间为555，输出555。
样例2
输入
3
3
1 1
2 2
3 3

输出
3

说明
3 33台服务器333个训练任务，不同优先级的任务可以同时执行。
333台服务器的执行时长依次为1、2、31、2、31、2、3。
训练任务的总执行时长为333。

#### TextSol

题面描述
团队申请了一组服务器，用于机器学习训练。为了充分利用资源，需要实现一个任务调度算法。具体要求如下：

服务器与任务：

有 MMM 台空闲服务器。
有 NNN 个训练任务，每个任务有训练时间 TTT 和优先级 PPP。

调度规则：

每台服务器同一时间只能执行一个训练任务。
所有任务在开始时刻（零时刻）一次性提交完毕，等待调度。
任务一旦开始执行，就不能暂停或更换服务器，直到任务结束。
优先级调度：

当空闲服务器不足时，优先执行优先级高（PPP 值小）的训练任务。
如果多个训练任务的优先级相同，优先执行训练时间长的任务。
当空闲服务器充足时，可以同时执行不同优先级的训练任务。

目标：

计算完成所有训练任务的总时间。

思路
为了计算完成所有训练任务的最小总时间，可以采用以下步骤：

任务排序：

首先，根据优先级 PPP 升序排序任务（即优先级高的任务排在前面）。
对于优先级相同的任务，按照训练时间 TTT 降序排序（即训练时间长的任务排在前面）。

服务器调度：

使用一个最小堆（优先队列）来跟踪每台服务器的空闲时间。初始时，所有服务器的空闲时间为 000。
遍历排序后的任务列表，对于每个任务：

从堆中取出当前最早空闲的服务器的空闲时间。
该任务的开始时间为服务器的空闲时间。
更新服务器的空闲时间为 开始时间 + T。
将更新后的空闲时间重新放回堆中。
记录任务的结束时间，维护一个最大结束时间作为总时间。

结果输出：

遍历完所有任务后，最大结束时间即为完成所有任务的总时间。

这种方法的时间复杂度为 O(Nlog⁡N+Nlog⁡M)O(N \log N + N \log M)O(NlogN+NlogM)，其中 NNN 是任务数量，MMM 是服务器数量。在题目给定的约束下，该算法是可行且高效的。
cpp
#include <bits/stdc++.h>
using namespace std;

struct Task {
int T;
int P;
};

// Comparator: 优先级升序，训练时间降序
bool cmp(const Task &a, const Task &b) {
if(a.P != b.P)
return a.P < b.P;
return a.T > b.T;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(0);
int M, N;
cin >> M >> N;
vector<Task> tasks(N);
for(int i=0; i<N; ++i){
cin >> tasks[i].T >> tasks[i].P;
}
// 排序
sort(tasks.begin(), tasks.end(), cmp);
// 最小堆，存储服务器的空闲时间
priority_queue<long long, vector<long long>, std::greater<long long>> pq;
// 初始化所有服务器为空闲，时间为0
for(int i=0; i<M; ++i){
pq.push(0);
}
long long max_time = 0;
for(auto &task: tasks){
long long avail_time = pq.top(); pq.pop();
long long finish_time = avail_time + task.T;
max_time = max(max_time, finish_time);
pq.push(finish_time);
}
cout << max_time;
}

python
import sys
import heapq

def main():
import sys
import sys
input = sys.stdin.read
data = input().split()

idx = 0
M = int(data[idx]);
idx += 1
N = int(data[idx]);
idx += 1
tasks = []
for _ in range(N):
T = int(data[idx]);
idx += 1
P = int(data[idx]);
idx += 1
tasks.append((P, -T))  # 负的T用于降序排序

# 排序：优先级升序，训练时间降序
tasks.sort()

# 初始化最小堆，存储每台服务器的空闲时间
heap = [0] * M
heapq.heapify(heap)

max_time = 0
for P, neg_T in tasks:
T = -neg_T
avail_time = heapq.heappop(heap)
finish_time = avail_time + T
max_time = max(max_time, finish_time)
heapq.heappush(heap, finish_time)

print(max_time)

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main {
static class Task {
int time; // 训练时间
int priority; // 优先级

Task(int time, int priority) {
this.time = time;
this.priority = priority;
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

// 读取服务器数量和任务数量
int M = scanner.nextInt(); // 空闲服务器的数量
int N = scanner.nextInt(); // 训练任务的数量

List<Task> tasks = new ArrayList<>();

// 读取任务信息
for (int i = 0; i < N; i++) {
int T = scanner.nextInt(); // 训练时间
int P = scanner.nextInt(); // 优先级
tasks.add(new Task(T, P));
}

// 按优先级升序、训练时间降序排序
tasks.sort((a, b) -> {
if (a.priority != b.priority) {
return Integer.compare(a.priority, b.priority); // 优先级比较
}
return Integer.compare(b.time, a.time); // 训练时间比较
});

// 初始化最小堆，存储每台服务器的空闲时间
PriorityQueue<Long> minHeap = new PriorityQueue<>();
for (int i = 0; i < M; i++) {
minHeap.offer(0L); // 初始时，所有服务器的空闲时间为0
}

long maxTime = 0; // 记录最大完成时间

// 处理所有任务
for (Task task : tasks) {
long availTime = minHeap.poll(); // 取出最早空闲的服务器时间
long finishTime = availTime + task.time; // 计算任务完成时间
maxTime = Math.max(maxTime, finishTime); // 更新最大完成时间
minHeap.offer(finishTime); // 将新的空闲时间放回堆中
}

// 输出完成所有任务的总时间
System.out.println(maxTime);
}
}

---

### 第3题-让最远的员工少走点路（P2260）
- 链接：https://codefun2000.com/p/P2260

> 页面标题：#P2260. 第3题-让最远的员工少走点路

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

云某公司基地搬迁到新地点之后，新规划了一条班车路线，在这条路线上会经过NNN个小区，计划在这些小区中挑选出MMM个作为上车点，小区的位置可以用一维坐标上的点来表示，小区到上车点的距离为两个坐标点差值的绝对值。
现在给定NNN个小区的位置，即一维坐标上的整数点:x1、x2....xNx1、x2....xNx1、x2....xN，我们希望所有小区到最近上车点的距离的最大值尽可能小，请计算这个最大值的最小值能够是多少?当该小区被作为上车点，该小区到上车点的距离为000。
输入描述
第一行有两个整数，用空格隔开:N MN\ MN M,1<=M<=N<=1000001<=M<=N<=1000001<=M<=N<=100000
第二行有NNN个没有重复的递增的整数，用空格隔开，表示依次经过NNN个小区的位置，1<=xi<=10000001<=xi <=10000001<=xi<=1000000
输出描述
一个整数，表示所有小区到上车点距离的最大值的最小值
样例1
输入
5 2
1 2 3 6 7

输出
1

说明
将上车点设置在2、62、62、6这两个小区时，所有小区到上车点距离的最大值的最小值为111
样例2
输入
10 5
1 2 3 6 7 9 11 22 44 50

输出
3

说明
将上车点设置在2、9、22、44、502、9、22、44、502、9、22、44、50这555个小区时，所有小区到上车点距离的最大值的最小值为333。

#### TextSol

题面描述
云某公司在基地搬迁到新地点后，规划了一条经过 NNN 个小区的班车路线。公司计划在这些小区中挑选出 MMM 个小区作为上车点。小区的位置可以用一维坐标上的整数点表示。每个小区到最近上车点的距离为这两个坐标点差值的绝对值。若小区本身被选为上车点，则其到上车点的距离为 000。
任务：在给定 NNN 个小区的位置的情况下，选择 MMM 个上车点，使得所有小区到最近上车点的距离的最大值尽可能小。计算这个最大值的最小值。
思路
二分答案。二分这个最小可能值midmidmid，如何checkcheckcheck呢?我们贪心的考虑，我们放车站的时候尽可能大的覆盖到右边的区域，最多能覆盖盖positions[i]+midpositions[i] + midpositions[i]+mid这个位置，我们将下一个位置跳到upper_bound(positions.begin(), positions.end(),positions[i] + mid) - positions.begin();即可，最后检查车站数量是否不超过m即可
cpp
#include <bits/stdc++.h>
using namespace std;

// 函数用于判断在最大距离为mid时，是否可以用不超过M个上车点覆盖所有小区
bool canPlaceStations(const vector<int>& positions, int N, int M, int mid) {
int count = 0; // 已放置的上车点数量
int i = 0; // 当前检查的小区索引

while (i < N) {
count++; // 放置一个新的上车点
// 找到最右边的一个小区，使得它不超过 positions[i] + mid
int station_pos = positions[i] + mid;
int j = upper_bound(positions.begin(), positions.end(), station_pos) - positions.begin();
j--; // 上车点放置在 positions[j]

// 现在，所有小区 <= positions[j] + mid 都被覆盖
int cover_limit = positions[j] + mid;
i = upper_bound(positions.begin(), positions.end(), cover_limit) - positions.begin();
}

return count <= M;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(0);

int N, M;
cin >> N >> M;
vector<int> positions(N);
for(auto &x : positions) cin >> x;

int left = 0;
int right = positions[N-1] - positions[0];
int answer = right;

while(left <= right){
int mid = left + (right - left) / 2;
if(canPlaceStations(positions, N, M, mid)){
answer = mid;
right = mid - 1;
}
else{
left = mid + 1;
}
}

cout << answer;
}

python
def can_place_stations(positions, N, M, mid):
count = 0  # 已放置的上车点数量
i = 0  # 当前检查的小区索引

while i < N:
count += 1  # 放置一个新的上车点
station_pos = positions[i] + mid
# 找到最右边的一个小区，使得它不超过 positions[i] + mid
j = i
while j < N and positions[j] <= station_pos:
j += 1
j -= 1  # 上车点放置在 positions[j]

cover_limit = positions[j] + mid
# 找到第一个超过 cover_limit 的小区
while i < N and positions[i] <= cover_limit:
i += 1

return count <= M

def main():
import sys
input = sys.stdin.read
data = input().split()
N, M = map(int, data[:2])
positions = list(map(int, data[2:2 + N]))

left = 0
right = positions[-1] - positions[0]
answer = right

while left <= right:
mid = (left + right) // 2
if can_place_stations(positions, N, M, mid):
answer = mid
right = mid - 1
else:
left = mid + 1
print(answer)

if __name__ == "__main__":
main()

java
import java.util.*;
import java.io.*;

public class Main {
// 函数用于判断在最大距离为mid时，是否可以用不超过M个上车点覆盖所有小区
public static boolean canPlaceStations(int[] positions, int N, int M, int mid){
int count = 0; // 已放置的上车点数量
int i = 0; // 当前检查的小区索引

while (i < N){
count++; // 放置一个新的上车点
int station_pos = positions[i] + mid;
// 找到最右边的一个小区，使得它不超过 positions[i] + mid
int j = i;
while (j < N && positions[j] <= station_pos){
j++;
}
j--; // 上车点放置在 positions[j]

// 现在，所有小区 <= positions[j] + mid 都被覆盖
int cover_limit = positions[j] + mid;
while (i < N && positions[i] <= cover_limit){
i++;
}
}
return count <= M;
}

public static void main(String[] args)throws IOException{
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String[] first = br.readLine().split(" ");
int N = Integer.parseInt(first[0]);
int M = Integer.parseInt(first[1]);
String[] posStr = br.readLine().split(" ");
int[] positions = new int[N];
for(int i=0;i<N;i++) positions[i] = Integer.parseInt(posStr[i]);

int left =0;
int right = positions[N-1] - positions[0];
int answer = right;

while(left <= right){
int mid = left + (right - left)/2;
if(canPlaceStations(positions, N, M, mid)){
answer = mid;
right = mid -1;
}
else{
left = mid +1;
}
}
System.out.println(answer);
}
}

---

### 第3题-最少乘坐公交次数（P2263）
- 链接：https://codefun2000.com/p/P2263

> 页面标题：#P2263. 第3题-最少乘坐公交次数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

春节将近，小明想在节日期间逛一逛城里的 NNN 个著名景点，正好所有的景点都能通过坐公交到达，请帮小明设计一下，怎么搭乘公交路线才能最快逛完所有的景点。
1、景点编号 0,1,2,…,N−10,1,2,…,N-10,1,2,…,N−1
2、用数组 arr[N][N]arr[N] [N]arr[N][N]表示景点和景点之间是否有直达公交路线相连
3、arr[i][j]=1arr[i] [j]=1arr[i][j]=1 表示景点 iii 和景点 jjj 之间有直达公交相连，arr[i][j]=0arr[i] [j] =0arr[i][j]=0 表示没有
4、公交可以双向行驶，即如果 arr[i][j]=1arr[i] [j]=1arr[i][j]=1，则必然 arr[i][j]=1arr[i] [j]=1arr[i][j]=1
5、每个景点可以经过多次，两个景点的公交也可以坐多次
6、可以从任一景点开始游玩
输入描述
第一行:景点数量 N(0<N<=20)N(0<N<=20)N(0<N<=20)
后续 NNN 行: NNN 个元素表示景点与景点之间的公交到达关系
输出描述
最少乘坐公交的次数(如果不能逛完所有景点，则输出 000 )
样例1
输入
5
0 1 0 1 0
1 0 1 0 0
0 1 0 0 0
1 0 0 0 1
0 0 0 1 0

输出
4

说明

样例2
输入
6
0 1 1 0 0 0
1 0 0 0 0 0
1 0 0 1 1 0
0 0 1 0 0 0
0 0 1 0 0 1
0 0 0 0 1 0

输出
6

说明

▶️

#### TextSol

video solution

题目分析
这道题要求找到一种方式，以最少的公交乘坐次数游览完所有景点。我们可以把这道题理解成一个访问所有点至少一次的最短路径问题。类似于经典的旅行商问题（TSP），但稍有不同的是——每个景点允许重复访问。
思路：Floyd 最短路 + 状压 DP
为了解决这个问题，我们将使用 Floyd-Warshall 算法结合状态压缩动态规划（DP），来找到访问所有景点的最短路径（即乘坐公交的最少次数）。其中，Floyd-Warshall 用于预处理两点之间的最短路径，状态压缩 DP 则用于计算如何最少次数地遍历所有景点。
思路详解

预处理最短路径（Floyd-Warshall 算法）：
由于我们要访问所有景点且每个景点可以重复访问，因此我们只关心任意两个景点之间的最短路径距离。Floyd-Warshall 算法能够在 O(n^3) 的时间内找到图中所有节点对之间的最短路径。

构建一个二维数组 dist，其中 dist[i][j] 表示景点 i 到景点 j 的最短路径距离。
初始化时，dist[i][j] = 1（如果 i 和 j 之间有公交连接），否则设为一个极大值（如 10^9）表示不可达。
然后利用 Floyd-Warshall 算法迭代更新 dist[i][j]，找到任意两点之间的最短路径距离。

状态压缩动态规划（DP）：
由于最多只有 20 个景点，我们可以使用一个整数的二进制位来表示景点的访问状态。例如，00001 表示只访问了景点 0，11111 表示访问了 5 个景点。我们定义一个 DP 数组 dp[j][i]，表示在访问状态 i 下，到达景点 j 所需的最少公交次数。

初始化状态：每个景点 j 在只访问自己的状态 1 << j 下的公交次数为 0，即 dp[j][1 << j] = 0。

状态转移：对于每一个可能的状态 i 和在该状态下被访问的每一个景点 j，我们尝试从其他已访问的景点 k 转移到 j，并更新 dp[j][i]。

设 last = i ^ (1 << j) 为去掉景点 j 后的状态，遍历所有景点 k，若 k 在 last 状态中已被访问，则 dp[j][i] 更新为：dp[j][i] = min(dp[j][i], dp[k][last] + dist[k][j])。

计算结果：

state 的最终状态为 2^n - 1，即所有景点都已访问。我们遍历所有景点 i，计算在状态 state - 1 下访问所有景点的最小公交次数。
若 ans 仍为 10^9，则无法访问所有景点，输出 0；否则输出 ans。

QQQ:这样做是否会和dpdpdp的定义有冲突？因为在走最短路的过程中,有些路径上的点已经被访问过了，但是我们的dpdpdp并没有更新他们？
没有冲突。因为我们dpdpdp定义的访问或没访问，是人为的定序，是为了保证能够访问过所有可能情况。而不是看它实际被访问过没。
代码
java
import java.util.Scanner;
import java.util.Arrays;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

// 读取景点数量
int n = sc.nextInt();
int[][] edge = new int[n][n];

// 读取公交路线的二维数组
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
edge[i][j] = sc.nextInt();
}
}

// 初始化距离数组dist，初始值设为一个很大的数（10^9），表示不可达
int[][] dist = new int[n][n];
for (int i = 0; i < n; i++) {
Arrays.fill(dist[i], (int) 1e9);
dist[i][i] = 0;
}

// 根据输入的公交线路设置初始直达距离
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (edge[i][j] == 1) {
dist[i][j] = 1;
}
}
}

// 使用Floyd-Warshall算法计算所有景点之间的最短路径
for (int k = 0; k < n; k++) {
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
}
}
}

// 使用状态压缩DP来记录到达每个状态时的最少公交次数
int state = 1 << n;
int[][] dp = new int[n][state];
for (int i = 0; i < n; i++) {
Arrays.fill(dp[i], (int) 1e9);
dp[i][1 << i] = 0;
}

// 遍历所有可能的状态i（从1到2^n-1）
for (int i = 1; i < state; i++) {
for (int j = 0; j < n; j++) {
if ((i & (1 << j)) == 0) continue;
int last = i ^ (1 << j);
for (int k = 0; k < n; k++) {
if ((last & (1 << k)) == 0) continue;
if (dp[k][last] == (int) 1e9) continue;
dp[j][i] = Math.min(dp[j][i], dp[k][last] + dist[k][j]);
}
}
}

// 最终答案，遍历所有景点，在访问所有景点的状态（state - 1）下找到最小公交次数
int ans = (int) 1e9;
for (int i = 0; i < n; i++) {
ans = Math.min(ans, dp[i][state - 1]);
}

// 输出结果，如果ans仍然是初始值，说明无法访问所有景点，输出0，否则输出ans
if (ans == (int) 1e9) {
System.out.println(0);
} else {
System.out.println(ans);
}

sc.close();
}
}

python
# 读取景点数量
n = int(input())

# 读取公交路线的二维数组
edge = [list(map(int, input().split())) for _ in range(n)]

# 初始化距离数组dist，初始值设为一个很大的数（10^9），表示不可达
dist = [[10 ** 9] * n for _ in range(n)]

# 自己到自己距离为0
for i in range(n):
dist[i][i] = 0

# 根据输入的公交线路设置初始直达距离
for i in range(n):
for j in range(n):
if edge[i][j] == 1:  # 如果景点i和景点j之间有公交路线
dist[i][j] = 1   # 直达距离设为1

# 使用Floyd-Warshall算法计算所有景点之间的最短路径
for k in range(n):
for i in range(n):
for j in range(n):
# 更新dist[i][j]，通过中间景点k找到更短路径
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

# 使用状态压缩DP来记录到达每个状态时的最少公交次数
state = 1 << n  # 总的状态数量为2^n
dp = [[10 ** 9] * state for _ in range(n)]  # 初始化DP数组，初始值为10^9，表示不可达

# 初始化DP状态，每个景点作为起点时的状态
for i in range(n):
dp[i][1 << i] = 0  # 从每个景点开始只访问自己的状态，公交次数为0

# 遍历所有可能的状态i（从1到2^n-1）
for i in range(1, state):
# 遍历所有景点j，如果景点j在状态i中被访问
for j in range(n):
if (i >> j) & 1 == 0:  # 如果状态i中没有访问景点j，跳过
continue
# 计算上一个状态last，表示状态i中去掉景点j后的状态
last = i ^ (1 << j)
# 遍历景点k，尝试从景点k到达景点j
for k in range(n):
if (last >> k) & 1 == 0:  # 如果last状态中没有访问过景点k，跳过
continue
if dp[k][last] == 10 ** 9:  # 如果last状态下景点k不可达，跳过
continue
# 更新dp[j][i]为从状态last到达j的最小公交次数
dp[j][i] = min(dp[j][i], dp[k][last] + dist[k][j])

# 最终答案，遍历所有景点，在访问所有景点的状态（state - 1）下找到最小公交次数
ans = 10 ** 9
for i in range(n):
ans = min(ans, dp[i][state - 1])

# 输出结果，如果ans仍然是初始值，说明无法访问所有景点，输出0，否则输出ans
if ans == 10 ** 9:
print(0)
else:
print(ans)

cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int main() {
// 读取景点数量
int n;
cin >> n;

// 读取公交路线的二维数组
vector<vector<int>> edge(n, vector<int>(n));
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
cin >> edge[i][j];
}
}

// 初始化距离数组dist，初始值设为一个很大的数（INT_MAX），表示不可达
vector<vector<int>> dist(n, vector<int>(n, INT_MAX));
for (int i = 0; i < n; i++) {
dist[i][i] = 0;
}

// 根据输入的公交线路设置初始直达距离
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (edge[i][j] == 1) {
dist[i][j] = 1;
}
}
}

// 使用Floyd-Warshall算法计算所有景点之间的最短路径
for (int k = 0; k < n; k++) {
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX) {
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
}
}
}
}

// 使用状态压缩DP来记录到达每个状态时的最少公交次数
int state = 1 << n;
vector<vector<int>> dp(n, vector<int>(state, INT_MAX));

// 初始化DP状态，每个景点作为起点时的状态
for (int i = 0; i < n; i++) {
dp[i][1 << i] = 0;
}

// 遍历所有可能的状态i（从1到2^n-1）
for (int i = 1; i < state; i++) {
for (int j = 0; j < n; j++) {
if ((i & (1 << j)) == 0) continue;
int last = i ^ (1 << j);
for (int k = 0; k < n; k++) {
if ((last & (1 << k)) == 0 || dp[k][last] == INT_MAX || dist[k][j] == INT_MAX) continue;
dp[j][i] = min(dp[j][i], dp[k][last] + dist[k][j]);
}
}
}

// 最终答案，遍历所有景点，在访问所有景点的状态（state - 1）下找到最小公交次数
int ans = INT_MAX;
for (int i = 0; i < n; i++) {
ans = min(ans, dp[i][state - 1]);
}

// 输出结果，如果ans仍然是初始值，说明无法访问所有景点，输出0，否则输出ans
if (ans == INT_MAX) {
cout << 0 << endl;
} else {
cout << ans << endl;
}

return 0;
}

OJ会员可以通过点击题目上方《已通过》查看其他通过代码来学习。

---

### 第3题-起点交换机选择（P2254）
- 链接：https://codefun2000.com/p/P2254

> 页面标题：#P2254. 第3题-起点交换机选择

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

公司机房内由多台交换机树状组网，当前管理员想从这些交换机中选择一台起点交换机作为公网接入点，要求起点交换机到其他交换机最大跳数最小，请输出这个跳数最小值。
例如，当下面第一张图选取 333 号交换机作为起点交换机时，333 号交换机到 111 号和 444 号交换机跳数为 111 ，到 222 号、 555 号和 666 号交换机跳数为 222 ，则跳数最小值为 222 。

输入描述
第一行一个正整数 n(1≤n≤105)n(1 ≤n ≤ 10^5)n(1≤n≤105)，表示 nnn 个交换机的编号从 111 到 nnn 。
接下来 n−1n-1n−1 行每行两个正整数 ,x,y(1≤x,y≤n)x,y(1≤x,y≤n)x,y(1≤x,y≤n),表示有一
条连接 x,yx,yx,y 的边。
输出描述
一个正整数表示跳数最小值。
样例1
输入
7
1 2
1 3
3 4
4 5
4 6
4 7

输出
2

说明
请参考题目描述第一张图， 333 号交换机作为树的根节点后，树的深度为 222 。
样例2
输入
8
1 2
1 3
3 4
3 5
5 6
5 7
7 8

输出
3

说明
请参考题目描述第二张图，选择  333 号或 555 号交换机作为树的根节点后，树的深度为 333 。

#### TextSol

题目描述
在公司机房中，有 nnn 台交换机以树形结构连接，交换机的编号从 111 到 nnn。管理员希望选择一台交换机作为公网接入点（即树的根节点），使得这台交换机到其他任意交换机的最大跳数最小。请计算并输出这个最小的最大跳数。
思路
在树形结构中，最远的两点之间的路径长度称为树的直径。为了使根节点到其他所有节点的最大跳数最小，应将根节点放在直径的中间位置（即树的中心）。这样，根节点到最远节点的距离就是直径的一半，可能为整数或半整数。由于跳数必须是整数，所以我们取整数部分再加一，即最小的最大跳数为 (直径 + 1) / 2。因此，把边权设置为1，树形dp或者dfs,bfs求树的直径，答案为(树的直径+1)/2，这里提供bfs解法
cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

// 定义常量表示最大节点数量
const int MAXN = 100005;

// 邻接表存储树
vector<int> adj[MAXN];

// BFS 函数，返回最远的节点和距离
pair<int, int> bfs(int start, int n) {
vector<int> dist(n + 1, -1);
queue<int> q;
q.push(start);
dist[start] = 0;

int far_node = start;
while (!q.empty()) {
int u = q.front();
q.pop();
for (int v : adj[u]) {
if (dist[v] == -1) {
dist[v] = dist[u] + 1;
q.push(v);
if (dist[v] > dist[far_node]) {
far_node = v;
}
}
}
}
return {far_node, dist[far_node]};
}

int main() {
int n;
cin >> n;

// 读取边信息，构建邻接表
for (int i = 0; i < n - 1; ++i) {
int x, y;
cin >> x >> y;
adj[x].push_back(y);
adj[y].push_back(x);
}

// 第一次 BFS，找到最远的节点 u
auto p1 = bfs(1, n);

// 第二次 BFS，从节点 u 出发，找到最远的节点 v
auto p2 = bfs(p1.first, n);

// 计算半径
int diameter = p2.second;
int radius = (diameter + 1) / 2;

// 输出结果
cout << radius << endl;

return 0;
}

python
import sys
import threading
def main():
import sys
sys.setrecursionlimit(1 << 25)
n = int(sys.stdin.readline())
adj = [[] for _ in range(n + 1)]
for _ in range(n - 1):
x, y = map(int, sys.stdin.readline().split())
adj[x].append(y)
adj[y].append(x)

from collections import deque

def bfs(start):
dist = [-1] * (n + 1)
q = deque()
q.append(start)
dist[start] = 0
far_node = start
while q:
u = q.popleft()
for v in adj[u]:
if dist[v] == -1:
dist[v] = dist[u] + 1
q.append(v)
if dist[v] > dist[far_node]:
far_node = v
return far_node, dist[far_node]

u, _ = bfs(1)
v, diameter = bfs(u)
radius = (diameter + 1) // 2
print(radius)

threading.Thread(target=main).start()

java
import java.util.*;
public class Main {
static List<Integer>[] adj;
static int n;

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
adj = new ArrayList[n + 1];
for(int i = 0; i <= n; i++) {
adj[i] = new ArrayList<>();
}
for(int i = 0; i < n -1; i++) {
int x = sc.nextInt();
int y = sc.nextInt();
adj[x].add(y);
adj[y].add(x);
}

int[] p1 = bfs(1);
int[] p2 = bfs(p1[0]);

int diameter = p2[1];
int radius = (diameter + 1) / 2;
System.out.println(radius);
}

// BFS 函数，返回最远的节点和距离
static int[] bfs(int start) {
int[] dist = new int[n + 1];
Arrays.fill(dist, -1);
Queue<Integer> q = new LinkedList<>();
q.offer(start);
dist[start] = 0;
int far_node = start;

while(!q.isEmpty()) {
int u = q.poll();
for(int v : adj[u]) {
if(dist[v] == -1) {
dist[v] = dist[u] + 1;
q.offer(v);
if(dist[v] > dist[far_node]) {
far_node = v;
}
}
}
}
return new int[]{far_node, dist[far_node]};
}
}

---

### 第3题-大礼包（P2257）
- 链接：https://codefun2000.com/p/P2257

> 页面标题：#P2257. 第3题-大礼包

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某公司对新用户推出大礼包，从任意一天注册开始，连续登录xxx天，每天可以领取一定的金币，领取金币的数量与该公司新设计的虚假世界的日历相关，该日历一年有nnn个月，第iii个月有did_idi​天，每一年都一样。在每个月第一天会得到111个金币，第天会得到222个金币币第三天会得到333个金币，后面次类推。
请计算新用户注册后连续登陆xxx天，最多可以获取多少金币。
请注意，连续登陆可能会跨年。
输入描述
第一行包含两个整数nnn和x(1≤n≤2∗105)x(1\leq n\leq 2*10^{5})x(1≤n≤2∗105)，分别表示一年中的月数和连续登陆的天数。
第二行包含 nnn 个整数 d1,d2,...,dnd_1,d_2,...,d_nd1​,d2​,...,dn​，did_idi​表示第iii个月的天数(1≤di≤1061 ≤ d_i ≤ 10^{6}1≤di​≤106)
用例保证，1≤x≤d1+d2+...+dn1 \leq x \leq  d_1+ d_2 + ...+ d_n1≤x≤d1​+d2​+...+dn​。
输出描述
打印新用户连续号陆x天最多可以获取的金币数量
样例1
输入
3 2
1 3 1

输出
5

解释
一年中每天获取的金币数是{1,1,2,3,1}\{1,1,2,3,1\}{1,1,2,3,1}(对应每个月中的天数)。如果在一年中的第333天开始注册陆，最多可以获取 2+3=52+3=52+3=5 个金币。
样例2
输入
3 6
3 3 3

输出
12

解释
一年中每天获取的金币数是{1,2,3,1,2,3,1,2,3}\{1,2,3,1,2,3,1,2,3\}{1,2,3,1,2,3,1,2,3}(对应每个月中的天数)。如果在一年中的第12天开始注册登陆，最多可以获取3+1+2+3+1+2=123+1+2+3+1+2=123+1+2+3+1+2=12个金币.
样例3
输入
5 6
4 2 3 1 3

输出
15

解释
一年中每天获取的金币数是{1,2,3,4,1,2,1,2,3,1,1,2,3}\{1,2,3,4,1,2,1,2,3,1,1,2,3\}{1,2,3,4,1,2,1,2,3,1,1,2,3}(对应每个月中的天数)。如果在一年中的第12天开始注册登陆，最多可以获取2+3+1+2+3+4=152+3+1+2+3+4=152+3+1+2+3+4=15个金币

▶️

#### TextSol

video solution

题面描述:
某公司为新用户推出大礼包，用户从任意一天注册后，可以连续登录xxx天并领取金币。金币数量与一年中nnn个月的日历相关，每个月第一天得1个金币，第二天得2个金币，以此类推。输入包含月数nnn和连续登录天数xxx，以及每个月的天数d1,d2,…,dnd_1, d_2, \ldots, d_nd1​,d2​,…,dn​。要求计算用户在注册后连续登录xxx天，最多可以获得的金币总数，且连续登录可能跨年。
题解
塔子哥希望找到连续 x 天内可以获得最多金币的方案。为了实现这一目标，我们的日历数据是一个长度为 n 的数组 d，其中每个元素表示每个月的天数。由于塔子哥可以跨越到下一年的第一个月，因此我们需要考虑跨年情况。为了解决这个问题，我们采用了以下思路：

双倍日历数组：将日历数组 d 复制一份，形成一个长度为 2n 的数组。这一做法确保我们可以在任何地方找到长度为 x 的连续天数，并且能够平滑地处理跨年情况。

滑动窗口算法：我们通过滑动窗口的方式来计算在不同起点下，连续 x 天可以获得的金币总数。窗口的初始位置从 0 开始，每次移动一格，尝试不同的起点。

动态调整窗口：在窗口滑动过程中，维护当前窗口中的天数和金币总和。如果当前窗口内的天数和大于 x，则从左侧移除天数，直到窗口中的天数和小于等于 x。

计算金币总数：当窗口天数和恰好等于 x 时，直接记录当前金币总和；如果小于 x，则计算剩余天数并用 sumup() 方法加上右侧不足的金币数。

更新最优解：每次计算得到的总金币数与当前的最优解比较，保留最大值。

代码解释

get(int n) 函数：计算从 1 到 n 的金币数量，这里使用了高效的数学公式。

主函数逻辑：

输入 n 和 x，以及每个月的天数，并创建一个长度为 2n 的数组。
使用滑动窗口遍历双倍数组，每次更新当前窗口的天数和金币总数。
通过动态调整窗口的左侧，确保总天数不超过 x。
计算当前窗口的金币总数，并实时更新最大金币数量 res。

时间复杂度
该算法的时间复杂度为 (O(n))，每个元素最多被访问两次，因此可以在线性时间内找到答案。
代码实现
C++代码
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 400010;  // 2倍日历数组的最大长度
typedef long long LL;

// 计算从1到n的和，用于金币数量计算
LL get(int n) {
return (1ll + n) * n / 2;  // 使用公式计算1到n的和
}

int main() {
LL n, x;
cin >> n >> x;  // 输入月数和连续登录天数

// 定义2倍长度数组，并输入日历数据
LL a[N * 2];  // 双倍长度的数组
for(int i = 0; i < n; i++) {
cin >> a[i];  // 输入每个月的天数
a[i + n] = a[i]; // 复制一份，形成双倍数组
}

LL s = 0;  // 当前窗口的总天数
LL res = 0;  // 最优解，最大金币数
LL t = 0;  // 当前窗口的金币总数

// 滑动窗口遍历数组
for(int i = 0, j = 0; i < 2 * n; ++i) {
s += a[i];  // 更新当前窗口的天数和
t += get(a[i]);  // 计算当前天数的金币数量并累加到总金币数

// 动态调整窗口，保持总天数不超过x
while (s - a[j] >= x) {
s -= a[j];  // 从窗口左侧移除天数
t -= get(a[j++]);  // 移除相应的金币数量
}

// 计算当前窗口金币数并更新最优解
res = max(res, t - get(s - x));  // 如果窗口的天数小于x，计算缺失部分金币并更新结果
}

cout << res << endl;  // 输出最大金币数
return 0;
}

Python代码
# 计算从 l 到 r 的连续整数和
def sumup(l, r):
return r * (r + 1) // 2 - l * (l - 1) // 2

# 输入日历长度和连续天数
n, x = map(int, input().split())
d = list(map(int, input().split()))
d += d  # 复制日历数据以处理跨年情况

ans = 0  # 初始化答案为0
cursum = 0  # 当前窗口天数和
cur = 0  # 当前窗口金币总数
l = 0  # 左窗口边界

# 滑动窗口遍历
for i in range(n * 2):
cursum += d[i]
cur += d[i] * (d[i] + 1) // 2

# 若窗口天数和超过 x ，从左边界移除
while cursum > x:
cursum -= d[l]
cur -= d[l] * (d[l] + 1) // 2
l += 1

# 计算当前窗口金币数并更新最优解
curans = cur
cnt = x - cursum
if l > 0:
curans += sumup(d[l - 1] - cnt + 1, d[l - 1])
ans = max(ans, curans)

print(ans)

Java代码
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
long x = scanner.nextLong();
long[] d = new long[2 * n];

// 读取日历数据并复制一份
for (int i = 0; i < n; i++) {
d[i] = scanner.nextLong();
d[i + n] = d[i];
}

long dayCnt = 0;  // 当前窗口的总天数
long coinSum = 0;  // 当前窗口金币总数
int j = 0;  // 左窗口边界
long ans = 0;  // 最大金币数

// 滑动窗口遍历日历数组
for (int i = 0; i < 2 * n; i++) {
dayCnt += d[i];
coinSum += d[i] * (1 + d[i]) / 2;

// 动态调整窗口大小
while (dayCnt > x) {
dayCnt -= d[j];
coinSum -= d[j] * (1 + d[j]) / 2;
j++;
}

// 计算当前窗口金币数并更新最优解
long rest = x - dayCnt;
long curans = coinSum;
if (j > 0) {
curans += sumup(d[j - 1] - rest + 1, d[j - 1]);
}
ans = Math.max(ans, curans);
}

System.out.println(ans);
}

// 计算从 l 到 r 的和，用于补全天数
public static long sumup(long l, long r) {
return r * (r + 1) / 2 - l * (l - 1) / 2;
}
}

代码注释说明

滑动窗口和范围控制：窗口控制中，dayCnt 记录窗口中连续天数之和，若超过 x 天，则缩小左边界。
金币计算：每个元素 d[i] 对应的金币数为连续整数的和，可以通过公式 d[i] * (1 + d[i]) / 2 计算。
剩余天数计算：若窗口天数和小于 x，则调用 sumup() 计算剩余金币，以补全连续天数，使总天数等于 x。
最终输出：输出记录的最大金币数。

---

### 第3题-采摘水果（P2248）
- 链接：https://codefun2000.com/p/P2248

> 页面标题：#P2248. 第3题-采摘水果

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

果园里有各种果树，周末花花去果园里摘水果，果树的排列是一个 n∗nn*nn∗n 的网格，每个网格中的数据表示果树可以采摘的水果数量。
为了保证采摘果树有序不被破坏，采摘果树只能从 (0,0)(0,0)(0,0) 的位置出发，往某些特定的方向行走，直到走到 (n−1,n−1)(n-1,n-1)(n−1,n−1) 位置再回头，出发时只能向下或者向右行走，回头时只能向上或向左行走回到原始位置 (0,0)(0,0)(0,0)，由于某些果树未成熟，通过路障进行保护，不让通过，每颗果树只能采摘一次，即去的路上采摘回来路上可以经过但不可以采摘。采摘水果只能进行一次来回。

网格中的数字有如下含义:
1、000 表示没有果树可以采摘;
2、−1-1−1 表示果树未成熟不能通过;
3、其他数值表示可以采摘的水果数量。
请你帮忙统计，花花在果园里最多可以采摘的水果数量。
输入描述
输入第一行是 nnn 的大小，接下来输入 nnn 行，表示 n∗nn*nn∗n 的网格数量， nnn 的取值范围为 111 ~ 100100100 。
注意每个网格来回经过只能算采摘一次。
输出描述
输出最多可以采摘的水果数量。
样例1
输入
3
0 2 0
1 -1 0
3 0 1

输出
7

说明
路径 111 ：从 (0,0)(0,0)(0,0) 出发，向下、向下、向右、向右走到 (2,2)(2,2)(2,2) ，这一行程中采摘 555 个水果，然后向上、向上、向左、向左，返回起点，再采摘 222 个水果，共采摘 777 个水果。
如下图中红色的箭头是出发的线路，蓝色的箭头是回来的路线:

路径 222 ：从 (0,0)(0,0)(0,0) 出发，向右、向右、向下、向下走到 (2,2)(2,2)(2,2)，这一行程中采摘 333 个水果，然后向左、向左、向上、向上，返回起点，再采摘 444 个水果，共采摘 777 个水果。
两种路径均可
样例2
输入
4
2 0 1 -1
0 -1 3 1
2 0 1 0
4 -1 1 3

输出
14

说明
路径 111 ：从 (0,0)(0,0)(0,0) 出发，向右、向右、向下、向右、向下、向下走到 (3,3)(3,3)(3,3) ，这行程中采摘 101010 个水果，然后向左、向上、向左、向左、向上、向上，返回起点，再采摘 444 个水果，共采摘 141414 个水果。
提示
在指定的行走规则下输出最多的可以采集的水果数量，只有一次来回。

#### TextSol

题解
题面描述
果园里有一个 n×nn \times nn×n 的网格，每个网格中的数字表示该位置的果树可以采摘的水果数量：

0 表示没有果树可以采摘。
-1 表示果树未成熟，不能通过该位置。
其他正整数表示可以采摘的水果数量。

花花需要从起点 (0,0)(0,0)(0,0) 出发，按照以下规则进行采摘：

出发路径：只能向下或向右移动，直到到达终点 (n−1,n−1)(n-1,n-1)(n−1,n−1)。
回程路径：只能向上或向左移动，返回起点 (0,0)(0,0)(0,0)。

采摘水果时，每个果树只能采摘一次，即在出发和回程路径中，同一位置的水果只能被采摘一次。回程路径可以经过已采摘的果树，但不能再次采摘。
目标是找到一条满足上述条件的路径，使得花花可以采摘到的水果总数最大。
思路
这道题与经典的“樱桃采摘”问题类似。我们可以将整个来回采摘过程视为两个人从起点同时出发，最终同时到达终点的过程。为了避免重复采摘同一位置的水果，我们需要确保两条路径上相同位置的水果只被采摘一次。
具体来说，可以使用动态规划的方法来解决这个问题。设定一个三维的 DP 数组 dp[k][i][j]，其中：

k 表示当前的步数。
i 和 j 分别表示两个人在第 k 步时的行位置。
根据步数 k 和行位置 i，可以确定两个人的列位置分别为 k - i 和 k - j。

状态转移方程需要考虑两个人的移动方向，并且处理位置重叠时水果只被采摘一次的情况。同时，需要考虑障碍物（-1）的存在，如果某一步的位置为 -1，则该状态无效。
状态转移详细分析
为了计算 dp[k][i][j] 的值，我们需要考虑两条路径在第 k 步时可以从哪些位置转移过来。具体来说，两条路径在第 k-1 步时可以分别位于 (i-1, k-1 - (i-1)) 或 (i, k-1 - i)，以及 (j-1, k-1 - (j-1)) 或 (j, k-1 - j)。
因此，状态转移方程可以表示为：

具体解释如下：

选择前一步的位置：

第一条路径可以从上方 (i-1, k-1 - (i-1)) 或左方 (i, k-1 - i) 移动到 (i, k-i)。
第二条路径可以从上方 (j-1, k-1 - (j-1)) 或左方 (j, k-1 - j) 移动到 (j, k-j)。

计算当前步的水果数量：

如果两条路径当前位置 (i, k-i) 和 (j, k-j) 是同一个位置，即 i == j 且 k-i == k-j，那么只采摘一次该位置的水果。
否则，分别采摘两条路径当前位置的水果，即 grid[i][k-i] + grid[j][k-j]。

考虑障碍物和无果树情况：

如果当前位置 (i, k-i) 或 (j, k-j) 有障碍物 -1，则该状态不可达，dp[k][i][j] 设为 -1。

cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
int n;
cin >> n;
vector<vector<int>> grid(n, vector<int>(n));
for(auto &row : grid) {
for(auto &cell : row) cin >> cell;
}

// 初始化DP数组，dp[k][i][j] 表示第k步时，两人分别在(i, k-i)和(j, k-j)位置的最大水果数
// 初始化所有状态为 -1，表示不可达
// 步数 k 从 0 到 2*(n-1)
vector<vector<vector<int>>> dp(2*n, vector<vector<int>>(n, vector<int>(n, -1)));

// 初始状态
if(grid[0][0] != -1){
dp[0][0][0] = grid[0][0];
}

// 遍历所有步数 k
for(int k = 1; k <= 2*(n-1); ++k){
for(int i = 0; i < n; ++i){
for(int j = 0; j < n; ++j){
// 根据步数k和行坐标i、j计算列坐标y1和y2
int y1 = k - i;
int y2 = k - j;
// 检查列坐标是否在范围内
if(y1 < 0 || y1 >= n || y2 < 0 || y2 >= n){
continue;
}
// 获取两个人的位置
int x1 = i, y_1 = y1;
int x2 = j, y_2 = y2;
// 如果当前位置有障碍，跳过
if(grid[x1][y_1] == -1 || grid[x2][y_2] == -1){
continue;
}
// 计算前一步的最大值
int res = -1;
// 两个人的前一步可以来自上方或左方，共四种组合
for(int pi = i-1; pi <= i; pi++){
for(int pj = j-1; pj <= j; pj++){
if(pi < 0 || pj < 0){
continue;
}
if(dp[k-1][pi][pj] == -1){
continue;
}
res = max(res, dp[k-1][pi][pj]);
}
}
if(res == -1){
continue;
}
// 计算当前步采摘的水果数
if(x1 == x2 && y_1 == y2){
// 如果两人在同一个位置，只采摘一次
res += grid[x1][y_1];
}
else{
// 不同位置，分别采摘
res += grid[x1][y_1] + grid[x2][y_2];
}
// 更新dp[k][i][j]的值
dp[k][i][j] = max(dp[k][i][j], res);
}
}
}

// 获取最终结果
int result = dp[2*(n-1)][n-1][n-1];
// 无需再减去终点的水果，因为在DP过程中已正确处理
cout << (result < 0 ? 0 : result);
}

python
import sys

def main():
n = int(sys.stdin.readline())
grid = []
for _ in range(n):
grid.append(list(map(int, sys.stdin.readline().split())))

# 初始化DP数组，dp[k][i][j] 表示第k步时，两人分别在(i, k-i)和(j, k-j)位置的最大水果数
dp = [[[-1 for _ in range(n)] for _ in range(n)] for _ in range(2*n)]

# 初始状态
if grid[0][0] != -1:
dp[0][0][0] = grid[0][0]

# 遍历所有步数 k
for k in range(1, 2*(n-1)+1):
for i in range(n):
for j in range(n):
y1 = k - i
y2 = k - j
# 检查列坐标是否在范围内
if y1 < 0 or y1 >= n or y2 < 0 or y2 >= n:
continue
x1, y_1 = i, y1
x2, y_2 = j, y2
# 如果当前位置有障碍，跳过
if grid[x1][y_1] == -1 or grid[x2][y_2] == -1:
continue
# 计算前一步的最大值
res = -1
for pi in [i-1, i]:
for pj in [j-1, j]:
if pi < 0 or pj < 0:
continue
if dp[k-1][pi][pj] == -1:
continue
res = max(res, dp[k-1][pi][pj])
if res == -1:
continue
# 计算当前步采摘的水果数
if x1 == x2 and y_1 == y2:
# 如果两人在同一个位置，只采摘一次
res += grid[x1][y_1]
else:
# 不同位置，分别采摘
res += grid[x1][y_1] + grid[x2][y_2]
# 更新dp[k][i][j]的值
dp[k][i][j] = max(dp[k][i][j], res)

# 获取最终结果
result = dp[2*(n-1)][n-1][n-1]
# 无需再减去终点的水果，因为在DP过程中已正确处理
print(max(result, 0))

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main{
public static void main(String[] args){
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();
int[][] grid = new int[n][n];
for(int i=0;i<n;i++) {
for(int j=0;j<n;j++) {
grid[i][j] = sc.nextInt();
}
}

// 初始化DP数组，dp[k][i][j] 表示第k步时，两人分别在(i, k-i)和(j, k-j)位置的最大水果数
int[][][] dp = new int[2*n][n][n];
for(int k=0; k<2*n; k++){
for(int i=0; i<n; i++){
Arrays.fill(dp[k][i], -1);
}
}

// 初始状态
if(grid[0][0] != -1){
dp[0][0][0] = grid[0][0];
}

// 遍历所有步数 k
for(int k=1; k<=2*(n-1); k++){
for(int i=0; i<n; i++){
for(int j=0; j<n; j++){
int y1 = k - i;
int y2 = k - j;
// 检查列坐标是否在范围内
if(y1 < 0 || y1 >= n || y2 < 0 || y2 >= n){
continue;
}
int x1 = i, y_1 = y1;
int x2 = j, y_2 = y2;
// 如果当前位置有障碍，跳过
if(grid[x1][y_1] == -1 || grid[x2][y_2] == -1){
continue;
}
// 计算前一步的最大值
int res = -1;
// 两个人的前一步可以来自上方或左方，共四种组合
for(int pi = i-1; pi <= i; pi++){
for(int pj = j-1; pj <= j; pj++){
if(pi < 0 || pj < 0){
continue;
}
if(dp[k-1][pi][pj] == -1){
continue;
}
res = Math.max(res, dp[k-1][pi][pj]);
}
}
if(res == -1){
continue;
}
// 计算当前步采摘的水果数
if(x1 == x2 && y_1 == y2){
// 如果两人在同一个位置，只采摘一次
res += grid[x1][y_1];
}
else{
// 不同位置，分别采摘
res += grid[x1][y_1] + grid[x2][y_2];
}
// 更新dp[k][i][j]的值
dp[k][i][j] = Math.max(dp[k][i][j], res);
}
}
}

// 获取最终结果
int result = dp[2*(n-1)][n-1][n-1];
// 无需再减去终点的水果，因为在DP过程中已正确处理
System.out.println(result < 0 ? 0 : result);
}
}

---

### 第3题-小明踢足球（P2251）
- 链接：https://codefun2000.com/p/P2251

> 页面标题：#P2251. 第3题-小明踢足球

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明在一个足球场上踢球。他需要绕过障碍物把球踢到门里。
足球场用大小为M∗MM*MM∗M的正方形网格表示，其中每个元素可以是空地、障碍物、球或者是球门:

小明用字母'XXX'表示，只要他在空地里面，就可以上下左右四个方向移动。

空地用字母'000'表示，在空地上可以自由行走。

障碍物用字母'111'表示，意味着不能通行，可能有多个障碍物。

足球用字符'BBB' 表示，球场上只有111个球。

球门用字符'GGG' 表示，球场上只有111个球门。
踢球方式:初始时小明和球可能不相邻，小明首先需要走到球的位置才能开始踢球;当移动到球边(相邻格子)后，然后继续向着球的方向移动，球会被踢到同方向相邻格的位置，即:球移动的方向只能与小明移动的方向相同，一次移动一格。
注:如果球移动前方会碰到障碍物或者边界，那么此次踢球无效，小明和球的位置均会保持不变。
举例:小明首先移动到球左侧的相邻格子，然后再向右移动到球当前所在格子(意味
着踢了一脚球)，那么球就会移动到当前格的右侧一格(算作踢球一次)、且只能移动
到右侧格子。如果小明从球下方朝上移动到当前球所在格子，那么球会移动到当前格
的上方一格。
小明需要持续移动最终把球踢到门所在的格子内。返回小明把球踢到门里需要踢球的最少次数，若无法踢到门中，返回−1-1−1。
注意:足球每移动一次算做一次踢球，小明自己移动没有踢球的情况下不算踢球次
数。

输入描述
输入第一行输入一个正整数M(5<=M<=20)M(5<=M<=20)M(5<=M<=20)。
接下来输入111个M∗MM*MM∗M的矩阵,一共M行，每行MMM个字符。
数组的行列M 取值范围5<=m<=20<=m<=20<=m<=20
数组中仅包含字符'000'，'111','BBB','GGG',以及'XXX'。
数组中'XXX'，'BBB'和'GGG'各只能出现一个。。
输出描述
返回小明把球踢到门中需要踢球的最少次数
样例1
输入
5
0 0 0 0 0
0 0 0 0 G
0 0 B 0 0
X 1 0 0 0
0 0 0 0 0

输出
3

说明
小明把球踢到门里最少需要踢333次球。
样例2
输入
5
0 0 0 0 0
0 0 0 0 G
1 0 B 0 0
X 1 0 0 0
1 0 0 0 0

输出
-1

说明
小明无法把球踢到门里

▶️

#### TextSol

video solution

题解
问题分析
在一个 m * m 的网格中，小明需要踢球，球经过障碍物和边界会停下。目标是计算小明将球踢入球门的最少踢球次数，若无法将球踢入球门则返回 -1。为了记录状态，我们需要四个变量来存储小明和球的位置。
解题思路:0-1 BFS

多维度状态记录：

使用 dist[x][y][fx][fy] 数组记录小明和球在不同位置的最小踢球次数。这里 x, y 表示小明的位置，fx, fy 表示球的位置。
初始值 -1 表示该状态未被访问。

初始化位置：

通过遍历网格，找到小明、球和球门的初始坐标，分别记为 (sx, sy)、(fx, fy)、(ex, ey)。

0-1 BFS 队列初始化：

使用双端队列 deque 实现 0-1 BFS。
初始时，将小明和球的位置 (sx, sy, fx, fy) 入队，并将 dist[sx][sy][fx][fy] 初始化为 0，表示从起始状态出发，最少踢球次数为 0。

状态转移过程：

进行 BFS 扩展时，遍历小明的四个移动方向 (dx, dy)。
小明移动：

对于每一个方向，计算小明移动后的新位置 (nx, ny)，跳过超出边界或遇到障碍物的位置。
如果小明移动后的位置与球的当前位置相同，表示要踢球。

计算球在踢动后的位置 (nnx, nny)，并检查新位置的有效性（不超出边界且不是障碍物）。
如果 dist[nx][ny][nnx][nny] == -1，则更新 dist 并将新状态加入队列尾部（踢球算作一步，因此边权为 1）。
若球的位置达到球门，则更新 ans 为当前的踢球次数，并返回。

如果小明移动后没有踢球（nx, ny 位置与球不同），则直接将新状态入队列头部（边权为 0）。

返回结果：

若找到最短路径，则返回 ans。若搜索结束未找到可行路径，则返回 -1。

代码解析
from collections import deque

m = int(input())
arr = [list(map(str, input().split())) for _ in range(m)]

# 初始化小明、球和球门的位置
sx, sy, ex, ey, fx, fy = 0, 0, 0, 0, 0, 0
for i in range(m):
for j in range(m):
if arr[i][j] == 'B':
fx, fy = i, j
if arr[i][j] == 'G':
ex, ey = i, j
if arr[i][j] == 'X':
sx, sy = i, j

# 移动方向
dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

# 4维距离数组，记录状态
dist = [[[[-1] * m for _ in range(m)] for _ in range(m)] for _ in range(m)]

def bfs():
global sx, sy, ex, ey, fx, fy
q = deque()
q.append((sx, sy, fx, fy))
dist[sx][sy][fx][fy] = 0
ans = -1

while q:
x, y, fx, fy = q.popleft()
for i in range(4):
nx, ny = x + dx[i], y + dy[i]
if nx < 0 or nx >= m or ny < 0 or ny >= m or arr[nx][ny] == '1':
continue
# 检查是否需要踢球
if nx == fx and ny == fy:
nnx, nny = fx + dx[i], fy + dy[i]
if nnx < 0 or nnx >= m or nny < 0 or nny >= m or arr[nnx][nny] == '1':
continue
if dist[nx][ny][nnx][nny] == -1:
dist[nx][ny][nnx][nny] = dist[x][y][fx][fy] + 1
q.append((nx, ny, nnx, nny))
if nnx == ex and nny == ey:
if ans == -1 or ans > dist[nx][ny][nnx][nny]:
ans = dist[nx][ny][nnx][nny]
return ans
else:
if dist[nx][ny][fx][fy] == -1:
dist[nx][ny][fx][fy] = dist[x][y][fx][fy]
q.appendleft((nx, ny, fx, fy))

return -1

print(bfs())

cpp
#include <iostream>
#include <deque>
#include <vector>
#include <cstring>
using namespace std;

int m; // 地图的大小
vector<vector<string>> arr; // 存储地图
int sx, sy, ex, ey, fx, fy; // 小明起始位置(sx, sy)，球门位置(ex, ey)，球位置(fx, fy)
int dx[] = {0, 0, 1, -1}; // 四个方向的横坐标变化量
int dy[] = {1, -1, 0, 0}; // 四个方向的纵坐标变化量
int dist[50][50][50][50]; // 记录每个状态的最短距离

// BFS函数
int bfs() {
deque<tuple<int, int, int, int>> q; // 队列存储当前状态
q.push_back({sx, sy, fx, fy}); // 将起始位置入队
dist[sx][sy][fx][fy] = 0; // 初始化距离
int ans = -1; // 最终答案，若无法到达则为-1

// BFS循环
while (!q.empty()) {
auto [x, y, fx, fy] = q.front(); // 获取队首的状态
q.pop_front(); // 队首出队

for (int i = 0; i < 4; ++i) { // 遍历四个方向
int nx = x + dx[i], ny = y + dy[i]; // 计算新的位置
if (nx < 0 || nx >= m || ny < 0 || ny >= m || arr[nx][ny] == "1") continue; // 超出边界或遇到障碍物

// 如果新位置是球的位置，则尝试踢球
if (nx == fx && ny == fy) {
int nnx = fx + dx[i], nny = fy + dy[i]; // 计算踢球后新的球位置
if (nnx < 0 || nnx >= m || nny < 0 || nny >= m || arr[nnx][nny] == "1") continue; // 如果踢球位置超出边界或遇到障碍
if (dist[nx][ny][nnx][nny] == -1) { // 如果该状态未被访问
dist[nx][ny][nnx][nny] = dist[x][y][fx][fy] + 1; // 更新距离
q.push_back({nx, ny, nnx, nny}); // 将新状态入队
if (nnx == ex && nny == ey) { // 如果球已经进了球门
if (ans == -1 || ans > dist[nx][ny][nnx][nny]) {
ans = dist[nx][ny][nnx][nny]; // 更新最短路径
return ans; // 直接返回答案
}
}
}
} else { // 如果没有踢球，直接移动
if (dist[nx][ny][fx][fy] == -1) { // 如果该状态未被访问
dist[nx][ny][fx][fy] = dist[x][y][fx][fy]; // 保持距离不变
q.push_front({nx, ny, fx, fy}); // 将新的移动状态加入队列
}
}
}
}
return -1; // 如果找不到解，返回-1
}

int main() {
cin >> m; // 输入地图大小
arr.resize(m, vector<string>(m)); // 初始化地图
// 读取地图数据，并找到起始位置、小明位置、球位置和球门位置
for (int i = 0; i < m; ++i) {
for (int j = 0; j < m; ++j) {
cin >> arr[i][j];
if (arr[i][j] == "B") {
fx = i, fy = j; // 球的位置
}
if (arr[i][j] == "G") {
ex = i, ey = j; // 球门的位置
}
if (arr[i][j] == "X") {
sx = i, sy = j; // 小明的位置
}
}
}

memset(dist, -1, sizeof(dist)); // 初始化dist数组为-1
cout << bfs() << endl; // 执行BFS并输出结果

return 0;
}

java
import java.util.*;

public class Main {
static int m; // 地图的大小
static String[][] arr; // 存储地图
static int sx, sy, ex, ey, fx, fy; // 小明起始位置(sx, sy)，球门位置(ex, ey)，球位置(fx, fy)
static int[] dx = {0, 0, 1, -1}; // 四个方向的横坐标变化量
static int[] dy = {1, -1, 0, 0}; // 四个方向的纵坐标变化量
static int[][][][] dist = new int[50][50][50][50]; // 记录每个状态的最短距离

// BFS函数
public static int bfs() {
Deque<int[]> q = new ArrayDeque<>(); // 队列存储当前状态
q.add(new int[]{sx, sy, fx, fy}); // 将起始位置入队
dist[sx][sy][fx][fy] = 0; // 初始化距离
int ans = -1; // 最终答案，若无法到达则为-1

// BFS循环
while (!q.isEmpty()) {
int[] front = q.poll(); // 获取队首的状态
int x = front[0], y = front[1], fx = front[2], fy = front[3];

for (int i = 0; i < 4; i++) { // 遍历四个方向
int nx = x + dx[i], ny = y + dy[i]; // 计算新的位置
if (nx < 0 || nx >= m || ny < 0 || ny >= m || arr[nx][ny].equals("1")) continue; // 超出边界或遇到障碍物

// 如果新位置是球的位置，则尝试踢球
if (nx == fx && ny == fy) {
int nnx = fx + dx[i], nny = fy + dy[i]; // 计算踢球后新的球位置
if (nnx < 0 || nnx >= m || nny < 0 || nny >= m || arr[nnx][nny].equals("1")) continue; // 如果踢球位置超出边界或遇到障碍
if (dist[nx][ny][nnx][nny] == -1) { // 如果该状态未被访问
dist[nx][ny][nnx][nny] = dist[x][y][fx][fy] + 1; // 更新距离
q.add(new int[]{nx, ny, nnx, nny}); // 将新状态入队
if (nnx == ex && nny == ey) { // 如果球已经进了球门
if (ans == -1 || ans > dist[nx][ny][nnx][nny]) {
ans = dist[nx][ny][nnx][nny]; // 更新最短路径
return ans; // 直接返回答案
}
}
}
} else { // 如果没有踢球，直接移动
if (dist[nx][ny][fx][fy] == -1) { // 如果该状态未被访问
dist[nx][ny][fx][fy] = dist[x][y][fx][fy]; // 保持距离不变
q.addFirst(new int[]{nx, ny, fx, fy}); // 将新的移动状态加入队列
}
}
}
}
return -1; // 如果找不到解，返回-1
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
m = sc.nextInt(); // 输入地图大小
arr = new String[m][m]; // 初始化地图
// 读取地图数据，并找到起始位置、小明位置、球位置和球门位置
for (int i = 0; i < m; i++) {
for (int j = 0; j < m; j++) {
arr[i][j] = sc.next();
if (arr[i][j].equals("B")) {
fx = i; fy = j; // 球的位置
}
if (arr[i][j].equals("G")) {
ex = i; ey = j; // 球门的位置
}
if (arr[i][j].equals("X")) {
sx = i; sy = j; // 小明的位置
}
}
}

// 初始化dist数组为-1
for (int[][][] layer1 : dist) {
for (int[][] layer2 : layer1) {
for (int[] layer3 : layer2) {
Arrays.fill(layer3, -1);
}
}
}

System.out.println(bfs()); // 执行BFS并输出结果
}
}

总结
这段代码利用 0-1 BFS，通过多维数组跟踪每一种状态下的最少踢球次数，并在每次移动和踢球时更新队列与状态。小明的移动不增加踢球次数，因此使用双端队列进行操作，而每次踢球则计为一次操作（边权为 1）。通过这种方法，代码实现了最短路径的查找。

---

### 第3题-新能源汽车充电桩建设策略（P2602）
- 链接：https://codefun2000.com/p/P2602

> 页面标题：#P2602. 第3题-新能源汽车充电桩建设策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

随着新能源汽车的蓬勃发展，新能源汽车充电桩的覆盖密度越来越重要。某汽车公司建设充电桩的思路如下:
一条高速沿线，每个区域建设一个充电站，充电站内有多个充电桩，充电站之间保持合理的距离，每个充电站可以覆盖相邻范围的多个区域
我们使用nnn来表示区域充电站的数目，使用station[i]station[i]station[i]数组表示第i个充电站中充电桩的数目。
给定一个范围rrr，iii区域可以被附近范围内的充电站覆盖，∣i−j∣<=r,0<=i,j<=n−1,∣i−j∣|i-j|<=r,0<=i,j<=n-1,|i-j|∣i−j∣<=r,0<=i,j<=n−1,∣i−j∣表示绝对值。
因此覆盖区域的充电桩包括iii区域内充电站的充电桩以及满足上述覆盖条件区域jjj区域充电站的充电桩。
汽车公司打算在一些城市新增kkk个充电桩，如何分配这kkk个充电桩给充电站，使得所有区域总，被充电桩覆盖最少区域的充电桩数目最大化。
输入描述
第一行输入为nnn，表示有nnn个充电站区域，取值范围[0,100000][0,100000][0,100000]
第二行输入为station[n]为station[n]为station[n]数组，表示n个充电站中充电桩的数目[0,100000][0,100000][0,100000]
第三行输入为rrr，表示充电站可覆盖的相邻区域的范围[0,n−1][0,n-1][0,n−1]
第四行输入为kkk，表示需要新增的充电桩数目[0,1000000000][0,1000000000][0,1000000000]
输出描述
输出被充电桩覆盖最少的区域的充电桩的数目
样例1
输入
5
1 2 4 5 0
1
2

输出
5

说明
最优方案是把222个充电桩都放在充电站111，这样每个充电站的充电桩数目分别为1 4 4 5 01\ 4\  4\ 5\ 01 4 4 5 0。

区域000的覆盖充电桩为1+4=51+4=51+4=5,
区域111为1+4+4=91+4+4=91+4+4=9，
区域222为4+4+5=134+4+5=134+4+5=13，
区域333为5+4=95+4=95+4=9，
区域444为5+0=55+0=55+0=5

充电桩覆盖数目最少是555
无法得到更优解，所以我们返回555。
样例2
输入
4
4 4 4 4
0
2

输出
4

说明
无论怎么分配新增的333个充电站，总有一个区域的充电桩覆盖数目是444

#### TextSol

题目描述
在一座城市中，划分为多个区域，每个区域内建设一个充电站，充电站内设有多个充电桩，充电站之间需要保持合理的距离。定义：

n：区域充电站的数目。
station[i]：表示第 i 个充电站中充电桩的数量。
r：充电站可覆盖的相邻区域范围，满足条件 |i-j| <= r。
k：需要新增的充电桩数量。

我们的目标是合理分配这 k 个新增充电桩，使得所有区域总的被充电桩覆盖最少区域的充电桩数目最大化。
思路：二分+贪心+差分
二分每个区域被覆盖的最小充电桩数量，每个区域至少需要这么多的充电桩数量，对于给定的最低充电桩数量，判断是否可以在只分配k个充电桩的情况下实现。
贪心的做法是从左到右遍历，计算当前区域的充电桩数量，如果低于最低充电桩数量，则尽量放置充电桩在最右侧的区域，因为这样可以让右边更多的区域增加充电桩。
由于计算当前区域的充电桩数量需要累计附近的充电桩，所以每个区域的充电桩其实可以视为对一个区间的区域进行累加，在遍历过程中维护当前的充电桩数量比较简单，所以建议采用差分的方式来计算累计充电桩。
解题思路

二分法：我们采用二分搜索的方式来找到可以实现的最低覆盖充电桩数量。设定左右边界，L 为 0，R 为一个合理的最大值（如 (2 \times 10^{10})），在这个范围内寻找最小的充电桩覆盖数量。

覆盖量计算：使用差分数组（或前缀和）来快速计算每个区域在覆盖范围内的充电桩数量。通过维护一个差分数组 d 来简化范围累加的计算。

贪心分配充电桩：在判断某个覆盖数量 x 是否可以实现时，优先从右侧区域向左分配充电桩。若当前区域的充电桩数量低于 x，则尽量在右侧的区域放置充电桩，尽可能使更多的区域得到覆盖。

算法步骤

初始化输入，包括区域数量 n、充电桩数量 a、覆盖范围 r 和需要新增的充电桩数量 k。
利用差分数组计算每个区域的实际覆盖充电桩数量。
实现一个函数 check，用于判断在给定的最低充电桩数量 x 下，是否能够通过分配最多 k 个充电桩实现该覆盖。
使用二分搜索来找到最大的 L，即最大的最低充电桩覆盖数量。

JavaScript
// 检查在新增k个充电桩的情况下是否可以实现至少x个覆盖数量
function check(d, r, x, n, k) {
let td = new Array(n + 1).fill(0); // 用于记录每个区域需要新增的充电桩数量
let cur = 0; // 当前新增的充电桩数量

// 遍历区域，从r开始，计算需要新增的充电桩数量
for (let i = r; i < n; i++) {
// 如果当前索引超出覆盖范围，减去相应的新增充电桩
if (i > 2 * r) {
cur -= td[i - 2 * r - 1];
}
// 如果当前区域的充电桩数量不足x，则需要新增充电桩
if (d[i - r] + cur < x) {
td[i] = x - d[i - r] - cur; // 计算需要新增的充电桩数量
cur += td[i]; // 更新当前的新增充电桩数量
}
}

// 存储实际覆盖的充电桩数量
let b = new Array(n + 1).fill(0);

// 更新覆盖数组b，计算每个区域的充电桩数量
for (let i = 0; i < n; i++) {
b[Math.max(i - r, 0)] += td[i]; // 更新覆盖范围
b[Math.min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算每个区域的实际覆盖数量
for (let i = 1; i < n; i++) {
b[i] += b[i - 1]; // 前缀和
}

let need = 0; // 记录最终需要的充电桩数量
// 在最后几个区域检查所需的充电桩数量
for (let i = n - r; i < n; i++) {
need = Math.max(need, x - b[i] - d[i]); // 计算需要增加的充电桩数量
}

// 更新最后需要的充电桩数量
b[Math.max(0, n - r - 1)] += need;

// 计算所有新增充电桩的总和
let sum = td.reduce((acc, val) => acc + val, 0);

// 判断总新增的充电桩是否小于等于k
return sum <= k;
}

// 使用readline模块从标准输入读取数据
let readline = require('readline');
let rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

// 提示用户输入区域数量n
rl.question("Enter n: ", function(n) {
n = parseInt(n); // 转换为整数
// 提示用户输入充电桩数量数组
rl.question("Enter array a: ", function(aStr) {
let a = aStr.split(' ').map(Number); // 将输入的字符串转换为数字数组
// 提示用户输入覆盖范围r
rl.question("Enter r: ", function(r) {
r = parseInt(r); // 转换为整数
// 提示用户输入需要新增的充电桩数量k
rl.question("Enter k: ", function(k) {
k = parseInt(k); // 转换为整数

// 初始化差分数组d
let d = new Array(n + 1).fill(0);

// 构造差分数组d
for (let i = 0; i < n; i++) {
d[Math.max(i - r, 0)] += a[i]; // 当前区域的充电桩数加到最左侧的覆盖区域
d[Math.min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (let i = 1; i < n; i++) {
d[i] += d[i - 1]; // 前缀和
}

let L = 0; // 二分搜索的下界
let R = 2e10; // 二分搜索的上界

// 二分搜索查找最大的最低覆盖充电桩数量
while (L < R) {
let mid = (L + R + 1) >> 1; // 计算中间值
// 调用check函数判断是否可以在k个充电桩内实现至少mid个覆盖数量
if (check(d, r, mid, n, k)) {
L = mid; // 如果可以实现，则更新下界
} else {
R = mid - 1; // 否则更新上界
}
}
// 输出最大的最低覆盖充电桩数量
console.log(L);
rl.close(); // 关闭readline接口
});
});
});
});

Java
import java.util.Scanner;

public class ChargingStations {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

// 读取区域数量
long n = scanner.nextLong();
long[] a = new long[(int) n]; // 存储每个充电站的充电桩数量

// 读取每个充电站中的充电桩数量
for (int i = 0; i < n; i++) {
a[i] = scanner.nextLong();
}

// 读取覆盖范围和新增充电桩数量
long r = scanner.nextLong();
long k = scanner.nextLong();

// 差分数组，长度为n+1
long[] d = new long[(int) (n + 1)];

// 构造差分数组d
for (int i = 0; i < n; i++) {
d[(int) Math.max(i - r, 0)] += a[i]; // 当前区域的充电桩数加到最左侧的覆盖区域
d[(int) Math.min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (int i = 1; i < n; i++) {
d[i] += d[i - 1]; // 前缀和
}

long L = 0; // 二分搜索的下界
long R = (long) 2e10; // 二分搜索的上界

// 二分搜索查找最大的最低覆盖充电桩数量
while (L < R) {
long mid = (L + R + 1) >> 1; // 计算中间值
// 调用check函数判断是否可以在k个充电桩内实现至少mid个覆盖数量
if (check(d, r, mid, n, k)) {
L = mid; // 如果可以实现，则更新下界
} else {
R = mid - 1; // 否则更新上界
}
}

// 输出最大的最低覆盖充电桩数量
System.out.println(L);
}

// 检查是否可以在新增k个充电桩的情况下使得覆盖数量至少为x
private static boolean check(long[] d, long r, long x, long n, long k) {
long[] td = new long[(int) (n + 1)]; // 用于记录需要新增的充电桩数量
long cur = 0; // 当前新增的充电桩数量

// 遍历区域，从r开始，计算需要新增的充电桩数量
for (long i = r; i < n; i++) {
// 如果当前索引超出覆盖范围，减去相应的新增充电桩
if (i > 2 * r) {
cur -= td[(int) (i - 2 * r - 1)];
}
// 如果当前区域的充电桩数量不足x，则需要新增充电桩
if (d[(int) (i - r)] + cur < x) {
td[(int) i] = x - d[(int) (i - r)] - cur; // 计算需要新增的充电桩数量
cur += td[(int) i]; // 更新当前的新增充电桩数量
}
}

// 存储实际覆盖的充电桩数量
long[] b = new long[(int) (n + 1)];

// 更新覆盖数组b，计算每个区域的充电桩数量
for (int i = 0; i < n; i++) {
b[(int) Math.max(i - r, 0)] += td[i]; // 更新覆盖范围
b[(int) Math.min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算每个区域的实际覆盖数量
for (int i = 1; i < n; i++) {
b[i] += b[i - 1]; // 前缀和
}

long need = 0; // 记录最终需要的充电桩数量
// 在最后几个区域检查所需的充电桩数量
for (long i = n - r; i < n; i++) {
need = Math.max(need, x - b[(int) i] - d[(int) i]); // 计算需要增加的充电桩数量
}

// 更新最后需要的充电桩数量
b[(int) Math.max(0, n - r - 1)] += need;
long sum = 0; // 计算新增充电桩的总数

// 计算所有新增充电桩的总和
for (long value : td) {
sum += value;
}

// 判断总新增的充电桩是否小于等于k
return sum <= k;
}
}

Python
n = int(input())
a = list(map(int, input().split()))
r = int(input())
k = int(input())
d = [0] * (n + 1)
for i, v in enumerate(a):
# 差分
d[max(i - r, 0)] += v
d[min(n, i + r + 1)] -= v
for i in range(1, n):
d[i] += d[i - 1]
L, R = 0, int(2e10)

def check(x):
td, cur = [0] * (n + 1), 0
b = [0] * (n + 1)
# 用cur维护当前附近范围增加的累计充电桩数量
for i in range(r, n):
if i > 2 * r:
# 超过2 * r的范围则需要减去
cur -= td[i - 2 * r - 1]
if d[i - r] + cur < x:
td[i] = x - d[i - r] - cur
cur += td[i]
for i, v in enumerate(td):
b[max(i - r, 0)] += v
b[min(n, i + r + 1)] -= v
for i in range(1, n):
b[i] += b[i - 1]
need = 0
for i in range(n - r, n):
need = max(need, x - b[i] - d[i])
td[max(0, n - r - 1)] += need
return sum(td) <= k

while L < R:
mid = L + R + 1 >> 1
if check(mid):
L = mid
else:
R = mid - 1
print(L)

C++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

void solve() {
int n, k, r;
cin >> n; // 输入区域数量
vector<int> a(n);
vector<LL> d(n + 1, 0); // 差分数组初始化

// 输入每个充电站的充电桩数量
for (int i = 0; i < n; ++i)
cin >> a[i];

cin >> r >> k; // 输入覆盖范围和需要新增的充电桩数量

// 计算差分数组
for (int i = 0; i < n; ++i) {
d[max(i - r, 0)] += a[i]; // 当前区域的充电桩数量加到其覆盖的最左侧区域
d[min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (int i = 1; i < n; ++i) {
d[i] += d[i - 1]; // 前缀和累加
}

LL L = 0, R = (LL)2e10; // 设置二分搜索的边界

// 判断是否可以实现的函数
function<bool(LL)> check = [&](LL x) -> bool {
vector<LL> td(n + 1, 0), b(n + 1, 0); // 新增充电桩数组和实际覆盖数组
LL cur = 0; // 当前增加的充电桩数量

for (int i = r; i < n; ++i) {
if (i > 2 * r) {
cur -= td[i - 2 * r - 1]; // 维护当前的充电桩数量
}
// 如果当前区域充电桩不足，则需要添加
if (d[i - r] + cur < x) {
td[i] = x - (d[i - r] + cur); // 计算需要新增的充电桩
cur += td[i]; // 更新当前新增充电桩数量
}
}

// 更新覆盖数组
for (int i = 0; i < n; ++i) {
b[max(i - r, 0)] += td[i]; // 更新覆盖范围
b[min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算实际覆盖
for (int i = 1; i < n; ++i)
b[i] += b[i - 1];

LL need = 0; // 记录最终需要的充电桩数量
for (int i = n - r; i < n; ++i) {
need = max(need, x - b[i] - d[i]); // 计算在最后几区域所需的充电桩
}

td[max(0, n - r - 1)] += need; // 更新最后需要添加的充电桩
LL res = 0;
for (LL v : td) {
res += v; // 计算新增充电桩的总数
}
return res <= k; // 判断是否在k范围内
};

// 二分搜索找到最大的L
while (L < R) {
LL mid = L + R + 1 >> 1; // 计算中间值
if (check(mid)) {
L = mid; // 如果可以实现，则更新L
} else {
R = mid - 1; // 否则更新R
}
}

cout << L << endl; // 输出结果
}

signed main() {
solve(); // 执行solve函数
return 0; // 返回0
}

---

### 第3题-景点游览计划（P2608）
- 链接：https://codefun2000.com/p/P2608

> 页面标题：#P2608. 第3题-景点游览计划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明计划到某网红旅游景区来一次“特种兵”旅游，景区有 NNN 个最点,请帮助小明规划一条游览路径，使得游览完所有景点花费的时间最短,以便于安排返程时间。
输入描述
第一行，景点数量 NNN 。
接下来的 N+1N+1N+1 行，每行 N+1N+1N+1 个整数，以空格分隔，构成一个 N+1∗N+1N+1*N+1N+1∗N+1 的矩阵。其中，坐标 000 表示景区入口，G[0][j]G[0] [j]G[0][j] 表示从景区入口到景区 jjj 路程的耗时，G[j][0]G[j] [0]G[j][0] 表示从景区 jjj 到景区入口路程的耗时，G[i][j]G [i] [j]G[i][j] 表示从景区 iii 到景点 jjj 路程的耗时。
由于景区的道路不总是平坦的，景点间往返路程上花费的时间可能不同。如果 i=ji=ji=j，G[i][j]=0G [i] [j] =0G[i][j]=0 ；如果景点 iii 与景点 jjj 之间没有直接相通的道路，则 G[i][j]=G[j][i]=−1G [i] [j]=G [j] [i] = -1G[i][j]=G[j][i]=−1；从景区入口，一定可以到达每一个景点(直达或者经过其它景点)。

1<=N<=151 <= N <= 151<=N<=15

从景区入口出发，可以到达所有景点，要么是直达，要么是经过其它景点

在游览路径中，可以重复经过任一景点

输出描述
游览完所有景点在路途上花费的最短时间。
样例1
输入
2
0 2 3
1 0 5
2 2 0

输出
6

说明
如图所示， 游览路径: 景区入口>景点 222  ->景点 111  ->景区入口，耗时 3+2+1=63+2+1=63+2+1=6 最少。

样例2
输入
3
0 1 2 -1
3 0 5 2
2 2 0 3
-1 2 4 0

输出
9

说明
如图所示，游览路径:景区入口->景点 111 ->景点 333  ->景点 222  ->景区入口，耗时 1+2+4+2=91+2+4+2=91+2+4+2=9 最少。

样例3
输入
3
0 1 3 1
2 0 -1 -1
1 -1 0 4
1 -1 5 0

输出
9

说明
如图所示，游览路径:景区入口>景点 111 -> 景区入口 -> 景点 222  ->景区入口->景点 333  ->景区入口，耗时1+2+3+1+1+1=91+2+3+1+1+1=91+2+3+1+1+1=9 最少。

#### TextSol

题解
题目描述
小明计划到某网红旅游景区进行一次“特种兵”旅游。景区共有 NNN 个景点，编号从 111 到 NNN，编号为 000 的点表示景区入口。给定一个 (N+1)×(N+1)(N+1) \times (N+1)(N+1)×(N+1) 的矩阵 GGG，其中：

G[0][j]G[0][j]G[0][j] 表示从景区入口到景点 jjj 的耗时。
G[j][0]G[j][0]G[j][0] 表示从景点 jjj 到景区入口的耗时。
G[i][j]G[i][j]G[i][j] 表示从景点 iii 到景点 jjj 的耗时。
如果 G[i][j]=−1G[i][j] = -1G[i][j]=−1，表示景点 iii 与景点 jjj 之间没有直接通路。
对于所有的 iii，有 G[i][i]=0G[i][i] = 0G[i][i]=0。

小明需要规划一条游览路径，起点和终点都在景区入口，经过所有景点至少一次，且路径上的总耗时最短。路径中可以多次经过同一个景点或返回入口。
思路
这是一个带有方向性和可能缺失路径的旅行商问题（TSP，Traveling Salesman Problem）的变种。主要目标是找到一条起点和终点都在入口，经过所有景点至少一次的最短路径。由于允许多次经过同一个景点或返回入口，问题的复杂度有所增加。
主要步骤如下：

预处理最短路径：

使用 Floyd 算法计算所有景点之间的最短路径，填补直接路径不存在的情况。这一步确保即使某些景点之间没有直接通路，也能通过其他景点间接到达。

动态规划（DP）与状态压缩：

(1). 状态定义：

位掩码表示：对于 NNN 个景点，可以用一个 NNN 位的二进制数来表示已访问的景点集合。具体来说，第 iii 位（从 000 开始）为 1 表示景点 i+1i+1i+1 已被访问，0 表示未被访问。
DP 状态：dp[mask][u] 表示在已经访问了 mask 集合的景点后，当前位于景点 uuu 时的最小耗时。

mask：一个整数，二进制形式表示已访问的景点集合。
u：当前所在的景点编号（包括入口 000）。

(2). 初始状态：

dp[0][0] = 0：表示一开始在入口且未访问任何景点，耗时为 000。
其他状态初始化为 INF，表示尚未计算或不可达。

(3). 状态转移：

遍历所有可能的 mask：

从 0 到 (1 << N) - 1，即所有可能的景点访问状态。

对于每个 mask，遍历所有可能的当前所在景点 u：

如果 dp[mask][u] 已被计算（即不为 INF），则尝试从 u 移动到其他景点 v。

尝试移动到每个未被访问的景点 v：

检查景点 v 是否已在 mask 中：

如果未被访问，则更新新的 mask 为 mask | (1 << (v-1))。
计算新的耗时：dp[new_mask][v] = min(dp[new_mask][v], dp[mask][u] + G[u][v])，其中 G[u][v] 是从 u 到 v 的最短耗时。

允许重复访问：

虽然问题允许重复访问景点，但在 DP 转移中，只需考虑首次访问未访问的景点 v，因为重复访问不会带来新的状态，只会增加耗时，不会有助于找到最优解。

(4). 最终结果：

所有景点被访问后的状态：mask = (1 << N) - 1。
从所有可能的终点 u 回到入口 000：

计算 dp[all_visited][u] + G[u][0]，即从终点 u 返回入口的总耗时。

选择最小的总耗时 作为最终结果。

cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

int main(){
int N;
cin >> N;
// 初始化距离矩阵
vector<vector<int>> G(N+1, vector<int>(N+1, INF));
for(int i=0;i<=N;i++){
for(int j=0;j<=N;j++){
int val;
cin >> val;
if(val == -1){
G[i][j] = INF;
}
else{
G[i][j] = val;
}
}
}
// Floyd-Warshall 计算所有点之间的最短路径
for(int k=0;k<=N;k++){
for(int i=0;i<=N;i++){
for(int j=0;j<=N;j++){
if(G[i][k] < INF && G[k][j] < INF){
G[i][j] = min(G[i][j], G[i][k] + G[k][j]);
}
}
}
}
int size = 1 << N; // N个景点
// 初始化 DP 数组，设为 INF
// dp[mask][u] 表示访问了 mask 集合的景点，当前在景点 u 的最小耗时
vector<vector<int>> dp(size, vector<int>(N+1, INF));
dp[0][0] = 0; // 从入口出发，未访问任何景点
// 遍历所有状态
for(int mask=0; mask < size; mask++){
for(int u=0; u<=N; u++){
if(dp[mask][u] < INF){
// 尝试前往每一个景点，包括入口
for(int v=0; v<=N; v++){
if(v == 0){
// 前往入口，不改变 mask
if(G[u][v] < INF){
dp[mask][v] = min(dp[mask][v], dp[mask][u] + G[u][v]);
}
}
else{
int bit = v-1;
if(!(mask & (1 << bit))){ // 如果景点v未被访问
if(G[u][v] < INF){
int next_mask = mask | (1 << bit);
dp[next_mask][v] = min(dp[next_mask][v], dp[mask][u] + G[u][v]);
}
}
else{
// 景点v已访问，仍可前往（允许重复经过）
if(G[u][v] < INF){
dp[mask][v] = min(dp[mask][v], dp[mask][u] + G[u][v]);
}
}
}
}
}
}
}
// 最终需要访问所有景点，并回到入口
int final_mask = (1 << N) -1;
int res = INF;
for(int u=0; u<=N; u++){
if(dp[final_mask][u] < INF && G[u][0] < INF){
res = min(res, dp[final_mask][u] + G[u][0]);
}
}
cout << res;
return 0;
}

python
import sys
import math

def main():
import sys
sys.setrecursionlimit(1 << 25)
N = int(sys.stdin.readline())
INF = math.inf
G = []
for _ in range(N+1):
row = list(map(int, sys.stdin.readline().split()))
new_row = []
for val in row:
if val == -1:
new_row.append(INF)
else:
new_row.append(val)
G.append(new_row)
# Floyd-Warshall 算法
for k in range(N+1):
for i in range(N+1):
for j in range(N+1):
if G[i][k] != INF and G[k][j] != INF:
if G[i][j] > G[i][k] + G[k][j]:
G[i][j] = G[i][k] + G[k][j]
size = 1 << N
# 初始化 DP 数组，设为 INF
# dp[mask][u] 表示访问了 mask 集合的景点，当前在景点 u 的最小耗时
dp = [ [INF]*(N+1) for _ in range(size) ]
dp[0][0] = 0
# 遍历所有状态
for mask in range(size):
for u in range(N+1):
if dp[mask][u] < INF:
# 尝试前往每一个景点，包括入口
for v in range(N+1):
if v ==0:
# 前往入口，不改变 mask
if G[u][v] < INF:
if dp[mask][v] > dp[mask][u] + G[u][v]:
dp[mask][v] = dp[mask][u] + G[u][v]
else:
bit = v-1
if not (mask & (1 << bit)):
# 景点v未被访问
if G[u][v] < INF:
next_mask = mask | (1 << bit)
if dp[next_mask][v] > dp[mask][u] + G[u][v]:
dp[next_mask][v] = dp[mask][u] + G[u][v]
else:
# 景点v已被访问，允许重复经过
if G[u][v] < INF:
if dp[mask][v] > dp[mask][u] + G[u][v]:
dp[mask][v] = dp[mask][u] + G[u][v]
# 最终需要访问所有景点，并回到入口
final_mask = (1 << N) -1
res = INF
for u in range(N+1):
if dp[final_mask][u] < INF and G[u][0] < INF:
res = min(res, dp[final_mask][u] + G[u][0])
print(int(res))

if __name__ == "__main__":
main()

java
import java.util.*;
import java.io.*;

public class Main {
static final int INF = 1000000000;

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
int[][] G = new int[N + 1][N + 1];
for (int i = 0; i <= N; i++) {
String[] parts = br.readLine().split(" ");
for (int j = 0; j <= N; j++) {
int val = Integer.parseInt(parts[j]);
if (val == -1) {
G[i][j] = INF;
} else {
G[i][j] = val;
}
}
}

// Floyd-Warshall 算法计算所有点之间的最短路径
for (int k = 0; k <= N; k++) {
for (int i = 0; i <= N; i++) {
for (int j = 0; j <= N; j++) {
if (G[i][k] < INF && G[k][j] < INF) {
G[i][j] = Math.min(G[i][j], G[i][k] + G[k][j]);
}
}
}
}

int size = 1 << N;
int[][] dp = new int[size][N + 1];
for (int i = 0; i < size; i++) {
Arrays.fill(dp[i], INF);
}
dp[0][0] = 0; // 从入口出发，未访问任何景点

// 遍历所有状态
for (int mask = 0; mask < size; mask++) {
for (int u = 0; u <= N; u++) {
if (dp[mask][u] < INF) {
// 尝试前往每一个景点，包括入口
for (int v = 0; v <= N; v++) {
if (v == 0) {
// 前往入口，不改变 mask
if (G[u][v] < INF) {
dp[mask][v] = Math.min(dp[mask][v], dp[mask][u] + G[u][v]);
}
} else {
int bit = v - 1;
if ((mask & (1 << bit)) == 0) {
// 景点 v 未被访问
if (G[u][v] < INF) {
int next_mask = mask | (1 << bit);
dp[next_mask][v] = Math.min(dp[next_mask][v], dp[mask][u] + G[u][v]);
}
} else {
// 景点 v 已被访问，允许重复经过
if (G[u][v] < INF) {
dp[mask][v] = Math.min(dp[mask][v], dp[mask][u] + G[u][v]);
}
}
}
}
}
}
}

// 最终需要访问所有景点，并回到入口
int final_mask = (1 << N) - 1;
int res = INF;
for (int u = 0; u <= N; u++) {
if (dp[final_mask][u] < INF && G[u][0] < INF) {
res = Math.min(res, dp[final_mask][u] + G[u][0]);
}
}
System.out.println(res);
}
}

---

### 第3题-光芒散射（P2372）
- 链接：https://codefun2000.com/p/P2372

> 页面标题：#P2372. 第3题-光芒散射

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明有一些神奇的镜子，这些镜子能够吸收光芒，并在一定时间后对光芒进行散射。
小明的镜子分为一级镜和二级镜，一级镜的散射速度比较快，1ms1ms1ms就可以将光芒向上下左右四个方向散射过去，而二级镜则需要2ms2ms2ms。
小明将这些镜子放在了一个二维矩阵中，且每个镜子的坐标均为整数。
现在，小明给某一个镜子一道光芒，他想知道，最早什么时候所有镜子都能够吸收到光芒？
注：矩阵的下标从0开始
输入描述
矩阵的列数n(n≤500)n(n\le500)n(n≤500)
矩阵的行数m(n≤500)m(n\le500)m(n≤500)
最初获得光芒的镜子的坐标(i,j)(i,j)(i,j)
接下来mmm行，每行nnn个数字，代表该位置镜子的等级:
如果为000，表示该位置是一堵密不透光的墙，它足以抵挡所有的光线。
如果为111，表示该位置的镜子散射耗时1ms
如果为222，表示该位置的镜子散射耗时2ms

输出描述
一个数字代表最小时间。如果有镜子不能够吸收到光芒，那么输出-1
样例
输入
5
5
2 2
1 0 2 1 0
2 2 1 2 0
0 0 1 0 0
2 1 1 0 0
1 1 1 1 1

输出
6

#### TextSol

题面描述
塔子哥有一些神奇的镜子，能够吸收光芒并在一定时间后散射。镜子分为一级镜和二级镜，一级镜散射光芒需1毫秒，而二级镜需2毫秒。塔子哥将这些镜子放在一个二维矩阵中，并给定光源镜子的坐标。输入包括矩阵的行列数、光源坐标以及每个位置的镜子等级（0为墙体，1为一级镜，2为二级镜）。输出为所有镜子最早吸收到光芒的时间，若有镜子无法吸收到光芒则输出-1。
思路：Dijkstra
目标是找到所有镜子接收到光芒的最早时间。因此可以想到单源最短路算法：dijkstra
首先，我们需要创建一个二维数组 dis 来存储每个镜子接收到光芒的时间，初始值设为一个较大的数。同时，我们需要一个二维数组 bk 来标记每个镜子是否已经接收到光芒，初始值设为 False。
然后，我们使用优先队列 q，并将初始镜子的坐标和接收到光芒的时间（设为 0）加入队列。
接下来，我们进行Dijkstra算法。在每一步，我们取出队列中时间最早的镜子，然后更新其四个方向的镜子的接收时间。如果新的接收时间比当前的接收时间早，我们就更新接收时间，并将新的镜子加入队列。
最后，我们遍历所有的镜子，找出接收到光芒的最晚时间，即为所有镜子都能够吸收到光芒的最早时间。
算法步骤：

初始化：

创建一个二维数组 dist 来存储每个镜子接收到光芒的时间，初始值设为一个较大的数（INT_MAX / 2），以避免溢出。
创建一个二维布尔数组 visited 来标记每个镜子是否已经接收到光芒，初始值设为 false。
使用优先队列 pq 存储每个镜子的坐标和接收到光芒的时间，并将初始镜子的坐标和时间（0）加入队列。

Dijkstra算法：

在每一步中，从队列中取出时间最早的镜子，检查其四个方向（上下左右）的邻接镜子。
如果邻接镜子的接收时间比当前的接收时间早，则更新接收时间，并将邻接镜子加入队列。
继续这个过程，直到所有可达的镜子都接收到光芒或队列为空。

结果计算：

遍历所有镜子，找出接收到光芒的最晚时间，即为所有镜子都能够吸收到光芒的最早时间。如果有镜子仍未接收到光芒，则返回-1。

时间复杂度
O(nmlog(nm))O(nmlog(nm))O(nmlog(nm))
代码
C++
#include <bits/stdc++.h>
using namespace std;
typedef pair<int, int> pii;

int main() {
vector<int> directions{-1, 0, 1, 0, -1}; // 四个方向的移动向量
int n, m;
cin >> n; // 矩阵的列数
cin >> m; // 矩阵的行数

int si, sj;
cin >> si >> sj; // 初始光源镜子的坐标

int left = 0; // 镜子的数量
vector<vector<int>> grid(n, vector<int>(m, 0)); // 存储镜子的等级
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
cin >> grid[i][j]; // 输入每个位置的镜子等级
if (grid[i][j] > 0) left++; // 统计可接收光芒的镜子数量
}
}

vector<vector<int>> dist(n, vector<int>(m, INT_MAX / 2)); // dist数组，用于存储到达每个镜子的时间
vector<vector<bool>> visited(n, vector<bool>(m, false)); // visited数组，标记镜子是否接收到光芒
priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq; // 优先队列，存储<时间, 镜子坐标>

pq.push({0, si, sj}); // 将初始镜子加入队列
dist[si][sj] = 0; // 初始镜子的接收时间为0
left--; // 初始镜子已接收到光芒

while (!pq.empty()) {
auto item = pq.top(); // 取出时间最早的镜子
int d = item[0], i = item[1], j = item[2];
pq.pop();
if (visited[i][j]) continue; // 如果该镜子已接收到光芒，跳过

visited[i][j] = true; // 标记该镜子已接收到光芒

// 检查四个方向
for (int k = 0; k < 4; k++) {
int nx = i + directions[k]; // 新的x坐标
int ny = j + directions[k + 1]; // 新的y坐标
// 判断新坐标是否在有效范围内，且为镜子
if (nx >= 0 && nx < n && ny >= 0 && ny < m && grid[nx][ny] > 0 && dist[nx][ny] > d + grid[i][j] && !visited[nx][ny]) {
if (dist[nx][ny] >= INT_MAX / 2) // 刚到达了一个镜子
left--; // 剩余可接收光芒的镜子数量减一
dist[nx][ny] = d + grid[i][j]; // 更新接收时间
pq.push({dist[nx][ny], nx, ny}); // 将新镜子加入队列
}
}
if (left == 0) break; // 如果所有镜子都接收到光芒，结束
}

int stamp = 0; // 存储接收到光芒的最晚时间
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
if (grid[i][j] > 0) // 只检查镜子
stamp = max(stamp, dist[i][j]); // 更新最晚时间
}
}

if (stamp >= INT_MAX / 2) {
stamp = -1; // 如果未能接收到光芒，返回-1
}
cout << stamp << endl; // 输出结果

return 0;
}

python代码
import heapq  # 导入堆队列算法库，用于实现优先队列

# 输入矩阵的行数和列数
m = int(input())  # 行数
n = int(input())  # 列数

# 输入光源镜子的起始坐标
s, e = map(int, input().split())

# 输入矩阵数据，表示镜子的等级
a = [list(map(int, input().split())) for i in range(n)]

# 初始化距离数组，设为一个很大的数（模拟无穷大）
dis = [[10**9] * m for i in range(n)]
# 初始化访问标记数组，标记镜子是否已经接收到光芒
bk = [[False] * m for i in range(n)]

# 定义四个方向的移动向量（上下左右）
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

# 设置初始光源的接收时间为0，并将其加入优先队列
dis[s][e] = 0
q = []
heapq.heappush(q, [0, s, e])  # 将初始镜子的坐标和时间加入队列

# Dijkstra算法的主循环
while len(q) > 0:
# 从队列中取出时间最早的镜子
u = q.pop(0)  # 弹出优先队列中的最小元素
u = u[1:]     # 获取镜子的坐标
if bk[u[0]][u[1]]:  # 如果该镜子已接收到光芒，跳过
continue
bk[u[0]][u[1]] = True  # 标记该镜子已接收到光芒

# 遍历四个方向的邻接镜子
for d in range(4):
x = u[0] + dx[d]  # 新的x坐标
y = u[1] + dy[d]  # 新的y坐标

# 检查新坐标是否在有效范围内，且为镜子
if x < 0 or x >= n or y < 0 or y >= m or a[x][y] == 0:
continue  # 跳过不合法的坐标或墙体

# 更新接收时间
if dis[x][y] > dis[u[0]][u[1]] + a[u[0]][u[1]]:
dis[x][y] = dis[u[0]][u[1]] + a[u[0]][u[1]]  # 更新新镜子的接收时间
heapq.heappush(q, [dis[x][y], x, y])  # 将新镜子加入队列

# 计算所有镜子接收到光芒的最晚时间
ans = 0  # 最晚接收到光芒的时间
ok = True  # 用于判断是否所有镜子都接收到光芒

# 遍历所有镜子，找出接收到光芒的最晚时间
for i in range(n):
for j in range(m):
if a[i][j] != 0:  # 只检查镜子
ans = max(ans, dis[i][j])  # 更新最晚时间

# 输出结果，如果未能接收到光芒，返回-1
print(ans if ans != 10**9 else -1)

Java代码
import java.util.*;

public class Main {

public static void main(String[] args) {
Scanner in = new Scanner(System.in); // 创建输入扫描器
while (in.hasNextInt()) { // 当输入有整数时继续循环
int n = in.nextInt(); // 读取矩阵的行数
int m = in.nextInt(); // 读取矩阵的列数
int[][] mirrors = new int[n][m]; // 创建二维数组存储镜子的等级
int initI = in.nextInt(); // 读取光源镜子的起始行坐标
int initJ = in.nextInt(); // 读取光源镜子的起始列坐标

// 输入矩阵数据，填充镜子的等级
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
mirrors[i][j] = in.nextInt(); // 读取每个镜子的等级
}
}

// 初始化接收时间数组，设为一个很大的数（模拟无穷大）
int[][] times = new int[n][m];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
times[i][j] = Integer.MAX_VALUE; // 设置为无穷大
}
}

// 使用优先队列来实现Dijkstra算法
Queue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {
@Override
public int compare(int[] o1, int[] o2) {
return o1[2] - o2[2]; // 根据时间进行比较
}
}); // 队列存储[x, y, 耗时]

int[][] visited = new int[n][m]; // 访问标记数组
queue.offer(new int[]{initI, initJ, 0}); // 将起始点加入队列

// Dijkstra算法主循环
while (!queue.isEmpty()) {
int[] poll = queue.poll(); // 从队列中取出耗时最小的元素
int x = poll[0]; // 当前镜子的行坐标
int y = poll[1]; // 当前镜子的列坐标
int time = poll[2]; // 当前镜子的接收时间

// 检查坐标是否在有效范围内
if (x < 0 || x >= mirrors.length || y < 0 || y >= mirrors[0].length) {
continue; // 如果超出范围，跳过
}
if (mirrors[x][y] == 0) { // 如果是墙体，跳过
continue;
}
if (visited[x][y] == 1) { // 如果该镜子已访问，跳过
continue;
}

visited[x][y] = 1; // 标记该镜子已访问
times[x][y] = time; // 记录该镜子接收光芒的时间

// 将四个方向的邻接镜子加入队列，计算新的接收时间
queue.offer(new int[]{x - 1, y, time + mirrors[x][y]}); // 上
queue.offer(new int[]{x + 1, y, time + mirrors[x][y]}); // 下
queue.offer(new int[]{x, y - 1, time + mirrors[x][y]}); // 左
queue.offer(new int[]{x, y + 1, time + mirrors[x][y]}); // 右
}

// 计算所有镜子接收到光芒的最晚时间
int max = 0; // 存储最晚接收到光芒的时间
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
if (mirrors[i][j] != 0) { // 只检查镜子
max = Math.max(max, times[i][j]); // 更新最晚接收时间
}
}
}
// 输出结果，如果未能接收到光芒，则返回-1
if (max == Integer.MAX_VALUE) {
System.out.println(-1); // 如果没有镜子接收到光芒，输出-1
} else {
System.out.println(max); // 输出所有镜子接收到光芒的最晚时间
}
}
}
}

---

### 第3题-内存分配（P2369）
- 链接：https://codefun2000.com/p/P2369

> 页面标题：#P2369. 第3题-内存分配

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在一个有依赖关系的任务系统中，任务必须在前置任务完成后才能执行，每个任务需要特定的内存，且内存使用完后会被释放以供其他任务使用。给定任务数量及其内存需求和依赖关系，要求计算系统执行所有任务所需的最小内存。输入数据包括任务数量、各任务的内存需求以及各任务对其他任务的依赖关系矩阵。根据样例输入，系统中有9个任务，分别需要50、50、80、40、40、40、60、60、60的内存，并展示了任务之间的依赖关系。输出为执行所有任务所需的最小内存。
思路: 拓扑排序
一个任务依赖另一个任务表示被依赖的任务是依赖的任务的前置，即如果a[i][j]==1a[i][j] == 1a[i][j]==1就代表着有一条j指向i的边。如果需要运行时间更小，那么就需要尽量让多的任务并行。那么考虑拓扑排序，每轮将所有入度为0的点的权值求和，即为本轮所消耗的内存。每轮消耗的内存的最大值即为答案。
代码分析
这段代码实现了基于拓扑排序的任务调度算法，用于计算执行所有任务所需的最小内存。以下是简要分析：
1. 数据结构

int in[M]: 存储每个任务的入度（依赖于该任务的其他任务数）。
int a[M]: 存储每个任务所需的内存大小。
vector<int> e[M]: 邻接表表示任务间的依赖关系。

2. 输入处理

读取任务数量 n 和每个任务的内存需求。
构建依赖关系矩阵，更新入度数组和邻接表。

3. 拓扑排序实现

使用队列 q 存储当前入度为0的任务。
每轮处理队列中的任务，累加内存消耗，并更新依赖任务的入度。
将入度减至0的任务加入临时队列 tmp。

4. 更新最大内存消耗

每轮结束后，更新记录的最大内存消耗 ans。

5. 输出结果

输出最终的最大内存消耗，即执行所有任务所需的最小内存。

代码
C++
#include <bits/stdc++.h>

using namespace std;

#define ll long long // 定义长整型
#define pii pair<int, int> // 定义一个整数对
#define pb push_back // 简化向容器添加元素的操作

const int M = 605; // 定义最大任务数量
int in[M], a[M]; // in数组存储每个任务的入度，a数组存储每个任务的内存需求
vector<int> e[M]; // 使用邻接表表示依赖关系图

int main() {
int n, t; // n表示任务数量，t用于读取依赖关系
cin >> n; // 输入任务数量
for (int i = 1; i <= n; i++) {
scanf("%d", a + i); // 输入每个任务的内存需求
}
// 读取任务间的依赖关系
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
scanf("%d", &t);
if (t) {
in[i]++; // 增加任务i的入度
e[j].pb(i); // 记录有一条从任务j到任务i的依赖边
}
}
}

queue<int> q, tmp; // q保存当前入度为0的任务，tmp用于保存下一轮的任务
// 将所有入度为0的任务加入队列
for (int i = 1; i <= n; i++) {
if (in[i] == 0) q.push(i); // 加入初始任务
}

int ans = 0; // 用于记录最大内存消耗
while (!q.empty()) { // 当队列不为空时，说明还有可执行的任务
int sum = 0; // 当前轮次内存消耗总和
while (!q.empty()) { // 处理当前轮次所有入度为0的任务
int u = q.front(); // 获取队头任务
q.pop(); // 从队列中移除该任务
sum += a[u]; // 累加内存消耗
// 遍历所有依赖于任务u的任务
for (int i = 0; i < (int)e[u].size(); i++) {
in[e[u][i]]--; // 将依赖于u的任务的入度减1
if (in[e[u][i]] == 0) tmp.push(e[u][i]); // 如果入度为0，将其加入tmp队列
}
}
ans = max(ans, sum); // 更新最大内存消耗
// 将下一轮的所有入度为0的任务加入队列
while (!tmp.empty()) {
q.push(tmp.front());
tmp.pop();
}
}
cout << ans << endl; // 输出最终的最大内存消耗
return 0; // 结束程序
}

java
import java.util.*;

public class Main {
static final int M = 20;
static int[] in = new int[M];
static int[] a = new int[M];

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
ArrayList<Integer>[] e = new ArrayList[M];
for (int i = 1; i <= n; i++) {
a[i] = scanner.nextInt();
e[i] = new ArrayList<>();
}

for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
int t = scanner.nextInt();
if (t != 0) {
in[i]++; // 拓扑排序入度++
e[j].add(i);  // 表示有一条j到i的边
}
}
}

Queue<Integer> q = new LinkedList<>();
Queue<Integer> tmp = new LinkedList<>(); // tmp保存本轮产生的所有入度为0的点，q表示已经入度为零的点
for (int i = 1; i <= n; i++) {
if (in[i] == 0) {
q.add(i); // 加入初始点
}
}

int ans = 0;
while (!q.isEmpty()) {
int sum = 0;
while (!q.isEmpty()) {
int u = q.poll();
sum += a[u];  // 本轮所有点消耗求和
for (int i = 0; i < e[u].size(); i++) {
int v = e[u].get(i);
in[v]--;
if (in[v] == 0) {
tmp.add(v);
}
}
}
ans = Math.max(ans, sum);
q.addAll(tmp);// 下一轮的点
tmp.clear();
}

System.out.println(ans);
}
}

python
from collections import deque

M = 605
in_degree = [0] * M
a = [0] * M
e = [[] for _ in range(M)]

n = int(input())
a[1:n+1] = map(int, input().split())

for i in range(1, n+1):
row = list(map(int, input().split()))
for j in range(1, n+1):
if row[j-1]:
in_degree[i] += 1 # 拓扑排序入度++
e[j].append(i) # 表示有一条j到i的边

q = deque()
tmp = deque() # tmp保存本轮产生的所有入度为0的点，q表示已经入度为零的点

for i in range(1, n+1):
if in_degree[i] == 0:
q.append(i) # 加入初始点

ans = 0

while q:
total_sum = 0
while q:
u = q.popleft()
total_sum += a[u]  # 本轮所有点消耗求和
for v in e[u]:
in_degree[v] -= 1
if in_degree[v] == 0:
tmp.append(v)
ans = max(ans, total_sum)
q.extend(tmp) # 下一轮的点
tmp.clear()

print(ans)

题目描述
系统由nnn个任务组成，任务运行有依赖关系，前序任务执行完毕才可以启动后续任务。任务在启动前申请内存，执行完毕后释放，内存释放后可用于其他任务使用。解除依赖后的任务会直接由操作系统调度，分配内存，进入运行状态。每个任务的运行时间相等。请计算系统所有任务执行所需要的最小内存。
输入
第111行为111个正整数nnn，表示任务个数，n<20n<20n<20
第222行为nnn个正整数，表示每个任务所需要的内存大小，0<内存<10000<内存<10000<内存<1000
第333行为nnn个取值为000或111的数，表示任务000对其他任务的依赖关系，000表示不依赖，111表示依赖
....
第3+n3+n3+n行为nnn个取值为000或111的数，表示任务n−1n-1n−1对其他任务的依赖关系，000表示不依赖，111表示依赖
输出
输出系统任务执行所需要的最小内存
样例
输入
9
50 50 80 40 40 40 60 60 60
0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0
0 0 1 0 0 1 0 0 0
0 0 0 1 0 0 0 0 0
0 1 0 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0
0 0 0 1 0 0 0 0 0
0 0 0 0 0 0 1 1 0

输出
120

解释
第一行:999，表示有999个任务
第二行: 505050 505050 808080 404040 404040 404040 606060 606060 606060，表示任务t0 08t0~08t0 08需要的内存大小
第三行:000 000 000 000 000 000 000 000 000，表示ttt不依赖任务其他任务
第四行:101010 000 000 000 000 000 000 000，表示t1t1t1依赖t0t0t0
第五行:010101  000 000 000 000 000 000 000，表示t2t2t2依赖t1t1t1
~
任务的关系用图表示

40
60

t4
t6

↑

50
80
40
60

t0
t1
t2
t3
t7
t8

↑

40

t5

执行t0t0t0，分配m0=50m0=50m0=50，占用空间[0,50)[0,50)[0,50)，最大访问地址为505050
执行t1t1t1，分配m1=50m1=50m1=50，占用空间[0,50)[0,50)[0,50)，最大访问地址为505050
并发执行t2t2t2和t5t5t5，分配m2=80m2=80m2=80，m5=40m5=40m5=40，占用空间[0,120)[0,120)[0,120)，最大访问地址为120
执行t3t3t3，分配m3=40m3=40m3=40，占用空间[0,40)[0,40)[0,40)，最大访问地址404040
并发执行t4t4t4和t7t7t7，分配m4=40m4=40m4=40，m7=60m7=60m7=60，占用空间[0,100)[0,100)[0,100)
执行t6t6t6，分配m6=60m6=60m6=60，占用空间[0,60)[0,60)[0,60)，最大访问地址606060
执行t8t8t8，分配m8=60m8=60m8=60，占用空间[0,60)[0,60)[0,60)，最大访问地址606060

输出系统的需要的最小内存为120120120
样例2
输入
10
40 50 80 10 30 80 90 30 70 150
0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0 0
0 0 1 1 0 0 0 0 0 0
0 0 0 0 1 0 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 1 0 0 0 0
0 0 0 0 0 0 0 1 0 0
0 0 0 0 0 0 0 0 0 0

输入
190

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 78ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-占领（P2366）
- 链接：https://codefun2000.com/p/P2366

> 页面标题：#P2366. 第3题-占领

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

暂无题解

题目描述
小明准备占领一个地盘，可以将这个地盘看成一个10000×1000010000 \times 1000010000×10000的矩阵，每个士兵可以占领他自身周围3×33 \times 33×3的矩阵。现在小明已经在地图上布置了一些士兵。现在他想在不减少占领的地盘的情况少收回尽可能多的士兵。现在小明想要知道他留下了多少士兵，占领了多少地盘。
输入描述
第一行一个整数n，表示士兵的个数。(1≤n≤10000)(1 \leq n \leq 10000)(1≤n≤10000)
接下来n行每行两个整数x, y表示一个士兵的位置 (1<x,y<10000)(1 < x,y < 10000)(1<x,y<10000)
输出描述
输出留下士兵的个数和占领的格子数，使用空格隔开。
样例
输入
4
2 2
3 3
4 4
5 5

输出
4 24

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 75ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-对战（P2361）
- 链接：https://codefun2000.com/p/P2361

> 页面标题：#P2361. 第3题-对战

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在一个虚拟游戏中，塔子哥的目标是将初始等级x提升到更高的等级y（y > x），与n个对手对战。每当他的等级大于或等于对手的等级时，他就获胜并提升1级，反之则降低1级。塔子哥必须选择与对战次数最少的对手进行比赛。任务是计算他达到目标等级y所需的最少对战次数，若无法实现则输出-1。输入包括n、x、y和n个对手的等级，输出为最少对战数。
思路：二分查找 + 贪心
首先，将所有对手的等级进行排序，并计算每个等级与其索引之间的差值。这个差值表示塔子哥在达到这个等级之前需要赢得的比赛数量。
然后，使用二分查找来找到满足条件的最小比赛次数。在每一步，检查当前的比赛次数是否能够使塔子哥的等级达到目标等级。如果可以，就更新答案，并继续在更小的比赛次数中查找。否则，在更大的比赛次数中查找。
在检查当前的比赛次数是否满足条件时，使用贪心的思想。从最低的等级开始，每次选择能够使塔子哥的等级最大提升的比赛。如果当前的比赛次数不足以提升到下一个等级，就停止查找。
最后，输出所需的最少比赛次数。
具体实现

对手等级排序：首先，将所有对手的等级进行排序。这样可以确保塔子哥每次都能以最小的代价与等级较低的对手对战。

计算差值：对于每个对手的等级，我们计算塔子哥当前等级与其等级之间的差值。这个差值代表了塔子哥在达到该等级之前需要赢得的比赛数量。通过这个差值，可以判断塔子哥是否能够在规定的比赛次数内提升自己的等级。

使用二分查找：通过二分查找找到最小的比赛次数。在每一步，检查当前的比赛次数是否能够使塔子哥的等级达到目标等级。如果可以，就更新答案，并继续在更小的比赛次数中查找；否则，转向更大的比赛次数。

贪心策略：在检查比赛次数是否满足条件时，使用贪心的思路。从等级最低的对手开始，每次选择能够使塔子哥的等级最大提升的比赛。这样可以快速累积塔子哥的等级。

输出结果：最后，输出所需的最少比赛次数。如果塔子哥无法达到目标等级，则输出-1。

时间复杂度
O(nlogn)O(nlogn)O(nlogn)
代码
C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
int n, cnt = 0; // n是对手数量，cnt用来统计可以直接战胜的对手数量
long long x, y; // x是塔子哥的初始等级，y是目标等级

vector<long long> nums; // 存储对手的等级

cin >> n >> x >> y; // 输入对手数量、初始等级和目标等级

for (int i = 0; i < n; i++) {
long long num; // 临时变量，用于读取每个对手的等级
cin >> num;
nums.push_back(num); // 将每个对手的等级添加到数组中
}

sort(nums.begin(), nums.end()); // 对对手等级进行排序

vector<long long> diff(n); // 存储每个对手等级与塔子哥等级之间的差值

for (int i = 0; i < n; i++) {
diff[i] = max(0LL, nums[i] - i); // 计算当前等级差值
if (diff[i] <= x) cnt++; // 如果塔子哥能战胜该对手，计数
}

// 如果当前等级加上可以直接战胜的对手数量 >= 目标等级
if (x + cnt >= y) {
cout << y - x << endl; // 输出所需比赛次数
return 0;
}

// 如果当前可以战胜的对手数量小于无法战胜的对手数量，输出-1
if (n - cnt >= cnt) {
cout << -1 << endl;
return 0;
}

long long ans = 0; // 记录总比赛次数

while (x < y) {
int l = 0, r = n - 1; // 二分查找的左右边界
while (l < r) {
int mid = (l + r + 1) / 2; // 计算中间值
if (diff[mid] <= x) l = mid; // 如果当前等级足够，移动左边界
else r = mid - 1; // 否则，移动右边界
}

if (r == n - 1) { // 如果r指向最后一个元素
cout << ans + y - x << endl; // 输出总比赛次数
return 0;
}

r++; // r指向可以战胜的下一个对手
int cur = 2 * r - n; // 当前能带来的增益
long long next = min(diff[r], y); // 计算下一个目标等级
long long d = next - x; // 计算所需的增益

// 如果能达到目标等级，且所需的比赛次数 <= 当前对手数
if (next == y && d <= r) {
cout << ans + d << endl; // 输出总比赛次数
return 0;
}

// 如果当前可用的增益为负，说明无法提升等级，输出-1
if (cur < 0) {
cout << -1 << endl;
return 0;
}

// 计算所需的比赛次数
long long time = d / cur;
ans += time * n; // 更新总比赛次数
x += cur * time; // 更新塔子哥的等级
}

cout << ans << endl; // 输出最终的比赛次数
return 0;
}

python代码
import bisect  # 导入bisect模块，用于二分查找

# 读取输入并将n、x、y分别赋值，x是初始等级，y是目标等级
[n, x, y] = map(int, input().split())
# 读取对手的等级，排序后存入列表a
a = list(sorted(map(int, input().split())))

# 计算每个对手的等级与其在数组中的索引之间的差值
for i in range(n):
a[i] = max(0, a[i] - i)  # 将等级减去其索引，确保不小于0

count = 0  # 初始化比赛次数计数
index = 0  # 用于存储当前二分查找的索引

# 只要塔子哥的等级未达到目标等级y，就不断进行循环
while x < y:
# 使用二分查找找到第一个大于x的对手等级的索引
index = bisect.bisect(a, x)

# 如果索引等于n，说明所有对手等级都小于等于x
if index == n:
count += y - x  # 直接增加到目标等级所需的比赛次数
break  # 结束循环

base = 2 * index - n  # 计算当前能够提升的基础增益
target = min(a[index], y)  # 当前目标等级应为a[index]或y的最小值
diff = target - x  # 计算到达目标等级所需的差值

# 如果目标等级是y，并且差值小于等于当前可用的对手数量
if target == y and diff <= index:
count += diff  # 直接增加所需的比赛次数
break  # 结束循环

# 如果当前的基础增益为负，表示无法进行有效提升
if base < 0:
count = -1  # 设置为-1，表示无法达成目标
break  # 结束循环

# 计算需要的比赛次数，确保整数除法
t = diff // base
count += t * n  # 增加总比赛次数
x += base * t  # 更新塔子哥的等级

# 输出总的比赛次数
print(count)

Java代码
import java.util.*; // 导入Java的集合类和工具类

public class Main {

public static void main(String[] args) {
int n, cnt = 0; // n为对手数量，cnt为可以直接战胜的对手计数
long x, y; // x为塔子哥的初始等级，y为目标等级

long[] nums; // 存储对手等级的数组

Scanner in = new Scanner(System.in); // 创建输入扫描器
n = in.nextInt(); // 读取对手数量
x = in.nextLong(); // 读取塔子哥的初始等级
y = in.nextLong(); // 读取塔子哥的目标等级
nums = new long[n]; // 初始化对手等级数组
for (int i = 0; i < n; i++) {
nums[i] = in.nextLong(); // 读取每个对手的等级
}

Arrays.sort(nums); // 对对手等级进行排序

long[] diff = new long[n]; // 用于存储每个对手等级与塔子哥等级之间的差值

for (int i = 0; i < n; i++) {
diff[i] = Math.max(0, nums[i] - i); // 计算当前等级差值
if (diff[i] <= x) cnt++; // 如果塔子哥可以战胜该对手，计数
}

// 如果当前等级加上可以直接战胜的对手数量 >= 目标等级
if (x + cnt >= y) {
System.out.println(y - x); // 输出所需比赛次数
return; // 结束程序
}

// 如果当前可战胜的对手数量小于无法战胜的对手数量，输出-1
if (n - cnt >= cnt) {
System.out.println(-1); // 表示无法达到目标等级
return; // 结束程序
}

long ans = 0; // 初始化比赛次数计数
while (x < y) { // 当塔子哥的等级小于目标等级时继续循环
int l = 0, r = n - 1; // 二分查找的左右边界
while (l < r) { // 进行二分查找
int mid = (l + r + 1) >> 1; // 计算中间值
if (diff[mid] <= x) l = mid; // 如果当前等级足够，移动左边界
else r = mid - 1; // 否则，移动右边界
}

// 如果r指向最后一个元素，说明塔子哥已经能够战胜所有对手
if (r == n - 1) {
System.out.println(ans + y - x); // 输出总比赛次数
return; // 结束程序
}

r++; // r指向可以战胜的下一个对手
int cur = 2 * r - n; // 当前能带来的增益
long next = Math.min(diff[r], y); // 计算下一个目标等级
long d = next - x; // 计算所需的增益

// 如果能达到目标等级，且所需的比赛次数 <= 当前对手数
if (next == y && d <= r) {
System.out.println(ans + d); // 输出总比赛次数
return; // 结束程序
}

// 如果当前可用的增益为负，说明无法提升等级，输出-1
if (cur < 0) {
System.out.println(-1); // 表示无法达成目标
return; // 结束程序
}

// 计算所需的比赛次数
long time = d / cur; // 计算可以进行的比赛次数
ans += time * n; // 更新总比赛次数
x += cur * time; // 更新塔子哥的等级
}

System.out.println(ans); // 输出最终的比赛次数
}
}

题目描述
在一个虚拟的游戏世界中，小明参加了一场在线比赛，这场比赛要求他与n个对手进行对战，以提高自己的等级。然而，比赛有着一些独特的规则和挑战。
小明的目标很明确：他希望将自己的等级从初始等级x提升到更高的等级y（y > x）。
在比赛中，如果小明的等级大于等于对手的等级，他就能够获胜，并提升1级。但如果小明输掉了比赛，他将减少1级。对手的等级始终保持不变，不受比赛结果的影响。
比赛有一条特殊规则：每局比赛小明只能选择和对战次数最少的对手进行对战。
小明面临的挑战是，在保证按照规则选择对手的情况下，以尽可能少的比赛次数提升自己的等级。他需要计算出实现这一目标所需的最少比赛次数，以达到他渴望的更高等级y。
输入格式
第一行包含三个整数nnn，xxx和yyy(1≤n≤2×105,1≤x<y≤10121\le n \le 2 \times 10^5,1\le x<y\le 10^{12}1≤n≤2×105,1≤x<y≤1012)表示对手个数，小明的初始等级和期望等级。
第二行包含nnn个整数a1,a2,a3,...,an(1≤ai≤1012)a_1,a_2,a_3,...,a_n(1\le a_i\le 10^{12})a1​,a2​,a3​,...,an​(1≤ai​≤1012)表示对手的等级。
输出格式
输出小明提升到等级y所需的最少对战数，如果不可能达到目标，则输出−1-1−1。
7 2 10
3 1 9 2 5 20 8

20

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 74ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-运货（P2358）
- 链接：https://codefun2000.com/p/P2358

> 页面标题：#P2358. 第3题-运货

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在这个问题中，有mmm个集装箱和nnn个叉车，叉车的载重量需大于等于集装箱的重量才能运输。还有xxx个增强组件，每个组件可以让叉车的载重量增加yyy，但每个叉车最多只能使用一个组件。目标是计算出最多能运输多少个集装箱。输入包括集装箱重量和叉车载重量的信息，输出为最大可运输的集装箱数量。
思路：二分答案 + 贪心算法
原题链接：2071. 你可以安排的最多任务数目 - 力扣（LeetCode）
这个问题可以通过二分答案和贪心算法来解决。我们的目标是找到最大的集装箱数量
首先，我们对叉车和集装箱按照重量进行排序。这样我们可以保证每次都是最轻的叉车去运送最轻的集装箱。
然后，我们使用二分答案来找到最大的满足条件的集装箱数量。我们设定一个范围，最小值为-1（表示没有一个集装箱可以被运送），最大值为m和n的最小值加1（表示所有的集装箱都可以被运送）。
在二分查找的每一步，我们都会尝试一个中间的集装箱数量，然后检查是否所有的叉车都能在使用增强组件的情况下运送这么多的集装箱。我们使用一个check函数来进行这个检查。
check函数会遍历所有的叉车，对于每一个叉车，如果它的载重量大于等于当前的集装箱的重量，那么它就可以运送这个集装箱，我们就将这个集装箱从列表中移除。否则，我们就需要使用一个增强组件来增加叉车的载重量。我们使用二分搜索来找到一个可以使叉车的载重量大于等于当前集装箱重量的增强组件。如果我们找到了这样的增强组件，我们就将它从列表中移除，然后继续下一个叉车。如果我们没有找到这样的增强组件，或者增强组件已经用完了，那么我们就返回False，表示当前的集装箱数量不满足条件。

如果check函数返回True，表示当前的集装箱数量满足条件，我们就尝试增大集装箱数量。否则，我们就尝试减小集装箱数量。

当我们找到了最大的满足条件的集装箱数量，我们就输出这个数量。

题解
我们的问题可以使用二分答案结合贪心算法来求解，目标是找到能够运输的最大集装箱数量。

数据结构准备：首先，我们将叉车和集装箱的重量进行排序。通过排序，我们可以确保在每一步中，最轻的叉车去尝试运输最轻的集装箱，这样可以提高运输的效率。

二分查找：我们设定二分查找的范围，最小值为-1（表示没有一个集装箱可以被运送），最大值为mmm和nnn的最小值加1（表示理论上所有的集装箱都可以被运送）。在每次查找中，我们尝试一个中间值作为当前集装箱的数量。

检查函数：我们定义一个check函数来验证在当前设定的集装箱数量下，是否能找到足够的叉车进行运输。函数的逻辑如下：

遍历每个集装箱，尝试为其找到一个合适的叉车。
如果叉车的载重量能够满足集装箱的重量，则该叉车可以运送该集装箱。
如果叉车不能直接运送该集装箱，则尝试使用增强组件来提升叉车的载重量。
通过线性搜索来找合适的叉车，如果未能找到合适的叉车，则返回False。

调整二分查找范围：如果check函数返回True，则表示当前的集装箱数量可以满足条件，我们尝试增加集装箱数量；如果返回False，则减少集装箱数量。

输出结果：最终输出满足条件的最大集装箱数量。

时间复杂度
O(nlogm)O(nlogm)O(nlogm)
代码
C++
#include <bits/stdc++.h>

using namespace std;

int m, n, x, y; // m: 集装箱数量, n: 叉车数量, x: 增强组件数量, y: 增强重量
int weight[50005]; // 存储集装箱的重量
int load[50005]; // 存储叉车的载重量

bool is_get[50005]; // 用于标记叉车是否被使用

// 检查是否能运送当前数量的集装箱
bool check(int m, int n, int cur_res) {
int cur_x = 0; // 当前使用的增强组件数量
vector<int> weight_copy(weight, weight + cur_res); // 当前需要运输的集装箱
vector<int> load_copy(load + n - cur_res, load + n); // 当前可用的叉车

// 从重到轻遍历集装箱
for (int i = weight_copy.size() - 1; i >= 0; --i) {
bool is_find = false; // 标记当前集装箱是否找到叉车
// 查找一个合适的叉车直接运输集装箱
for (int j = 0; j < load_copy.size(); ++j) {
if (weight_copy[i] <= load_copy[j]) { // 叉车可以直接运输集装箱
load_copy.erase(load_copy.begin() + j); // 使用该叉车
is_find = true; // 找到叉车
break;
}
}
// 如果未找到，尝试使用增强组件
if (!is_find) {
for (int j = 0; j < load_copy.size(); ++j) {
if (weight_copy[i] <= load_copy[j] + y && cur_x < x) { // 使用增强组件后可以运输
load_copy.erase(load_copy.begin() + j); // 使用该叉车
cur_x++; // 增加使用的增强组件数量
is_find = true; // 找到叉车
break;
}
}
}
// 如果仍未找到合适的叉车，返回 false
if (!is_find)
return false;
}
return true; // 找到所有集装箱的合适叉车
}

int main() {
int res = 0; // 最终结果
cin >> m >> n >> x >> y; // 输入集装箱数量、叉车数量、增强组件数量和增强重量
for (int i = 0; i < m; ++i) {
cin >> weight[i]; // 输入每个集装箱的重量
}
for (int i = 0; i < n; ++i) {
cin >> load[i]; // 输入每个叉车的载重量
}

// 对集装箱和叉车的重量进行排序
sort(weight, weight + m);
sort(load, load + n);

// 二分查找的范围
int left = 1, right = min(m, n); // 集装箱数量的范围
while (left <= right) {
int mid = left + (right - left) / 2; // 中间值
// 检查是否能运输 mid 个集装箱
if (check(m, n, mid)) {
res = mid; // 更新结果
left = mid + 1; // 尝试运输更多的集装箱
} else {
right = mid - 1; // 尝试运输更少的集装箱
}
}
cout << res << endl; // 输出结果
return 0;
}

python代码
from sortedcontainers import SortedList  # 引入SortedList库，用于维护有序列表（此行代码未使用）
import bisect  # 引入bisect库，用于二分查找操作

# 定义检查函数
def check(ts, ws):
p, s = pills, strength  # 将增强组件数量和增强力量分别赋值给p和s
for i in range(len(ws)):  # 遍历所有叉车
if ws[i] >= ts[0]:  # 如果叉车的载重量大于等于当前最轻集装箱的重量
ts.pop(0)  # 直接使用该叉车运送该集装箱
else:
# 查找在增强后可以运输的集装箱的索引
idx = bisect.bisect_right(ts, ws[i] + s)
if idx == 0 or p == 0:  # 如果没有可用的集装箱，或者增强组件用完
return False  # 返回False，表示无法运输
p -= 1  # 使用一个增强组件
ts.pop(idx - 1)  # 移除能运送的集装箱
return True  # 如果所有叉车都能运输集装箱，返回True

# 输入集装箱数量、叉车数量、增强组件数量和增强重量
m, n, pills, strength = list(map(int, input().split()))
# 输入每个集装箱的重量
tasks = list(map(int, input().split()))
# 输入每个叉车的载重量
workers = list(map(int, input().split()))

# 对集装箱和叉车的重量进行排序
tasks.sort()
workers.sort()

# 设置二分查找的范围
lo, hi = -1, min(m, n) + 1
while lo + 1 < hi:  # 当low小于high时，进行二分查找
mid = (lo + hi) // 2  # 计算中间值
# 检查是否可以运输mid个集装箱
if check(tasks[:mid], workers[n - mid:n]):
lo = mid  # 可以运输，尝试增加集装箱数量
else:
hi = mid  # 不能运输，减少集装箱数量

# 输出最大可运输的集装箱数量
print(lo)

Java代码
import java.util.*; // 导入Java集合类库

public class Main {
static int m; // 货物的数量
static int n; // 卡车的数量
static int x; // 拖斗的数量
static int y; // 每个拖斗的载重量
static int[] weights; // 每个货物的重量
static int[] loads; // 每个卡车的载重量

public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 创建输入扫描器
m = sc.nextInt(); // 输入货物数量
n = sc.nextInt(); // 输入卡车数量
x = sc.nextInt(); // 输入拖斗数量
y = sc.nextInt(); // 输入每个拖斗的载重
weights = new int[m]; // 初始化货物重量数组
for (int i = 0; i < m; i++) weights[i] = sc.nextInt(); // 输入每个货物的重量
loads = new int[n]; // 初始化卡车载重量数组
for (int i = 0; i < n; i++) loads[i] = sc.nextInt(); // 输入每个卡车的载重
sc.close(); // 关闭扫描器

// 将货物按重量升序排序
Arrays.sort(weights);
// 将卡车按载重量升序排序
Arrays.sort(loads);

// 使用贪心算法和二分查找
int left = 0, right = m; // 设置二分查找的范围
while(left < right) {
int mid = (left + right + 1) >> 1; // 计算中间值
if(check(mid)) { // 检查是否能运输mid个集装箱
left = mid; // 可以运输，尝试增加集装箱数量
} else {
right = mid - 1; // 不能运输，减少集装箱数量
}
}
System.out.println(left); // 输出最大可运输的集装箱数量
}

// 检查在当前设定的集装箱数量下是否能运输
public static boolean check(int mid) {
if (mid > n) return false; // 如果货物数量大于卡车数量，返回false

// TreeMap自动排序（默认按key升序排序），存储卡车载重量及其数量
TreeMap<Integer, Integer> map = new TreeMap<>();
// 将可以使用的卡车载重存入map
for (int i = n - mid; i < n; i++)
map.compute(loads[i], (k, v) -> (v == null ? 1 : v + 1)); // 更新卡车数量

// 从重到轻遍历货物
int t = x; // 当前可用的拖斗数量
for (int i = mid - 1; i >= 0; i--) {
int weight = weights[i]; // 当前货物重量
Map.Entry<Integer, Integer> en = map.lastEntry(); // 获取map中载重量最大的卡车
if (en.getKey() >= weight) { // 如果卡车可以运输该货物
map.compute(en.getKey(), (k, v) -> (v <= 1 ? null : v - 1)); // 更新卡车数量
} else if (t > 0 && (en = map.ceilingEntry(weight - y)) != null) { // 否则，尝试使用拖斗增强
t--; // 使用一个拖斗
map.compute(en.getKey(), (k, v) -> (v <= 1 ? null : v - 1)); // 更新卡车数量
} else {
return false; // 如果都不满足，返回false
}
}
return true; // 能够运输，返回true
}
}

题目描述
有m个集装箱，n个叉车，每个叉车只能运一个集装箱。叉车的载重量大于等于集装箱重量就可以运送该集装箱。一共有x个增强组件，每个组件都可以使叉车的举重量增加y，但是每个叉车只能使用至多一个组件，且一个组件只能安装到至多一个叉车上。问最多可以运送多少个集装箱。
输入描述
第一行四个整数m,n,x,ym,n,x,ym,n,x,y。
第二行m个整数，表示m个货物的重量
第三行n个整数，表示n个叉车的载重量
输出描述
输出最多可以运送多少个集装箱
样例
输入
5 5 2 5
9 5 7 8 5
1 6 2 6 4

输出
4

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 70ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-存储（P2355）
- 链接：https://codefun2000.com/p/P2355

> 页面标题：#P2355. 第3题-存储

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥正在研究虚拟化内存，并希望实现一个地址范围为32G的内存机制，支持数据的读写和清空操作。输入包括多个指令，格式为“Command Address Length Data”，其中Command可以是Read、Write或Clear，Address是64位无符号十六进制数，Length是64位无符号十进制数，Data是以字节流形式表示的十六进制数据。输出只针对Read指令，返回相应地址的数据，若参数不合法则不输出。示例输入包括Write、Read和Clear指令，程序需要根据指令处理内存数据，并确保符合题目要求。
思路：哈希表模拟
观察数据规模，存储的数据量不超过16MB，即为2242^{24}224，因此可以使用哈希表来存储

执行Clear操作时，清空哈希表即可
执行Write操作时，按位置写入每个字节
执行Read操作时，首先需要判断哈希表中是否存在，如果不存在，使用00代替，

每次执行Write和Read操作时，都需要判断输入的长度lenlenlen是否在合法范围，lenlenlen的合法范围为0≤len≤2340\le len \le 2^{34}0≤len≤234
时间复杂度
O(nlogn)O(nlogn)O(nlogn)
代码
C++
#include <bits/stdc++.h>
#include <unordered_map>
using namespace std;

// 使用哈希表存储地址和对应的数据
unordered_map<unsigned long long, string> m;

int main() {
int n; // 指令数量
cin >> n; // 输入指令的数量

for (int i = 0; i < n; i++) {
string cmd, data; // cmd为命令，data为数据
unsigned long long address, length; // address为地址，length为长度
cin >> cmd; // 读取命令

if (cmd == "Write") {
// 处理Write命令
cin >> hex >> address >> dec >> length; // 读取地址（十六进制）和长度（十进制）
cin >> data; // 读取数据（十六进制字符串）

// 如果提供的数据长度小于指定长度，补零
if (data.size() < length * 2) {
string s(length * 2 - data.size(), '0'); // 生成补零字符串
data += s; // 在data后添加补零
}
// 将数据写入对应地址
m[address] = data;
} else if (cmd == "Read") {
// 处理Read命令
cin >> hex >> address >> dec >> length; // 读取地址和长度

// 判断地址是否存在
if (m.find(address) != m.end()) {
string data = m[address]; // 从哈希表中获取数据
// 如果请求的长度大于存储的数据长度，进行补零
if (length * 2 > data.size()) {
data += string(length * 2 - data.size(), '0'); // 追加补零
} else {
// 截取到指定长度
data = data.substr(0, length * 2);
}
cout << data << endl; // 输出读取的数据
} else {
// 如果地址不存在，返回全0
cout << string(length * 2, '0') << endl; // 返回补零
}
} else if (cmd == "Clear") {
// 处理Clear命令
m.clear(); // 清空哈希表
}
}
}

python代码
import sys
from collections import defaultdict

# 主要的处理函数
def solution(lines):
n = len(lines)  # 获取输入行数
rec = defaultdict(str)  # 使用defaultdict来存储地址到数据的映射，默认值为空字符串

# 遍历每一行指令
for line in lines:
strs = line.split()  # 将每行指令按空格分割成字符串列表

if strs[0] == 'Clear':
# 如果指令是Clear，清空记录
rec = defaultdict(str)  # 重新初始化defaultdict

elif strs[0] == 'Write':
# 如果指令是Write，处理写入操作
add = strs[1]  # 获取地址
if len(add) > 66:  # 如果地址长度超过66字符，跳过该指令
continue

length = int(strs[2])  # 获取写入的长度
if length > 16 * 1024 * 1024:  # 如果长度超过16MB，跳过该指令
continue

data = strs[3]  # 获取要写入的数据
if len(data) > length * 2:  # 如果数据长度大于指定长度
data = data[:length * 2]  # 截取数据至指定长度

rec[add] = data  # 将数据写入到对应的地址

elif strs[0] == 'Read':
# 如果指令是Read，处理读取操作
add = strs[1]  # 获取地址
if len(add) > 66:  # 如果地址长度超过66字符，跳过该指令
continue

length = int(strs[2])  # 获取读取的长度
data = rec[add]  # 从记录中获取对应地址的数据

if len(data) > length * 2:  # 如果获取的数据长度超过读取长度
print(data[:length * 2])  # 输出截取的结果
else:
# 如果获取的数据长度小于读取长度，输出数据并补零
print(data + ''.join(['0' for _ in range(length * 2 - len(data))]))  # 输出补零的结果

# 主函数
def main():
n = int(input())  # 读取指令的数量
lines = []  # 创建一个空列表来存储输入行
for _ in range(n):
lines.append(input())  # 逐行读取指令并添加到列表中

solution(lines)  # 调用处理函数

# 执行主函数
main()

Java代码
import java.util.Arrays; // 导入Arrays类用于数组操作
import java.util.Scanner; // 导入Scanner类用于输入
import java.util.stream.IntStream; // 导入IntStream类用于流操作

public class Main {

@SuppressWarnings({ "resource" }) // SuppressWarnings用于抑制警告
public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 创建Scanner对象，用于读取输入
String[] strs = sc.nextLine().split(","); // 读取一行输入并按逗号分割成字符串数组
int[] arr = Arrays.stream(strs).mapToInt(Integer::parseInt).toArray(); // 将字符串数组转换为整数数组
Arrays.sort(arr); // 对整数数组进行排序
int[] sum = new int[arr.length]; // 创建一个数组用于存储从当前索引到末尾的和
int res = 0; // 初始化结果变量

// 遍历数组，计算从当前索引到末尾的和
for (int i = 0; i < arr.length; i++) {
// 计算从索引i到末尾的和，并存储在sum[i]
sum[i] = IntStream.of(Arrays.copyOfRange(arr, i, arr.length)).sum();
// 如果当前和大于0，累加到结果
if (sum[i] > 0) {
res = res + sum[i]; // 更新结果
}
}
// 输出最终结果
System.out.println(res);
}
}

题目描述
最近小明正在研究什么是虚拟化内存，于是小明想自己亲自动手试一试，你能帮助他吗？
实现一个地址范围为32G，可在范围内任意位置进行数据读写的虚拟化内存机制，数据默认清零。
功能:

读写任意地址数据；
往任意地址写入任意数据；
清空数据，并释放内存；

PS：一个地址空间存一个数据，各地址空间独立
输入描述
输入格式：Command Address Length Data
1、Command为Read、Write、Clear之一
2、Address采用64位无符号十六进制数，全大写
3、Length采用64位无符号十进制数，单位为“字节”
4、Data采用字节流(2个16进制数表示一个Byte)，全大写;
5、如果指定的Length大于实际给定的Data，需要程序自行未尾补0，小于则末尾截断
每条指令一行，一个用例输入可以是多条指令混合，只有Read指令有输出。
每个用倒保证指令、参数格式正确，但不保证参数范围，需要程序照题目规格要求自行校验，参数不合法，则对应的指令无效。
每个用例保证需要存储的总数据量最大不超过16MB。一个用例最多不超过500条指令。
例如(3表示有3条指令)
3
Write 0x100 7 001122AA
Read 0x100 4
Clear
输出描述
采用字节流(2个16进制数表示一个Byte)，全大写
例如
001122AA
每条Read指令对应一行输出数据，如果指令给的参数不合法，对应的输出为空(不换行)。
样例
输入1
1
Read 0x100 4

输出1
00000000

说明
0x100地址空间未被写入数据，默认返回全0，一共4个字节
输入2
3
Write 0x100 8 00001122AABBCCDD
Read 0x100 12
Clear

输出2
00001122AABBCCDD00000000

说明
0x100地址，前8个字节被写入了有效数据00001122AABBCCDD，读取0x100地址12字节数据，后4个字节补齐默认数0，因此结果为00001122AABBCCDD00000000

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 1, 109ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-分糖果方案（P2352）
- 链接：https://codefun2000.com/p/P2352

> 页面标题：#P2352. 第3题-分糖果方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥组织了一场小朋友的游戏，需要分发糖果以确保每根绳子的两端至少有一个小朋友开心。每个小朋友可以牵引多个同学，形成树形结构。通过合理分配糖果，目标是用最少的糖果让每个小朋友开心，从而实现快乐的游戏氛围。输入包含小朋友数量及其牵引关系，输出所需的最少糖果数。
思路：树形DP
定义f[i][j]f[i][j]f[i][j]为以iii为结点的子树中，不放消防栓/放消防栓（j=0/1j=0/1j=0/1）的最小个数
如果在第iii个结点放置消防栓，那么对于结点iii的所有子节点，都可以放置/不放置消防栓
则有$f[i][1]=\sum_{}^{}min(f[u][0],f[u][1]) (u\in {i|u是i的子节点})$
如果在第iii个结点不放置消防栓，那么对于结点iii的所有子节点，都必须要放置消防栓
则有f[i][0]=∑f[u][1](u∈i∣u是i的子节点)f[i][0]=\sum_{}^{}f[u][1] (u\in {i|u是i的子节点})f[i][0]=∑​f[u][1](u∈i∣u是i的子节点)
代码分析
这段代码的目的是在树形结构中找到最优的消防栓放置策略，以最小化需要的消防栓数量。以下是代码的详细分析：

变量与数据结构的初始化：

const int N = 1510;：定义最大节点数为1510。
int n;：小朋友数量，即树的节点数量。
vector<vector<int>> g;：邻接表，用于存储树的结构。
int f[N][2];：动态规划数组，其中 f[i][0] 表示不在节点 i 放置消防栓时的最小数量，f[i][1] 表示在节点 i 放置消防栓时的最小数量。
int d[N];：入度数组，用于记录每个节点的入度，以便找到根节点。

深度优先搜索（DFS）函数：

void dfs(int u)：递归函数，遍历树的节点。

初始化 f[u][1] = 1，表示当前节点放置消防栓的数量。
初始化 f[u][0] = 0，表示当前节点不放置消防栓时的数量。
对于每个子节点 x，递归调用 dfs(x)。
更新状态转移方程：如果放置消防栓，子节点可以选择放或不放；如果不放，则子节点必须放置。

C++
#include<bits/stdc++.h>
using namespace std;
int n;
vector<vector<int>>g;
const int N=1510;
int f[N][2],d[N];
void dfs(int u)
{
f[u][1]=1;f[u][0]=0;
for(int &x:g[u])
{
dfs(x);
f[u][1]+=min(f[x][0],f[x][1]);
f[u][0]+=f[x][1];
}

}
int main()
{
cin>>n;
g.resize(n);
memset(d,0,sizeof d);
int t,cnt;
for(int i=0;i<n;i++)
{
scanf("%d:(%d)",&t,&cnt);
while(cnt--)
{
int a;
cin>>a;
g[t].push_back(a);
d[a]++;
}
}
int root=0;
while(d[root])root++;
dfs(root);
int res=min(f[root][0],f[root][1]);
cout<<res<<endl;
return 0;
}

Java
import java.util.*;

public class Main {
static int n;
static List<List<Integer>> g;
static final int N = 1510;
static int[][] f = new int[N][2];
static int[] d = new int[N];

static void dfs(int u) {
f[u][1] = 1;
f[u][0] = 0;
for (int x : g.get(u)) {
dfs(x);
f[u][1] += Math.min(f[x][0], f[x][1]);
f[u][0] += f[x][1];
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
g = new ArrayList<>(n);
for (int i = 0; i < n; i++) {
g.add(new ArrayList<>());
}
Arrays.fill(d, 0);
for (int i = 0; i < n; i++) {
String[] data = sc.next().split(":");
int t = Integer.parseInt(data[0]);
int cnt = Integer.parseInt(data[1].substring(1, data[1].length() - 1));
while (cnt-- > 0) {
int a = sc.nextInt();
g.get(t).add(a);
d[a]++;
}
}
int root = 0;
while (d[root] > 0) {
root++;
}
dfs(root);
int res = Math.min(f[root][0], f[root][1]);
System.out.println(res);
}
}

Python
import re

n = int(input())
g = [[] for _ in range(n)]
N = 1510
f = [[0, 0] for _ in range(N)]
d = [0 for _ in range(N)]

def dfs(u):
f[u][1] = 1
f[u][0] = 0
for x in g[u]:
dfs(x)
f[u][1] += min(f[x][0], f[x][1])
f[u][0] += f[x][1]

for _ in range(n):
data = re.findall(r'\d+', input())
t = int(data[0])
cnt = int(data[1])
for i in range(2, 2 + cnt):
a = int(data[i])
g[t].append(a)
d[a] += 1

root = 0
while d[root] > 0:
root += 1

dfs(root)
res = min(f[root][0], f[root][1])
print(res)

题目描述
小明组织小朋友们在玩一场小游戏, 一共有nnn个小朋友, 编号为0...n−10 ... n-10...n−1, 每个小朋友身后都有一根绳子, 一个小朋友可以不拿或者拿多个同学的绳子, 拿完之后小明会让小朋友们保持不动, 给小朋友发糖果。
给一个小朋友分糖果, 他就会开心, 否则他就会不开心。
可是小明的糖果没有很多了, 怎么分才能使最少的糖果让每个绳子两头都最少有一个开心的小朋友呢
(一个小朋友只能被一个小朋友牵, 一个小朋友可以牵多个小朋友, 最终类似一个树形结构, 题目保证所有小孩子都牵了人或者被人牵)
输入描述
第一行一个整数nnn，表示小朋友数量(1≤n≤1500)(1\le n\le 1500)(1≤n≤1500)
接下来nnn行，每行以a:(b)a:(b)a:(b) 这样的格式开头，aaa表示小朋友的编号(0≤a≤n−1)(0\le a\le n-1)(0≤a≤n−1)
bbb表示第iii个小朋友牵了几个小朋友,接下来bbb个数，表示被牵的小朋友的编号
输出描述
一个数字，为需要的糖果的最少个数
样例
输入1
3
0:(2) 1 2
1:(0)
2:(0)

输出1
1

说明
0号小朋友与1号和2号相连，那么只需要给0号发一个糖果就可使得所有绳子两端都有开心的小朋友
输入2
8
0:(3) 1 2 3
1:(1) 6
2:(0)
3:(0)
6:(1) 7
7:(2) 4 5
4:(0)
5:(0)

输出2
3

说明
给 0, 6, 7号小朋友发糖果, 就可使得所有绳子两端都有开心的小朋友

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 114ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-平面灯阵中寻找最大正方形边界（P2347）
- 链接：https://codefun2000.com/p/P2347

> 页面标题：#P2347. 第3题-平面灯阵中寻找最大正方形边界

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述：
在这个问题中，给定一个二维数组表示黑白棋盘，黑棋用1表示，白棋用0表示。目标是找到一个最大的正方形，其边界由黑棋（1）组成，并返回该正方形的右下角坐标及其宽度。如果有多个满足条件的正方形，则返回右下角行号最小的，若行号相同则返回列号最小的。输入包括棋盘的行数和列数，以及棋盘的具体内容，输出为一个列表，包含满足条件的最大正方形的信息。
思路：动态规划/前缀和
原题来自于LeetCode 1139. 最大的以 1 为边界的正方形
我们只需要在此基础上找到这个正方形的右下角即可。
由于题目数据大为200200200 , 所以O(n3)O(n^3)O(n3) 可过。那么就有非常多的做法(参考leetcode题解)。*下面给出的是一种前缀和差分的做法:*
枚举右下角，再枚举对角线。这样我们就用O(n3)O(n^3)O(n3)的复杂度枚举出了所有可能的正方形。
然后我们只需要差分求这个正方形 减去 内部小正方形的和。这样就得到了边界上的值的和。看他是不是(边长 - 1) * 4 即可。
题解
在给定的黑白棋盘中，我们需要找到一个最大的正方形，其边界上都是黑棋（值为1）。由于棋盘的大小限制为200x200，因此可以采用 O(n3)O(n^3)O(n3) 的复杂度进行求解。以下是利用前缀和和差分的方法来解决此问题的思路：

前缀和计算：使用一个额外的数组 dp 来存储到当前位置的黑棋（1）的累积和。这样可以快速计算任意子矩形的黑棋总数。

枚举正方形的右下角：我们从棋盘的右下角开始枚举每个可能的正方形的右下角位置，接着枚举可能的正方形的边长。

计算边界和：通过差分的方式，我们可以快速计算出正方形的边界值的和，并与理论值比较，判断是否为合法的正方形。

更新结果：当找到一个合法的正方形时，更新当前最大正方形的信息，如果存在多个满足条件的正方形，则根据题目要求选择合适的返回值。

时间复杂度
O(n3)O(n^3)O(n3)
代码
C++
#include <bits/stdc++.h>
using namespace std;

int dp[205][205]; // 前缀和数组

class Solution {
public:
// 计算区域 (x, y) 到 (a, b) 的和
inline int ask(int x, int y, int a, int b) {
return dp[a][b] - dp[a][y - 1] - dp[x - 1][b] + dp[x - 1][y - 1];
}

vector<int> largest1BorderedSquare(vector<vector<int>>& a) {
int n = a.size(), m = a[0].size(); // 行数和列数
int sum = 0; // 黑棋的总数
int i, j, k;

// 计算前缀和
for (i = 1; i <= n; i++) {
for (j = 1; j <= m; j++) {
int v = a[i - 1][j - 1]; // 当前元素的值
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + v;
sum += v; // 累计黑棋的总数
}
}

// 如果没有黑棋，返回 [0, 0, 0]
if (!sum) return {0, 0, 0};

int ans = 1, len;
int r = 1e9, c = 1e9; // 初始化返回值

// 从右下角开始枚举
for (i = n; i >= 1; i--) {
for (j = m; j >= 1; j--) {
len = min(i, j); // 当前正方形的最大边长

// 枚举边长
for (k = ans; k <= len; k++) {
// 计算边界的和，并与理论值比较
if (ask(i - k + 1, j - k + 1, i, j) - ask(i - k + 2, j - k + 2, i - 1, j - 1) == 4 * (k - 1)) {
// 更新最大正方形的信息
if (ans < k) {
ans = k; // 更新边长
r = i; // 更新右下角行号
c = j; // 更新右下角列号
} else if (ans == k) {
if (i < r) { // 优先选择行号最小的
r = i;
c = j;
} else if (i == r && j < c) { // 行号相同，选择列号最小的
c = j;
}
}
}
}
}
}
return {r, c, ans}; // 返回右下角坐标和边长
}
};

int main() {
int n, m;
cin >> n >> m; // 输入行数和列数
Solution sol;
vector<vector<int>> a(n, vector<int>(m)); // 创建棋盘数组
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
cin >> a[i][j]; // 输入棋盘数据
}
}
vector<int> res = sol.largest1BorderedSquare(a); // 计算结果
cout << "[" << res[0] - 1 << "," << res[1] - 1 << "," << res[2] << "]" << endl; // 输出结果
return 0;
}

python代码
def ask(x, y, a, b, dp):
# 计算矩形 (x, y) 到 (a, b) 的和
return dp[a][b] - dp[a][y - 1] - dp[x - 1][b] + dp[x - 1][y - 1]

def largest1BorderedSquare(a):
n = len(a)  # 获取行数
m = len(a[0])  # 获取列数
# 初始化前缀和数组，大小为 (n + 1) x (m + 1)
dp = [[0] * (m + 1) for _ in range(n + 1)]
sum = 0  # 黑棋的总数

# 计算前缀和
for i in range(1, n + 1):
for j in range(1, m + 1):
v = a[i - 1][j - 1]  # 当前元素的值
# 更新前缀和
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + v
sum += v  # 累计黑棋的总数

# 如果没有黑棋，返回 [0, 0, 0]
if sum == 0:
return [0, 0, 0]

ans = 1  # 当前找到的最大正方形的边长
r = float('inf')  # 右下角的行号初始化为正无穷
c = float('inf')  # 右下角的列号初始化为正无穷

# 从右下角开始枚举每个可能的正方形的右下角
for i in range(n, 0, -1):
for j in range(m, 0, -1):
length = min(i, j)  # 当前正方形的最大边长

# 枚举边长
for k in range(ans, length + 1):
# 计算边界的和，并与理论值比较
if ask(i - k + 1, j - k + 1, i, j, dp) - ask(i - k + 2, j - k + 2, i - 1, j - 1, dp) == 4 * (k - 1):
# 更新最大正方形的信息
if ans < k:
ans = k  # 更新边长
r = i  # 更新右下角行号
c = j  # 更新右下角列号
elif ans == k:
# 优先选择行号最小的
if i < r:
r = i
c = j
elif i == r and j < c:  # 行号相同，选择列号最小的
c = j

# 返回右下角坐标和边长
return [r, c, ans]

# 读取输入
n = int(input())  # 输入行数
m = int(input())  # 输入列数
a = []  # 初始化棋盘数组

# 读取棋盘数据
for _ in range(n):
a.append(list(map(int, input().split())))

# 计算最大正方形信息
res = largest1BorderedSquare(a)

# 输出结果，返回值减去1以符合题目要求（0-indexed）
print("[{},{},{}]".format(res[0] - 1, res[1] - 1, res[2]))

Java代码
import java.util.*;

public class Main {
private static int[][] dp; // 前缀和数组，用于存储到当前位置的黑棋（1）的累积和

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt(); // 输入棋盘的行数
int m = scanner.nextInt(); // 输入棋盘的列数
int[][] a = new int[n][m]; // 初始化棋盘数组
// 读取棋盘数据
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
a[i][j] = scanner.nextInt(); // 读取每个位置的值
}
}
// 计算最大正方形并输出结果
int[] res = largest1BorderedSquare(a);
System.out.println("[" + (res[0] - 1) + "," + (res[1] - 1) + "," + res[2] + "]"); // 输出结果，返回值减去1以符合题目要求
}

public static int[] largest1BorderedSquare(int[][] a) {
int n = a.length, m = a[0].length, sum = 0; // 获取行数、列数和黑棋总数
dp = new int[n + 1][m + 1]; // 初始化前缀和数组，大小为 (n + 1) x (m + 1)

// 计算前缀和
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
int v = a[i - 1][j - 1]; // 当前元素的值
// 更新前缀和数组
dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1] + v;
sum += v; // 累计黑棋（1）的总数
}
}

// 如果没有黑棋，直接返回 [0, 0, 0]
if (sum == 0) return new int[]{0, 0, 0};

int ans = 1; // 当前找到的最大正方形的边长
int len, r = Integer.MAX_VALUE, c = Integer.MAX_VALUE; // 初始化右下角行列号为正无穷

// 从右下角开始枚举每个可能的正方形的右下角
for (int i = n; i >= 1; i--) {
for (int j = m; j >= 1; j--) {
len = Math.min(i, j); // 当前正方形的最大边长

// 枚举边长
for (int k = ans; k <= len; k++) {
// 计算边界的和，并与理论值比较
if (ask(i - k + 1, j - k + 1, i, j) - ask(i - k + 2, j - k + 2, i - 1, j - 1) == 4 * (k - 1)) {
// 更新最大正方形的信息
if (ans < k) {
ans = k; // 更新边长
r = i; // 更新右下角行号
c = j; // 更新右下角列号
} else if (ans == k) {
// 优先选择行号最小的
if (i < r) {
r = i; // 更新行号
c = j; // 更新列号
} else if (i == r) {
if (j < c) {
c = j; // 更新列号
}
}
}
}
}
}
}
// 返回右下角坐标和边长
return new int[]{r, c, ans};
}

// 计算区域 (x, y) 到 (a, b) 的和
private static int ask(int x, int y, int a, int b) {
return dp[a][b] - dp[a][y - 1] - dp[x - 1][b] + dp[x - 1][y - 1];
}
}

本题考察的LeetCode原题
LeetCode 1139. 最大的以 1 为边界的正方形
题目描述
现在有一个二维数组来模拟一个黑白棋盘，将黑白棋子置于方格之中，棋盘中每个位置都放入黑棋或白棋，分别对应数组每个元素取值只能为 111 或 000 （黑棋为 111 , 白棋为 000），现在需要找一个正方形边界，其每条边上的棋子都是黑棋(对应数组中元素的值为 111 )的，且该正方形面积最大。
输入描述
输入第一行为棋盘的行数(二维数组的行数)
输入第二行为棋盘的列数(二维数组的列数)
紧接着为模拟棋盘的二维数组 arrarrarr
1<arr.length≤2001 < arr.length \le 2001<arr.length≤200
1<arr[0].length≤2001 < arr[0].length \le 2001<arr[0].length≤200
输出描述
返回满足条件的面积最大正方形边界信息。返回信息[r,c,wr,c,wr,c,w],其中 rrr , ccc 分别代表方阵右下角的行号和列号，www 代表正方形的宽度。如果存在多个满足条件的正方形，则返回 rrr 最小的，若 rrr 相同，返回 ccc 最小的正方形。
样例1
输入
4
5
1 0 0 0 1
1 1 1 1 1
1 0 1 1 0
1 1 1 1 1

输出
[3,2,3]

说明：满足条件且面积最大的正方形边界，其右下角的顶点为 [3,2]，即行号为 333 ，列好为 222 ，其宽度为 333 ，因此返回信息为 [3,2,33,2,33,2,3]。
样例2
输入
3
3
1 0 0
0 1 0
0 0 1

输出
[0,0,1]

**说明：**满足条件且面积最大的正方形边界有三个。即为 [0,0,10,0,10,0,1]、[1,1,11,1,11,1,1]、[2,2,12,2,12,2,1]，根据要求，如果满足条件有多个，则返回 rrr 最小，即为[0,0,10,0,10,0,1]

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 1, 166ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-新能源汽车充电桩建设策略（P2344）
- 链接：https://codefun2000.com/p/P2344

> 页面标题：#P2344. 第3题-新能源汽车充电桩建设策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题目描述
在一座城市中，划分为多个区域，每个区域内建设一个充电站，充电站内设有多个充电桩，充电站之间需要保持合理的距离。定义：

n：区域充电站的数目。
station[i]：表示第 i 个充电站中充电桩的数量。
r：充电站可覆盖的相邻区域范围，满足条件 |i-j| <= r。
k：需要新增的充电桩数量。

我们的目标是合理分配这 k 个新增充电桩，使得所有区域总的被充电桩覆盖最少区域的充电桩数目最大化。
思路：二分+贪心+差分
二分每个区域被覆盖的最小充电桩数量，每个区域至少需要这么多的充电桩数量，对于给定的最低充电桩数量，判断是否可以在只分配k个充电桩的情况下实现。
贪心的做法是从左到右遍历，计算当前区域的充电桩数量，如果低于最低充电桩数量，则尽量放置充电桩在最右侧的区域，因为这样可以让右边更多的区域增加充电桩。
由于计算当前区域的充电桩数量需要累计附近的充电桩，所以每个区域的充电桩其实可以视为对一个区间的区域进行累加，在遍历过程中维护当前的充电桩数量比较简单，所以建议采用差分的方式来计算累计充电桩。
解题思路

二分法：我们采用二分搜索的方式来找到可以实现的最低覆盖充电桩数量。设定左右边界，L 为 0，R 为一个合理的最大值（如 (2 \times 10^{10})），在这个范围内寻找最小的充电桩覆盖数量。

覆盖量计算：使用差分数组（或前缀和）来快速计算每个区域在覆盖范围内的充电桩数量。通过维护一个差分数组 d 来简化范围累加的计算。

贪心分配充电桩：在判断某个覆盖数量 x 是否可以实现时，优先从右侧区域向左分配充电桩。若当前区域的充电桩数量低于 x，则尽量在右侧的区域放置充电桩，尽可能使更多的区域得到覆盖。

算法步骤

初始化输入，包括区域数量 n、充电桩数量 a、覆盖范围 r 和需要新增的充电桩数量 k。
利用差分数组计算每个区域的实际覆盖充电桩数量。
实现一个函数 check，用于判断在给定的最低充电桩数量 x 下，是否能够通过分配最多 k 个充电桩实现该覆盖。
使用二分搜索来找到最大的 L，即最大的最低充电桩覆盖数量。

JavaScript
// 检查在新增k个充电桩的情况下是否可以实现至少x个覆盖数量
function check(d, r, x, n, k) {
let td = new Array(n + 1).fill(0); // 用于记录每个区域需要新增的充电桩数量
let cur = 0; // 当前新增的充电桩数量

// 遍历区域，从r开始，计算需要新增的充电桩数量
for (let i = r; i < n; i++) {
// 如果当前索引超出覆盖范围，减去相应的新增充电桩
if (i > 2 * r) {
cur -= td[i - 2 * r - 1];
}
// 如果当前区域的充电桩数量不足x，则需要新增充电桩
if (d[i - r] + cur < x) {
td[i] = x - d[i - r] - cur; // 计算需要新增的充电桩数量
cur += td[i]; // 更新当前的新增充电桩数量
}
}

// 存储实际覆盖的充电桩数量
let b = new Array(n + 1).fill(0);

// 更新覆盖数组b，计算每个区域的充电桩数量
for (let i = 0; i < n; i++) {
b[Math.max(i - r, 0)] += td[i]; // 更新覆盖范围
b[Math.min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算每个区域的实际覆盖数量
for (let i = 1; i < n; i++) {
b[i] += b[i - 1]; // 前缀和
}

let need = 0; // 记录最终需要的充电桩数量
// 在最后几个区域检查所需的充电桩数量
for (let i = n - r; i < n; i++) {
need = Math.max(need, x - b[i] - d[i]); // 计算需要增加的充电桩数量
}

// 更新最后需要的充电桩数量
b[Math.max(0, n - r - 1)] += need;

// 计算所有新增充电桩的总和
let sum = td.reduce((acc, val) => acc + val, 0);

// 判断总新增的充电桩是否小于等于k
return sum <= k;
}

// 使用readline模块从标准输入读取数据
let readline = require('readline');
let rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

// 提示用户输入区域数量n
rl.question("Enter n: ", function(n) {
n = parseInt(n); // 转换为整数
// 提示用户输入充电桩数量数组
rl.question("Enter array a: ", function(aStr) {
let a = aStr.split(' ').map(Number); // 将输入的字符串转换为数字数组
// 提示用户输入覆盖范围r
rl.question("Enter r: ", function(r) {
r = parseInt(r); // 转换为整数
// 提示用户输入需要新增的充电桩数量k
rl.question("Enter k: ", function(k) {
k = parseInt(k); // 转换为整数

// 初始化差分数组d
let d = new Array(n + 1).fill(0);

// 构造差分数组d
for (let i = 0; i < n; i++) {
d[Math.max(i - r, 0)] += a[i]; // 当前区域的充电桩数加到最左侧的覆盖区域
d[Math.min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (let i = 1; i < n; i++) {
d[i] += d[i - 1]; // 前缀和
}

let L = 0; // 二分搜索的下界
let R = 2e10; // 二分搜索的上界

// 二分搜索查找最大的最低覆盖充电桩数量
while (L < R) {
let mid = (L + R + 1) >> 1; // 计算中间值
// 调用check函数判断是否可以在k个充电桩内实现至少mid个覆盖数量
if (check(d, r, mid, n, k)) {
L = mid; // 如果可以实现，则更新下界
} else {
R = mid - 1; // 否则更新上界
}
}
// 输出最大的最低覆盖充电桩数量
console.log(L);
rl.close(); // 关闭readline接口
});
});
});
});

Java
import java.util.Scanner;

public class ChargingStations {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

// 读取区域数量
long n = scanner.nextLong();
long[] a = new long[(int) n]; // 存储每个充电站的充电桩数量

// 读取每个充电站中的充电桩数量
for (int i = 0; i < n; i++) {
a[i] = scanner.nextLong();
}

// 读取覆盖范围和新增充电桩数量
long r = scanner.nextLong();
long k = scanner.nextLong();

// 差分数组，长度为n+1
long[] d = new long[(int) (n + 1)];

// 构造差分数组d
for (int i = 0; i < n; i++) {
d[(int) Math.max(i - r, 0)] += a[i]; // 当前区域的充电桩数加到最左侧的覆盖区域
d[(int) Math.min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (int i = 1; i < n; i++) {
d[i] += d[i - 1]; // 前缀和
}

long L = 0; // 二分搜索的下界
long R = (long) 2e10; // 二分搜索的上界

// 二分搜索查找最大的最低覆盖充电桩数量
while (L < R) {
long mid = (L + R + 1) >> 1; // 计算中间值
// 调用check函数判断是否可以在k个充电桩内实现至少mid个覆盖数量
if (check(d, r, mid, n, k)) {
L = mid; // 如果可以实现，则更新下界
} else {
R = mid - 1; // 否则更新上界
}
}

// 输出最大的最低覆盖充电桩数量
System.out.println(L);
}

// 检查是否可以在新增k个充电桩的情况下使得覆盖数量至少为x
private static boolean check(long[] d, long r, long x, long n, long k) {
long[] td = new long[(int) (n + 1)]; // 用于记录需要新增的充电桩数量
long cur = 0; // 当前新增的充电桩数量

// 遍历区域，从r开始，计算需要新增的充电桩数量
for (long i = r; i < n; i++) {
// 如果当前索引超出覆盖范围，减去相应的新增充电桩
if (i > 2 * r) {
cur -= td[(int) (i - 2 * r - 1)];
}
// 如果当前区域的充电桩数量不足x，则需要新增充电桩
if (d[(int) (i - r)] + cur < x) {
td[(int) i] = x - d[(int) (i - r)] - cur; // 计算需要新增的充电桩数量
cur += td[(int) i]; // 更新当前的新增充电桩数量
}
}

// 存储实际覆盖的充电桩数量
long[] b = new long[(int) (n + 1)];

// 更新覆盖数组b，计算每个区域的充电桩数量
for (int i = 0; i < n; i++) {
b[(int) Math.max(i - r, 0)] += td[i]; // 更新覆盖范围
b[(int) Math.min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算每个区域的实际覆盖数量
for (int i = 1; i < n; i++) {
b[i] += b[i - 1]; // 前缀和
}

long need = 0; // 记录最终需要的充电桩数量
// 在最后几个区域检查所需的充电桩数量
for (long i = n - r; i < n; i++) {
need = Math.max(need, x - b[(int) i] - d[(int) i]); // 计算需要增加的充电桩数量
}

// 更新最后需要的充电桩数量
b[(int) Math.max(0, n - r - 1)] += need;
long sum = 0; // 计算新增充电桩的总数

// 计算所有新增充电桩的总和
for (long value : td) {
sum += value;
}

// 判断总新增的充电桩是否小于等于k
return sum <= k;
}
}

Python
n = int(input())
a = list(map(int, input().split()))
r = int(input())
k = int(input())
d = [0] * (n + 1)
for i, v in enumerate(a):
# 差分
d[max(i - r, 0)] += v
d[min(n, i + r + 1)] -= v
for i in range(1, n):
d[i] += d[i - 1]
L, R = 0, int(2e10)

def check(x):
td, cur = [0] * (n + 1), 0
b = [0] * (n + 1)
# 用cur维护当前附近范围增加的累计充电桩数量
for i in range(r, n):
if i > 2 * r:
# 超过2 * r的范围则需要减去
cur -= td[i - 2 * r - 1]
if d[i - r] + cur < x:
td[i] = x - d[i - r] - cur
cur += td[i]
for i, v in enumerate(td):
b[max(i - r, 0)] += v
b[min(n, i + r + 1)] -= v
for i in range(1, n):
b[i] += b[i - 1]
need = 0
for i in range(n - r, n):
need = max(need, x - b[i] - d[i])
td[max(0, n - r - 1)] += need
return sum(td) <= k

while L < R:
mid = L + R + 1 >> 1
if check(mid):
L = mid
else:
R = mid - 1
print(L)

C++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

void solve() {
int n, k, r;
cin >> n; // 输入区域数量
vector<int> a(n);
vector<LL> d(n + 1, 0); // 差分数组初始化

// 输入每个充电站的充电桩数量
for (int i = 0; i < n; ++i)
cin >> a[i];

cin >> r >> k; // 输入覆盖范围和需要新增的充电桩数量

// 计算差分数组
for (int i = 0; i < n; ++i) {
d[max(i - r, 0)] += a[i]; // 当前区域的充电桩数量加到其覆盖的最左侧区域
d[min(n, i + r + 1)] -= a[i]; // 超出覆盖范围的部分减去
}

// 计算每个区域的实际充电桩数量
for (int i = 1; i < n; ++i) {
d[i] += d[i - 1]; // 前缀和累加
}

LL L = 0, R = (LL)2e10; // 设置二分搜索的边界

// 判断是否可以实现的函数
function<bool(LL)> check = [&](LL x) -> bool {
vector<LL> td(n + 1, 0), b(n + 1, 0); // 新增充电桩数组和实际覆盖数组
LL cur = 0; // 当前增加的充电桩数量

for (int i = r; i < n; ++i) {
if (i > 2 * r) {
cur -= td[i - 2 * r - 1]; // 维护当前的充电桩数量
}
// 如果当前区域充电桩不足，则需要添加
if (d[i - r] + cur < x) {
td[i] = x - (d[i - r] + cur); // 计算需要新增的充电桩
cur += td[i]; // 更新当前新增充电桩数量
}
}

// 更新覆盖数组
for (int i = 0; i < n; ++i) {
b[max(i - r, 0)] += td[i]; // 更新覆盖范围
b[min(n, i + r + 1)] -= td[i]; // 超出范围的部分减去
}

// 计算实际覆盖
for (int i = 1; i < n; ++i)
b[i] += b[i - 1];

LL need = 0; // 记录最终需要的充电桩数量
for (int i = n - r; i < n; ++i) {
need = max(need, x - b[i] - d[i]); // 计算在最后几区域所需的充电桩
}

td[max(0, n - r - 1)] += need; // 更新最后需要添加的充电桩
LL res = 0;
for (LL v : td) {
res += v; // 计算新增充电桩的总数
}
return res <= k; // 判断是否在k范围内
};

// 二分搜索找到最大的L
while (L < R) {
LL mid = L + R + 1 >> 1; // 计算中间值
if (check(mid)) {
L = mid; // 如果可以实现，则更新L
} else {
R = mid - 1; // 否则更新R
}
}

cout << L << endl; // 输出结果
}

signed main() {
solve(); // 执行solve函数
return 0; // 返回0
}

题目描述
将一座城市划分为多个区域，每一个区域建设一个充电站，充电站内有多个充电桩，充电站之间保持合理的距离，每个充电站可以覆盖相邻范围的多个区域。
我们使用n来表示区域充电站的数目，使用station[i]数组表示第i个充电站中充电桩的数目。
给定一个范围r，i区域可以被附近范围内的充电站覆盖，|i-j|<=r,0<=i,j<=n-1,|i-j|表示绝对值。
因此覆盖区域的充电桩包括i区域内充电站的充电桩以及满足上述覆盖条件区域j区域充电站的充电桩。
汽车公司打算在一些城市新增k个充电桩，如何分配这k个充电桩给充电站，使得所有区域总，被充电桩覆盖最少区域的充电桩数目最大化。
输入描述
输入：第一行输入为n，表示有n个充电站区域。
第二行输入为station[n]数组，表示n个充电站中充电桩的数目.
第三行输入为r，表示充电站可覆盖的相邻区域的范围。
第四行输入为k，表示需要新增的充电桩数目。
输出描述
输出：一行包含一个整数，表示被充电桩覆盖最少区域的充电桩数目。
备注：

0 <= r < n <= 100000
0 <= station[i] <= 100000
0 <= k <= 1000000000

示例1
输入
5
1 2 4 5 0
1
2

输出
5

说明：
最优方案是把2个充电桩都放在充电站1，这样每个充电站的充电桩数目分别为1 4 4 5 0。
此时区域0的覆盖充电桩为1+4=5, 区域1为1+4+4=9，区域2为4+4+5=13，区域3为5+4=9，区域4为5+0=5.
示例2
输入
4
4 4 4 4
0
3

输出
4

说明：
无论怎么分配新增的3个充电站，总有一个区域的充电桩覆盖数目为4

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 1, 225ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-整数分解结果的枚举（P2341）
- 链接：https://codefun2000.com/p/P2341

> 页面标题：#P2341. 第3题-整数分解结果的枚举

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
给定一个整数 NNN (满足 1<N≤2561 < N \leq 2561<N≤256)，我们需要输出所有符合条件的分解形式 N=a1∗a2∗a3....axN = a_1 * a_2 * a_3....a_xN=a1​∗a2​∗a3​....ax​，其中 1<ai≤aj1 < a_i \leq a_j1<ai​≤aj​ (当 i≤ji \leq ji≤j 时)，并按照字典序排列。例如，输入 242424 时，输出应为所有可能的分解，如 24=2∗2∗2∗324=2*2*2*324=2∗2∗2∗3、24=2∗2∗624=2*2*624=2∗2∗6 等，直到 24=2424=2424=24。对于输入仅为一个整数 NNN，程序需将其所有分解方式逐行输出。
思路:递归+质因分解
实现思路

递归分解：

使用递归函数 fac(int n, int p) 来进行质因分解，其中 nnn 是当前待分解的数，ppp 是当前分解时的最小因子。
当 nnn 为 1 时，返回一个包含空向量的结果，表示一种有效的分解。

分解过程：

从最小因子 ppp 开始遍历所有可能的因子 iii，如果 iii 是 nnn 的因子，则递归调用 fac 函数处理 n/in/in/i。
将因子 iii 插入到分解结果的最前面。

输出结果：

在主函数中，调用 fac 函数获得所有分解形式，并格式化输出。

python
n = int(input())
def fac(n, p): #获取 n 的所有对于每个 1 <= i <= x，都有 a[i] >= p 的分解。
if n == 1: #当 n 等于 1 时，返回 [[]], 表示 n 只有一种分解且这个分解里面没有数。
return [[]]
ans = []
for i in range(p, n + 1): #遍历 [p, n] 区间内所有整数，并测试它是否可以整除 n。
if n % i == 0: #如果 i 可以整除 n
for v in fac(n // i, i): #获取 n / i 的所有对于每个 1 <= j <= x，都有 a[j] >= i 的分解。
ans.append([i] + v) #把分解追加到答案。
return ans
ans = fac(n, 2)
for v in ans:
print(str(n) + "=" + '*'.join(map(str, v)))

Java
import java.util.Scanner;
import java.util.*;
import java.util.stream.Collectors;

public class Main {
public static void main(String[] args) {
// 创建一个 Scanner 对象用于接收用户输入
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt(); // 读取整数 N
List<List<Integer>> ans = fac(n, 2); // 调用分解函数，初始因子为 2
for (List<Integer> s : ans) { // 遍历所有分解结果
System.out.println(list2String(n, s)); // 输出格式化的分解字符串
}
}

// 递归函数，返回所有分解形式
public static List<List<Integer>> fac(int n, int p) {
// 基本情况，当 n 为 1 时，返回包含空向量的列表
if (n == 1) {
List<List<Integer>> tmp = new ArrayList<>();
tmp.add(new ArrayList<>()); // 添加空列表表示一种有效的分解
return tmp;
}

List<List<Integer>> ans = new ArrayList<>(); // 存储所有分解形式
// 从最小因子 p 开始遍历可能的因子
for (int i = p; i <= n; i++) {
if (n % i == 0) { // 如果 i 是 n 的因子
// 递归调用寻找 n/i 的分解形式
List<List<Integer>> next = fac(n / i, i);
for (List<Integer> list : next) { // 遍历下一层递归返回的结果
List<Integer> tmp = new ArrayList<>(list); // 创建新的列表
tmp.add(0, i); // 将当前因子 i 插入到列表开头
ans.add(tmp); // 保存这条新的分解形式
}
}
}
return ans; // 返回所有的分解形式
}

// 将列表转换为字符串格式
public static String list2String(int n, List<Integer> numbers) {
return n + "=" + numbers.stream() // 将列表中的数字转换为字符串
.map(String::valueOf) // 转换每个整数为字符串
.collect(Collectors.joining("*")); // 用 "*" 连接字符串
}
}

c++
#include <iostream>
#include <vector>

using namespace std;

// 递归函数，返回所有分解形式
vector<vector<int>> fac(int n, int p) {
vector<vector<int>> ans; // 存储所有分解形式的二维向量
if (n == 1) {
ans.push_back(vector<int>()); // 当 n 为 1 时，返回空向量表示一种分解
return ans;
}
// 从最小因子 p 开始遍历
for (int i = p; i <= n; i++) {
if (n % i == 0) { // 如果 i 是 n 的因子
// 递归调用，寻找 n/i 的分解形式
vector<vector<int>> temp = fac(n / i, i);
// 将当前因子 i 插入到分解结果中
for (vector<int>& v : temp) {
v.insert(v.begin(), i); // 将 i 添加到分解的开头
ans.push_back(v); // 保存这条新的分解形式
}
}
}
return ans; // 返回所有的分解形式
}

int main() {
int n;
cin >> n; // 输入整数 N
vector<vector<int>> ans = fac(n, 2); // 从 2 开始进行质因分解
for (vector<int>& v : ans) { // 遍历所有分解形式
cout << n << "="; // 输出分解式的开头
for (int i = 0; i < v.size(); i++) {
if (i > 0) {
cout << "*"; // 输出乘号
}
cout << v[i]; // 输出因子
}
cout << "\n"; // 换行
}
return 0; // 程序结束
}

给你一个整数N(1<N≤256)N (1 < N \leq 256)N(1<N≤256) ,它的一个分解是$N = a_1 \times a_2 \times a_3  \times ...  \times a_x$  , 其中1<ai≤aj(i≤j)1 < a_i \leq a_j (i \leq j)1<ai​≤aj​(i≤j).
对于整数NNN , 请依次输出每一个分解(按照字典序)
例如,给定整数24,输出是
24=2*2*2*3
24=2*2*6
24=2*3*4
24=2*12
24=3*8
24=4*6
24=24

解答要求
时间限制:C/C++ 1000ms,其他语言:2000ms
内存限制:C/C++ 256MB, 其他语言:512MB
输入
输入只有一个整数NNN
输出
按照字典序，依次输出整数NNN的每一个分解.
样例1
输入
11

输出
11=11

解释
无
样例2
输入
12

输出
12=2*2*3
12=2*6
12=3*4
12=12

解释
无

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 72ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-年会奖品分配策略（P2416）
- 链接：https://codefun2000.com/p/P2416

> 页面标题：#P2416. 第3题-年会奖品分配策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明的公司准备在年会上开展抽奖活动。他们购买了若干个奖品，每个奖品都有一个价格，用一个正整数数组表示。在抽奖环节，公司准备设置一等奖、二等奖和三等奖，每个等级设置一个奖品，并将所有奖品分成三份大礼包。公司希望尽可能地减小一等奖和三等奖之间的价格差异，同时满足一等奖总价格大于二等奖总价格，二等奖总价格大于三等奖总价格。
为了实现这一目标，公司需要找到一种合适的分配方案。具体来说，假设一等奖总价格为 xxx，二等奖总价格为 yyy，三等奖总价格为 zzz，则 x>y>z>0x>y>z>0x>y>z>0。同时，假设奖品的总数量为 nnn，用正整数数组 arrayarrayarray 表示每个奖品的价格。
现在的问题是小明他们不知道如何分配奖品，才能使得一等奖和三等奖之间的价格差最小，你能帮帮他们吗？
输入描述
第一行：正整数 nnn ，表示奖品的数量，取值范围 [3,16)[3,16)[3,16)
第二行：一个正整数数组 arrayarrayarray ，每个元素表示奖品的价格，取值范围 [1,1000][1,1000][1,1000]
输出描述
一个非负整数，表示一等奖和三等奖的差值，没有方案返回 000
样例
样例一：
输入
3
5 4 2

输出
3

样例解释
分配方案只有一种 5,4,2{5,4,2}5,4,2
样例二：
输入
4
10 5 4 2

输出
5

样例解释
分配方案有 10,9,2{10,9,2}10,9,2 ， 10,7,4{10,7,4}10,7,4 ， 10,6,5{10,6,5}10,6,5 ，15,4,2{15,4,2}15,4,2 ， 14,5,2{14,5,2}14,5,2 ， 12,5,4{12,5,4}12,5,4
一等奖和三等奖差值最小的方案是 10,6,5{10,6,5}10,6,5

#### TextSol

题目大意
这道题目要求将若干个奖品分配到三个不同的奖项（一等奖、二等奖、三等奖）中，使得一等奖的总价格大于二等奖，二等奖的总价格大于三等奖，同时尽可能地减小一等奖和三等奖之间的价格差异
题目思路
分配方式：
每个奖品只能被分配到一个奖项中。
每个奖项至少分配一个奖品，以确保 x, y, z 都大于零。
搜索策略：
由于奖品数量 n 在 [3, 16) 的范围内，可以考虑使用深度优先搜索（DFS）或回溯算法来穷举所有可能的分配方案。
每个奖品有三种选择（分配到一等奖、二等奖或三等奖），因此总的分配方式为 3^n。当 n 较小时（如 n=15），这种方法是可行的，尤其是通过优化剪枝来减少实际的计算量。
剪枝策略：
早期终止：在分配过程中，如果当前的分配方案已经无法满足 x > y > z 的条件，可以立即终止该分支的搜索。
排序：将奖品按价格从大到小排序，优先分配价格较高的奖品，有助于更快地达到 x > y > z 的条件，并可能触发更多的剪枝。
记录最小差值：在搜索过程中，维护一个全局变量记录当前找到的最小 x - z，并在搜索过程中不断更新。当当前路径的 x - z 已经不小于已记录的最小差值时，可以剪枝。
优化目标：
目标是最小化 x - z，因此在搜索过程中，可以优先考虑那些使 x - z 较小的分配方案。
通过维护一个全局最小差值，可以在搜索过程中不断更新，以确保最终得到最优解。
代码
Java代码
import java.util.Scanner;

public class Main {
static int n;
static int[] arr = new int[16];
static int minn = Integer.MAX_VALUE;

public static void main(String[] args) {
Scanner input = new Scanner(System.in);//输入
n = input.nextInt();
for(int i = 1; i <= n; i++){
arr[i] = input.nextInt();
}
dfs(1, 0, 0,0);
if(minn == Integer.MIN_VALUE) System.out.println(0);//如果minn没更新过，说明没有合理的分法，那么就输出0
else System.out.println(minn);

}
static void dfs(int tar, int sumx, int sumy, int sumz){
if(tar == n + 1){//dfs终止条件
if(sumx > sumy && sumy > sumz && sumz > 0){
minn = Math.min(minn, sumx - sumz);
}
return;
}//下面三个dfs分别表示第tar物品，放进哪个盒子
dfs(tar + 1, sumx + arr[tar], sumy, sumz);
dfs(tar + 1, sumx, sumy + arr[tar], sumz);
dfs(tar + 1, sumx, sumy, sumz + arr[tar]);
}
}

C++代码
#include <iostream>
#include <algorithm>
using namespace std;
int n;
int arr[16];
int minn = 2e9;
void dfs(int tar, int sumx, int sumy, int sumz) {
if (tar == n + 1) { //dfs终止条件
if (sumx > sumy && sumy > sumz && sumz > 0) {
minn = min(minn, sumx - sumz);
}
return;
}//下面三个dfs分别表示第tar物品，放进哪个盒子
dfs(tar + 1, sumx + arr[tar], sumy, sumz);
dfs(tar + 1, sumx, sumy + arr[tar], sumz);
dfs(tar + 1, sumx, sumy, sumz + arr[tar]);
}
int main() {
cin>>n;
for (int i = 1; i <= n; i++) {
cin>>arr[i];
}
dfs(1, 0, 0, 0);
if (minn == (int)2e9) cout<<0<<endl; //如果minn没更新过，说明没有合理的分法，那么就输出0
else cout<<minn<<endl;
return 0;
}

Python代码
def dfs(tar,sumx,sumy,sumz):
global minn
if (tar == n + 1):#dfs终止条件
if (sumx > sumy and sumy > sumz and sumz > 0):
minn = min(minn, sumx - sumz);
return;
#下面三个dfs分别表示第tar物品，放进哪个盒子
dfs(tar + 1, sumx + arr[tar], sumy, sumz);
dfs(tar + 1, sumx, sumy + arr[tar], sumz);
dfs(tar + 1, sumx, sumy, sumz + arr[tar]);

arr=[0 for i in range(16)]
minn = int(2e9);
n=int(input())
arr=list(map(int,input().split()))
arr.insert(0,0)
dfs(1,0,0,0)
if minn==int(2e9):#如果minn没更新过，说明没有合理的分法，那么就输出0
print(0)
else:
print(minn)

Js代码
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';

process.stdin.on('data', (data) => {
input += data;
return;
});
process.stdin.on('end', () => {
function dfs(tar,sumx,sumy,sumz){
if (tar == n + 1) { //dfs终止条件
if (sumx > sumy && sumy > sumz && sumz > 0) {
minn = Math.min(minn, sumx - sumz);
}
return;
}//下面三个dfs分别表示第tar物品，放进哪个盒子
dfs(tar + 1, sumx + arr[tar], sumy, sumz);
dfs(tar + 1, sumx, sumy + arr[tar], sumz);
dfs(tar + 1, sumx, sumy, sumz + arr[tar]);
}
let minn = Number(2e9);
input=input.split('\n');
var n=Number(input[0][0]);
var arr=new Array();
for (let i=1;i<=n;i++)
arr[i]=Number(input[1].split(' ')[i-1]);
dfs(1, 0, 0, 0);
if (minn == 2000000000) console.log(0); //如果minn没更新过，说明没有合理的分法，那么就输出0
else console.log(minn);
});

---

### 第3题-DNS本地缓存（P2412）
- 链接：https://codefun2000.com/p/P2412

> 页面标题：#P2412. 第3题-DNS本地缓存

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一名软件工程师，他正在开发一个DNS本地缓存系统。在互联网中，DNS（Domain Name System）用于将域名（例如www.example.com）解析为IP地址，以便将请求发送到正确的服务器上。通常情况下，DNS请求会发送到互联网上的某个DNS服务器，这会造成一定的网络延迟和负载。为了解决这个问题，小明想要开发一个本地DNS缓存系统，可以在本地缓存一部分DNS请求的结果，以提高性能和减轻网络负载。
小明的这个DNS本地缓存系统有功能如下：

系统初始状态无存储记录，最大可缓存N条记录;
系统每1秒能解析1个URL地址，先从本地DNS上查找，如果本地缓存中能查到就直接返回from_cache;
如果本地DNS.上没有该地址，返回from_internet, 并从URL的属性列表tls上，读取该URL的TTL(Time To Live代表该URL的生存时长，即能够保存到缓存系统中的时长)，并将URL存入缓存系统中;如果在ts上未能读到该URL的TTL,设置默认TTL为5s;
本地缓存系统中URL地址的TTL每秒减1，当TTL=0时，将该URL地址从缓存系统中移除;
在系统空间装满后，如果还有新的URL要录入，则将TTL最小的一个URL移除，如果TTL最小的URL存在多个，按照先进先出的方式移除1个URL.

现在每1秒输入一个URL地址,求每个URL地址的解析方式(from_cache 还是 from_internet)。
输入描述
第一行两个整数N XN\ XN X ， 代表DNS的缓存空间以及待请求的URL的数量
接下来一行XXX个整数，分别代表对应的urlurlurl , 形如: url1,url2,url3,...,urlXurl_1 ,url_2 , url_3 , ... ,url_Xurl1​,url2​,url3​,...,urlX​ , 元素允许重复
接下来一行整数 YYY , 代表URL的属性列表tls长度.
接下来YYY行，每行两个整数，urliurl_iurli​ 和 ttlittl_ittli​ .
数据范围说明:
0<N,X,Y≤65535，N,X，Y为正整数0 < N, X, Y \leq 65535，N, X，Y为正整数0<N,X,Y≤65535，N,X，Y为正整数
0≤urli,ttli≤65535,urli,ttli为整数 0 \leq url_i, ttl_i \leq 65535, url_i, ttl_i为整数0≤urli​,ttli​≤65535,urli​,ttli​为整数
输出描述
每秒中url的解析方式列表(0: from_cache, 1: from_internet)
样例1
输入
5 5
3 1 2 1 2
2
1 4
2 2

输出
1 1 1 0 1

样例2
输入
10 15
11 14 10 5 8 3 8 13 12 9 12 15 15 7 7
8
11 2
14 11
10 9
5 7
8 1
13 10
9 10
15 8

输出
1 1 1 1 1 1 1 1 1 1 0 1 0 1 0

#### TextSol

题目大意
这道题目要求我们模拟一个DNS本地缓存系统
思路
1.缓存容量：缓存最多能存储N条记录。
2.URL请求处理：
每秒处理一个URL请求。
如果请求的URL已经存在于缓存中，直接返回from_cache（输出0）。
如果请求的URL不在缓存中，返回from_internet（输出1），并将该URL加入缓存。
3.TTL管理：
每个URL在缓存中都有一个TTL（Time To Live）值，表示其在缓存中的存活时间。
每秒钟，缓存中所有URL的TTL值减1。当TTL值减为0时，该URL从缓存中移除。
如果加入缓存的新URL没有指定TTL，默认TTL值为5秒。
如果有指定TTL，则使用指定的TTL值。
4.缓存替换策略：
当缓存已满且需要加入新的URL时，移除TTL值最小的URL。
如果有多个URL的TTL值相同，则按照先进先出的原则移除最早加入的URL。
类似题目推荐
LeetCode
1.239. 滑动窗口最大值  - 优先队列入门
2.264. 丑数 II
3.621. 任务调度器
4.857. 雇佣 K 名工人的最低成本
CodeFun2000
1.P1211 塔子大厂真题模拟赛-第一题-魔法石(Ⅰ)
2.P1057 华为od 2022.11.17-分奖金
3.P1052 华东师范大学保研机试-2022-乘法
代码
CPP
#include <bits/stdc++.h>
using namespace std;
const int N = 65536;
struct Node		//维护一个URL的信息
{
int edt, stt, id;		//edt代表生存周期结束时间，stt代表开始时间
bool operator<(const Node& b) const		//为了使用优先队列存储要重载运算符<
{	//优先队列应该要将待删除的数放在队列顶，而优先队列默认为大堆顶，所以要将优先删除的 TTL最小的，即结束时间最小的定为最"大"的值，相等时按先进先出原则，按开始时间排序。
if(edt == b.edt) return stt > b.stt;
return edt > b.edt;
}
};
priority_queue<Node> que;	//优先队列定义
int n, x, y;
int q[N];			//询问数组
int ttls[N];		//每个URL的ttl
bool f[N];			//记录当前队列中有没有某个URL
int main()
{
cin >> n >> x;
for(int i = 1 ; i <= x ; i ++) {		//输入待处理的YLRL
cin >> q[i];
}
for(int &t:ttls) {	//将所有的ttl初始化为5
t = 5;
}
cin >> y;
while(y--) {		//循环y次
int url, ttl;
cin >> url >> ttl;
ttls[url] = ttl;		//更新这些URL的ttl
}
for(int i = 1 ; i <= x ; i++) {
while(que.size() && que.top().edt <= i) {		//删除所有结束时间在i之前的本地缓存
f[que.top().id] = 0;
que.pop();
}
if(f[q[i]]) {		//如果本地缓存中有输出0
cout << 0 << " \n"[i==x];
} else {
cout << 1 << " \n"[i==x];	//没有则输出1，然后添加到本地缓存中
if(que.size() == n) {		//如果满了删除队列顶一个元素
f[que.top().id] = 0;
que.pop();
}
f[q[i]] = 1;
que.push({i+ttls[q[i]], i, q[i]});//将当前的URL放入队列
}
}
}

python
import copy
from queue import PriorityQueue

N, X = map(int, input().strip().split()) # 输入 DNS 缓存上限和 TTL 上限
askurls = list(map(int, input().strip().split())) # 多次 DNS 查询的 URL 序列
urltmap = {}
Y = int(input().strip())
for i in range(Y):
url, ttl = map(int, input().strip().split()) # 输入 DNS 地址以及相应的生存周期 TTL
urltmap[url] = ttl # 将 URL 和 TTL 存储在字典 urltmap 中
ans = ""
fn = [False] * 65536 # 初始化布尔数组 fn，用于判断某个 URL 是否已经被缓存
pq = PriorityQueue() # 初始化优先队列 pq，用于维护本地 DNS 缓存
for i in range(len(askurls)):
while not pq.empty() and pq.queue[0][0] <= i:
# 找到优先队列中已过期的生存周期的 URL，进行删除处理
cur = pq.get()
fn[cur[2]] = False
# 如果当前 URL 已经被缓存，则将结果字符串连接 "0 "
if fn[askurls[i]]:
ans += "0 "
else: # 否则当前 URL 还未被缓存，则将结果字符串连接 "1 "
ans += "1 "
if len(pq.queue) >= N: # 如果已缓存的 URL 数量达到 DNS 缓存上限 N，则进行删除处理
cur = pq.get() # 取出优先级最高的 URL，进行删除处理
fn[cur[2]] = False # 将被删除的 URL 对应的缓存状态设置为 False
pq.put((i+urltmap.get(askurls[i], 5), i, askurls[i])) # 将当前 URL 存储在优先队列中，并根据 TTL 计算其生存周期结束时间
fn[askurls[i]] = True # 将当前 URL 对应的缓存状态设置为 True，表示已被缓存
print(ans[:-1]) # 输出结果字符串

Java
import java.util.*;
public class Main {
public static void main(String[] args) {
Scanner scanner=new Scanner(System.in);
int n= scanner.nextInt(),x= scanner.nextInt();
int[] url=new int[x];
int max=0;
for (int i = 0; i < x; i++) {
url[i]= scanner.nextInt();
}
int y= scanner.nextInt();
Map<Integer,Integer> map=new HashMap<>();
for(int i=0;i<y;i++){
map.put(scanner.nextInt(),scanner.nextInt());
}
PriorityQueue<int[]> pq=new PriorityQueue<>((o1, o2) -> o1[1]==o2[1]?o1[0]-o2[0]:o1[1]-o2[1]);
Map<Integer,int[]> cache=new HashMap<>();
int[] ans=new int[x];
for(int i=0;i<x;i++){
//先删除持续时间结束的
while(pq.size()>0&&pq.peek()[1]<=i){
int[] rem=pq.poll();
cache.remove(rem[2]);
}
if(cache.containsKey(url[i])){
ans[i]=0;
}else {
ans[i]=1;
//如果优先队列的第一个元素的结束时间小于当前时间
if(pq.size()==n){
int[] rem=pq.poll();
cache.remove(rem[2]);
}
//开始时间 结束时间 url
int[] add=new int[]{i,i+map.getOrDefault(url[i],5),url[i]};
pq.offer(add);
cache.put(url[i],add);
}
}
for(int i=0;i<x;i++){
System.out.print(ans[i]+" ");
}
}
}
// by 月与海

Go
package main

import (
"fmt"
)

const N = 70000

var n, x, y, idx int
var urls, tls map[int]int //urls: key url,value ttl
var q, ans, seq []int     //seq记录url进入的时机

func getMin() int {
//选择缓存中ttl最小的删除
var res int = -1
minTtl := N
for url, ttl := range urls {
if ttl < minTtl {
minTtl = ttl
res = url
} else if ttl == minTtl {
if seq[url] < seq[res] {
res = url
}
}
}
return res
}

func main() {
//初始化所有slice和map
q = make([]int, N)
ans = make([]int, N)
seq = make([]int, N)
urls, tls = make(map[int]int), make(map[int]int)
fmt.Scan(&n, &x)
for i := 0; i < x; i++ {
fmt.Scan(&q[i])
}
fmt.Scan(&y)
for i := 0; i < y; i++ {
//初始化urls序列
var url, ttl int
fmt.Scan(&url, &ttl)
tls[url] = ttl
}
//每1秒输入一个URL地址 那么x有个暗含的意思就是处理时间
for i := 0; i < x; i++ {
//先从本地DNS上查找，如果本地缓存中能查到就直接返回from_cache -> 0
if _, ok := urls[q[i]]; ok {
ans[i] = 0
} else {
//本地缓存中查不到 -> from_internet 1
ans[i] = 1
//将这条url加入 urls中 先判断有没有装满 如果装满了就ttl最小的移除 如果ttl一样 就将入队时间早的移除
if len(urls) == n {
delete(urls, getMin())
}
//将url 放入urls 从URL的属性列表tls上，读取该URL的TTL 并将URL存入缓存系统中;如果在ts上未能读到该URL的TTL,设置默认TTL为5s;
if _, ok := tls[q[i]]; ok {
urls[q[i]] = tls[q[i]]
} else {
urls[q[i]] = 5
}
seq[q[i]] = idx
idx++
}
//一秒结束了 URL地址的TTL每秒减1，当TTL=0时，将该URL地址从缓存系统中移除;
for url := range urls {
urls[url]--
if urls[url] == 0 {
delete(urls, url)
}
}
}
for i := 0; i < x; i++ {
fmt.Printf("%d", ans[i])
if i != x-1 {
fmt.Printf(" ")
}
}
}
// by xchen

Js
// 设置 stdin 接收输入数据
process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
input += data;
return;
});

process.stdin.on('end', () => {
// input 数组以字符串形式存储了所有输入内容。input[i] 存储第i行的所有内容.
input = input.split('\n');

// 获取输入参数
const param0 = input[0].split(' ')
const N = Number(param0[0]) // 缓存容量
const X = Number(param0[1]) // 请求个数

const urlList = new Array() // url 请求列表
const param1 = input[1].split(' ')
for (let m = 0; m < X; m++) {
urlList.push(Number(param1[m]))
}

const Y = Number(input[2])
const tls = new Map()
for (let i = 0; i < Y; i++) {
let tmp = input[3+i].split(' ')
tls.set(Number(tmp[0]), Number(tmp[1]))
}

const cache = new Array() // 缓存
const set = new Set() // 缓存中 url 集合

// 添加 url 到缓存
function add(url){
if(cache.length < N){
cache.push([url, tls.get(url) || 5])
set.add(url)
} else {
if(set.has(url)){
// 当前 url 已经存在于缓存中，不需要进行任何操作
} else {
// 缓存已满，删除缓存中生命周期最短的 url ，并将新的 url 添加到缓存中
cache.sort((a, b) => a[1]-b[1])
set.delete(cache[0][0])
cache.shift()
cache.push([url, tls.get(url) || 5])
set.add(url)
}
}
}

// 更新缓存中 url 的 TTL
function TTL() {
for(let i = 0; i < cache.length; i++){
cache[i][1] -= 1
let urlTTL = cache[i][1]
if(urlTTL === 0){
set.delete(cache[i][0])
cache.splice(i,1)
i--
}
}
}

let result = new Array()
for (let i = 0; i < X; i++) {
// 更新缓存中 url 的 TTL
TTL()
if(set.has(urlList[i])){
// url 存在于缓存中
result.push('0')
}else{
// url 不存在于缓存中，将其添加至缓存中
result.push('1')
add(urlList[i])
}
}

let ans = ''
for(let i = 0; i < result.length - 1; i++){
ans += result[i] + ' '
}
ans += result[result.length-1]
console.log(ans)
})

---

### 第3题-分糖果（P2409）
- 链接：https://codefun2000.com/p/P2409

> 页面标题：#P2409. 第3题-分糖果

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题目大意
这道题目要求将一组糖果分成两堆，使得按照kozi的加法方式（即二进制异或运算），两堆糖果的总重量相等。同时，塔子哥希望自己获得的糖果总重量尽可能大。
思路：贪心
具体步骤
1.计算总体异或值和总重量：
遍历所有糖果，计算它们的总重量sum和总体异或值m。
同时，记录最小重量的糖果mn。
2.判断分组的可行性：
如果总体异或值m不为0：
无法将糖果分成两堆异或值相等的部分。
输出"NO"，表示无法满足kozi的要求。
如果总体异或值m为0：
存在至少一种分组方式使得两堆糖果的异或值相等。
为了让塔子哥获得尽可能多的糖果，总重量最大化，可以采用贪心策略：
将重量最小的一块糖果分给kozi，这样塔子哥获得的糖果总重量为sum - mn。
3.输出结果：
根据上述判断，输出塔子哥的糖果总重量或"NO"
代码
C++代码
#include<bits/stdc++.h>
using namespace std;

// 定义解决函数
void solve() {
int n;          // 糖果的数量
int m = 0;      // 总异或值初始化为0
long long sum = 0; // 总重量初始化为0
int mn = 1e9;   // 最小重量初始化为一个较大的值

cin >> n; // 读取糖果的数量

// 遍历每一块糖果，读取其重量并更新总重量、总异或值和最小重量
for(int i = 0, x; i < n; ++i) {
cin >> x;        // 读取第i块糖果的重量
sum += x;        // 累加总重量
m ^= x;          // 计算总异或值
mn = min(mn, x); // 更新最小重量
}

if(m == 0) { // 如果总异或值为0，表示可以分成两堆异或值相等
cout << sum - mn << endl; // 输出塔子哥可以获得的最大糖果总重量
} else { // 如果总异或值不为0，无法分成两堆异或值相等
cout << "NO" << endl; // 输出"NO"
}
}

signed main() {
solve(); // 调用解决函数
return 0; // 程序结束
}

python代码
def solve():
n = int(input())  # 读取糖果的数量
m = 0             # 初始化总异或值为0
total_sum = 0     # 初始化总重量为0
mn = int(1e9)     # 初始化最小重量为一个较大的值
a = list(map(int, input().split()))  # 读取所有糖果的重量并存储在列表a中

for x in a:
total_sum += x      # 累加每块糖果的重量到总重量
m ^= x              # 计算所有糖果重量的异或值
mn = min(mn, x)     # 更新最小重量

if m == 0:
print(total_sum - mn)  # 如果总异或值为0，输出塔子哥可以获得的最大糖果总重量
else:
print("NO")            # 如果总异或值不为0，输出"NO"，表示无法分组

if __name__ == "__main__":
solve()

Java代码
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
solve(); // 调用解决函数
}

static void solve() {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt(); // 读取糖果的数量
int m = 0; // 初始化总异或值为0
long sum = 0; // 初始化总重量为0
int mn = 1000000000; // 初始化最小重量为一个较大的值

// 遍历每一块糖果，读取其重量并更新总重量、总异或值和最小重量
for (int i = 0; i < n; i++) {
int x = sc.nextInt(); // 读取第i块糖果的重量
sum += x; // 累加总重量
m ^= x; // 计算总异或值
mn = Math.min(mn, x); // 更新最小重量
}

if (m == 0) { // 如果总异或值为0，表示可以分成两堆异或值相等
System.out.println(sum - mn); // 输出塔子哥可以获得的最大糖果总重量
} else { // 如果总异或值不为0，无法分成两堆异或值相等
System.out.println("NO"); // 输出"NO"
}

sc.close(); // 关闭扫描器
}
}

题目描述
Tazi和kozi是两兄弟，妈妈给了他们一大袋糖，每块糖都有属于自己的重量。
现在他们想要将这些糖分成两堆。
分糖的任务当然落到了大哥Tazi的身上，然而kozi要求必须两个人获得的糖的总重量“相等”（根据kozi的逻辑），要不然就会哭的。
非常不幸的是，kozi还非常小，并且他只会先将两个数转成二进制再进行加法，而且总会忘记进位。
如当12（1100）加5（101）时：
1100
+ 0101
————
1001
于是kozi得到的计算结果是9（1001）。
此外还有一些例子：
5 + 4 = 1
7 + 9 = 14
50 + 10 = 56
现在Tazi非常贪婪，他想要尽可能使自己得到的糖的总重量最大，且不让kozi哭。
输入
输入的第一行是一个整数 N( 2≤N≤152 ≤ N ≤ 152≤N≤15 )，表示有袋中多少块糖。
第二行包含N个用空格分开的整数 WeightiWeight_iWeighti​  ( 1≤Weighti≤1061 ≤  Weight_i  ≤ 10^61≤Weighti​≤106 )，表示第i块糖的重量。
输出
如果能让kozi不哭，输出Tazi所能获得的糖的总重量，否则输出“NO”。
样例
输入
3
1 5 4

输出
9

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 72ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-快递员（P2406）
- 链接：https://codefun2000.com/p/P2406

> 页面标题：#P2406. 第3题-快递员

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一名快递员，他每天都要在城市里送很多快递。他负责的一个小区是一个很特别的地方，这个小区原本是一个军事基地，后来被改造成了住宅区。因为基地的设计很复杂，所以小区的布局也很奇怪，大体上可以看成一个 m×nm \times nm×n 个方格组成的矩阵。有些地方还保留了原来的防御设施。这些设施对于普通人来说是不可进入的，所以小明不能穿过它们。(0 代表空地， B 代表楼栋, # 代表防御设施)
小区的住户大多数是退伍军人或者军人家属，他们都有一种特殊的习惯：他们不喜欢下楼取快递，而是要求小明把快递送到他们附近的某个地方，然后他们再去取。这是因为他们觉得下楼太麻烦，而且有些人还有战争创伤，不愿意和外界接触。小明虽然觉得这样很不合理，但是他也不敢得罪这些住户，只能尽量满足他们的要求。
小明每天都会从小区的一个入口开始送快递，这个入口的位置是 [row,col][row,col][row,col]  。他可以在空地和楼栋之间自由移动，但是不能穿过防御设施。他的投递方式是这样的：他会在小区里选最多 kkk 个派件点，然后通知周边楼栋的住户前来取件。派件点必须是空地或者楼栋，并且小明可以到达。通知范围是和派件点距离不超过 sss 的同一行或者同一列，并且没有被防御设施挡住的楼栋。
小明希望能够选择合适的派件点，使得他可以给最多楼栋派发快递，并且节省时间和精力。你能帮助小明吗？
输入描述
第一行：两个整数 mmm 和 nnn  (0<m,n≤9)(0\lt m,n \leq 9)(0<m,n≤9),代表小区的大小
第二行：两个整数 rowrowrow 和 colcolcol  (0≤row<m,0≤col<n) (0 \leq row \lt m,0 \leq col \lt n)(0≤row<m,0≤col<n),代表快递员的初始位置
第三行：派件点数目 kkk  (0<k≤5)(0 \lt k \leq 5)(0<k≤5)
第四行：派件点可派件的最大距离 sss  (0<s≤30)(0 \lt s \leq 30)(0<s≤30)
接下来是 mmm 行 nnn 列的矩阵，每一行的元素以空格分隔，内容为(0,B,#)
用例保证所有的输入在正常范围内。
输出描述
返回最多可派件的楼栋数量。
样例
输入
4 4
0 1
2
1
#0B#
0BB#
0#0#
B#B0

输出
4

#### TextSol

题目描述
这道题目要求在一个 m × n 的矩阵中，选择最多 k 个派件点，使得派件点能够覆盖尽可能多的楼栋 (B)。派件点的覆盖范围是在同一行或同一列内，距离不超过 s 且不被防御设施 (#) 阻挡的楼栋。快递员只能移动到空地 (0) 或楼栋 (B) 上，不能穿过防御设施
思路
思路步骤
1.确定可达点：
使用广度优先搜索（BFS）从快递员的起始位置 [row, col] 出发，找到所有可以到达的点（0 或 B），这些点是潜在的派件点。
2.标记楼栋位置：
遍历整个矩阵，记录所有楼栋 (B) 的位置，并为每个楼栋分配一个唯一的编号，用于后续的位运算。
3.计算每个派件点的覆盖：
对于每个可达的派件点，计算其在同一行和同一列内，不超过 s 的距离且不被 # 阻挡的所有楼栋。
使用位运算将这些楼栋的编号表示为一个位掩码（Bitmask）。
4.选择派件点：
使用回溯（DFS）或动态规划的方法，选择最多 k 个派件点，使得它们的覆盖位掩码的并集最大。
由于 k 较小，可以通过组合枚举或贪心策略进行优化。
5.剪枝优化：
在搜索过程中，如果当前选择的派件点数量已达到 k，或无法超过当前已记录的最大覆盖数，立即停止该分支的搜索。
6.输出结果：
最终输出最大的覆盖楼栋数量。
#include <bits/stdc++.h>
using namespace std;
const int N = 35;
int n, m;
char a[N][N];
int k, s;
int ans;
bool ch(int x, int y) {		//检查(x,y)是否在图内并不是墙
return min(x, y) >= 0 && x < n && y < m && a[x][y] != '#';
}
int dx[] = { 1,0,-1,0 };	//四个方向横坐标偏移量
int dy[] = { 0,1,0,-1 };	//纵坐标偏移量
bool bk[N][N];			//是否搜索过
vector<pair<int, int>> v;	//所有合法点集合
void dfs(int x, int y) {
if (bk[x][y]) return;	//如果当前点搜索过直接return
bk[x][y] = 1;		//标记为搜索过
v.push_back({ x, y });	//放入点集
for (int i = 0; i < 4; i++) {	//遍历四个方向
int tx = x + dx[i], ty = y + dy[i];
if (!ch(tx, ty)) continue;	//如果出地图或者是墙，继续遍历下一个方向
dfs(tx, ty);	//dfs搜索
}
}
void dfs2(int now, int cnt, int nows) {		//代表选到v中的第now个点，还剩cnt个派件点可以选，当前答案为nows
if (cnt == 0 || now == v.size()) {	//如果选完了cnt个派件点或者遍历完所有的点
ans = max(ans, nows);		//更新答案并返回
return;
}
//剪枝，如果剩余的所有点都选满(4*s+1)个楼房还不比当前答案大，则直接返回
if(nows + cnt*(4*s+1) <= ans)return;
vector<pair<int, int>> fix;		//记录当前状态中被修改的点，用于dfs状态回溯
for (int i = 0; i < 4; i++) {		//遍历四个方向各s格
for (int j = 0; j <= s; j++) {
int tx = v[now].first + dx[i] * j;
int ty = v[now].second + dy[i] * j;
if (!ch(tx, ty))break;		//如果出地图或者是墙，遍历下一个方向，break当前循环
if (a[tx][ty] == 'B') {		//如果是楼，将当前楼置为空地防止重复计算
fix.push_back({ tx, ty });	//放入fix中之后回溯时还原
a[tx][ty] = '0';		//置为空地
}
}
}
dfs2(now + 1, cnt - 1, nows+fix.size());	//遍历下一个点，选了当前点，当前答案增加fix.size()
for(auto g:fix) {		//还原
a[g.first][g.second] = 'B';
}
dfs2(now + 1, cnt, nows);		//遍历下一个点，不选当前点，当前答案不变
}
int main()
{
int x, y;
cin >> n >> m >> x >> y >> k >> s;	//输入
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
cin >> a[i][j];
}
}
dfs(x, y);		//搜索出所有的从起始点能到达的点。
random_shuffle(v.begin(), v.end());		//随机排列一下，降低期望复杂度
dfs2(0, k, 0);	//选出所有状态，更新答案
cout << ans << endl;	//输出答案
}

python
import sys
import random

# 提高递归深度限制，防止递归过深导致的错误
sys.setrecursionlimit(1000000)

# 定义四个方向的移动（下、右、上、左）
dx = [1, 0, -1, 0]  # 下、右、上、左
dy = [0, 1, 0, -1]

# 全局变量初始化
n, m = 0, 0        # 地图的行数和列数
a = []             # 地图矩阵
k, s = 0, 0        # 派件点数量和覆盖范围
ans = 0            # 最大覆盖的楼栋数量
bk = []            # 是否搜索过的标记矩阵
v = []             # 所有可达的点集合

def ch(x, y):
"""
检查坐标 (x, y) 是否在地图内且不是墙
"""
return 0 <= x < n and 0 <= y < m and a[x][y] != '#'

def dfs(x, y):
"""
深度优先搜索，收集所有从起始点可达的点
:param x: 当前点的行坐标
:param y: 当前点的列坐标
"""
global ans
if bk[x][y]:
return  # 如果当前点已经被搜索过，直接返回
bk[x][y] = True  # 标记当前点为已搜索
v.append((x, y))  # 将当前点加入可达点集合
for i in range(4):  # 遍历四个方向
tx = x + dx[i]
ty = y + dy[i]
if ch(tx, ty):
dfs(tx, ty)  # 递归搜索新的坐标

def dfs2(now, cnt, nows):
"""
递归选择派件点的函数，尝试覆盖更多的楼栋
:param now: 当前正在考虑的点在可达点集合中的索引
:param cnt: 剩余可以选择的派件点数量
:param nows: 当前已经覆盖的楼栋数量
"""
global ans
if cnt == 0 or now == len(v):
# 如果没有剩余派件点可以选择，或者已经遍历完所有点
ans = max(ans, nows)  # 更新答案
return
# 剪枝：如果即使选择剩余的所有派件点，每个派件点最多覆盖 (4*s +1) 个楼栋
# 仍然无法超过当前的答案，则提前返回
if nows + cnt * (4 * s + 1) <= ans:
return
fix = []  # 记录当前状态中被修改的楼栋，用于回溯
x, y = v[now]  # 当前考虑的派件点坐标
for i in range(4):  # 遍历四个方向
for j in range(0, s + 1):  # 修正为从 j=0 开始，包含派件点自身
tx = x + dx[i] * j
ty = y + dy[i] * j
if not ch(tx, ty):
break  # 如果出地图或者遇到墙，停止该方向的遍历
if a[tx][ty] == 'B':
fix.append((tx, ty))  # 记录被覆盖的楼栋
a[tx][ty] = '0'        # 将楼栋标记为已覆盖，防止重复计算
# 选择当前派件点
dfs2(now + 1, cnt - 1, nows + len(fix))
# 回溯，恢复被覆盖的楼栋
for g in fix:
a[g[0]][g[1]] = 'B'
# 不选择当前派件点
dfs2(now + 1, cnt, nows)

def main():
global n, m, k, s, ans, a, bk, v
# 读取所有输入数据并分割为列表
input_data = sys.stdin.read().split()
idx = 0
# 读取小区的行数和列数
n = int(input_data[idx])
m = int(input_data[idx + 1])
idx += 2
# 读取快递员的初始位置
x = int(input_data[idx])
y = int(input_data[idx + 1])
idx += 2
# 读取最多可以选择的派件点数量
k = int(input_data[idx])
# 读取派件点的覆盖范围
s = int(input_data[idx + 1])
idx += 2
# 读取地图布局
a = [['0' for _ in range(m)] for _ in range(n)]
for i in range(n):
if idx >= len(input_data):
break
line = input_data[idx]
for j in range(m):
if j < len(line):
a[i][j] = line[j]
else:
a[i][j] = '0'  # 默认为空地
idx += 1
# 初始化标记矩阵和可达点集合
bk = [[False for _ in range(m)] for _ in range(n)]
v = []
# 执行深度优先搜索，收集所有可达点
if ch(x, y):
dfs(x, y)
# 随机打乱可达点顺序，降低期望复杂度
random.shuffle(v)
# 执行递归选择派件点，更新答案
dfs2(0, k, 0)
# 输出结果
print(ans)

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main {
// 定义四个方向的移动（下、右、上、左）
static int[] dx = {1, 0, -1, 0}; // 下、右、上、左
static int[] dy = {0, 1, 0, -1};

// 地图的行数和列数
static int m, n;
// 地图矩阵
static char[][] a;
// 派件点数量和覆盖范围
static int k, s;
// 最大覆盖的楼栋数量
static int ans = 0;
// 是否搜索过的标记矩阵
static boolean[][] bk;
// 所有可达的点集合
static List<Point> v = new ArrayList<>();

// Point 类表示坐标点
static class Point {
int x, y;
Point(int x, int y){
this.x = x;
this.y = y;
}
}

/**
* 检查坐标 (x, y) 是否在地图内且不是墙
* @param x 行坐标
* @param y 列坐标
* @return 如果合法且不是墙，返回 true，否则返回 false
*/
static boolean ch(int x, int y){
return (0 <= x && x < m) && (0 <= y && y < n) && (a[x][y] != '#');
}

/**
* 深度优先搜索，收集所有从起始点可达的点
* @param x 当前点的行坐标
* @param y 当前点的列坐标
*/
static void dfs(int x, int y){
if(bk[x][y]) return; // 如果当前点已经被搜索过，直接返回
bk[x][y] = true; // 标记当前点为已搜索
v.add(new Point(x, y)); // 将当前点加入可达点集合
for(int i = 0; i < 4; i++){ // 遍历四个方向
int tx = x + dx[i];
int ty = y + dy[i];
if(ch(tx, ty)){
dfs(tx, ty); // 递归搜索新的坐标
}
}
}

/**
* 递归选择派件点的函数，尝试覆盖更多的楼栋
* @param now 当前正在考虑的点在可达点集合中的索引
* @param cnt 剩余可以选择的派件点数量
* @param nows 当前已经覆盖的楼栋数量
*/
static void dfs2(int now, int cnt, int nows){
if(cnt == 0 || now == v.size()){
// 如果没有剩余派件点可以选择，或者已经遍历完所有点
ans = Math.max(ans, nows); // 更新答案
return;
}
// 剪枝：如果即使选择剩余的所有派件点，每个派件点最多覆盖 (4*s +1) 个楼栋
// 仍然无法超过当前的答案，则提前返回
if(nows + cnt * (4 * s + 1) <= ans){
return;
}
// 当前考虑的派件点坐标
Point current = v.get(now);
int x = current.x;
int y = current.y;
// 记录当前状态中被修改的楼栋，用于回溯
List<Point> fix = new ArrayList<>();
for(int i = 0; i < 4; i++){ // 遍历四个方向
for(int j = 0; j <= s; j++){ // 修正为从 j=0 开始，包含派件点自身
int tx = x + dx[i] * j;
int ty = y + dy[i] * j;
if(!ch(tx, ty)){
break; // 如果出地图或者遇到墙，停止该方向的遍历
}
if(a[tx][ty] == 'B'){
fix.add(new Point(tx, ty)); // 记录被覆盖的楼栋
a[tx][ty] = '0'; // 将楼栋标记为已覆盖，防止重复计算
}
}
}
// 选择当前派件点
dfs2(now + 1, cnt - 1, nows + fix.size());
// 回溯，恢复被覆盖的楼栋
for(Point g : fix){
a[g.x][g.y] = 'B';
}
// 不选择当前派件点
dfs2(now + 1, cnt, nows);
}

public static void main(String[] args){
Scanner sc = new Scanner(System.in);
// 读取小区的行数和列数
m = sc.nextInt();
n = sc.nextInt();
// 读取快递员的初始位置
int row = sc.nextInt();
int col = sc.nextInt();
// 读取最多可以选择的派件点数量
k = sc.nextInt();
// 读取派件点的覆盖范围
s = sc.nextInt();
sc.nextLine(); // 读取换行符
// 初始化地图矩阵
a = new char[m][n];
for(int i = 0; i < m; i++){
String line = sc.nextLine();
for(int j = 0; j < n; j++){
if(j < line.length()){
a[i][j] = line.charAt(j);
}
else{
a[i][j] = '0'; // 默认为空地
}
}
}
// 初始化标记矩阵
bk = new boolean[m][n];
// 执行深度优先搜索，收集所有可达点
if(ch(row, col)){
dfs(row, col);
}
// 随机打乱可达点顺序，降低期望复杂度
Collections.shuffle(v, new Random());
// 执行递归选择派件点，更新答案
dfs2(0, k, 0);
// 输出结果
System.out.println(ans);
sc.close();
}
}

---

### 第3题-最小操作次数（P2808）
- 链接：https://codefun2000.com/p/P2808

> 页面标题：#P2808. 第3题-最小操作次数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个N∗NN*NN∗N的二维矩阵，其中包含[1，N2][1，N^2][1，N2]的互不相同的正整数。
定义一种操作:
每次可以选择矩阵中的一个元素，将其与其在顺时针螺旋顺序中的下一个元素交换位置
例如:
在3∗33*33∗3的矩阵中,
螺旋顺序为从左上角[0,0][0,0][0,0]开始，向右到[0,2][0,2][0,2]，向下到[2,2][2,2][2,2]，向左到[2,0][2,0][2,0]，再向上到[1,0][1,0][1,0]，最
后到中心[1,1][1,1][1,1]。
目标是通过若干次操作，将矩阵变为“顺时针螺旋递增”顺序，即螺旋遍历时元素依次为
1,2,3,...,N21,2,3,...,N^21,2,3,...,N2。
求将给定矩阵转换为顺时针螺旋递增顺序所需的最小操作次数。
输入描述
第一行为整数NNN;
接下来NNN行，每行NNN个整数,表示矩阵。
参数范围:
矩阵的N取值范围为[1,103][1,10^3][1,103]；
矩阵中元素的取值范围[1,N2][1,N^2][1,N2]；
输出描述
一个整数;
表示最小操作次数。
特别注意:
结果可能过大，因此结果需要取模100000000710000000071000000007。
例如，计算初始结果为:100000000810000000081000000008，请返回111。
样例1
输入
2
3 1
2 4

输出
3

说明
根据要求，通过若干次操作得到的目标矩阵为：
1 21\ 21 2
4 34\ 34 3
第一次交换,选择(0,0)(0,0)(0,0)的333与螺旋顺序上相邻的(0,1)(0,1)(0,1)的111交换，矩阵为:
1 31\ 31 3
2 42\ 42 4
第二次交换,选择(1,1)(1,1)(1,1)的444与螺旋顺序上相邻的(1,0)(1,0)(1,0)的222交换，矩阵为:
1 31\ 31 3
4 24\ 24 2
第三次交换，选择(0,1)(0,1)(0,1)的333与螺旋顺序上相邻的(1,1)(1,1)(1,1)的222交换，矩阵为：
1 21\ 21 2
4 34\ 34 3
目标达成;
操作次数333;
样例2
输入
3
3 2 1
6 5 4
9 8 7

输出
10

说明
解释:根据要求，通过若干次操作得到的目标矩阵为:
1 2 31\ 2\ 31 2 3
8 9 48\ 9\ 48 9 4
7 6 57\ 6\ 57 6 5
开始交换(注意选择螺旋顺序上相邻的交换);
第111次交换:
3 2 13\ 2\ 13 2 1
5 6 45\ 6\ 45 6 4
9 8 79\ 8\ 79 8 7
第222次交换:
3 2 13\ 2\  13 2 1
9 6 49\ 6\ 49 6 4
5 8 75\ 8\ 75 8 7
第333次交换:
3 2 13\ 2\ 13 2 1
6 9 46\ 9\ 46 9 4
5 8 75\ 8\ 75 8 7
第444次交换:
3 2 13\ 2\ 13 2 1
6 9 46\ 9\ 46 9 4
8 5 78\ 5\ 78 5 7
第555次交换:
3 2 13\ 2\ 13 2 1
8 9 48\ 9\ 48 9 4
6 5 76\ 5\ 76 5 7
第666次交换:
3 2 13\ 2\ 13 2 1
8 9 48\ 9\ 48 9 4
6 7 56\ 7\ 56 7 5
第777次交换:
3 2 13\ 2\ 13 2 1
8 9 48\ 9\ 48 9 4
7 6 57\ 6\ 57 6 5
第888次交换:
3 1 23\ 1\ 23 1 2
8 9 48\ 9\ 48 9 4
7 6 57\ 6\ 57 6 5
第999次交换:
1 3 21\ 3\ 21 3 2
8 9 48\ 9\ 48 9 4
7 6 57\ 6\ 57 6 5
第101010次交换:
1 2 31\ 2\ 31 2 3
8 9 48\ 9\ 48 9 4
7 6 57\ 6\ 57 6 5
目标达成;
操作次数101010;

▶️

#### TextSol

video solution

题解
题面描述
给定一个 N×NN \times NN×N 的二维矩阵，其中包含 [1, N2][1,\,N^2][1,N2] 的互不相同正整数。允许的操作为：
每次选择矩阵中的一个元素，将其与其在顺时针螺旋顺序中的下一个元素交换。
目标是通过若干次操作，使矩阵变为“顺时针螺旋递增”顺序，即按照螺旋遍历时，元素依次为 1,2,3,…,N21,2,3,\dots,N^21,2,3,…,N2。要求求出最小操作次数，并对 100000000710000000071000000007 取模。

思路

将矩阵按照顺时针螺旋顺序遍历，转化为长度为 N2N^2N2 的一维数组 spiral\text{spiral}spiral。
最终目标数组为 [1,2,3,…,N2][1,2,3,\dots,N^2][1,2,3,…,N2]。
每次操作相当于交换数组中相邻的两个元素，而最少操作次数等于数组排列的逆序数数量。
采用树状数组（Binary Indexed Tree）方法可以在 O(N2log⁡(N2))O(N^2 \log (N^2))O(N2log(N2)) 的时间内统计逆序数。

对于数组中每个元素 xxx（取值范围为 [1, N2[1,\,N^2[1,N2），遍历时利用树状数组查询在其前面已经出现的数中，大于 xxx 的个数，即 inversionsinversionsinversions += (当前已处理个数 - query(x)query(x)query(x))。
同时更新树状数组中 xxx 的计数值。

最终对逆序数结果取模 100000000710000000071000000007 得到答案。

C++
#include <iostream>
#include <vector>
using namespace std;

const int MOD = 1000000007;

// 树状数组类，用于统计前缀和
struct BIT {
vector<int> tree;
int n;
BIT(int n): n(n), tree(n+1, 0) {}

// 更新树状数组，在位置 idx 加上 val
void update(int idx, int val) {
for(; idx <= n; idx += idx & -idx)
tree[idx] += val;
}

// 查询前缀和，从 1 查询到 idx
int query(int idx) {
int sum = 0;
for(; idx > 0; idx -= idx & -idx)
sum += tree[idx];
return sum;
}
};

int main(){
ios::sync_with_stdio(false);
cin.tie(0);

int N;
cin >> N;
vector<vector<int>> matrix(N, vector<int>(N));
for (int i = 0; i < N; i++){
for (int j = 0; j < N; j++){
cin >> matrix[i][j];
}
}

// 螺旋遍历提取矩阵中的元素
vector<int> spiral;
int top = 0, bottom = N - 1;
int left = 0, right = N - 1;
while(top <= bottom && left <= right) {
// 从左到右
for(int j = left; j <= right; j++){
spiral.push_back(matrix[top][j]);
}
top++;
if(top > bottom) break;
// 从上到下
for(int i = top; i <= bottom; i++){
spiral.push_back(matrix[i][right]);
}
right--;
if(left > right) break;
// 从右到左
for(int j = right; j >= left; j--){
spiral.push_back(matrix[bottom][j]);
}
bottom--;
if(top > bottom) break;
// 从下到上
for(int i = bottom; i >= top; i--){
spiral.push_back(matrix[i][left]);
}
left++;
}

// 使用树状数组统计逆序数（最少交换次数）
int size = spiral.size();
// 元素取值范围为 [1, N*N]
BIT bit(N * N);
long long inversions = 0;

// 从左到右遍历，每个元素统计在其之前已插入的个数中大于它的个数
for (int i = 0; i < size; i++){
int x = spiral[i];
// query(x) 得到前面已经插入的 ≤ x 的数量，因此 (i - query(x)) 即为大于 x 的数量
inversions = (inversions + (i - bit.query(x))) % MOD;
bit.update(x, 1);
}

cout << inversions % MOD << "\n";
return 0;
}

Python
# 树状数组类，用于统计前缀和
class BIT:
def __init__(self, n):
self.n = n
self.tree = [0] * (n + 1)

# 更新树状数组，在位置 idx 加上 val
def update(self, idx, val):
while idx <= self.n:
self.tree[idx] += val
idx += idx & -idx

# 查询前缀和，从 1 查询到 idx
def query(self, idx):
s = 0
while idx:
s += self.tree[idx]
idx -= idx & -idx
return s

MOD = 1000000007

def main():
import sys
data = sys.stdin.read().strip().split()
if not data:
return
N = int(data[0])
matrix = []
index = 1
for i in range(N):
row = []
for j in range(N):
row.append(int(data[index]))
index += 1
matrix.append(row)

# 螺旋遍历提取矩阵中的元素
spiral = []
top, bottom = 0, N - 1
left, right = 0, N - 1
while top <= bottom and left <= right:
# 从左到右
for j in range(left, right + 1):
spiral.append(matrix[top][j])
top += 1
if top > bottom:
break
# 从上到下
for i in range(top, bottom + 1):
spiral.append(matrix[i][right])
right -= 1
if left > right:
break
# 从右到左
for j in range(right, left - 1, -1):
spiral.append(matrix[bottom][j])
bottom -= 1
if top > bottom:
break
# 从下到上
for i in range(bottom, top - 1, -1):
spiral.append(matrix[i][left])
left += 1

size = len(spiral)
bit = BIT(N * N)
inversions = 0
# 从左到右遍历，统计当前元素前面大于它的个数
for i in range(size):
x = spiral[i]
inversions = (inversions + (i - bit.query(x))) % MOD
bit.update(x, 1)

print(inversions % MOD)

if __name__ == "__main__":
main()

Java
import java.util.*;
import java.io.*;

public class Main {
static final int MOD = 1000000007;

// 树状数组类，用于统计前缀和
static class BIT {
int[] tree;
int n;

public BIT(int n) {
this.n = n;
tree = new int[n + 1];
}

// 更新树状数组，在位置 idx 加上 val
public void update(int idx, int val) {
while(idx <= n) {
tree[idx] += val;
idx += idx & -idx;
}
}

// 查询前缀和，从 1 到 idx
public int query(int idx) {
int sum = 0;
while(idx > 0) {
sum += tree[idx];
idx -= idx & -idx;
}
return sum;
}
}

public static void main(String[] args) throws Exception {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine().trim());
int[][] matrix = new int[N][N];
for(int i = 0; i < N; i++){
String[] parts = br.readLine().trim().split("\\s+");
for(int j = 0; j < N; j++){
matrix[i][j] = Integer.parseInt(parts[j]);
}
}

// 螺旋遍历提取矩阵中的元素
ArrayList<Integer> spiralList = new ArrayList<>();
int top = 0, bottom = N - 1;
int left = 0, right = N - 1;
while(top <= bottom && left <= right) {
// 从左到右
for(int j = left; j <= right; j++){
spiralList.add(matrix[top][j]);
}
top++;
if(top > bottom) break;
// 从上到下
for(int i = top; i <= bottom; i++){
spiralList.add(matrix[i][right]);
}
right--;
if(left > right) break;
// 从右到左
for(int j = right; j >= left; j--){
spiralList.add(matrix[bottom][j]);
}
bottom--;
if(top > bottom) break;
// 从下到上
for(int i = bottom; i >= top; i--){
spiralList.add(matrix[i][left]);
}
left++;
}

int size = spiralList.size();
int[] spiral = new int[size];
for (int i = 0; i < size; i++){
spiral[i] = spiralList.get(i);
}

// 使用树状数组统计逆序数（最少操作次数）
BIT bit = new BIT(N * N);
long inversions = 0;
// 从左到右遍历，对于每个元素统计前面大于它的元素个数
for (int i = 0; i < size; i++){
int x = spiral[i];
inversions = (inversions + (i - bit.query(x))) % MOD;
bit.update(x, 1);
}

System.out.println(inversions % MOD);
}
}

---

### 第3题-最大化城市CDN节点建设的最小服务质量（P2850）
- 链接：https://codefun2000.com/p/P2850

> 页面标题：#P2850. 第3题-最大化城市CDN节点建设的最小服务质量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

CDNCDNCDN(content delivery network，内容分发网络)机房可以加速网站内容的加载速度，通过在地理位置上靠近用户的地点存储网站的内容副本。
给定一个下标从 000 开始长度为 nnn 的整数数组 citiescitiescities ，其中 citiescitiescities 表示第 iii 座
城市中现有的 CDNCDNCDN 机房数量。
每个 CDNCDNCDN 机房能够服务的城市覆盖范围由其所在位置决定，所有节点具有相同的城市盖范围。
如果给定的覆盖范围是 rrr ，则位于城市 iii 的 CDNCDNCDN 机房可以为其周围 ∣i−j∣<=r∣i-j∣<=r∣i−j∣<=r 范围内的所有城市提供服务，这里 ∣x∣∣x∣∣x∣ 表示 xxx 的绝对值。例如，∣5−3∣=2，∣4−9∣=5∣5-3∣=2，∣4-9∣=5∣5−3∣=2，∣4−9∣=5 。
一座城市的“服务质量”定义为能够访问到的 CDNCDNCDN 机房的数量，你的任务是在全国范围内选择多个城市来新建 kkk 个 CDNCDNCDN 机房(同一个城市可重复建设)，以确保即使在网络流量高峰时期也能提供最佳的服务质量。
现在给定两个整数 rrr 和 kkk ，你需要决定在哪些城市新建 kkk 个 CDNCDNCDN 机房，使所有城市中最小的服务质量达到最大，并返回最小服务质量。
输入描述
第一行数字为 rrr ，第二行数字为 kkk ，第三行数字为城市数量 nnn ，第四行 nnn 个数字为 citiescitiescities 的值
输入限制：
1<=n<=1000001<=n<=1000001<=n<=100000
0<=cities[i]<=1000000<=cities[i]<=1000000<=cities[i]<=100000
0<=r<=n−10<=r<=n-10<=r<=n−1
0<=k<=1090<=k<=10^90<=k<=109
输出描述
返回所有城市中最小服务质量达到最大时的 CDNCDNCDN 节点数
样例1
输入
1
2
5
1 2 4 9 3

输出
5

说明
输入转换成 cities=[1,2,4,9,3]，r=1，k=2cities=[1,2,4,9,3]，r=1，k=2cities=[1,2,4,9,3]，r=1，k=2
最优方案之一是把 222 个节点都建在城市 111 ，建设完后每座城市的CDN节点数目分别为 [1,4,4,9,3][1,4,4,9,3][1,4,4,9,3] 。

城市 000 的节点数目为 1+4=51+4=51+4=5。

城市 111 的节点数目为 1+4+4=91+4+4=91+4+4=9 。

城市 222 的节点数目为 4+4+9=174+4+9=174+4+9=17 。

城市 333 的节点数目为 4+9+3=164+9+3=164+9+3=16 。

城市 444 的节点数目为 9+3=129+3=129+3=12 。

这些城市中节点数最小的是 555 ，已无法使得这个最小值更大。
样例2
输入
0
3
4
5 5 5 5

输出
5

说明
输入转换成 cities=[5,5,5,5]，r=0，k=3cities=[5,5,5,5]，r=0，k=3 cities=[5,5,5,5]，r=0，k=3。无论如何安排，总有一座城市的 CDNCDNCDN 节点数目是 555 ，所以最优解是 555 。

#### TextSol

题解思路
对于长度为 n 的城市数组 cities，每座城市初始拥有若干 CDN 机房。每个机房的服务半径为 r，相当于它能为相距不超过 r 的城市提供服务。给定还可以新建 k 个机房，允许在同一城市重复建设，目标是使所有城市的最小“服务质量”（即能访问到的机房总数）最大化。
我们可以抽象为：让每个城市 i “窗口”内（[i–r, i+r]）的机房总和至少达到 m，问是否能用不超过 k 次增量操作做到这一点。增量操作：在某个城市 j 新增一台机房，会使得所有覆盖到 j 的城市窗口内总和加 1。

二分答案：对最小服务质量 m 进行二分搜索。
可行性检验：固定候选值 m，判断是否在 k 次新增内使所有城市窗口和 ≥ m。
贪心策略：从城市 0 到 n–1 遍历，维护当前对每个城市由新增机房带来的累计增量 cur_add（通过差分数组模拟区间加法）。若某城市窗口和 initial[i] + cur_add 小于 m，则在最右能覆盖该城市的点 j = min(n–1, i+r) 上新增所需的机房数 need = m – (initial[i] + cur_add)，并将 need 加到差分数组上。若累计新增量超出 k，则判定不可行。

这样，每次检验的时间复杂度为 O(n)，二分需要 O(log T) 次，其中 T 约为初始最小窗口和 + k。
算法流程

前缀和
计算城市机房数的前缀和 ps，用以快速求任意区间和。

初始窗口和
对每座城市 i，计算其初始服务质量
initial[i] = sum(cities[max(0, i-r) .. min(n-1, i+r)])
= ps[min(n-1,i+r)] - ps[max(0,i-r)-1]

二分答案

lo = 0, hi = min(initial) + k
循环直至 lo < hi：设 mid = (lo + hi + 1) // 2

若 check(mid) 可行，则 lo = mid
否则 hi = mid - 1

可行性检验 check(m)

设差分数组 diff[n] 全 0，cur_add = 0，used = 0
对 i 从 0 遍历到 n-1：

cur_add += diff[i]
计算当前覆盖：cover = initial[i] + cur_add
若 cover < m，需新增 need = m - cover：

used += need，若 used > k 返回 false
选点 j = min(n-1, i+r)，其增量区间 [L = max(0,j-r), R = min(n-1,j+r)]，而此时 L=i，故：cur_add += need
if R+1 < n: diff[R+1] -= need

若遍历结束仍未超出 k，则返回 true。

返回 最终二分出的 lo。

复杂度分析

计算初始前缀和和窗口和：O(n)
每次可行性检验：O(n)
二分次数：O(log(初始最小窗口和 + k))，该值上限约 O(log(n·max(cities)+k))
总复杂度：O(n log (n·max(cities)+k))，对 n ≤ 10^5 完全可行。

代码实现
Python 实现
def max_min_service(cities, r, k):
n = len(cities)
# 1. 前缀和
ps = [0] * n
ps[0] = cities[0]
for i in range(1, n):
ps[i] = ps[i-1] + cities[i]
# 2. 初始窗口和
initial = [0] * n
for i in range(n):
L = max(0, i - r)
R = min(n - 1, i + r)
initial[i] = ps[R] - (ps[L - 1] if L > 0 else 0)
# 二分上下界
lo, hi = 0, min(initial) + k

def check(m):
diff = [0] * (n + 1)  # 差分数组，多一位便于操作
cur_add = used = 0
for i in range(n):
cur_add += diff[i]
cover = initial[i] + cur_add
if cover < m:
need = m - cover
used += need
if used > k:
return False
# 在 j 位置新增 need 台机房
j = min(n - 1, i + r)
R = min(n - 1, j + r)
# 新增在 i 开始生效，到 R 结束
cur_add += need
diff[R + 1] -= need
return True

# 二分寻找最大可行 m
while lo < hi:
mid = (lo + hi + 1) // 2
if check(mid):
lo = mid
else:
hi = mid - 1
return lo

# 读入输出
if __name__ == "__main__":
import sys
data = sys.stdin.read().split()
r, k, n = map(int, data[:3])
cities = list(map(int, data[3:]))
print(max_min_service(cities, r, k))

Java 实现
import java.io.*;
import java.util.*;

public class Main {
public static long maxMinService(int[] cities, int r, long k) {
int n = cities.length;
// 1. 前缀和
long[] ps = new long[n];
ps[0] = cities[0];
for (int i = 1; i < n; i++) {
ps[i] = ps[i-1] + cities[i];
}
// 2. 初始窗口和
long[] initial = new long[n];
for (int i = 0; i < n; i++) {
int L = Math.max(0, i - r);
int R = Math.min(n - 1, i + r);
initial[i] = ps[R] - (L > 0 ? ps[L-1] : 0);
}
long lo = 0, hi = Arrays.stream(initial).min().getAsLong() + k;

// 检验函数
class Checker {
boolean check(long m) {
long[] diff = new long[n + 1];
long curAdd = 0, used = 0;
for (int i = 0; i < n; i++) {
curAdd += diff[i];
long cover = initial[i] + curAdd;
if (cover < m) {
long need = m - cover;
used += need;
if (used > k) return false;
int j = Math.min(n - 1, i + r);
int R = Math.min(n - 1, j + r);
curAdd += need;
diff[R + 1] -= need;
}
}
return true;
}
}

Checker checker = new Checker();
while (lo < hi) {
long mid = (lo + hi + 1) >>> 1;
if (checker.check(mid)) lo = mid;
else hi = mid - 1;
}
return lo;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int r = Integer.parseInt(br.readLine());
long k = Long.parseLong(br.readLine());
int n = Integer.parseInt(br.readLine());
String[] parts = br.readLine().split(" ");
int[] cities = new int[n];
for (int i = 0; i < n; i++) cities[i] = Integer.parseInt(parts[i]);
System.out.println(maxMinService(cities, r, k));
}
}

C++ 实现
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll maxMinService(const vector<int>& cities, int r, ll k) {
int n = cities.size();
// 1. 前缀和
vector<ll> ps(n);
ps[0] = cities[0];
for (int i = 1; i < n; i++) {
ps[i] = ps[i-1] + cities[i];
}
// 2. 初始窗口和
vector<ll> initial(n);
for (int i = 0; i < n; i++) {
int L = max(0, i - r);
int R = min(n - 1, i + r);
initial[i] = ps[R] - (L > 0 ? ps[L-1] : 0);
}
ll lo = 0, hi = *min_element(initial.begin(), initial.end()) + k;

// 检验函数
auto check = [&](ll m) {
vector<ll> diff(n+1, 0);
ll curAdd = 0, used = 0;
for (int i = 0; i < n; i++) {
curAdd += diff[i];
ll cover = initial[i] + curAdd;
if (cover < m) {
ll need = m - cover;
used += need;
if (used > k) return false;
int j = min(n - 1, i + r);
int R = min(n - 1, j + r);
curAdd += need;
diff[R+1] -= need;
}
}
return true;
};

// 二分
while (lo < hi) {
ll mid = (lo + hi + 1) >> 1;
if (check(mid)) lo = mid;
else hi = mid - 1;
}
return lo;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int r; ll k; int n;
cin >> r >> k >> n;
vector<int> cities(n);
for (int i = 0; i < n; i++) {
cin >> cities[i];
}
cout << maxMinService(cities, r, k) << "\n";
return 0;
}

---

### 第3题-数据中心网络地址规划（P2847）
- 链接：https://codefun2000.com/p/P2847

> 页面标题：#P2847. 第3题-数据中心网络地址规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你作为数据中心网络地址规划人员，需要尽可能满足不同业务的网络地址需求。每个业务需要的地址范围为一个闭区间 [start_ip,end_ip] 表示，其中 start_ip是起始 IPIPIP 地址，end_ip 是终止 IPIPIP 地址，end_ip 大于等于 start_ip。
不同业务的 IPIPIP 地址不能重叠，因此你需要将业务地址需求，按照一定规则排序，让数据中心网络地址规划尽可能满足更多数量的业务需求。当业多数量相同时，以 IPIPIP 地址占用最少优先。当业务数量和 IPIPIP 地址占用数量相同时，按照 IPIPIP 范围顺序，比较起始 IPIPIP 地址，起始地址最小者优先。
输入描述
1.第一行为业务个数 NNN ，有效范围为 [1,1000][1,1000][1,1000]
2.输入 NNN 行 IPIPIP 地址区间，其中每个区间的格式为 start_ip  end_ip (中间用空格分隔)，其中 start_ip 和 end_ip 为合法的 IPv4IPv4IPv4 地址点分十进制格式，即 A,B,C,DA,B,C,DA,B,C,D ，其中 A、B、CA、B、CA、B、C 和 DDD 的取值范围为 [0,255][0,255][0,255] 。
3.IPIPIP 地址大小的比较，是按照 A、B、CA、B、CA、B、C 和 DDD 的顺序进行比较。
输出描述
输出排序好的 MMM 个 IPIPIP 区间，每行一个。每个区间的格式为 start_ip end_ip , 中间用空格分隔。
样例1
输入
3
192.168.1.9 192.168.1.12
192.168.1.1 192.168.1.10
192.168.1.12 192.168.1.13

输出
192.168.1.1 192.168.1.10
192.168.1.12 192.168.1.13

说明
区间 1(192.168.1.9 192.168.1.12) 与区间 2(192.168.1.1 192.168.1.10)和 区间 3(192.168.1.12.192.168.1.13)均有重叠。
因此可规划的业务地址范围为区间 1(192.168.1.1 192.168.1.10) 和 (192.168.1.12 192.168.1.13)，其满足的业务数量最多。
样例2
输入
4
192.168.1.9 192.168.1.12
192.168.1.13 192.168.1.15
192.168.1.7 192.168.1.10
192.168.1.11 192.168.1.17

输出
192.168.1.7 192.168.1.10
192.168.1.13 192.168.1.15

说明
共有 333 种方案，都是两个业务：

192.168.1.7 192.168.1.10 和 192.168.1.13 192.168.1.15

192.168.1.7 192.168.1.10 和 192.168.1.11 192.168.1.17

192.168.1.9 192.168.1.12 和 192.168.1.13 192.168.1.15

方案 111 占用 777 个 IPIPIP ，方案 222 占用 111111 个 IPIPIP ，方案 333 占用 777 个 IPIPIP 。从 IPIPIP 占用数量上，方案 222 被放弃。
方案 111 和方案 333 对比，第一个业务区间，方案 111 的起始 IPIPIP 比方案 333 的起始 IPIPIP 小，因此选择方案 111 。

▶️

#### TextSol

video solution

题解
题面描述
给定 NNN 个业务，每个业务需要的 IP 地址范围是一个闭区间 [startip,endip][start_{ip}, end_{ip}][startip​,endip​]，其中 startipstart_{ip}startip​ 表示起始 IP，endipend_{ip}endip​ 表示终止 IP，并且满足 endip≥startipend_{ip} \geq start_{ip}endip​≥startip​。由于不同业务的 IP 地址不能重叠，需要从这些业务中选出一些不重叠的区间，使得满足的业务数量最多。在满足业务数量最多的前提下，选出占用 IP 地址数量最少的方案；如果业务数量和 IP 地址占用数量均相同，则按照选中区间中各业务 startipstart_{ip}startip​ 的字典序排序，起始 IP 较小者优先。
输入格式：

第一行输入一个整数 NNN，其中 1≤N≤10001 \leq N \leq 10001≤N≤1000。
接下来 NNN 行，每行输入一个 IP 区间，格式为 startip endipstart_{ip}\ end_{ip}startip​ endip​，其中 startipstart_{ip}startip​ 和 endipend_{ip}endip​ 为合法的 IPv4 地址。

输出格式：

输出排序好的若干个 IP 区间，每个区间占一行，格式为 startip endipstart_{ip}\ end_{ip}startip​ endip​。

思路

IP 地址转换
将每个 IP 地址转换为 323232 位整数，这样便于比较大小和计算区间长度。区间长度的计算公式为
cost=endip−startip+1cost = end_{ip} - start_{ip} + 1
cost=endip​−startip​+1

区间排序
按照以下规则对区间进行排序：

首先按照 endipend_{ip}endip​ 升序排序。
若 endipend_{ip}endip​ 相同，则按照区间长度 costcostcost 升序排序。
若上面两者都相同，则按照 startipstart_{ip}startip​ 升序排序。

预处理非重叠区间
对于每个区间 iii，利用二分查找找到最大的下标 jjj，使得区间 jjj 的 endipend_{ip}endip​ 小于区间 iii 的 startipstart_{ip}startip​，记为 p(i)p(i)p(i)。

动态规划
设 dp[i]dp[i]dp[i] 表示在前 iii 个区间中能够获得的最优方案，每个方案包括：

选中的业务数量（尽可能多）
总的 IP 地址占用数（尽可能少）
按选中区间中各业务 startipstart_{ip}startip​ 的字典序（起始 IP 较小者优先）

对于每个区间 iii，有两种选择：

不选区间 iii：则方案继承自 dp[i−1]dp[i-1]dp[i−1]。
选择区间 iii：则方案为 dp[p(i)]dp[p(i)]dp[p(i)] 加上当前区间 iii，此时业务数量加 111，IP 占用数增加当前区间的 costcostcost，并将当前区间的 startipstart_{ip}startip​ 加入字典序列表中。

最后比较两种方案，选择更优的一个更新 dp[i]dp[i]dp[i]。

输出结果
输出 dp[N−1]dp[N-1]dp[N−1] 中保存的区间，按照原始输入格式输出。

综上，通过预处理非重叠区间信息并结合动态规划，可以选出满足最多业务、占用 IP 地址最少且字典序最优的方案。
cpp
#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <cstdio>
#include <algorithm>
using namespace std;
// 将IP地址字符串转换为无符号整数
unsigned int ipToInt(const string &ip) {
unsigned int a, b, c, d;
sscanf(ip.c_str(), "%u.%u.%u.%u", &a, &b, &c, &d);
return ((a << 24) | (b << 16) | (c << 8) | d);
}
// 将无符号整数转换为IP地址字符串
string intToIp(unsigned int ipInt) {
return to_string((ipInt >> 24) & 0xFF) + "." +
to_string((ipInt >> 16) & 0xFF) + "." +
to_string((ipInt >> 8) & 0xFF) + "." +
to_string(ipInt & 0xFF);
}
// 业务区间结构体
struct Interval {
unsigned int start, end; // 转换后的起始和结束IP（整数形式）
unsigned int cost;       // IP占用数：end - start + 1
string s_str, e_str;     // 原始起始和结束IP字符串
};
// 记录 DP 状态的结构体
struct Result {
int cnt;                 // 选择的区间数
unsigned long long cost; // 总 IP 占用数
vector<unsigned int> lex; // 方案中各区间的起始IP（用于字典序比较）
vector<int> idx;         // 选中的区间在排序后数组中的下标（用于输出）
};
// 自定义比较函数：比较两个 DP 结果，返回 true 表示 a 更优
bool better(const Result &a, const Result &b) {
if(a.cnt != b.cnt) return a.cnt > b.cnt;          // 业务数越多越好
if(a.cost != b.cost) return a.cost < b.cost;          // IP占用越少越好
// 字典序比较：逐个比较起始IP
for (size_t i = 0; i < a.lex.size(); i++) {
if(a.lex[i] != b.lex[i])
return a.lex[i] < b.lex[i];                 // 起始IP较小者优先
}
return true; // 完全相同时，任意认为 a 更优
}
int main(){
int n;
cin >> n;
vector<Interval> intervals(n);
// 读取输入
for (int i = 0; i < n; i++){
string start_ip, end_ip;
cin >> start_ip >> end_ip;
intervals[i].s_str = start_ip;
intervals[i].e_str = end_ip;
intervals[i].start = ipToInt(start_ip);
intervals[i].end = ipToInt(end_ip);
intervals[i].cost = intervals[i].end - intervals[i].start + 1;
}
// 排序规则：按结束IP升序；若结束相同，则按区间长度（cost）升序；再按起始IP升序
sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b) {
if(a.end != b.end) return a.end < b.end;
if(a.cost != b.cost) return a.cost < b.cost;
return a.start < b.start;
});
// 预处理 p 数组：对于每个 i，找到最大的 j < i 使得 intervals[j].end < intervals[i].start
vector<int> p(n, -1);
for (int i = 0; i < n; i++){
int lo = 0, hi = i - 1, pos = -1;
while(lo <= hi){
int mid = (lo + hi) / 2;
if(intervals[mid].end < intervals[i].start){
pos = mid;
lo = mid + 1;
} else {
hi = mid - 1;
}
}
p[i] = pos;
}
// dp[i] 表示考虑前 i 个区间（按照排序顺序，i 从 0 到 n-1）的最优结果
// 为方便 dp 使用，令 dp[-1] 为初始空方案
vector<Result> dp(n);
// 处理第0个区间
Result init;
init.cnt = 1;
init.cost = intervals[0].cost;
init.lex.push_back(intervals[0].start);
init.idx.push_back(0);
dp[0] = init;
// 记录 dp 的最佳方案（在 dp[i] 与不选当前区间时需要比较）
// 使用一个辅助变量 prev[i] 表示 dp[0...i] 的最优解
vector<Result> best_dp(n);
best_dp[0] = dp[0];
// 从第1个区间开始DP
for (int i = 1; i < n; i++){
// 选当前区间 i 的候选方案：先从 p[i] 的最优方案延伸
Result candidate;
if(p[i] != -1) {
candidate = best_dp[p[i]]; // 选取 p[i] 的方案
} else {
candidate.cnt = 0;
candidate.cost = 0;
candidate.lex.clear();
candidate.idx.clear();
}
// 加上当前区间
candidate.cnt += 1;
candidate.cost += intervals[i].cost;
candidate.lex.push_back(intervals[i].start);
candidate.idx.push_back(i);
// 另一个方案是不选当前区间，即 best_dp[i-1]
Result noPick = best_dp[i-1];

// dp[i] 取二者中更优的方案
if(better(candidate, noPick))
dp[i] = candidate;
else
dp[i] = noPick;

best_dp[i] = dp[i];
}
// 最优方案在 best_dp[n-1] 中
Result ans = best_dp[n-1];

// 输出选择的区间，按照原来的字符串格式输出
for (int index : ans.idx) {
cout << intervals[index].s_str << " " << intervals[index].e_str << "\n";
}

return 0;
}

python
import sys

# 将IP地址转换为整数，便于比较
def ip_to_int(ip):
a, b, c, d = map(int, ip.split('.'))
return (a << 24) | (b << 16) | (c << 8) | d

# 定义区间类
class Interval:
def __init__(self, start_str, end_str):
self.s_str = start_str  # 原始起始IP字符串
self.e_str = end_str  # 原始结束IP字符串
self.start = ip_to_int(start_str)
self.end = ip_to_int(end_str)
self.cost = self.end - self.start + 1  # IP占用数

# 比较两个DP方案的好坏
def better(a, b):
# a、b为字典，分别记录了方案的业务数（cnt）、总IP占用（cost）、各区间起始IP（lex）和选择的区间下标（indices）
if a['cnt'] != b['cnt']:
return a['cnt'] > b['cnt']  # 业务数越多越好
if a['cost'] != b['cost']:
return a['cost'] < b['cost']  # IP占用越少越好
# 按字典序比较各区间的起始IP
for x, y in zip(a['lex'], b['lex']):
if x != y:
return x < y
return True

# 主函数
def main():
n = int(sys.stdin.readline().strip())
intervals = []
for _ in range(n):
parts = sys.stdin.readline().strip().split()
intervals.append(Interval(parts[0], parts[1]))

# 按结束IP、区间长度和起始IP升序排序
intervals.sort(key=lambda inter: (inter.end, inter.cost, inter.start))

# 预处理：对于每个i，找到最大的 j < i，使得 intervals[j].end < intervals[i].start
p = [-1] * n
for i in range(n):
lo, hi, pos = 0, i - 1, -1
while lo <= hi:
mid = (lo + hi) // 2
if intervals[mid].end < intervals[i].start:
pos = mid
lo = mid + 1
else:
hi = mid - 1
p[i] = pos

# dp[i]记录前i个区间（排序后的）中最优的方案，方案由业务数、总IP占用、字典序和选择的区间下标构成
dp = [None] * n
best_dp = [None] * n
# 初始状态：选择第0个区间
init = {'cnt': 1, 'cost': intervals[0].cost, 'lex': [intervals[0].start], 'indices': [0]}
dp[0] = init
best_dp[0] = init

for i in range(1, n):
if p[i] != -1:
candidate = {
'cnt': best_dp[p[i]]['cnt'] + 1,
'cost': best_dp[p[i]]['cost'] + intervals[i].cost,
'lex': best_dp[p[i]]['lex'][:] + [intervals[i].start],
'indices': best_dp[p[i]]['indices'][:] + [i]
}
else:
candidate = {'cnt': 1, 'cost': intervals[i].cost, 'lex': [intervals[i].start], 'indices': [i]}
no_pick = best_dp[i - 1]
dp[i] = candidate if better(candidate, no_pick) else no_pick
best_dp[i] = dp[i]

# 输出最终方案中选择的区间（原始字符串格式）
ans = best_dp[n - 1]
for idx in ans['indices']:
print(intervals[idx].s_str, intervals[idx].e_str)

if __name__ == '__main__':
main()

java
import java.io.*;
import java.util.*;

// 主类
public class Main {
// 定义区间类
static class Interval {
long start, end;    // 转换后的起始和结束IP（整数形式）
long cost;          // IP占用数：end - start + 1
String sStr, eStr;  // 原始起始和结束IP字符串

public Interval(String sStr, String eStr) {
this.sStr = sStr;
this.eStr = eStr;
this.start = ipToInt(sStr);
this.end = ipToInt(eStr);
this.cost = end - start + 1;
}
}

// 定义DP状态类，用于记录方案
static class Result {
int cnt;                    // 业务数量
long cost;                  // 总IP占用数
ArrayList<Long> lex;        // 方案中各区间的起始IP列表，用于字典序比较
ArrayList<Integer> indices; // 选中的区间在排序数组中的下标

public Result() {
cnt = 0;
cost = 0;
lex = new ArrayList<>();
indices = new ArrayList<>();
}

// 拷贝构造函数
public Result(Result other) {
this.cnt = other.cnt;
this.cost = other.cost;
this.lex = new ArrayList<>(other.lex);
this.indices = new ArrayList<>(other.indices);
}
}

// 将IP地址字符串转换为整数
static long ipToInt(String ip) {
String[] parts = ip.split("\\.");
long a = Long.parseLong(parts[0]);
long b = Long.parseLong(parts[1]);
long c = Long.parseLong(parts[2]);
long d = Long.parseLong(parts[3]);
return (a << 24) | (b << 16) | (c << 8) | d;
}

// 比较两个DP方案，返回true表示a更优
static boolean better(Result a, Result b) {
if (a.cnt != b.cnt)
return a.cnt > b.cnt; // 业务数越多越好
if (a.cost != b.cost)
return a.cost < b.cost; // IP占用越少越好
// 字典序比较各区间的起始IP
for (int i = 0; i < Math.min(a.lex.size(), b.lex.size()); i++) {
if (!a.lex.get(i).equals(b.lex.get(i))) {
return a.lex.get(i) < b.lex.get(i);
}
}
return true;
}

public static void main(String[] args) throws Exception {
// 输入读取
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine().trim());
Interval[] intervals = new Interval[n];
for (int i = 0; i < n; i++) {
String[] parts = br.readLine().split(" ");
intervals[i] = new Interval(parts[0], parts[1]);
}

// 按结束IP、区间长度和起始IP升序排序
Arrays.sort(intervals, new Comparator<Interval>() {
public int compare(Interval a, Interval b) {
if (a.end != b.end)
return Long.compare(a.end, b.end);
if (a.cost != b.cost)
return Long.compare(a.cost, b.cost);
return Long.compare(a.start, b.start);
}
});

// 预处理 p 数组：对于每个 i，找到最大的 j < i，使得 intervals[j].end < intervals[i].start
int[] p = new int[n];
Arrays.fill(p, -1);
for (int i = 0; i < n; i++) {
int lo = 0, hi = i - 1, pos = -1;
while (lo <= hi) {
int mid = (lo + hi) / 2;
if (intervals[mid].end < intervals[i].start) {
pos = mid;
lo = mid + 1;
} else {
hi = mid - 1;
}
}
p[i] = pos;
}

// dp[i]表示前i个区间中最优的方案，方案由业务数、IP占用、字典序和选择的区间下标构成
Result[] dp = new Result[n];
Result[] best_dp = new Result[n];

// 初始化：选择第0个区间
Result init = new Result();
init.cnt = 1;
init.cost = intervals[0].cost;
init.lex.add(intervals[0].start);
init.indices.add(0);
dp[0] = init;
best_dp[0] = init;

for (int i = 1; i < n; i++) {
Result candidate;
if (p[i] != -1) {
candidate = new Result(best_dp[p[i]]);
candidate.cnt += 1;
candidate.cost += intervals[i].cost;
candidate.lex.add(intervals[i].start);
candidate.indices.add(i);
} else {
candidate = new Result();
candidate.cnt = 1;
candidate.cost = intervals[i].cost;
candidate.lex.add(intervals[i].start);
candidate.indices.add(i);
}
Result noPick = best_dp[i - 1];
dp[i] = better(candidate, noPick) ? candidate : noPick;
best_dp[i] = dp[i];
}

// 输出最终选择的区间，格式与输入相同
Result ans = best_dp[n - 1];
for (int index : ans.indices) {
System.out.println(intervals[index].sStr + " " + intervals[index].eStr);
}
}
}

---

### 第3题-消除单点故障（P2896）
- 链接：https://codefun2000.com/p/P2896

> 页面标题：#P2896. 第3题-消除单点故障

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在某个系统的运行环境中，存在着很多服务器实例，服务器实例之间存在数据流动，假设原先从AAA到BBB服务器存在数据流动，即有一条或多条可用路径。如果某个服务器实例CCC(不包括起止点AAA和BBB)故障后，会导致A、BA、BA、B之间所有的数据流动路径中断，那么我们称服务器CCC是A−BA-BA−B线路上存在单点故障风险的服务器。已知服务器实例网络的数据流动图,请列出有单点故障的实例清单。
输入描述
第一行，NNN，服务器实例个数，3<=N<=203<=N<=203<=N<=20
第二行至第 N+1N+1N+1 行，服务器节点之间的数据流向矩阵 MMM，M[i,j]=1M[i,j]=1M[i,j]=1表示 iii 和 jjj 之间有数据流动，M[i,j]=0M[i,j]=0M[i,j]=0 表示没有数据流动。
第 N+2N+2N+2 行，起止服务器 A、BA、BA、B 所对应的序号 ( 000 至 N−1N-1N−1 )
输出描述
请验出单点故障实例的数字编号(服务器编号从 000 开始，000 至 N−1N-1N−1)。有多个实例时，用空格隔开，排列顺序从小到大,本题绘出的所有用例一定存在单点故障实例。
样例1
输入
4
0 1 0 0
1 0 1 0
0 1 0 1
0 0 1 0
0 3

输出
1 2

说明
上述输入对应的图形如下：

图中有 444 个节点：0、1、2、30、1、2、30、1、2、3
节点 0−10-10−1、节点 1−21-21−2、节点 2−32-32−3 之间有数据流动。
上述输入节点 111 和 222 有单点故障风险，发生故障后会导致 0−30-30−3 之间无法传输数据，因此输出为：111 222
样例2
输入
8
0 1 0 0 1 0 0 0
1 0 1 0 1 0 0 0
0 1 0 1 0 1 0 1
0 0 1 0 0 1 1 0
1 1 0 0 0 1 0 0
0 0 1 1 1 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0
1 6

输出
3

说明
上述输入对应的图形如下：

对于 AAA 和 BBB 来说，只有服务然 333 存在单点故障风险，因此输出为 333

#### TextSol

题目描述
给定一个包含 NNN 个服务器实例的无向图（用邻接矩阵表示），以及两个特别的节点 AAA 和 BBB。如果去掉某个中间节点 CCC（不包括 AAA 和 BBB）后，原本所有连接 AAA 到 BBB 的路径都会被切断，则称节点 CCC 存在单点故障风险。请列出所有这样的节点编号。

输入：

第一行：整数 NNN（3≤N≤203 \le N \le 203≤N≤20）
接下来 NNN 行：N×NN\times NN×N 的邻接矩阵 MMM，其中 M[i][j]=1M[i][j]=1M[i][j]=1 表示 iii 与 jjj 直接相连。
最后一行：两个整数 AAA、BBB（节点编号，范围 000 到 N−1N-1N−1）。

输出：

将所有单点故障风险节点的编号（升序），用空格分隔。

解题思路
基本思路
我们要找的是「删除某个节点后，AAA 与 BBB 之间不再连通」的中间节点。直观的方法是：

枚举每个候选节点 ccc（跳过 AAA 和 BBB 本身）。
在图中「移除」节点 ccc（即视为已访问或不允许通过）。
从 AAA 出发做一次 DFS 或 BFS，看是否能到达 BBB。
如果到达不了，则说明 ccc 是单点故障风险节点。

相关算法

图的遍历：使用深度优先搜索（DFS）或广度优先搜索（BFS）检测连通性。
点割点评估：在小规模图（N≤20N\le20N≤20）上，直接枚举并每次做一次图遍历的复杂度足够。

复杂度分析

枚举每个节点：O(N)O(N)O(N)
每次 DFS/BFS：O(N+E)O(N+E)O(N+E)，在邻接矩阵下 E=O(N2)E=O(N^2)E=O(N2)，故一次遍历 O(N2)O(N^2)O(N2)。
总体时间复杂度：O(N)×O(N2)=O(N3)O(N)\times O(N^2)=O(N^3)O(N)×O(N2)=O(N3)。
由于 N≤20N\le20N≤20，最坏也只有 8000 次简单操作，足够快速。

代码实现
Python 版本
import sys
from collections import deque

def main():
n = int(sys.stdin.readline().strip())
adj = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]
a, b = map(int, sys.stdin.readline().split())
res = []

for c in range(n):
if c == a or c == b:
continue
# 标记 c 为已访问，相当于移除
vis = [False] * n
vis[c] = True

# 从 a 开始 BFS
q = deque([a])
vis[a] = True
while q:
u = q.popleft()
for v in range(n):
if adj[u][v] and not vis[v]:
vis[v] = True
q.append(v)

# 如果 b 不可达，说明 c 是单点故障
if not vis[b]:
res.append(str(c))

print(" ".join(res))

if __name__ == "__main__":
main()

Java 版本
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int n = in.nextInt();
int[][] adj = new int[n][n];
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
adj[i][j] = in.nextInt();
}
}
int a = in.nextInt(), b = in.nextInt();
List<Integer> ans = new ArrayList<>();

for (int c = 0; c < n; c++) {
if (c == a || c == b) continue;
boolean[] vis = new boolean[n];
vis[c] = true; // 移除 c

// BFS
Queue<Integer> q = new LinkedList<>();
q.offer(a);
vis[a] = true;
while (!q.isEmpty()) {
int u = q.poll();
for (int v = 0; v < n; v++) {
if (adj[u][v] == 1 && !vis[v]) {
vis[v] = true;
q.offer(v);
}
}
}
if (!vis[b]) {
ans.add(c);
}
}
// 输出结果
for (int i = 0; i < ans.size(); i++) {
System.out.print(ans.get(i) + (i + 1 < ans.size() ? " " : ""));
}
}
}

C++ 版本
#include <bits/stdc++.h>
using namespace std;

int main() {
int n;
cin >> n;
vector<vector<int>> adj(n, vector<int>(n));
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
cin >> adj[i][j];
int a, b;
cin >> a >> b;
vector<int> res;

for (int c = 0; c < n; c++) {
if (c == a || c == b) continue;
vector<bool> vis(n, false);
vis[c] = true; // 移除 c

// BFS
queue<int> q;
q.push(a);
vis[a] = true;
while (!q.empty()) {
int u = q.front(); q.pop();
for (int v = 0; v < n; v++) {
if (adj[u][v] && !vis[v]) {
vis[v] = true;
q.push(v);
}
}
}
if (!vis[b]) {
res.push_back(c);
}
}

// 输出
for (int i = 0; i < (int)res.size(); i++) {
cout << res[i] << (i + 1 < res.size() ? ' ' : '\n');
}
return 0;
}

---

### 第3题-最赚钱的骑手（P2893）
- 链接：https://codefun2000.com/p/P2893

> 页面标题：#P2893. 第3题-最赚钱的骑手

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

外卖骑手是一个和时间赛跑的工作。由于外卖订单一般集中在一日三餐的时间，具有时间短突发量大的特点，骑手们需要在订单集中的时间段内尽可能送出更多的订单以获得更多的收入。
骑手的工作流程大致是这样的，从一个商家出发，选择一个订单，送到目的地点，在目的地点接新的订单送到下一个目的地，如此循环。一个订单只能配送一次，骑手不能重复配送相同的订单。
从出发地点到取的地点的一次配送需要消耗1单位的时间。同一个地点可能发出多笔订单，其中一些订单可能要送往同一个目的地，这些起点和终点相同的订单可以合并配送，合并配送的多笔订单和单笔订单一样都只消耗1单位的时间。
简化起见，我们不区分商家和配送目的地点，统一视作地图上的一个地点。骑手的工作时间总时间是给定的，如果剩余的工作时间为0，则配送工作结束;如果到达目的地点之后，没有再从该地点发出的订单，则配送工作结束。
假设地图上有NNN个地点，每个地点有[0,X][0,X] [0,X]个待送出的订单，每个订单以[s,d,f][s,d,f][s,d,f]来表示，一共有MMM个订单。其中sss是出发站点编号，ddd是目的站点编号，ppp是这笔订单的配送费，约定s !=ds\ !=ds !=d。给定骑手的出发地点编号SnS_nSn​和工作总时间ttt，请计算出骑手最多能获得的收入。
具体每个取值的范围说明:

输入描述
第1行为空格分隔的222个整数，分别表示骑手的出发地点编号SnS_nSn​和工作总时间ttt；
第222行为一个表示订单数量的整数MMM;
第333行开始的MMM行每行都是以空格分隔的333个整数s,ds,ds,d和p,sp,sp,s表示出发站点，ddd表示目标站点，ppp表示订单收入。
输出描述
第111行是一个整数，表示骑手能获得的最多的收入;
第222行是空格分隔的整数数组，每个数字是一个地点编号，表示从开始到结束的配送路径。当多个路径能够获取相同的收入时，输出从前往后数字序最小的路径。
样例1
输入
0 2
6
0 1 2
0 5 3
5 3 3
1 2 3
2 4 10
1 3 4

输出
6
0 1 3

说明
如图所示：

工作时间ttt为222的条件下，从000出发，节点444不可达，可选的线路是:
1，0−>1−>31，0->1->31，0−>1−>3收入是2+4=62+4=62+4=6
2，0−>5−>32，0->5->32，0−>5−>3收入是3+3=63+3=63+3=6
2，0−>1−>22，0->1->22，0−>1−>2收入是2+3=52+3=52+3=5
线路111和线路222的收入最大，都是666，选择数字序最小的路径0−>1−>30->1->30−>1−>3,输出总收入666和线路0 1 30\ 1\ 30 1 3
样例2
输入
3 2
5
3 4 10
4 5 5
4 5 10
4 5 15
5 6 20

输出
40
3 4 5

说明
如图所示：

工作时间ttt为222的条件下，可以进行222次配送，其中从333到444消耗111的时间，可以获取收入101010。从444到555有333个订单，这333个订单的起终点相同(都是从444到555)，可以合并配送，收入5+10+15=305+10+15=305+10+15=30，只消耗111的时间。
所以唯一的路线是3−>4−>53->4->53−>4−>5，总收入为10+30=4010+30=4010+30=40
样例3
输入
1 2
5
1 2 5
2 3 10
2 3 8
2 4 6
4 5 6

输出
23
1 2 3

说明
如图所示：

工作时间ttt为222的条件下，从111出发，可选的线路是:
1，1−>2−>31，1->2->31，1−>2−>3 注意从111到333有222个要配送的外卖，可以合并配送，时间只算111，所以总收入是5+8+10=235+8+10=235+8+10=23
2，1−>2−>42，1->2->42，1−>2−>4收入是5+6=115+6=115+6=11
线路111的收入最大，选择线路111，输出总收入232323和线路0 1 30\ 1\ 30 1 3

▶️

#### TextSol

video solution

题解
题面描述
外卖骑手需要在给定的起始地点 SnS_nSn​ 和总工作时间 ttt 内，依次选择若干订单进行配送。每个订单由出发站点 sss、到达站点 ddd 和配送费 ppp 三元组表示，且 s≠ds \ne ds=d。若同一对 (s,d)(s,d)(s,d) 存在多笔订单，可将它们合并，合并后耗时仍为 111 单位，但收入为这批订单费用之和。每次配送无论合并与否，均耗时 111，且每笔订单只能配送一次。配送结束条件为工作时间用尽或当前地点无可接订单。输出骑手可获得的最大总收入及对应路径，若多条路径收入相同，则取字典序最小的路径。

思路

合并订单权重
使用哈希表将每个相同起点 sss、终点 ddd 的订单费用相加，得到边权值 ws,dw_{s,d}ws,d​。

构建有向图
以各个地点为节点，存在合并后订单的 (s,d)(s,d)(s,d) 对应一条边，边权为 ws,dw_{s,d}ws,d​。

DFS＋分支定界
从起点 SnS_nSn​ 出发，深度优先搜索最长路径，状态参数为当前节点 uuu、剩余时间 rrr、已获收入 vvv、当前路径。

若 r=0r = 0r=0 或无可用出边，则更新最优解。
通过预先计算所有边权的降序前缀和，估算上界：ub=v+∑i=1min⁡(r, E)wi\text{ub} = v + \sum_{i=1}^{\min(r,\,E)} w_i
ub=v+i=1∑min(r,E)​wi​
若 ub\text{ub}ub 小于当前最优收入，则剪枝。
枚举按终点升序排列的出边，保证字典序最小性。
标记已用边，递归后回溯。

复杂度

边数 EEE 最多为订单数 MMM。
最坏情况下 DFS 搜索分支较多，但分支定界剪枝有效降低了实际搜索量。

cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int t, sn;
vector<vector<pair<int,int>>> adj; // 邻接表：adj[u] 存储 (v, eid)
vector<ll> w;                      // 每条边的权值 w[eid]
vector<bool> used;                 // 标记边是否已用
vector<ll> pref;                   // 边权降序前缀和
ll bestV = 0;                      // 全局最优收入
vector<int> curP, bestP;           // 当前路径与最优路径

// 深度优先搜索，u=当前节点，rem=剩余时间，val=当前收入
void dfs(int u, int rem, ll val) {
// 更新最优解（优先收入，其次字典序）
if (val > bestV || (val == bestV && curP < bestP)) {
bestV = val;
bestP = curP;
}
if (rem == 0) return;  // 时间耗尽
// 计算上界：当前收入 + 剩余时间内最大可能收入
ll ub = val + pref[min(rem, (int)pref.size() - 1)];
if (ub < bestV) return; // 剪枝

// 枚举所有出边
for (auto &pr : adj[u]) {
int v = pr.first, e = pr.second;
if (used[e]) continue;      // 边已用不可重复
used[e] = true;
curP.push_back(v);
dfs(v, rem - 1, val + w[e]);
curP.pop_back();
used[e] = false;
}
}

int main(){
ios::sync_with_stdio(false);
cin.tie(NULL);

int m;
cin >> sn >> t >> m;
map<pair<int,int>, ll> mp;
// 读入并合并相同起终点的订单费用
for (int i = 0; i < m; i++) {
int s, d, p;
cin >> s >> d >> p;
mp[{s, d}] += p;
}
// 收集所有节点编号，确定图的大小
set<int> nodes;
for (auto &kv : mp) {
nodes.insert(kv.first.first);
nodes.insert(kv.first.second);
}
int maxn = *max_element(nodes.begin(), nodes.end());
adj.resize(maxn + 1);

// 构建图
int eid = 0;
for (auto &kv : mp) {
int u = kv.first.first, v = kv.first.second;
w.push_back(kv.second);
adj[u].push_back({v, eid});
eid++;
}
used.assign(eid, false);

// 预处理前缀和（降序）
vector<ll> ws = w;
sort(ws.begin(), ws.end(), greater<ll>());
pref.resize(ws.size() + 1);
for (int i = 0; i < ws.size(); i++)
pref[i + 1] = pref[i] + ws[i];

// 保证遍历出边时按照终点升序，以获取字典序最小路径
for (int i = 0; i <= maxn; i++)
sort(adj[i].begin(), adj[i].end());

// 启动 DFS
curP.push_back(sn);
bestP = curP;
dfs(sn, t, 0);

// 输出结果
cout << bestV << "\n";
for (int i = 0; i < bestP.size(); i++) {
if (i) cout << " ";
cout << bestP[i];
}
cout << "\n";
return 0;
}

python
import sys
sys.setrecursionlimit(10**7)

def main():
sn, t = map(int, sys.stdin.readline().split())
m = int(sys.stdin.readline())
mp = {}
# 合并相同起终点的订单费用
for _ in range(m):
s, d, p = map(int, sys.stdin.readline().split())
mp[(s, d)] = mp.get((s, d), 0) + p

# 构建节点和邻接表
nodes = set()
for (s, d) in mp:
nodes.add(s); nodes.add(d)
maxn = max(nodes)
adj = [[] for _ in range(maxn + 1)]
w = []
for eid, ((s, d), cost) in enumerate(mp.items()):
w.append(cost)
adj[s].append((d, eid))

# 标记数组和前缀和
used = [False] * len(w)
ws = sorted(w, reverse=True)
pref = [0] * (len(ws) + 1)
for i, val in enumerate(ws):
pref[i + 1] = pref[i] + val

# 按目标节点升序，确保字典序最小
for lst in adj:
lst.sort()

bestV = 0
bestP = []
curP = []

# DFS 搜索
def dfs(u, rem, val):
nonlocal bestV, bestP
# 更新最优解
if val > bestV or (val == bestV and curP < bestP):
bestV, bestP = val, curP.copy()
if rem == 0:
return
# 上界剪枝
ub = val + pref[min(rem, len(ws))]
if ub < bestV:
return
# 枚举出边
for v, eid in adj[u]:
if not used[eid]:
used[eid] = True
curP.append(v)
dfs(v, rem - 1, val + w[eid])
curP.pop()
used[eid] = False

# 启动 DFS
curP = [sn]
bestP = [sn]
dfs(sn, t, 0)

# 输出
print(bestV)
print(" ".join(map(str, bestP)))

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main {
static int t, sn;
static List<List<int[]>> adj; // adj.get(u) 存 (v, eid)
static long[] w;              // 边权
static boolean[] used;
static long[] pref;           // 前缀和
static long bestV = 0;
static List<Integer> curP = new ArrayList<>(), bestP = new ArrayList<>();

// DFS 搜索
static void dfs(int u, int rem, long val) {
// 更新最优解
if (val > bestV || (val == bestV && compare(curP, bestP) < 0)) {
bestV = val;
bestP = new ArrayList<>(curP);
}
if (rem == 0) return;
// 上界剪枝
long ub = val + pref[Math.min(rem, pref.length - 1)];
if (ub < bestV) return;
// 枚举出边
for (int[] e : adj.get(u)) {
int v = e[0], eid = e[1];
if (!used[eid]) {
used[eid] = true;
curP.add(v);
dfs(v, rem - 1, val + w[eid]);
curP.remove(curP.size() - 1);
used[eid] = false;
}
}
}

// 列表字典序比较
static int compare(List<Integer> a, List<Integer> b) {
int n = Math.min(a.size(), b.size());
for (int i = 0; i < n; i++) {
if (!a.get(i).equals(b.get(i)))
return a.get(i) - b.get(i);
}
return a.size() - b.size();
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
sn = in.nextInt();
t = in.nextInt();
int m = in.nextInt();
Map<String, Long> mp = new HashMap<>();
// 合并订单费用
for (int i = 0; i < m; i++) {
int s = in.nextInt(), d = in.nextInt(), p = in.nextInt();
String key = s + "#" + d;
mp.put(key, mp.getOrDefault(key, 0L) + p);
}
// 构建图
Set<Integer> nodes = new HashSet<>();
for (String key : mp.keySet()) {
String[] sp = key.split("#");
nodes.add(Integer.parseInt(sp[0]));
nodes.add(Integer.parseInt(sp[1]));
}
int maxn = Collections.max(nodes);
adj = new ArrayList<>();
for (int i = 0; i <= maxn; i++) adj.add(new ArrayList<>());
w = new long[mp.size()];
int eid = 0;
for (Map.Entry<String, Long> e : mp.entrySet()) {
String[] sp = e.getKey().split("#");
int s = Integer.parseInt(sp[0]), d = Integer.parseInt(sp[1]);
w[eid] = e.getValue();
adj.get(s).add(new int[]{d, eid});
eid++;
}
used = new boolean[eid];
// 前缀和
long[] ws = Arrays.stream(w).boxed()
.sorted(Comparator.reverseOrder())
.mapToLong(Long::longValue)
.toArray();
pref = new long[ws.length + 1];
for (int i = 0; i < ws.length; i++) {
pref[i + 1] = pref[i] + ws[i];
}
// 保证终点升序
for (List<int[]> lst : adj) {
lst.sort(Comparator.comparingInt(a -> a[0]));
}
// 启动 DFS
curP.add(sn);
bestP.add(sn);
dfs(sn, t, 0);
// 输出
System.out.println(bestV);
for (int i = 0; i < bestP.size(); i++) {
if (i > 0) System.out.print(" ");
System.out.print(bestP.get(i));
}
System.out.println();
}
}

---

### 第3题-樱桃等级筛选（P2934）
- 链接：https://codefun2000.com/p/P2934

> 页面标题：#P2934. 第3题-樱桃等级筛选

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某大型樱桃加工厂使用自动化机械扫描了一批樱桃的尺寸大小。现在获得了直径范围 [L,H][L,H][L,H] 各个区间所有的樱桃个数统计。现在需要通过 mmm 个等级 (m<H−L)(m<H-L)(m<H−L) 来筛选不同尺寸大小的樱桃，筛选后需使得各等级内的樱桃数目的标准差最小。
输入描述
第一行输入两个数字，第一个数字表示樱桃的总组数 n(2<n<=20)n(2<n<= 20)n(2<n<=20) ，第二个数字 mmm 表示需要获取的等级数目 aaa ，2<a<n2<a<n2<a<n
第二行输入一个长度为 H−L+1H-L+1H−L+1 的数列 AAA ，a<H−L+1a<H-L+1a<H−L+1，其中的第 iii 个元素 aia_iai​ ；表示直径为 L+iL+iL+i 樱桃个数 (i∈[0,H−L])，0<ai<100(i∈[0,H-L])，0< a_i <100(i∈[0,H−L])，0<ai​<100.
输出描述
输出长度为 mmm 的数列 BBB ，其中的第 111 个元素 b0b_0b0​ 表示顺序从 AAA 中取 b0b_0b0​ 个元素，将该尺寸范围内的樱桃作为一个分类等级；第 222 个元素 bbb 表示顺序从 AAA 中起始点 b0b_0b0​ 开始取 b1b_1b1​ 个元素，将该尺寸范围内的樱桃作为一个分类等级，依次类推。
样例1
输入
9 3
1 2 3 4 5 6 7 8 9

输出
5 2 2

说明
要把 999 组樱桃分为三组，使得三组樱桃数量和的标准差最小
顺序取数列 555 个元素和为 1+2+3+4+5=151+2+3+4+5=151+2+3+4+5=15
再顺序取数列 222 个元素和 6+7=136+7=136+7=13
再顺序取数列 222 个元素和 8+9=178+9=178+9=17
[15[15[15 131313 17]17]17] 的平均值为 151515 ，标准差为 sqrt((15−15)2+(15−13)2+(15−17)2)/3sqrt((15-15)^2+(15-13)^2+(15-17)^2)/3sqrt((15−15)2+(15−13)2+(15−17)2)/3，为所有筛选方案中的最小值。
样例2
输入
10 4
16 40 37 20 18 30 18 60 50 37

输出
3 3 2 2

说明
顺序取数列 333 个元素和为 16+40+37=9316+40+37=9316+40+37=93
再顺序取数列 333 个元素和 20+18+30=6820+18+30=6820+18+30=68
再顺序取数列 222 个元素和 18+60=7818+60=7818+60=78
再顺序取数列 222 个元素和 50+37=8750+37=8750+37=87
[93,68,78,87][93,68,78,87][93,68,78,87] 的平均值为 81.581.581.5 ，标准差为 sqrt((93−81.5)2sqrt((93-81.5)^2sqrt((93−81.5)2+(68−81.5)2+(68-81.5)^2+(68−81.5)2+(78−81.5)2+(78-81.5)^2+(78−81.5)2+(87−81.5)2)/4+(87-81.5)^2)/4+(87−81.5)2)/4 ，为所有筛选方案中的最小值。
提示
测试样例保证输出答案唯一

#### TextSol

题目描述
某大型樱桃加工厂使用自动化机械扫描了一批樱桃的尺寸大小。现在获得了直径范围 [L,H][L,H][L,H] 各个区间所有的樱桃个数统计。现需通过 mmm 个等级（m<H−Lm < H - Lm<H−L）来筛选不同尺寸大小的樱桃，筛选后需使得各等级内的樱桃数量和的标准差最小。

输入第一行：两个整数 nnn（樱桃总组数，2<n≤202 < n \le 202<n≤20）和 mmm（需要的等级数，2<m<n2 < m < n2<m<n）。
输入第二行：长度为 nnn 的整数序列 A=[a0,a1,…,an−1]A = [a_0, a_1, \dots, a_{n-1}]A=[a0​,a1​,…,an−1​]，其中 aia_iai​ 表示第 iii 组直径对应的樱桃个数（0<ai<1000 < a_i < 1000<ai​<100）。

输出长度为 mmm 的序列 B=[b0,b1,…,bm−1]B = [b_0, b_1, \dots, b_{m-1}]B=[b0​,b1​,…,bm−1​]，其中：

b0b_0b0​ 表示从 AAA 的第 000 位开始，顺序取 b0b_0b0​ 个元素作为第 111 个等级；
b1b_1b1​ 表示从 AAA 的第 b0b_0b0​ 位开始，顺序取 b1b_1b1​ 个元素作为第 222 个等级；
依次类推，保证所有元素被分配且所得到的等级和序列和的标准差最小。

问题本质分析
这是一个将长度为 nnn 的序列分割成 mmm 段，使得每一段元素之和的标准差最小的分割优化问题。由于 n≤20n \le 20n≤20，可以使用 动态规划 + 枚举 或者 DFS + 剪枝 来搜索最优分割方案。
思路

前缀和：预处理序列 AAA 的前缀和 SSS，使得任意区间和 sum(i,j)=S[j+1]−S[i]\mathrm{sum}(i,j)=S[j+1]-S[i]sum(i,j)=S[j+1]−S[i] 能够 O(1)O(1)O(1) 获得。

DFS 枚举与剪枝：递归枚举每一段的长度，维护已分配的段数、当前位置、已经选取的各段和列表。

当分配到第 mmm 段时，将剩余元素作为最后一段，计算所有段和的标准差。
记录最小标准差的分割方案。
剪枝策略：若当前已分配段数与剩余元素无法满足分段数时剪枝。

标准差计算：对于段和数组 W=[w0,w1,…,wm−1]W=[w_0,w_1,\dots,w_{m-1}]W=[w0​,w1​,…,wm−1​]，其平均值为
μ=1m∑k=0m−1wk,\mu = \frac{1}{m} \sum_{k=0}^{m-1} w_k,
μ=m1​k=0∑m−1​wk​,
标准差为

C++
#include <bits/stdc++.h>
using namespace std;

int n, m;
vector<int> A;
vector<int> S; // 前缀和

double best_std = 1e300;
vector<int> best_B;

// 计算区间和 [l, r)
int intervalSum(int l, int r) {
return S[r] - S[l];
}

void dfs(int pos, int k, vector<int>& W, vector<int>& B) {
if (k == m - 1) {
int len = n - pos;
B.push_back(len);
W.push_back(intervalSum(pos, n));
// 计算平均值
double mu = accumulate(W.begin(), W.end(), 0.0) / m;
// 计算方差
double var = 0;
for (double w : W) var += (w - mu) * (w - mu);
var /= m;
double std = sqrt(var);
if (std < best_std) {
best_std = std;
best_B = B;
}
B.pop_back(); W.pop_back();
return;
}
// 至少留出 (m-k-1) 个元素，每段至少 1 个
for (int len = 1; pos + len + (m - k - 1) <= n; ++len) {
B.push_back(len);
int w = intervalSum(pos, pos + len);
W.push_back(w);
dfs(pos + len, k + 1, W, B);
B.pop_back(); W.pop_back();
}
}

int main() {
cin >> n >> m;
A.resize(n);
for (int i = 0; i < n; ++i) cin >> A[i];
S.assign(n+1, 0);
for (int i = 0; i < n; ++i) S[i+1] = S[i] + A[i];

vector<int> W, B;
dfs(0, 0, W, B);
for (int x : best_B) cout << x << ' ';
return 0;
}

Python
import math

# 输入
n, m = map(int, input().split())
A = list(map(int, input().split()))
# 前缀和
S = [0] * (n + 1)
for i in range(n):
S[i+1] = S[i] + A[i]

best_std = float('inf')
best_B = []

# 区间和
def interval_sum(l, r):
return S[r] - S[l]

# DFS 枚举
def dfs(pos, k, W, B):
global best_std, best_B
if k == m - 1:
length = n - pos
B.append(length)
W.append(interval_sum(pos, n))
mu = sum(W) / m
var = sum((w - mu) ** 2 for w in W) / m
std = math.sqrt(var)
if std < best_std:
best_std = std
best_B = B.copy()
B.pop(); W.pop()
return
# 枚举当前段长度
for length in range(1, n - pos - (m - k - 1) + 1):
B.append(length)
W.append(interval_sum(pos, pos + length))
dfs(pos + length, k + 1, W, B)
B.pop(); W.pop()

# 调用 DFS
dfs(0, 0, [], [])
# 输出结果
print(' '.join(map(str, best_B)))

Java
import java.util.*;

public class Main {
static int n, m;
static int[] A;
static int[] S;
static double bestStd = Double.MAX_VALUE;
static List<Integer> bestB = new ArrayList<>();

static int intervalSum(int l, int r) {
return S[r] - S[l];
}

static void dfs(int pos, int k, List<Integer> W, List<Integer> B) {
if (k == m - 1) {
int len = n - pos;
B.add(len);
W.add(intervalSum(pos, n));
double mu = W.stream().mapToDouble(x -> x).sum() / m;
double var = 0;
for (double w : W) var += (w - mu) * (w - mu);
var /= m;
double std = Math.sqrt(var);
if (std < bestStd) {
bestStd = std;
bestB = new ArrayList<>(B);
}
B.remove(B.size() - 1);
W.remove(W.size() - 1);
return;
}
for (int len = 1; pos + len + (m - k - 1) <= n; len++) {
B.add(len);
W.add(intervalSum(pos, pos + len));
dfs(pos + len, k + 1, W, B);
B.remove(B.size() - 1);
W.remove(W.size() - 1);
}
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
m = sc.nextInt();
A = new int[n];
for (int i = 0; i < n; i++) A[i] = sc.nextInt();
S = new int[n+1];
for (int i = 0; i < n; i++) S[i+1] = S[i] + A[i];
dfs(0, 0, new ArrayList<>(), new ArrayList<>());
for (int x : bestB) System.out.print(x + " ");
}
}

---

### 第3题-最小代价相遇的路径规划（P2928）
- 链接：https://codefun2000.com/p/P2928

> 页面标题：#P2928. 第3题-最小代价相遇的路径规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

假定有两辆车在给定一个n×nn×nn×n的非负整数矩阵地图gridgridgrid中行驶，地图左上角位置为[0,0][0,0][0,0]。我们简化车辆行驶的方式，每辆车可以从一个坐标行驶到相邻 (上下左右)的另一个坐标，并且经过的每个位置都会产生代价，包括起始位置的代价。其中grid[i][j]grid[i][j]grid[i][j]表示通过网格位置[i,j][i,j][i,j] 所需的代价。矩阵中，grid[i][j]grid[i][j]grid[i][j]等于000表示该位置为障碍物，车辆无法通过。两辆车约定好需要在地图中快速相遇进行货物交接。
两辆车相遇的定义为:两辆车最终分别停在相邻的网格位置(上下或左右相邻)，并且路径可达。
两辆车相遇所需的代价定义为:两辆车到达各自相遇位置所需代价中的较大值。
注意:路径代价包含车辆的起始位置位置的代价;行驶过程中，车辆可以停在某一个网格位置上，两辆车无需同步行驶。
求两辆车可以相遇需要的最小代价，如果无法相遇则返回−1-1−1。
输入描述
第一行输入是一个整数nnn，代表地图grid[n][n]grid[n][n] grid[n][n]的大小，即nnn行nnn列大小的地图。
后续每一行代表地图中通过每个网格位置所需的时间信息，即grid[n][n]grid[n][n]grid[n][n]的每一行的元素值。
假设初始状态两辆车分别从左上角[0,0][0,0][0,0]和右下角 [n−1,n−1][n-1,n-1][n−1,n−1] 出发，左上角的车只能向右或向下移动，右下角的车只能向上或向左移动。
参数取值范围:

2<=n<=10002 <=n<=10002<=n<=1000
0<=grid[i][j]<=1000 <= grid[i][j]<= 1000<=grid[i][j]<=100
grid[0][0]!=0grid[0][0]!= 0grid[0][0]!=0
grid[n−1][n−1]!=0 grid[n-1][n-1] != 0grid[n−1][n−1]!=0

输出描述
一个整数，表示两辆车相遇的最小代价;如果两车无法相遇(例如都被障碍物阻挡)，则返回−1-1−1。
样例1
输入
2
1 2
2 1

输出
3

说明
第一行输入代表该地图大小是222，即222行222列的矩阵。
地图信息为:
grid[n][n]=grid[n][n]=grid[n][n]=
[[1,2],[[1, 2],[[1,2],
[2,1]][2,1]][2,1]]
最快相遇的一种方案是:
第一辆车路径:[0,0]−>[0,1][0,0] -> [0,1][0,0]−>[0,1]，所需代价:1+2=31+2=31+2=3
第二辆车路径:[1,1][1,1][1,1]，所需代价:111
两辆车在下方矩阵中小括号标记状态相遇，需要代价是333(取两辆车各自代价的较大值3作为相遇的代价)，所以返回333。
[[1,(2)][[1, (2)][[1,(2)]，
[2,(1)]][2, (1)]][2,(1)]]
样例2
输入
3
1 2 3
1 2 3
1 2 3

输出
5

说明
第一行输入代表该地图大小是3，即3行3列的矩阵。
地图信息为:
grid[n][n]=grid[n][n]=grid[n][n]=
[[1，2，3]，[[1，2，3]，[[1，2，3]，
[1，2，3]，[1，2，3]，[1，2，3]，
[1，2，3]][1，2，3]][1，2，3]]
最快相遇的一种方案是:
第一辆车路径:[e,0]−>[1,e]−>[2,0][e,0] -> [1,e] -> [2,0][e,0]−>[1,e]−>[2,0],所需代价:1+1+1=31+1+1=31+1+1=3
第二辆车路径:[2,2]−>[2,1][2,2] -> [2,1][2,2]−>[2,1]，所需代价:555
两辆车在下方矩阵中小括号标记状态相遇，需要代价是555(取两辆车各自代价的较大值5作为相遇的代价),所以返回555。
[[1,2，3]，[[ 1, 2， 3]，[[1,2，3]，
[1,2,3]，[ 1, 2, 3]，[1,2,3]，
[(1)，(2)，3]][(1)，(2)，3]][(1)，(2)，3]]
样例3
输入
3
1 0 3
1 0 3
1 0 3

输出
-1

说明
第一行输入代表该地图大小是333，即333行333列的矩阵。
地图信息为
grid[n][n]=grid[n][n]=grid[n][n]=
[[1，0，3],[[1，0，3],[[1，0，3],
[1，0，3]，[1，0，3]，[1，0，3]，
[1，0，3]][1，0，3]][1，0，3]]
由于地图中的障碍物，使得两辆车无法相遇，所以返回−1-1−1。

▶️

#### TextSol

video solution

题解
题面描述
给定一个大小为 n×nn\times nn×n 的非负整数矩阵 grid，其中 grid[i][j] 表示通过位置 [i,j][i,j][i,j] 所需的代价，若 grid[i][j] = 0 则该位置为障碍物，车辆无法通过。

第一辆车从 [0,0][0,0][0,0] 出发，只能向右或向下移动；
第二辆车从 [n−1,n−1][n-1,n-1][n−1,n−1] 出发，只能向上或向左移动；
任一车辆经过的每个位置（包括起始位置）都会产生对应的代价；
两辆车“相遇”定义为：它们最终分别停在一对相邻（上下或左右相邻）的网格位置上，且各自路径都可达；
相遇的总代价定义为两条路径代价的较大值；

求两辆车相遇所需的最小代价，若无法相遇则返回 -1。

解题思路

子问题划分

令
dp1[i][j]dp1[i][j]dp1[i][j] =第一辆车从(0,0)(0,0)(0,0)到(i,j)(i,j)(i,j)的最小代价
只允许向右或向下移动。
令
dp2[i][j]dp2[i][j]dp2[i][j] =第二辆车从(n−1,n−1)(n-1,n-1)(n−1,n−1)(i,j)$的最小代价
只允许向上或向左移动。

状态转移

对于 dp1dp1dp1：

对于 dp2dp2dp2：

答案计算
枚举所有相邻格子对 (i,j)(i,j)(i,j) 与 (i′,j′)(i',j')(i′,j′)，其中 ∣i−i′∣+∣j−j′∣=1|i-i'|+|j-j'|=1∣i−i′∣+∣j−j′∣=1，若 dp1[i][j]<∞dp1[i][j]<\inftydp1[i][j]<∞ 且 dp2[i′][j′]<∞dp2[i'][j']<\inftydp2[i′][j′]<∞，则可在这对格子上相遇，其代价为
max⁡(dp1[i][j],  dp2[i′][j′]).\max\bigl(dp1[i][j],\;dp2[i'][j']\bigr).
max(dp1[i][j],dp2[i′][j′]).
最终取所有相邻对的最小值，即为所求答案；若没有合法的相遇对，则返回 -1。

复杂度

时间：O(n2)O(n^2)O(n2)
空间：O(n2)O(n^2)O(n2)，也可滚动数组优化到 O(n)O(n)O(n)。

C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = (ll)4e18;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
vector<vector<int>> grid(n, vector<int>(n));
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
cin >> grid[i][j];

// dp1[i][j]: 第一辆车从 (0,0) 到 (i,j) 的最小代价
vector<vector<ll>> dp1(n, vector<ll>(n, INF));
if (grid[0][0] != 0) dp1[0][0] = grid[0][0];
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (grid[i][j] == 0) continue; // 障碍
if (i > 0 && dp1[i-1][j] != INF)
dp1[i][j] = min(dp1[i][j], dp1[i-1][j] + grid[i][j]);
if (j > 0 && dp1[i][j-1] != INF)
dp1[i][j] = min(dp1[i][j], dp1[i][j-1] + grid[i][j]);
}
}

// dp2[i][j]: 第二辆车从 (n-1,n-1) 到 (i,j) 的最小代价
vector<vector<ll>> dp2(n, vector<ll>(n, INF));
if (grid[n-1][n-1] != 0) dp2[n-1][n-1] = grid[n-1][n-1];
for (int i = n-1; i >= 0; i--) {
for (int j = n-1; j >= 0; j--) {
if (grid[i][j] == 0) continue;
if (i+1 < n && dp2[i+1][j] != INF)
dp2[i][j] = min(dp2[i][j], dp2[i+1][j] + grid[i][j]);
if (j+1 < n && dp2[i][j+1] != INF)
dp2[i][j] = min(dp2[i][j], dp2[i][j+1] + grid[i][j]);
}
}

ll ans = INF;
// 枚举相邻格子对
int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (dp1[i][j] == INF) continue;
for (auto &d : dirs) {
int ni = i + d[0], nj = j + d[1];
if (ni<0||ni>=n||nj<0||nj>=n) continue;
if (dp2[ni][nj] == INF) continue;
ans = min(ans, max(dp1[i][j], dp2[ni][nj]));
}
}
}

cout << (ans == INF ? -1 : ans) << "\n";
return 0;
}

Python
import sys
import math

def min_meeting_cost(grid):
n = len(grid)
INF = math.inf

# dp1[i][j]: 第一辆车到 (i,j)
dp1 = [[INF]*n for _ in range(n)]
if grid[0][0] != 0:
dp1[0][0] = grid[0][0]
for i in range(n):
for j in range(n):
if grid[i][j] == 0: continue
if i>0 and dp1[i-1][j]!=INF:
dp1[i][j] = min(dp1[i][j], dp1[i-1][j] + grid[i][j])
if j>0 and dp1[i][j-1]!=INF:
dp1[i][j] = min(dp1[i][j], dp1[i][j-1] + grid[i][j])

# dp2[i][j]: 第二辆车到 (i,j)
dp2 = [[INF]*n for _ in range(n)]
if grid[n-1][n-1] != 0:
dp2[n-1][n-1] = grid[n-1][n-1]
for i in range(n-1, -1, -1):
for j in range(n-1, -1, -1):
if grid[i][j] == 0: continue
if i+1<n and dp2[i+1][j]!=INF:
dp2[i][j] = min(dp2[i][j], dp2[i+1][j] + grid[i][j])
if j+1<n and dp2[i][j+1]!=INF:
dp2[i][j] = min(dp2[i][j], dp2[i][j+1] + grid[i][j])

ans = INF
dirs = [(1,0),(-1,0),(0,1),(0,-1)]
for i in range(n):
for j in range(n):
if dp1[i][j] == INF: continue
for di,dj in dirs:
ni, nj = i+di, j+dj
if 0<=ni<n and 0<=nj<n and dp2[ni][nj]!=INF:
ans = min(ans, max(dp1[i][j], dp2[ni][nj]))
return -1 if ans==INF else ans

if __name__ == "__main__":
data = sys.stdin.read().split()
n = int(data[0])
vals = list(map(int, data[1:]))
grid = [vals[i*n:(i+1)*n] for i in range(n)]
print(min_meeting_cost(grid))

Java
import java.io.*;
import java.util.*;

public class Main {
static final long INF = Long.MAX_VALUE / 4;

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int n = Integer.parseInt(br.readLine().trim());
int[][] grid = new int[n][n];
for (int i = 0; i < n; i++) {
String[] ss = br.readLine().split("\\s+");
for (int j = 0; j < n; j++) {
grid[i][j] = Integer.parseInt(ss[j]);
}
}

long[][] dp1 = new long[n][n];
long[][] dp2 = new long[n][n];
for (int i = 0; i < n; i++) {
Arrays.fill(dp1[i], INF);
Arrays.fill(dp2[i], INF);
}

// 第一辆车
if (grid[0][0] != 0) dp1[0][0] = grid[0][0];
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (grid[i][j] == 0) continue;
if (i > 0 && dp1[i-1][j] != INF)
dp1[i][j] = Math.min(dp1[i][j], dp1[i-1][j] + grid[i][j]);
if (j > 0 && dp1[i][j-1] != INF)
dp1[i][j] = Math.min(dp1[i][j], dp1[i][j-1] + grid[i][j]);
}
}

// 第二辆车
if (grid[n-1][n-1] != 0) dp2[n-1][n-1] = grid[n-1][n-1];
for (int i = n-1; i >= 0; i--) {
for (int j = n-1; j >= 0; j--) {
if (grid[i][j] == 0) continue;
if (i+1 < n && dp2[i+1][j] != INF)
dp2[i][j] = Math.min(dp2[i][j], dp2[i+1][j] + grid[i][j]);
if (j+1 < n && dp2[i][j+1] != INF)
dp2[i][j] = Math.min(dp2[i][j], dp2[i][j+1] + grid[i][j]);
}
}

long ans = INF;
int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
if (dp1[i][j] == INF) continue;
for (int[] d : dirs) {
int ni = i + d[0], nj = j + d[1];
if (ni<0||ni>=n||nj<0||nj>=n) continue;
if (dp2[ni][nj] == INF) continue;
ans = Math.min(ans, Math.max(dp1[i][j], dp2[ni][nj]));
}
}
}

System.out.println(ans == INF ? -1 : ans);
}
}

---

## 2025年5月14日-暑期实习 第1题-AI算法训练中的动态优先级经验回放 中等 第2题-游戏中的地图穿越 简单 第3题-救灾物资快速分配方案 中等

### 第2题-游戏中的地图穿越（P2958）
- 链接：https://codefun2000.com/p/P2958

> 页面标题：#P2958. 第2题-游戏中的地图穿越

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明用k∗kk*kk∗k的二维矩阵map[][]map[][]map[][]表示三维空间中的一个地图，map[i][j]map[i][j]map[i][j]表示位置[i,j][i,j][i,j]上的地形高度，玩家需控制游戏中的一个角色穿过这个地图，从矩阵左上角位置(坐标0,00,00,0)进入，从矩阵右侧任意位置出去。
1.角色在矩阵中只能向右或向下移动
2.如果相邻两个节点高度差大于111，则角色不能移动过去(太高角色爬不上去，太低了就摔死了)
3.角色通过(i,j)(i,j)(i,j)地点时，会消耗map[i][j]map[i][j]map[i][j]体力值。
求最省体力值的路线所消耗的体力值。
输入描述
输入有多行，第111行为数组的行数k(k<=100)k(k<=100)k(k<=100)，第222行至第k+1k+1k+1行为k∗kk*kk∗k矩阵，数组元素用空格分隔，0<=map[i][j]<=100<= map[i][j]<=100<=map[i][j]<=10
例如:
333
1 2 31\ 2\ 31 2 3
5 5 55\ 5\ 55 5 5
7 7 77\ 7\ 77 7 7
输出描述
输出一行，一个整数，表示最省体力值的路线所消耗的体力值。
当不存在可行路径，返回−1-1−1
参数不合法时返回−2-2−2
样例1
输入
3
1 2 3
5 5 5
7 7 7

输出
6

说明
通过路径的矩阵坐标为[0,0],[0,1],[0,2][0,0],[0,1],[0,2][0,0],[0,1],[0,2]，依次消耗了1,2,31,2,31,2,3体力值，共计666。其他路径由于高度差无法通过，因此最优解是666

样例2
输入
3
1 2 4
6 6 6
8 8 8

输出
-1

说明
由于高度差，没有可达到右侧的路径，返回-1
样例3
输入
3
1 2 1
1 1 2
9 9 9

输出
4

说明

红色路线消耗体力值为444，黄色路线消耗体力值为555，因此最优解为444。
(当然还存在其他路线，但都不如红色路线体力值小，本示例主要解释路径最优)

▶️

#### TextSol

video solution

题解
题面描述
给定一个大小为 k×kk\times kk×k 的二维矩阵 map[][]，表示二维空间中的一个地图，其中 map[i][j] 表示位置 (i,j)(i,j)(i,j) 上的地形高度。玩家控制一个角色从矩阵左上角位置 (0,0)(0,0)(0,0) 进入，从矩阵右侧任意位置出去。

角色在矩阵中只能向右或向下移动；
如果相邻两个节点高度差大于 111，则角色不能移动过去；
角色通过 (i,j)(i,j)(i,j) 地点时，会消耗 map[i][j]map[i][j]map[i][j] 的体力值。

要求计算最省体力值的路线所消耗的体力值。

若不存在可行路径，返回 −1-1−1；
若参数不合法（包括 k≤0k\le0k≤0 或 k>100k>100k>100，或任意 map[i][j]map[i][j]map[i][j] 不在 [0,10][0,10][0,10] 范围内），返回 −2-2−2。

思路

参数校验

判断 kkk 是否在 1≤k≤1001\le k\le1001≤k≤100；
判断所有 map[i][j]map[i][j]map[i][j] 是否满足 0≤map[i][j]≤100\le map[i][j]\le100≤map[i][j]≤10；
任一不满足则直接输出 −2-2−2。

状态定义

用 dp[i][j]dp[i][j]dp[i][j] 表示从起点 (0,0)(0,0)(0,0) 到达位置 (i,j)(i,j)(i,j) 的最小体力消耗。

初始化

所有 dp[i][j]dp[i][j]dp[i][j] 设为一个极大值 ∞\infty∞；
dp[0][0]=map[0][0]dp[0][0]=map[0][0]dp[0][0]=map[0][0]。

状态转移

对于每个格子 (i,j)(i,j)(i,j)，考虑从上方或左方转移，前提是高度差不超过 111：
|map[i][j]map[i][j]map[i][j]-map[i−1][j]map[i-1][j]map[i−1][j]|<=111,|map[i][j]map[i][j]map[i][j]-map[i][j−1]map[i][j-1]map[i][j−1]<=111
则
dp[i][j]dp[i][j]dp[i][j]=min(dp[i−1][j]dp[i-1][j]dp[i−1][j],dp[i][j−1]dp[i][j-1]dp[i][j−1])+map[i][j]map[i][j]map[i][j]

结果计算

最终答案为最右一列中最小的 dp[i][k−1]dp[i][k-1]dp[i][k−1]；
若仍为 ∞\infty∞，则无可行路径，输出 −1-1−1。

整体时间复杂度 O(k2)O(k^2)O(k2)，空间复杂度 O(k2)O(k^2)O(k2)，满足题目要求。
C++
#include <bits/stdc++.h>
using namespace std;

int main() {
int k;
if (!(cin >> k)) return 0;
// 参数 k 合法性检查
if (k <= 0 || k > 100) {
cout << -2;
return 0;
}
vector<vector<int>> mp(k, vector<int>(k));
for (int i = 0; i < k; i++) {
for (int j = 0; j < k; j++) {
cin >> mp[i][j];
// 地形高度合法性检查
if (mp[i][j] < 0 || mp[i][j] > 10) {
cout << -2;
return 0;
}
}
}
const int INF = 1e9;
vector<vector<int>> dp(k, vector<int>(k, INF));
dp[0][0] = mp[0][0];  // 起点消耗

// 动态规划填表
for (int i = 0; i < k; i++) {
for (int j = 0; j < k; j++) {
if (i > 0 && abs(mp[i][j] - mp[i-1][j]) <= 1) {
dp[i][j] = min(dp[i][j], dp[i-1][j] + mp[i][j]);
}
if (j > 0 && abs(mp[i][j] - mp[i][j-1]) <= 1) {
dp[i][j] = min(dp[i][j], dp[i][j-1] + mp[i][j]);
}
}
}

// 从最右列任意位置出去
int ans = INF;
for (int i = 0; i < k; i++) {
ans = min(ans, dp[i][k-1]);
}
// 输出结果
if (ans == INF) cout << -1;
else cout << ans;
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().split()
if not data:
return
k = int(data[0])
# 参数 k 合法性检查
if k <= 0 or k > 100:
print(-2)
return

mp = []
idx = 1
for _ in range(k):
row = list(map(int, data[idx:idx+k]))
# 地形高度合法性检查
if any(v < 0 or v > 10 for v in row):
print(-2)
return
mp.append(row)
idx += k

INF = 10**9
dp = [[INF]*k for _ in range(k)]
dp[0][0] = mp[0][0]  # 起点消耗

for i in range(k):
for j in range(k):
if i > 0 and abs(mp[i][j] - mp[i-1][j]) <= 1:
dp[i][j] = min(dp[i][j], dp[i-1][j] + mp[i][j])
if j > 0 and abs(mp[i][j] - mp[i][j-1]) <= 1:
dp[i][j] = min(dp[i][j], dp[i][j-1] + mp[i][j])

ans = min(dp[i][k-1] for i in range(k))
print(-1 if ans >= INF else ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int k = Integer.parseInt(br.readLine().trim());
// 参数 k 合法性检查
if (k <= 0 || k > 100) {
System.out.println(-2);
return;
}

int[][] mp = new int[k][k];
for (int i = 0; i < k; i++) {
String[] parts = br.readLine().split("\\s+");
for (int j = 0; j < k; j++) {
mp[i][j] = Integer.parseInt(parts[j]);
// 地形高度合法性检查
if (mp[i][j] < 0 || mp[i][j] > 10) {
System.out.println(-2);
return;
}
}
}

final int INF = 1_000_000_000;
int[][] dp = new int[k][k];
for (int i = 0; i < k; i++) {
Arrays.fill(dp[i], INF);
}
dp[0][0] = mp[0][0];  // 起点消耗

// 动态规划填表
for (int i = 0; i < k; i++) {
for (int j = 0; j < k; j++) {
if (i > 0 && Math.abs(mp[i][j] - mp[i-1][j]) <= 1) {
dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + mp[i][j]);
}
if (j > 0 && Math.abs(mp[i][j] - mp[i][j-1]) <= 1) {
dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + mp[i][j]);
}
}
}

// 从最右列任意位置出去
int ans = INF;
for (int i = 0; i < k; i++) {
ans = Math.min(ans, dp[i][k-1]);
}
System.out.println(ans == INF ? -1 : ans);
}
}

---

### 第2题-找到通信质量最高的基站（P5001）
- 链接：https://codefun2000.com/p/P5001

> 页面标题：#P5001. 第2题-找到通信质量最高的基站

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

闹市区中有一条马路，马路从000号路口开始，到N−1N-1N−1号路口结束，在每个路口都架设了最新技术的通信基站，每个基站的信号可以覆盖前后各kkk个路口的范围，即第1个路口上的基站，可以覆盖[i−k,i+k][i-k,i+k][i−k,i+k]这两个路口之间的马路，因此用户的手机处于多个基站的覆盖范围中。每个基站会统计当前接入人数，为保障最佳通信质量，用户手机应选择连接人数最少的基站进行通讯。
这条马路一共NNN个路口，小明从000号路口出发向前走，求小明在每个路段中的最佳通讯基站。不考虑处于路口中间的特殊场景,只考虑在每个路段中的场景，例如第1个路段应为000号路口到111号路口之间的路段，如果基站覆盖范围k=2k=2k=2，此时最佳基站应为0、1、20、1、20、1、2中连接人数最少的基站。
输入描述
输入为两行
第一行长度为NNN的整数数组crossroads[]crossroads[]crossroads[]，数组元素以空格分隔，其中crossroads[i]crossroads[i]crossroads[i]表示iii号路口基站的当前接入人数。
1<=crossroads.length1<=crossroads.length1<=crossroads.length数组长度<=105，0<=crossroads[i]<=102<=10^5，0<=crossroads[i]<=10^2<=105，0<=crossroads[i]<=102
第二行为基站覆盖范围kkk，1<=k<=crossroads.length1 <= k <= crossroads.length1<=k<=crossroads.length
非法输入返回−1-1−1
输出描述
返回一个数组ret，ret[i]ret，ret[i]ret，ret[i]表示iii路段上最佳基站的编号，数组元素之间以空格分隔。例如000号路口到111号路口的路段，为000号路段，其最佳基站用ret[0]ret[0]ret[0]表示。
样例1
输入
3 5 8 7 6 7 4
2

输出
0 0 1 4 6 6

说明
小明在第111段路时，位于000号和111号基站中间，此时可以连接到0、1、20、1、20、1、2这333个基站，而这三个基站中连接数最小的是000号基站(333个人)，因此输出数组第一个元素应为000号基站。小明位于第222段路时，位于111号和222号基站中间，此时可以连接到0、1、2、30、1、2、30、1、2、3这444个基站，选择其中连接人数最小的基站，即000号基站(333人)，因此输出数组第二个元素为000号基站。以此类推。
样例2
输入
9 8 7 6 7 8 9
2

输出
2 3 3 3 3 4

说明
小明在第111段路时，可以连接到的基站为0、1、20、1、20、1、2这333个基站，其中连接人数最小的基站为222号基站(777人连接)，因此输出数组第一个元素为222号基站。以此类推。

▶️

#### TextSol

video solution

道路最佳通信基站
题目描述
给定长度为 N 的数组 crossroads[]，其中 crossroads[i] 表示第 i 号路口基站的当前接入人数；以及覆盖范围 k。
基站 i 可覆盖路口 [max(0, i−k) … min(N−1, i+k)]。
小明从 0 号路口出发，走过第 i 段路（路口 i 到 i+1 之间）时，可连接所有覆盖该路段的基站，需选择接入人数最少的基站。
返回长度为 N−1 的数组 ret，其中 ret[i] 为第 i 段路的最佳基站编号。
解题思路
滑动窗口+单调队列

转化窗口：第 i 段路所能连接的基站编号范围为
L = max(0, i+1−k)   // 最早能覆盖该位置的基站
R = min(N−1, i+k)   // 最后能覆盖该位置的基站

维护最小值：我们需要在窗口 [L…R] 上快速查询最小值及其下标。

使用双端队列（monotonic queue）维护当前窗口内的下标，保证队首是窗口内值最小的下标。
当右端 R 增加时，将新下标入队，并在队尾弹出所有对应值 ≥ 新值的元素；
当左端 L 增加时，如队首下标 < L，则将其出队。

遍历 i 从 0 到 N−2：

计算当前段的 L、R
扩展右端到 R；收缩左端到 L
队首即为最小值基站编号，存入 ret[i]。

边界与非法输入

若 crossroads 为空或 k < 1 或 k > N，返回 -1。

复杂度分析

时间复杂度：O(N)，每个下标最多进出队各一次。
空间复杂度：O(N)，用于存放双端队列和结果数组。

代码实现
以下是在原有实现基础上，加入标准输入读取与输出的完整代码。均含中文注释，逻辑清晰简洁。
Python 实现
from collections import deque
import sys

def best_station(cross, k):
n = len(cross)
# 非法输入检查
if n < 2 or k < 1 or k > n:
return -1
dq = deque()     # 存放下标，保证 cross[dq] 单调递增
res = []
R = -1
for i in range(n-1):
# 计算第 i 段路可连接的基站编号范围
L = max(0, i+1-k)
newR = min(n-1, i+k)
# 扩展右端到 newR
while R < newR:
R += 1
# 弹出所有值 ≥ cross[R] 的下标
while dq and cross[dq[-1]] >= cross[R]:
dq.pop()
dq.append(R)
# 收缩左端，将队首下标 < L 的剔除
while dq and dq[0] < L:
dq.popleft()
# 队首即为当前最小接入人数的基站下标
res.append(dq[0])
return res

if __name__ == "__main__":
data = sys.stdin.readline().strip().split()
if not data:
print(-1)
sys.exit(0)
try:
cross = list(map(int, data))
k = int(sys.stdin.readline().strip())
except:
print(-1)
sys.exit(0)
ans = best_station(cross, k)
if ans == -1:
print(-1)
else:
print(" ".join(map(str, ans)))

Java 实现
import java.util.*;

public class Main {
// 计算每段路的最佳基站
public static List<Integer> bestStation(int[] cross, int k) {
int n = cross.length;
if (n < 2 || k < 1 || k > n) return Collections.singletonList(-1);
Deque<Integer> dq = new LinkedList<>();
List<Integer> res = new ArrayList<>();
int R = -1;
for (int i = 0; i < n - 1; i++) {
int L = Math.max(0, i + 1 - k);
int newR = Math.min(n - 1, i + k);
// 扩展右端
while (R < newR) {
R++;
while (!dq.isEmpty() && cross[dq.peekLast()] >= cross[R]) {
dq.pollLast();
}
dq.offerLast(R);
}
// 收缩左端
while (!dq.isEmpty() && dq.peekFirst() < L) {
dq.pollFirst();
}
res.add(dq.peekFirst());
}
return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
if (!sc.hasNextLine()) {
System.out.println(-1);
return;
}
String[] parts = sc.nextLine().trim().split("\\s+");
int n = parts.length;
int[] cross = new int[n];
try {
for (int i = 0; i < n; i++) cross[i] = Integer.parseInt(parts[i]);
if (!sc.hasNextInt()) throw new NumberFormatException();
int k = sc.nextInt();
List<Integer> ans = bestStation(cross, k);
if (ans.size() == 1 && ans.get(0) == -1) {
System.out.println(-1);
} else {
for (int i = 0; i < ans.size(); i++) {
System.out.print(ans.get(i));
if (i < ans.size() - 1) System.out.print(" ");
}
System.out.println();
}
} catch (Exception e) {
System.out.println(-1);
}
}
}

C++ 实现
#include <bits/stdc++.h>
using namespace std;

// 求每段路的最佳基站
vector<int> bestStation(const vector<int>& cross, int k) {
int n = cross.size();
if (n < 2 || k < 1 || k > n) return {-1};
deque<int> dq;        // 存放下标，保证 cross[dq] 单调递增
vector<int> res;
int R = -1;
for (int i = 0; i < n - 1; i++) {
int L = max(0, i + 1 - k);
int newR = min(n - 1, i + k);
// 扩展右端
while (R < newR) {
R++;
while (!dq.empty() && cross[dq.back()] >= cross[R]) {
dq.pop_back();
}
dq.push_back(R);
}
// 收缩左端
while (!dq.empty() && dq.front() < L) {
dq.pop_front();
}
res.push_back(dq.front());
}
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line;
if (!getline(cin, line)) {
cout << -1;
return 0;
}
istringstream iss(line);
vector<int> cross;
int x;
while (iss >> x) cross.push_back(x);

int k;
if (!(cin >> k)) {
cout << -1;
return 0;
}

vector<int> ans = bestStation(cross, k);
if (ans.size() == 1 && ans[0] == -1) {
cout << -1;
} else {
for (int i = 0; i < (int)ans.size(); i++) {
if (i) cout << ' ';
cout << ans[i];
}
}
return 0;
}

---

### 第2题-地震救灾线路（P2973）
- 链接：https://codefun2000.com/p/P2973

> 页面标题：#P2973. 第2题-地震救灾线路

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某市发生地震，为了尽快将救援物质输送到受灾乡镇，需要你设计出从救援物质集结点(有仅有一个)到某一个受灾乡镇的最短线路
应急部门通过无人机助察了受灾地区地形，提供了各乡镇之间以及乡镇到救援物质集结点的距离，请你算出救援物质集结点到受灾多镇的最短路径。
输入描述
第一行，NNN，受灾乡镇个数,3<=N<=203<=N<=203<=N<=20
第二行至第N+2N+2N+2行，救援物质集结点以及各乡镇之间的货(N+1N+1N+1个节点之间的相互距离短阵),距离取值范围是[0,100][0,100][0,100]、序号的节点表示救援物质集结点，序号1−N1-N1−N的节点表示各个受灾乡镇,000表示两个节点不相邻,
第N+3N+3N+3行，mmm，要抵达的乡镇序号(范围1−N1-N1−N)
输出描述
从物质集结点(节点000)到乡镇mmm(节点mmm)的最短路径长度
样例1
输入
5
0 5 13 0 0 0
5 0 12 0 75 0
13 12 0 25 0 0
0 0 25 0 35 20
0 75 0 35 0 40
0 0 0 20 40 0
3

输出
38

说明

从000到333的最短路径为0−2−30-2-30−2−3，长度为13+25=3813+25=3813+25=38
样例2
输入
5
0 5 13 0 0 0
5 0 12 0 75 0
13 12 0 25 0 0
0 0 25 0 35 20
0 75 0 35 0 40
0 0 0 20 40 0
5

输出
58

说明

从000到555的最短路径为0−2−3−50-2-3-50−2−3−5，长度为13+25+20=5813+25+20=5813+25+20=58

▶️

#### TextSol

video solution

题解
题目描述
给定一个救援物资集结点（编号为 000）和 NNN 个受灾乡镇（编号为 111 到 NNN），以及它们之间的距离矩阵。矩阵大小为 (N+1)×(N+1)(N+1)\times(N+1)(N+1)×(N+1)，其中元素 dijd_{ij}dij​ 表示节点 iii 到节点 jjj 的距离，不相邻时为 000。现在要求从节点 000 到指定乡镇节点 mmm 的最短路径长度。
思路
典型的单源最短路问题，可用 Dijkstra 算法 解决，适用于所有边权非负的情况。

用数组 dist[ ]\mathrm{dist}[\,]dist[] 记录从源点 000 到各节点的最短距离，初始时

用布尔数组 vis[ ]\mathrm{vis}[\,]vis[] 标记已确定最短路的节点，初始均为 false\text{false}false。
重复 N+1N+1N+1 次：

在所有 vis[i]=false\mathrm{vis}[i]=\text{false}vis[i]=false 的节点中选取 dist[i]\mathrm{dist}[i]dist[i] 最小者 uuu，将其标记为已访问：vis[u]=true\mathrm{vis}[u]=\text{true}vis[u]=true。
对于每个与 uuu 相邻且未访问的节点 vvv，若dist[v]>dist[u]+duv,\mathrm{dist}[v]>\mathrm{dist}[u]+d_{u v},
dist[v]>dist[u]+duv​,
则更新dist[v]=dist[u]+duv.\mathrm{dist}[v]=\mathrm{dist}[u]+d_{u v}.
dist[v]=dist[u]+duv​.

最终 dist[m]\mathrm{dist}[m]dist[m] 即为所求最短路径长度。

时间复杂度：O((N+1)2)O\bigl((N+1)^2\bigr)O((N+1)2)，当 N≤20N\le20N≤20 时完全可接受。
C++ 解法
#include <bits/stdc++.h>
using namespace std;

int main() {
int N;
cin >> N; // 受灾乡镇个数
int total = N + 1;
vector<vector<int>> d(total, vector<int>(total));
// 读入距离矩阵，节点 0 为物资集结点，1~N 为乡镇
for (int i = 0; i < total; i++) {
for (int j = 0; j < total; j++) {
cin >> d[i][j];
}
}
int m;
cin >> m; // 目标乡镇编号

const int INF = 1e9;
vector<int> dist(total, INF);
vector<bool> vis(total, false);

dist[0] = 0; // 源点到自己的距离为 0

// Dijkstra 算法主循环
for (int i = 0; i < total; i++) {
int u = -1, minDist = INF;
// 找到未访问且 dist 最小的节点 u
for (int j = 0; j < total; j++) {
if (!vis[j] && dist[j] < minDist) {
u = j;
minDist = dist[j];
}
}
if (u == -1) break; // 剩余节点不可达
vis[u] = true;
// 松弛以 u 为起点的所有边
for (int v = 0; v < total; v++) {
if (!vis[v] && d[u][v] > 0 && dist[v] > dist[u] + d[u][v]) {
dist[v] = dist[u] + d[u][v];
}
}
}

cout << dist[m] << endl; // 输出从 0 到 m 的最短距离
return 0;
}

Python 解法
import sys

def main():
N = int(sys.stdin.readline().strip())  # 受灾乡镇个数
total = N + 1
# 读取距离矩阵
d = [list(map(int, sys.stdin.readline().split())) for _ in range(total)]
m = int(sys.stdin.readline().strip())  # 目标乡镇编号

INF = 10**9
dist = [INF] * total
vis = [False] * total

dist[0] = 0  # 源点到自己的距离为 0

# Dijkstra 算法
for _ in range(total):
u = -1
minDist = INF
# 选出未访问的最小 dist 节点
for i in range(total):
if not vis[i] and dist[i] < minDist:
u = i
minDist = dist[i]
if u == -1:
break
vis[u] = True
# 松弛操作
for v in range(total):
if not vis[v] and d[u][v] > 0 and dist[v] > dist[u] + d[u][v]:
dist[v] = dist[u] + d[u][v]

print(dist[m])

if __name__ == "__main__":
main()

Java 解法
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int N = sc.nextInt(); // 受灾乡镇个数
int total = N + 1;
int[][] d = new int[total][total];
// 读取距离矩阵
for (int i = 0; i < total; i++) {
for (int j = 0; j < total; j++) {
d[i][j] = sc.nextInt();
}
}
int m = sc.nextInt(); // 目标乡镇编号

final int INF = Integer.MAX_VALUE / 2;
int[] dist = new int[total];
boolean[] vis = new boolean[total];
Arrays.fill(dist, INF);
dist[0] = 0; // 源点到自己距离为 0

// Dijkstra 算法
for (int i = 0; i < total; i++) {
int u = -1, minDist = INF;
// 找到未访问且 dist 最小的节点 u
for (int j = 0; j < total; j++) {
if (!vis[j] && dist[j] < minDist) {
u = j;
minDist = dist[j];
}
}
if (u == -1) break; // 剩余不可达
vis[u] = true;
// 对 u 的邻边进行松弛
for (int v = 0; v < total; v++) {
if (!vis[v] && d[u][v] > 0 && dist[v] > dist[u] + d[u][v]) {
dist[v] = dist[u] + d[u][v];
}
}
}

System.out.println(dist[m]); // 输出最短距离
}
}

---

### 第2题-游园线路（P3280）
- 链接：https://codefun2000.com/p/P3280

> 页面标题：#P3280. 第2题-游园线路

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某公园每年都会在新年时举办灯会，由于公园面积很大目各景点分散，希望你设计一条游园线路,从某个指定入口景点开始，到某个指定出口景点结束，使得游园总路程最短。最短路线不需要走完所有的景点，目中间允许经过其他出入口景点而不离开公园。
输入描述
第一行:N，景点个数，景点序号从000开始，N−1N-1N−1结束。2<=N<=152<=N<=152<=N<=15
第二行至第N+1N+1N+1行:是一个N∗NN*NN∗N的矩阵，表示各相邻景点之间的距离，距离为000表示不相邻。
第N+2N+2N+2行:该景点是否是公园出入口(111-是，000-否)。
第N+3N+3N+3行:要计算最短线路的入口景点序号和出口景点序号
所有用例的输入确保一定存在符合条件的线路，你无需考虑无解的情况。
输出描述
具体游园线路，如果有多条符合条件的线路，按景点序号从小到大进行排序。
样例1
输入
3
0 2 4
2 0 3
4 3 0
1 0 1
0 2

输出
0 2

说明

不难看出线路0−>20->20−>2是最短的
样例2
输入
4
0 2 0 3
2 0 3 1
0 3 0 4
3 1 4 0
1 0 1 0
0 2

输出
0 1 2

说明

不难看出符合要求的线路:
0−>1−>20->1->20−>1−>2,长度为555

▶️

#### TextSol

video solution

题解
题面描述
给定一个公园中的 NNN 个景点（编号从 000 到 N−1N-1N−1），以及一个 N×NN\times NN×N 的距离矩阵，矩阵中第 iii 行第 jjj 列的元素表示景点 iii 到景点 jjj 的距离，距离为 000 表示不相邻。还有一行标记哪些景点是公园的出入口（用 111 表示是，000 表示否）。最后给定一个入口景点编号 SSS 和一个出口景点编号 TTT。要求在允许经过任意其他景点但不需要访问所有景点的前提下，找到从 SSS 到 TTT 的最短游园线路，并输出具体经过的景点序列。如果存在多条等长最短路径，则输出按景点序号从小到大最小的那条路径。
思路

将景点和距离看作一个无向带权图，节点数为 NNN，边权由距离矩阵给出。
使用 Dijkstra 算法 从起点 SSS 计算到每个节点的最短距离 dist[i]dist[i]dist[i]。
为了在距离相同的情况下选择 字典序最小 的路径，我们在松弛操作中不仅维护距离，还需要维护到达该节点的路径序列 path[i]path[i]path[i]。
松弛时若新的距离更小，直接更新；若新的距离等于当前最优距离，则比较两个路径序列的字典序，选择更小者。
最终输出 path[T]path[T]path[T] 即为所求路径。

算法步骤

初始化：对所有 iii，dist[i]=∞dist[i]=\inftydist[i]=∞, path[i]={}path[i]=\{\}path[i]={}；令 dist[S]=0dist[S]=0dist[S]=0, path[S]={S}path[S]=\{S\}path[S]={S}。
使用优先队列（最小堆）存储 (dist, node)(dist,\,node)(dist,node)，初始压入 (0, S)(0,\,S)(0,S)。
当队列非空时，取出距离最小的 (d,u)(d,u)(d,u)，若 d>dist[u]d>dist[u]d>dist[u] 则跳过；否则对所有 vvv（满足 g[u][v]>0g[u][v]>0g[u][v]>0）尝试松弛：

若 dist[u]+g[u][v]<dist[v]dist[u] + g[u][v] < dist[v]dist[u]+g[u][v]<dist[v]，则dist[v]←dist[u]+g[u][v]dist[v] \leftarrow dist[u] + g[u][v]
dist[v]←dist[u]+g[u][v]
path[v]←path[u] 加上 vpath[v] \leftarrow path[u]\ \text{加上}\ v
path[v]←path[u] 加上 v

否则若dist[u]+g[u][v]=dist[v]dist[u] + g[u][v] = dist[v]
dist[u]+g[u][v]=dist[v]
则比较新路径 path[u]+{v}path[u] + \{v\}path[u]+{v} 与旧路径 path[v]path[v]path[v] 的字典序，若前者更小，则用前者更新 path[v]path[v]path[v]。
若发生更新，则将 (dist[v], v)(dist[v],\,v)(dist[v],v) 压入队列。

结束后，输出 path[T]path[T]path[T]。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
int N;
cin >> N;
vector<vector<int>> g(N, vector<int>(N));
for (int i = 0; i < N; i++)
for (int j = 0; j < N; j++)
cin >> g[i][j];

vector<int> isEntrance(N);
for (int i = 0; i < N; i++)
cin >> isEntrance[i];

int S, T;
cin >> S >> T;

const int INF = INT_MAX / 2;
vector<int> dist(N, INF);
vector<vector<int>> path(N);

// 最小堆，存 (距离, 节点)
using pii = pair<int,int>;
priority_queue<pii, vector<pii>, greater<pii>> pq;

dist[S] = 0;
path[S] = {S};
pq.emplace(0, S);

while (!pq.empty()) {
auto [d, u] = pq.top(); pq.pop();
if (d > dist[u]) continue;
for (int v = 0; v < N; v++) {
if (g[u][v] == 0) continue; // 不相邻
int nd = d + g[u][v];
vector<int> newPath = path[u];
newPath.push_back(v);

if (nd < dist[v] ||
(nd == dist[v] && newPath < path[v])) {
dist[v] = nd;
path[v] = newPath;
pq.emplace(nd, v);
}
}
}

// 输出路径
for (int i = 0; i < (int)path[T].size(); i++) {
if (i) cout << ' ';
cout << path[T][i];
}
return 0;
}

Python
import heapq

def shortest_path(N, g, is_entrance, S, T):
INF = float('inf')
dist = [INF] * N
paths = [[] for _ in range(N)]

dist[S] = 0
paths[S] = [S]
pq = [(0, S)]  # (距离, 节点)

while pq:
d, u = heapq.heappop(pq)
if d > dist[u]:
continue
for v in range(N):
if g[u][v] == 0:
continue  # 不相邻
nd = d + g[u][v]
new_path = paths[u] + [v]
# 如果新的距离更短，或距离相同但字典序更小，则更新
if nd < dist[v] or (nd == dist[v] and new_path < paths[v]):
dist[v] = nd
paths[v] = new_path
heapq.heappush(pq, (nd, v))
return paths[T]

# 读入
N = int(input())
g = [list(map(int, input().split())) for _ in range(N)]
is_entrance = list(map(int, input().split()))
S, T = map(int, input().split())

# 计算并输出
res = shortest_path(N, g, is_entrance, S, T)
print(' '.join(map(str, res)))

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int N = sc.nextInt();
int[][] g = new int[N][N];
for (int i = 0; i < N; i++)
for (int j = 0; j < N; j++)
g[i][j] = sc.nextInt();

int[] isEntrance = new int[N];
for (int i = 0; i < N; i++)
isEntrance[i] = sc.nextInt();

int S = sc.nextInt(), T = sc.nextInt();
final int INF = Integer.MAX_VALUE / 2;
int[] dist = new int[N];
List<List<Integer>> paths = new ArrayList<>();
for (int i = 0; i < N; i++) {
dist[i] = INF;
paths.add(new ArrayList<>());
}

dist[S] = 0;
paths.get(S).add(S);
// 优先队列，按 (距离, 节点) 升序排列
PriorityQueue<int[]> pq = new PriorityQueue<>(
Comparator.<int[]>comparingInt(a -> a[0])
.thenComparingInt(a -> a[1])
);
pq.offer(new int[]{0, S});

while (!pq.isEmpty()) {
int[] cur = pq.poll();
int d = cur[0], u = cur[1];
if (d > dist[u]) continue;
for (int v = 0; v < N; v++) {
if (g[u][v] == 0) continue; // 不相邻
int nd = d + g[u][v];
List<Integer> newPath = new ArrayList<>(paths.get(u));
newPath.add(v);
if (nd < dist[v] || (nd == dist[v] && lexLess(newPath, paths.get(v)))) {
dist[v] = nd;
paths.set(v, newPath);
pq.offer(new int[]{nd, v});
}
}
}

// 输出结果
List<Integer> ans = paths.get(T);
for (int i = 0; i < ans.size(); i++) {
if (i > 0) System.out.print(" ");
System.out.print(ans.get(i));
}
}

// 比较两条路径的字典序
private static boolean lexLess(List<Integer> a, List<Integer> b) {
int n = Math.min(a.size(), b.size());
for (int i = 0; i < n; i++) {
if (!a.get(i).equals(b.get(i))) {
return a.get(i) < b.get(i);
}
}
return a.size() < b.size();
}
}

---

### 第2题-迷宫最短路径（P3290）
- 链接：https://codefun2000.com/p/P3290

> 页面标题：#P3290. 第2题-迷宫最短路径

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个迷官的地图，地图是一个二维矩阵，其中 000 表示通道，111 表示墙壁，sss 表示起点，EEE 表示终点。你需要从起点 SSS 出发，通过最路径到达终点 EEE ，返回最短路径的步数，如果无法到达终点，则返回 −1-1−1，迷宫中会有虫洞，用数字 222 表示，成对出现，你走入虫洞可以穿越到另一个虫洞出口，耗费  000 步。
你只能上下左右移动，并且不能走出迷官的边界，也不能穿越墙壁
输入描述
第一行包含两个整数 m,n(1≤m,n≤50)m,n(1≤m,n≤50)m,n(1≤m,n≤50) ，表示迷宫的行数和列数。
接下来的 mmm 行，每行包含 nnn 个字符，表示迷宫的地图。字符为：
000：表示通道
111：表示墙壁
222：表示虫洞
SSS：表示起点
EEE：表示终点
输出描述
如果能够到达终点，输出最短路径的步数。
如果无法到达终点，输出 −1-1−1 。
样例1
输入
5 5
S0000
11110
01010
01010
0000E

输出
8

说明
在这个例子中，最短的路径如下所示：
$S ->(0,1)->(0,2)->(0,3)->(0,4)->(1,4)->(2,4)->(3,4)->E$
共8步。
样例2
输入
3 3
S00
111
E00

输出
-1

说明
在这个例子中，起点 555 和终点 EEE 被墙壁阻隔，因此无法到达终点，输出 −1-1−1 。
样例3
输入
3 3
S02
111
E02

输出
4

说明
在这个例子中，最短的路径如下所示：
S−>(0,1)−>(0,2)−>(2,1)−>ES ->(0,1)->(0,2)->(2,1)->ES−>(0,1)−>(0,2)−>(2,1)−>E 共 444 步。
(0,2)(0,2)(0,2) 进入虫洞后，可直接从 (2,1)(2,1)(2,1) 出来，不消耗步数

#### TextSol

核心思路
使用 广度优先搜索（BFS） 求解迷宫最短路径问题。BFS 自然保证第一次到达某状态时即为最短步数。

预处理
扫描整个地图，记录：

起点 SSS 的坐标；
终点 EEE 的坐标（可选，仅用于判断何时结束）；
所有虫洞 '2' 的坐标，按出现顺序两两配对，建立映射表 teleport，使得每个虫洞能瞬时传送至其配对位置。

BFS 初始化

构造队列 q，存放 (x,y,steps) 三元组；
构造访问标记 vis[m][n]，标记哪些格子已访问；
从起点入队，steps=0，并标记其为已访问。

BFS 过程

当队列非空时，弹出 (x,y,dist)；
若当前是终点，直接返回 dist；
遍历四个方向的新坐标 (nx,ny)，若在边界内、未被访问、且不是墙壁，则入队 (nx,ny,dist+1)，并标记访问；
若新坐标是虫洞 '2'，且其配对位置 (tx,ty) 未被访问，则将 (tx,ty,dist+1) 入队（不消耗步数），并标记访问。保证配对的虫洞在同一层bfs队列

无法到达
BFS 结束后仍未返回，则说明终点不可达，返回 -1。

复杂度分析

时间复杂度：

扫描地图 O(mn)O(mn)O(mn)；
BFS 最多访问每个格子一次，且每次扩展常量条边（4 个方向 + 1 条虫洞），故 O(mn)O(mn)O(mn)。
合计 O(mn)O(mn)O(mn)。

空间复杂度：

地图与访问标记数组各 O(mn)O(mn)O(mn)；
队列最坏情况也存放 O(mn)O(mn)O(mn) 个元素。
合计 O(mn)O(mn)O(mn)。

代码实现
Python
from collections import deque

def shortest_path(grid):
m, n = len(grid), len(grid[0])
# 方向数组：上、下、左、右
dirs = [(-1,0),(1,0),(0,-1),(0,1)]
# 记录虫洞配对
holes = []
for i in range(m):
for j in range(n):
if grid[i][j] == '2':
holes.append((i,j))
elif grid[i][j] == 'S':
sx, sy = i, j
teleport = {}
# 两两配对
for i in range(0, len(holes), 2):
a, b = holes[i], holes[i+1]
teleport[a] = b
teleport[b] = a

vis = [[False]*n for _ in range(m)]
q = deque()
q.append((sx, sy, 0))
vis[sx][sy] = True

while q:
x, y, d = q.popleft()
if grid[x][y] == 'E':
return d
# 四向移动
for dx, dy in dirs:
nx, ny = x+dx, y+dy
if 0 <= nx < m and 0 <= ny < n and not vis[nx][ny] and grid[nx][ny] != '1':
if grid[nx][ny] == '2':
tx, ty = teleport[(nx,ny)]
if not vis[tx][ty]:
vis[tx][ty] = True
q.append((tx, ty, d+1))
vis[nx][ny] = True
q.append((nx, ny, d+1))
return -1

# 读取输入并输出
if __name__ == '__main__':
m, n = map(int, input().split())
grid = [list(input().strip()) for _ in range(m)]
print(shortest_path(grid))

Java
import java.util.*;

public class Main {
static int m, n;
static char[][] g;
static boolean[][] vis;
static int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
public static void main(String[] args) {
Scanner in = new Scanner(System.in);
m = in.nextInt();
n = in.nextInt();
g = new char[m][n];
int sx=0, sy=0;
List<int[]> holes = new ArrayList<>();
for (int i = 0; i < m; i++) {
String line = in.next();
for (int j = 0; j < n; j++) {
g[i][j] = line.charAt(j);
if (g[i][j] == 'S') {
sx = i; sy = j;
} else if (g[i][j] == '2') {
holes.add(new int[]{i,j});
}
}
}
// 建立虫洞映射
Map<String, String> tel = new HashMap<>();
for (int i = 0; i < holes.size(); i += 2) {
int[] a = holes.get(i), b = holes.get(i+1);
tel.put(a[0]+","+a[1], b[0]+","+b[1]);
tel.put(b[0]+","+b[1], a[0]+","+a[1]);
}
vis = new boolean[m][n];
Queue<int[]> q = new LinkedList<>();
q.offer(new int[]{sx, sy, 0});
vis[sx][sy] = true;
int ans = -1;
while (!q.isEmpty()) {
int[] cur = q.poll();
int x = cur[0], y = cur[1], d = cur[2];
if (g[x][y] == 'E') { ans = d; break; }
// 四向
for (int[] dir : dirs) {
int nx = x + dir[0], ny = y + dir[1];
if (nx>=0 && nx<m && ny>=0 && ny<n
&& !vis[nx][ny] && g[nx][ny] != '1') {
// 走虫洞
if (g[nx][ny] == '2') {
String key = nx+","+ny;
String[] p = tel.get(key).split(",");
int tx = Integer.parseInt(p[0]), ty = Integer.parseInt(p[1]);
if (!vis[tx][ty]) {
vis[tx][ty] = true;
q.offer(new int[]{tx, ty, d+1});
}
}
vis[nx][ny] = true;
q.offer(new int[]{nx, ny, d+1});
}
}

}
System.out.println(ans);
}
}

C++
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;

int main(){
int m,n;
cin >> m >> n;
vector<string> g(m);
for(int i=0;i<m;i++) cin >> g[i];
vector<pii> holes;
int sx=0, sy=0;
for(int i=0;i<m;i++){
for(int j=0;j<n;j++){
if(g[i][j]=='S'){ sx=i; sy=j; }
else if(g[i][j]=='2'){
holes.emplace_back(i,j);
}
}
}
// 建立虫洞映射
map<pii,pii> tel;
for(int i=0;i<holes.size();i+=2){
pii a = holes[i], b = holes[i+1];
tel[a] = b;
tel[b] = a;
}
vector<vector<bool>> vis(m, vector<bool>(n,false));
queue<tuple<int,int,int>> q;
q.emplace(sx, sy, 0);
vis[sx][sy] = true;
int ans = -1;
int dx[4] = {-1,1,0,0}, dy[4] = {0,0,-1,1};
while(!q.empty()){
auto [x,y,d] = q.front(); q.pop();
if(g[x][y]=='E'){
ans = d;
break;
}
// 四向
for(int k=0;k<4;k++){
int nx = x+dx[k], ny = y+dy[k];
if(nx>=0 && nx<m && ny>=0 && ny<n
&& !vis[nx][ny] && g[nx][ny] != '1'){
// 虫洞
if(g[nx][ny]=='2'){
pii to = tel[{nx,ny}];
int tx = to.first, ty = to.second;
if(!vis[tx][ty]){
vis[tx][ty] = true;
q.emplace(tx, ty, d+1);
}
}
vis[nx][ny] = true;
q.emplace(nx, ny, d+1);
}
}

}
cout << ans << "\n";
return 0;
}

---

### 第2题-网络整改（P3287）
- 链接：https://codefun2000.com/p/P3287

> 页面标题：#P3287. 第2题-网络整改

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一个树形的网络拓扑中，有 nnn 台设备，编号 111 到 nnn ，其中我们固定 111 为根设备，如上图：根设备下可下挂多台设备(如设备编号 2、32、32、3 )，以此类推每一台设备下都可能下挂1台或者多台设备，最后没有下挂设备的设备成为边缘设备(如设备 3、5、6、73、5、6、73、5、6、7 )。
现在我们希望对网络进行整改，将组网中的部分设备移除，使得所有的边缘设备到根设备的距离相同，请你计算下最少需要移除多少台设备。
如上图：我们只需要移除 333 号和 555 号设备,可以使得剩下的所有边缘设备( 6、76、76、7 )到根设备的距离相同。
注：整个网络是单个连通的树型组网且没有环
输入描述
用例第一行为一个整数 n(3≤n≤5000)n(3≤n≤5000)n(3≤n≤5000) ，代表网络设备数目。
接下来 nnn 行每行包含两个整数 u,v(1≤u,v≤n,u≠v)u,v(1≤ u,v≤n,u≠v)u,v(1≤u,v≤n,u=v)  ，代表设备 uuu 与设备 vvv 相连接(注意仅代表链接关系，不表明确父子关系)。
注：我们保证每个设备的编号都小于等于 nnn ，且不重复；nnn 个网络设备，必然有 n−1n-1n−1 条连接。
输出描述
输出最少移除多少台设备，可以使得剩下的所有边缘设备到根设备距离都相同。
样例1
输入
7
1 2
1 3
2 4
2 5
4 6
4 7

输出
2

说明
如题目实例图中：我们移除 333 号和 555 号 222 台设备，可以使得剩下的所有边缘设备（6/76/76/7）到根设备的距离相同。
样例2
输入
5
4 1
2 4
5 1
5 3

输出
0

说明
该用例中的树形图为如下，可见不需要移除任何设备就满足边缘设备（2和3）到根设备1的距离都相等。

样例3
输入
7
1 2
2 3
3 4
1 5
1 6
1 7

输出
2

说明
该用例移除设备 444 后，再移除设备 333 即可。

▶️

#### TextSol

video solution

题解
题目描述
给定一棵以节点 111 为根的树型网络，包含 nnn 台设备（节点编号 111 到 nnn）。网络中任意两节点通过边相连，最后没有子节点的称为“边缘设备”。希望移除尽可能少的节点，使得剩下网络中所有边缘设备到根设备的距离都相同。输出最少需要移除的节点数。
思路

先从根节点 111 做一次 BFS/DFS，计算每个节点到根的初始距离 depth[v]depth[v]depth[v]。
设定一个目标距离 HHH，希望所有保留后的边缘节点深度都为 HHH。
对于每个节点 vvv，定义状态

若 depth[v]>Hdepth[v] > Hdepth[v]>H，则 dp[v][H]=−∞dp[v][H] = -\inftydp[v][H]=−∞（此节点深度已超出目标，无法保留）。
当 depth[v]=Hdepth[v]=Hdepth[v]=H 时，节点 vvv 必须成为边缘节点，故保留它本身计为 111。
当 depth[v]<Hdepth[v]<Hdepth[v]<H 时，节点 vvv 必须至少保留一个子节点路径以达到深度 HHH，因此累加所有能达成的子树的最大保留节点数。

根节点的 dp[1][H]dp[1][H]dp[1][H] 即是在目标深度 HHH 下可保留的最大节点数。遍历所有可能的 HHH（即树的最大深度范围），选取 max⁡Hdp[1][H]\max_H dp[1][H]maxH​dp[1][H]，则最少移除数为n−max⁡Hdp[1][H].n - \max_H dp[1][H].
n−Hmax​dp[1][H].

C++
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

// 全局变量
int n;
vector<vector<int>> adj;
vector<int> depth;
vector<vector<int>> children;
int maxDepth;

// 计算每个节点深度并构建子树
void dfsDepth(int u, int p) {
for (int v : adj[u]) {
if (v == p) continue;
depth[v] = depth[u] + 1;
maxDepth = max(maxDepth, depth[v]);
children[u].push_back(v);
dfsDepth(v, u);
}
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

cin >> n;
adj.assign(n+1, {});
for (int i = 0; i < n-1; i++) {
int u, v;
cin >> u >> v;
adj[u].push_back(v);
adj[v].push_back(u);
}

depth.assign(n+1, 0);
children.assign(n+1, {});
maxDepth = 0;
dfsDepth(1, 0);

// dp[v][h]: 子树 v 在目标叶深度 h 时最大保留节点数
// 为节省空间，用滚动数组：prev[h], cur[h]
vector<int> best(n+1, -INF), nxt;
int answer = 0;

// 对每个候选深度 h 从 0 到 maxDepth
for (int h = 0; h <= maxDepth; h++) {
// 自底向上后序遍历：我们可以用一次栈模拟，也可按节点编号逆序（因为深度越大后序肯定处理先）
// 这里简单地按深度从大到小分层遍历
vector<vector<int>> byDepth(maxDepth+1);
for (int v = 1; v <= n; v++) {
byDepth[depth[v]].push_back(v);
}
best.assign(n+1, -INF);
// 从最大深度层到 0 层
for (int d = maxDepth; d >= 0; d--) {
for (int v : byDepth[d]) {
if (depth[v] > h) {
best[v] = -INF;
} else if (depth[v] == h) {
// 变为叶子
best[v] = 1;
} else {
int sum = 0;
for (int u : children[v]) {
if (best[u] > 0) sum += best[u];
}
if (sum > 0) best[v] = sum + 1;
else best[v] = -INF;
}
}
}
answer = max(answer, best[1]);
}

// 最少移除数 = 总数 - 最大保留数
cout << (n - answer) << "\n";
return 0;
}

Python
import sys
sys.setrecursionlimit(10000)

n = int(sys.stdin.readline())
adj = [[] for _ in range(n+1)]
for _ in range(n-1):
u, v = map(int, sys.stdin.readline().split())
adj[u].append(v)
adj[v].append(u)

depth = [0]*(n+1)
children = [[] for _ in range(n+1)]
max_depth = 0

def dfs(u, p):
global max_depth
for v in adj[u]:
if v == p: continue
depth[v] = depth[u] + 1
max_depth = max(max_depth, depth[v])
children[u].append(v)
dfs(v, u)

dfs(1, 0)

# dp[v][h] 用滚动数组 best[v] 存储当前 h 的值
answer = 0
for h in range(max_depth+1):
# 按深度分层
by_depth = [[] for _ in range(max_depth+1)]
for v in range(1, n+1):
by_depth[depth[v]].append(v)

best = [-10**9]*(n+1)
for d in range(max_depth, -1, -1):
for v in by_depth[d]:
if depth[v] > h:
best[v] = -10**9
elif depth[v] == h:
best[v] = 1
else:
s = sum(best[u] for u in children[v] if best[u] > 0)
best[v] = s + 1 if s > 0 else -10**9
answer = max(answer, best[1])

print(n - answer)

Java
import java.io.*;
import java.util.*;

public class Main {
static int n;
static List<List<Integer>> adj;
static int[] depth;
static List<List<Integer>> children;
static int maxDepth = 0;

static void dfs(int u, int p) {
for (int v : adj.get(u)) {
if (v == p) continue;
depth[v] = depth[u] + 1;
maxDepth = Math.max(maxDepth, depth[v]);
children.get(u).add(v);
dfs(v, u);
}
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
n = Integer.parseInt(br.readLine());
adj = new ArrayList<>();
for (int i = 0; i <= n; i++) adj.add(new ArrayList<>());
for (int i = 0; i < n-1; i++) {
StringTokenizer st = new StringTokenizer(br.readLine());
int u = Integer.parseInt(st.nextToken()), v = Integer.parseInt(st.nextToken());
adj.get(u).add(v);
adj.get(v).add(u);
}

depth = new int[n+1];
children = new ArrayList<>();
for (int i = 0; i <= n; i++) children.add(new ArrayList<>());

dfs(1, 0);

int answer = 0;
for (int h = 0; h <= maxDepth; h++) {
List<List<Integer>> byDepth = new ArrayList<>();
for (int i = 0; i <= maxDepth; i++) byDepth.add(new ArrayList<>());
for (int v = 1; v <= n; v++) {
byDepth.get(depth[v]).add(v);
}

int[] best = new int[n+1];
Arrays.fill(best, Integer.MIN_VALUE / 2);
for (int d = maxDepth; d >= 0; d--) {
for (int v : byDepth.get(d)) {
if (depth[v] > h) {
best[v] = Integer.MIN_VALUE / 2;
} else if (depth[v] == h) {
best[v] = 1;
} else {
int sum = 0;
for (int u : children.get(v)) {
if (best[u] > 0) sum += best[u];
}
best[v] = (sum > 0 ? sum + 1 : Integer.MIN_VALUE / 2);
}
}
}
answer = Math.max(answer, best[1]);
}

System.out.println(n - answer);
}
}

---

### 第2题-最大营业额（P3296）
- 链接：https://codefun2000.com/p/P3296

> 页面标题：#P3296. 第2题-最大营业额

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某市场举办小吃节，小吃节持续nnn天，每天都会有不同的小吃摊位入驻，每个摊位每天在投入一定的人力之后产生一定的营业额。
管理方希望在小吃节期间选择连续的若干天，使得这些天的总营业额最大。但是由于人力限制，选择这些天中总的人力不超过KKK人天。
请你计算出满足条件的最大营业额。
输入描述
第111行输入222个数字，分别是小吃节持续天数n(0<n<100)n(0<n<100)n(0<n<100)，总的人力KKK人天(0<K<10000)(0<K<10000)(0<K<10000)
第222行到第n+1n+1n+1行，每一行输入222个数字，代表每天的营业额(0<j<10000)(0<j<10000)(0<j<10000)以及人力mmm人天(0<m<1000，m<K)(0<m<1000，m<K)(0<m<1000，m<K)
输出描述
在不超过KKK人天总人力限制的情况下，输出最大连续营业的营业额。
样例1
输入
6 6
3 1
1 2
5 1
2 3
7 2
4 4

输出
14

说明
小吃节持续666天，总人力限制666人天，
1.1.1.第111天营业额为333，人力为111
2.2.2.第222天营业额为111，人力为222
3.3.3.第333天营业额为555，人力为111
4.4.4.第444天营业额为222，人力为333
5.5.5.第555天营业额为777，人力为222
6.6.6.第666天营业额为444，人力为444
选择第333天到第555天，人力是1+3+2=61+3+2=61+3+2=6，不超过666人天，营业额总和为5+2+7=145+2+7=145+2+7=14，这是满足人力不超过666人天情况下的最大营业额。
样例2
输入
4 7
10 1
20 2
30 3
40 4

输出
70

说明
小吃节持续444天，总人力限制777人天。
1.1.1.第111天营业额为101010，人力为111
222.第222天营业额为202020，人力为222
3.3.3.第333天营业额为303030，人力为333
4.4.4.第444天营业额为404040，人力为444

#### TextSol

题解
题面描述
给定一个为期nnn天的小吃节，每天都有一个摊位，摊位第iii天产生的营业额为rir_iri​，消耗的人力为mim_imi​。管理方希望选取一段连续的天数区间，使得这段区间内的总人力不超过KKK，且总营业额最大。求该最大总营业额。

思路

由于所有mi>0m_i>0mi​>0，我们可以用双指针（滑动窗口）维护一个左指针LLL和右指针RRR，窗口表示天数区间 [L,R][L,R][L,R]。

用两个变量记录当前窗口的总人力cur_man和总营业额cur_rev。

初始令L=1L=1L=1,R=0R=0R=0,cur_man=0,cur_rev=0，最大答案ans=0ans=0ans=0。

不断将右指针RRR向右移入一天：

更新cur_man+!=m_R，cur_rev+!=r_R。

当cur_man>K时，说明超出人力，上移左指针直至cur_man<=K：

此时窗口合法，更新ans=max(ans,cur_rev)。

遍历结束后ans{ans}ans即为所求。整体时间复杂度为O(n)O(n)O(n)。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n, K;
cin >> n >> K;  // 输入天数 n 和人力上限 K

vector<int> r(n), m(n);
for (int i = 0; i < n; i++) {
cin >> r[i] >> m[i];  // 第 i 天的营业额 r[i] 和人力 m[i]
}

long long ans = 0;       // 最终答案：最大营业额
long long cur_rev = 0;   // 当前窗口总营业额
long long cur_man = 0;   // 当前窗口总人力
int L = 0;               // 窗口左指针

for (int R = 0; R < n; R++) {
cur_rev += r[R];
cur_man += m[R];
// 如果人力超限，则右移左指针收缩窗口
while (cur_man > K) {
cur_rev -= r[L];
cur_man -= m[L];
L++;
}
ans = max(ans, cur_rev);
}

cout << ans << "\n";
return 0;
}

Python
def max_revenue(n, K, revenues, manpowers):
ans = 0            # 最终最大营业额
cur_rev = 0        # 窗口当前营业额
cur_man = 0        # 窗口当前人力
L = 0              # 左指针

for R in range(n):
cur_rev += revenues[R]
cur_man += manpowers[R]
# 当人力超出上限时，移动左指针
while cur_man > K:
cur_rev -= revenues[L]
cur_man -= manpowers[L]
L += 1
ans = max(ans, cur_rev)
return ans

if __name__ == "__main__":
n, K = map(int, input().split())
revenues = []
manpowers = []
for _ in range(n):
r, m = map(int, input().split())
revenues.append(r)
manpowers.append(m)
print(max_revenue(n, K, revenues, manpowers))

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int n = sc.nextInt();    // 天数
int K = sc.nextInt();    // 人力上限

int[] r = new int[n];    // 营业额数组
int[] m = new int[n];    // 人力数组
for (int i = 0; i < n; i++) {
r[i] = sc.nextInt();
m[i] = sc.nextInt();
}

long ans = 0;            // 最终最大营业额
long curRev = 0;         // 当前窗口总营业额
long curMan = 0;         // 当前窗口总人力
int L = 0;               // 左指针

for (int R = 0; R < n; R++) {
curRev += r[R];
curMan += m[R];
// 若人力超限，则收缩窗口
while (curMan > K) {
curRev -= r[L];
curMan -= m[L];
L++;
}
ans = Math.max(ans, curRev);
}

System.out.println(ans);
sc.close();
}
}

---

### 第2题-版本选择（P3293）
- 链接：https://codefun2000.com/p/P3293

> 页面标题：#P3293. 第2题-版本选择

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

云化平台对于组件按版本号进行统一管理，版本号遵循语义版本控制系统,格式为:
major.minor.patch
其中
major: 项目进行重大更新，且包含不向后兼容的功能
minor:仅在以向后兼容的方式添加新功能
patch:仅在以向后兼容的方式修复错误，并且没有添加任何新的功能
业务AppAppApp在其配置文件中声明其依赖的组件及版本，如:1.1.01.1.01.1.0
并且版本号可以缩写，没有写出来的部分表示为000，如:

对于其依赖的版本号，有三种声明方式:
1.1.1.指定最新版本
业务AppAppApp的配置方式为:  *
它最终会匹配仓库中的最新版本给业务AppAppApp使用。
1.1.1.取majormajormajor版本一致情况下的最大版本
由于majormajormajor版本之间可能不兼容，指定主版本号，业务AppAppApp的配置方式为:^1.2.0
这样写会尝试匹配主版本号为1的最大版本。
更多样例含义:

1.保证majormajormajor和minorminorminor版本一致，只取最新的patchpatchpatch版本，写法为:
只进行BugBugBug修复，只更新patchpatchpatch，业务AppAppApp的配置方式为:~1.2.0 或者 -1.2.0
这样写会取majormajormajor版本号为1、minor1、minor1、minor版本2、patch2、patch2、patch版本号最大的版本。
输入描述
第一行给出当前仓库中指定组件的版本数量NNN，后续NNN行给出具体的每一个版本号(注意这里不保证版本号的大小顺序)，最后一行给出业务AppAppApp组件的版本号声明。
3<=N<=1000003<=N<=1000003<=N<=100000
版本号中的major、minor和patch都满足0<=yersion<=1000000<=yersion<=1000000<=yersion<=100000
输出描述
输出最终匹配到的版本号。
如果没有配置的版本号则输出NoneNoneNone
样例1
输入
5
1.1.1
2.1
1.2.2
1.2.6
1.3.3
^1.2

输出
1.3.3

说明
对于目标组件，当前在仓库中有555个版本，分别为
1.1.11.1.11.1.1
2.12.12.1
1.2.21.2.21.2.2
1.2.61.2.61.2.6
1.3.31.3.31.3.3
业务AppAppApp声明的组件依赖为^1.2，系统最终为其匹配到的版本为1.3.31.3.31.3.3
样例2
输入
5
1.1.1
2.1
1.2.2
1.2.6
1.3.3
*

输出
2.1

说明
*表示取所有版本中的最高版本，即2.12.12.1
样例3
输入
5
1.1.1
2.1
1.2.2
1.2.6
1.3.3
-1.2

输出
1.2.6

说明
−-−表示在major.minor不变的情况下取patch最大的版本号，这里
即:1.2.61.2.61.2.6
样例4
输入
6
1.1.1
2.1
1.2.2
1.2.6
1.3.3
1.4
^1.6

输出
None

说明
major版本号为111 minor大于等于666的版本号不存在，输出NoneNoneNone

▶️

#### TextSol

video solution

题解
题面描述
在云化平台中，组件按版本号统一管理，版本号遵循语义化版本控制，格式为：
major.minor.patch

majormajormajor：重大更新，可能包含向后不兼容的功能。
minorminorminor：在向后兼容的前提下新增功能。
patchpatchpatch：在向后兼容的前提下修复错误，没有新增功能。

业务AppAppApp在配置文件中声明其依赖组件及版本，支持如下三种声明方式：

*：取仓库中最新版本。
^major[.minor[.patch]]：匹配相同majormajormajor且版本号不低于声明版本的最大版本。
-major.minor[.patch] 或 ~major.minor[.patch]：匹配相同 majormajormajor 和 minorminorminor 且版本号不低于声明版本的最大版本（即只更新补丁）。

说明：- 与 ~ 前缀等价，示例中使用 - 时也表示只更新补丁。

版本号缩写
声明时可省略 minor 或 patch，未写出部分默认补齐为000，例如：

2 等价于 2.0.0
1.2 等价于 1.2.0

解题思路

解析版本号声明：

若声明为 *，直接从所有版本中选最大。
若声明以 ^ 开头，解析后缀版本为三元组(major_0,minor_0,patch_0)，保留所有满足 major = major_0 且 版本三元组 >= (major_0,minor_0,patch_0) 的版本。
若声明以 - 或 ~ 开头，解析后缀版本为三元组(major_0,minor_0,patch_0)，保留满足 major = major_0 且 minor = minor_0 且 版本三元组 >= (major_0,minor_0,patch_0) 的版本。

版本号标准化：

按 . 分割字符串，补齐至三元组(major,minor,patch)。

比较规则：

按字典序比较三元组：先比majormajormajor，再比minorminorminor，最后比patchpatchpatch。

遍历筛选：

遍历所有三元组，按声明方式过滤后，记录最大者。

格式化输出：

若无有效版本输出 None。

否则省略尾部 .0：

若 patch = 0，只输出 major.minor；
若 minor = 0 且 patch = 0，只输出 major；
否则输出完整 major.minor.patch。

C++
#include <bits/stdc++.h>
using namespace std;

// 解析版本号，并补齐为三元组
array<int,3> parse(const string &s) {
array<int,3> v = {0,0,0};
stringstream ss(s);
string part;
int i = 0;
while (getline(ss, part, '.') && i < 3) {
v[i++] = stoi(part);
}
return v;
}

// 三元组比较，大于返回 true
bool greaterThan(const array<int,3>& a, const array<int,3>& b) {
return a > b;
}

// 三元组是否 >=
bool atLeast(const array<int,3>& v, const array<int,3>& req) {
return v >= req;
}

string formatVersion(const array<int,3>& v) {
if (v[2] == 0) {
if (v[1] == 0) return to_string(v[0]);
return to_string(v[0]) + "." + to_string(v[1]);
}
return to_string(v[0]) + "." + to_string(v[1]) + "." + to_string(v[2]);
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N;
cin >> N;
vector<array<int,3>> versions(N);
string s;
for (int i = 0; i < N; i++) {
cin >> s;
versions[i] = parse(s);
}
cin >> s;

array<int,3> best = {-1,-1,-1};
if (s == "*") {
for (auto &v : versions) if (greaterThan(v, best)) best = v;
} else {
char mode = s[0];
auto req = parse(s.substr(1));
for (auto &v : versions) {
if (mode == '^') {
if (v[0] != req[0] || !atLeast(v, req)) continue;
} else if (mode == '-' || mode == '~') {
if (v[0] != req[0] || v[1] != req[1] || !atLeast(v, req)) continue;
}
if (greaterThan(v, best)) best = v;
}
}

if (best[0] < 0) cout << "None";
else cout << formatVersion(best);
return 0;
}

Python
import sys

def parse(s):
parts = s.split('.')
return tuple(int(parts[i]) if i < len(parts) else 0 for i in range(3))

def format_version(v):
major, minor, patch = v
if patch == 0:
if minor == 0:
return f"{major}"
return f"{major}.{minor}"
return f"{major}.{minor}.{patch}"

N = int(sys.stdin.readline())
versions = [parse(sys.stdin.readline().strip()) for _ in range(N)]
req = sys.stdin.readline().strip()

best = (-1, -1, -1)

def at_least(v, target):
return v >= target

if req == '*':
best = max(versions)
else:
mode = req[0]
target = parse(req[1:])
for v in versions:
if mode == '^':
if v[0] != target[0] or not at_least(v, target):
continue
if mode in ('-', '~'):
if v[0] != target[0] or v[1] != target[1] or not at_least(v, target):
continue
if v > best:
best = v

if best[0] < 0:
print('None')
else:
print(format_version(best))

Java
import java.io.*;
import java.util.*;

public class Main {
private static int[] parse(String s) {
String[] parts = s.split("\\.");
int[] v = {0,0,0};
for (int i = 0; i < parts.length && i < 3; i++) {
v[i] = Integer.parseInt(parts[i]);
}
return v;
}

private static String formatVersion(int[] v) {
if (v[2] == 0) {
if (v[1] == 0) return String.valueOf(v[0]);
return v[0] + "." + v[1];
}
return v[0] + "." + v[1] + "." + v[2];
}

private static int compare(int[] a, int[] b) {
for (int i = 0; i < 3; i++) if (a[i] != b[i]) return a[i] - b[i];
return 0;
}

private static boolean atLeast(int[] v, int[] req) {
for (int i = 0; i < 3; i++) {
if (v[i] < req[i]) return false;
if (v[i] > req[i]) return true;
}
return true;
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine());
List<int[]> versions = new ArrayList<>();
for (int i = 0; i < N; i++) {
versions.add(parse(br.readLine()));
}
String req = br.readLine();

int[] best = {-1,-1,-1};
if (req.equals("*")) {
for (int[] v : versions) if (compare(v, best) > 0) best = v;
} else {
char mode = req.charAt(0);
int[] target = parse(req.substring(1));
for (int[] v : versions) {
if (mode == '^') {
if (v[0] != target[0] || !atLeast(v, target)) continue;
} else if (mode == '-' || mode == '~') {
if (v[0] != target[0] || v[1] != target[1] || !atLeast(v, target)) continue;
}
if (compare(v, best) > 0) best = v;
}
}

if (best[0] < 0) System.out.println("None");
else System.out.println(formatVersion(best));
}
}

---

### 第2题-连通网络节点和（P3302）
- 链接：https://codefun2000.com/p/P3302

> 页面标题：#P3302. 第2题-连通网络节点和

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

本题定义的连通网络，是由有连接关系的一个或多个节点组成的无向图。
连通网络中每个节点，都赋予了一个权重，表示该节点的重要程度；所有节点的权重的和，代表该连通网络的权重。
假设一个连通网络中各个节点，权重都是唯一的，不会重复。
请根据输入的节点和权重，以及节点的连接关系，分析输入包含的连通网络并计算连通网络对应的权重，最终输出权重最大网络中权重最大的节点的名称，以及该网络整体的权重。
输入描述
第一行是节点数 nnn ，值的范围 [1,160][1,160][1,160] 。
接下来会出现n行，每一行的第一个输入是节点的名称（长度小于等于 323232 的字符串，只包含小写字母和数字），第二个是节点的权重，通过空格和节点名称分开，权重值的范围是 [1,10000][1,10000][1,10000] 。
接着是节点连接关系的数量 mmm ，值的范围 [0,160][0,160][0,160]
接下来会出现 mmm 行，每一行包含两个节点的名称，表示有连接关系的两个节点，节点顺序不分先后，且节点名称均包含在上面的节点列表中。如果为 000 ，代表节点间没有连接关系。
输出描述
找到权重最大的连通网络，输出权重最大的节点的名称，以及网络对应的权重（用例保证不同网络的权重不会相同）
样例1
输入
5
node1 15
node2 12
node3 13
node4 4
node5 50
3
node1 node2
node3 node2
node4 node5

输出
node5 54

说明
如下图，以上输入，形成了两个连通网络，node1、node2、node3node1、node2、node3node1、node2、node3 有连接关系，形成连通网络 111 ，权重最大的节点是 node1node1node1 ，所有节点和是 404040 ；node4、node5node4、node5node4、node5 有连接关系，形成连通网络 222 ，权重最大的节点是 node5node5node5 ，所有也点和是 545454 。权重最大的网络的权重是 545454 ，所以输出 node5node5node5 545454 。

样例2
输入
1
node1 100
0

输出
node1 100

说明
如下图，以上输入，形成了一个连通网络，该连通网络只有一个节点 node1node1node1 ，所以权重最大的节点也是 node1node1node1 ，所有节点和是 100100100 ，所以输出 node1node1node1 100100100 。

#### TextSol

题解
题面描述
本题定义的连通网络，是由有连接关系的一个或多个节点组成的无向图。

图中有nnn个节点，nnn 的取值范围为 [1,160][1,160][1,160]。
每个节点有一个唯一的权重，权重的取值范围为 [1,10000][1,10000][1,10000]。
节点之间有mmm条连接关系，mmm的取值范围为 [0,160][0,160][0,160]，每条连接表示无向边。
一个连通网络的权重定义为其所有节点权重之和；因为节点权重互不相同，连通网络内部可以确定“权重最大的节点”。
要求：找到权重最大的连通网络，输出该网络中权重最大的节点的名称，以及该网络的总权重。题目保证不同连通网络的总权重不会相同。

思路

建图与遍历

将节点按照名称映射为索引，记录每个节点的权重和名称。
构建邻接表表示无向图。

连通分量搜索

对每个未访问节点，启动一次深度优先搜索（DFS）或广度优先搜索（BFS），遍历其所属连通分量。
在遍历过程中，累计该分量的权重和，同时维护该分量内部权重最大的节点。

结果更新

每处理完一个连通分量，即可得到该分量的总权重SSS以及最大权重节点名称namemaxname_{max}namemax​。
用一个全局变量记录迄今为止最大的连通分量权重及对应节点。

输出

遍历完成后，直接输出全局记录的最大节点名称与对应分量权重。

代码实现
C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;  // 节点数 n
unordered_map<string, int> id;       // 节点名称到索引的映射
vector<string> names(n);
vector<int> weight(n);
for (int i = 0; i < n; i++) {
cin >> names[i] >> weight[i];
id[names[i]] = i;
}

int m;
cin >> m;  // 边数 m
vector<vector<int>> adj(n);
for (int i = 0; i < m; i++) {
string u, v;
cin >> u >> v;
int iu = id[u], iv = id[v];
adj[iu].push_back(iv);
adj[iv].push_back(iu);
}

vector<bool> vis(n, false);
long long bestSum = 0;    // 当前最大连通分量权重
string bestNode;          // 对应最大节点名称

// DFS 遍历函数
function<void(int, long long&, int&)> dfs = [&](int u, long long& sum, int& maxIdx) {
vis[u] = true;
sum += weight[u];
if (weight[u] > weight[maxIdx]) {
maxIdx = u;
}
for (int v : adj[u]) {
if (!vis[v]) dfs(v, sum, maxIdx);
}
};

// 遍历所有节点，找到各连通分量
for (int i = 0; i < n; i++) {
if (!vis[i]) {
long long sum = 0;
int maxIdx = i;
dfs(i, sum, maxIdx);
// 更新全局最优
if (sum > bestSum) {
bestSum = sum;
bestNode = names[maxIdx];
}
}
}

// 输出结果
cout << bestNode << " " << bestSum << "\n";
return 0;
}

Python
import sys
sys.setrecursionlimit(10000)

def main():
n = int(sys.stdin.readline().strip())  # 节点数 n
id_map = {}
names = []
weight = []
for i in range(n):
line = sys.stdin.readline().split()
names.append(line[0])
weight.append(int(line[1]))
id_map[line[0]] = i

m = int(sys.stdin.readline().strip())  # 边数 m
adj = [[] for _ in range(n)]
for _ in range(m):
u, v = sys.stdin.readline().split()
iu, iv = id_map[u], id_map[v]
adj[iu].append(iv)
adj[iv].append(iu)

visited = [False] * n
best_sum = 0
best_node = ""

def dfs(u):
"""返回当前连通分量的 (sum, max_idx)"""
visited[u] = True
total = weight[u]
max_idx = u
for v in adj[u]:
if not visited[v]:
s, mi = dfs(v)
total += s
if weight[mi] > weight[max_idx]:
max_idx = mi
return total, max_idx

for i in range(n):
if not visited[i]:
s, mi = dfs(i)
if s > best_sum:
best_sum = s
best_node = names[mi]

print(best_node, best_sum)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static int n, m;
static List<List<Integer>> adj;
static String[] names;
static int[] weight;
static boolean[] visited;
static long bestSum = 0;
static String bestNode = "";

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
n = Integer.parseInt(br.readLine().trim());  // 节点数 n
names = new String[n];
weight = new int[n];
Map<String, Integer> idMap = new HashMap<>();

for (int i = 0; i < n; i++) {
String[] parts = br.readLine().split(" ");
names[i] = parts[0];
weight[i] = Integer.parseInt(parts[1]);
idMap.put(names[i], i);
}

m = Integer.parseInt(br.readLine().trim());  // 边数 m
adj = new ArrayList<>();
for (int i = 0; i < n; i++) adj.add(new ArrayList<>());

for (int i = 0; i < m; i++) {
String[] edge = br.readLine().split(" ");
int u = idMap.get(edge[0]);
int v = idMap.get(edge[1]);
adj.get(u).add(v);
adj.get(v).add(u);
}

visited = new boolean[n];
for (int i = 0; i < n; i++) {
if (!visited[i]) {
long sum = dfs(i);
// dfs 中已全局更新 bestSum & bestNode
}
}

System.out.println(bestNode + " " + bestSum);
}

// 返回当前连通分量的权重总和，并在过程中更新 bestSum、bestNode
static long dfs(int u) {
visited[u] = true;
long sum = weight[u];
int maxIdx = u;
for (int v : adj.get(u)) {
if (!visited[v]) {
long s = dfs(v);
sum += s;
// 无法直接拿到子分量的局部最大 idx，故改用全局比较
}
}
// 这里单节点比较，实际只需在主循环后再额外一次遍历即可简化
if (sum > bestSum) {
// 在该分量中找到权重最大的节点
int curMax = u;
for (int i = 0; i < n; i++) {
if (visited[i] && weight[i] > weight[curMax]) {
curMax = i;
}
}
bestSum = sum;
bestNode = names[curMax];
}
return sum;
}
}

---

### 第2题-变量生命周期计算（P3299）
- 链接：https://codefun2000.com/p/P3299

> 页面标题：#P3299. 第2题-变量生命周期计算

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在 RustRustRust 语言中，一个变量的生命周期是与其变量的作用域绑定的，变量离开作用域时被自动销毁。
这里给出一个简单的模型；一对大括号为一个生命周期，除了括号之外，每一行包含以下两个操作之一：
letletlet {varvarvar_ namenamename}
dropdropdrop {varvarvar _ namenamename}
其中：letletlet 表示声明一个变量，{varvarvar_ namenamename} 为变量名；dropdropdrop 表示手动销毁一个变量，销毁的对象为变量名 {varvarvar_namenamename} 。
其它规则：离开一个作用域时，如果有变量没有被dropdropdrop显式销毁，则自动销毁，顺序规则是后声明的先销毁。
出错情况：
1.销毁了一个没有声明的变量。
2.一个已经声明的变量被手动 dropdropdrop 超过一次。
输入描述
第一行为一个数字 NNN ，表示后面待输入代码的行数。
其中：5<=N<=150005<=N<=150005<=N<=15000 。
{ 独占一行
} 独占一行
letletlet 和变量名之间只有一个空格
dropdropdrop 和变量名之间只有一个空格
变量名只包含大小写字母，长度为 [1,32][1,32][1,32]
输入约束：
1.全局每一行 letletlet 声明变量的变量名都不相同。
2.用例中不会出现 dropdropdrop 非同一作用域变量(包括父作用域)的情况。
3.除输入的第一行为行数，输入的第二行一定会是 '{' ，最后一行一定是'}' ：即一定会显式声明一个最外层作用域。
4.每一行输入的行头可能有 000 个或者多个前导空格，let/droplet/droplet/drop 与变量名之间只有一个空格。
5.不会出现括号不成对匹配、变量名不符号要求等输入异常的场景，编码时不需要考虑括输入不正确的场景。
输出描述
输出各变量的销毁顺序，以一个空格分隔
如果发生出错的情况，则将出错前成功释放的变量全部按要求打印出来之后，再接一个空格和一个固定字符串 “Error”“Error”“Error”，然后中止输出。
样例1
输入
6
{
let a
let b
let c
drop b
}

输出
b c a

说明
按行说明：
待输入的总代码行数为 666
新增第一个作用域
第一个作用域声明变量 aaa
第一个作用域声明变量 bbb
第一个作用域声明变量 ccc
显式销毁 bbb
离开第一个作用域，按声明反序，销毁 cacaca (因为 bbb 已经显式销毁)
样例2
输入
9
{
let a
let b
{
let c
}
drop b
drop d
}

输出
c b Error

说明
按行说明：
待输入的总代码行数为 999
新增第一个作用域
第一个作用域声明变量 aaa
第一个作用域声明变量 bbb
新增第二个作用域
第二个作用域声明变量 ccc
离开第二个作用域，按声明反序，自动销毁 ccc
显式销毁 bbb
显式销毁 ddd ，但是 ddd 在其所属的第一个作用域中还没有声明，报错退出
样例3
输入
12
{
let a
let b
{
let c
{
let d
let f
}
}
drop b
}

输出
f d c b a

说明
按行说明：
待输入的总代码行数为 121212
新增第一个作用域
第一个作用域声明变量 aaa
第一个作用域声明变量 bbb
新增第二个作用域
第二个作用域 声明变量 ccc
新增第三个作用域
第三个作用域 声明变量 ddd
第三个作用域 声明变量 fff
离开第三个作用域，按声明反序，销毁 fff ddd
离开第二个作用域，按声明反序，销毁 ccc
显式销毁变量 bbb
离开第一个作用，按声明反序，销毁 aaa (因为bbb已经显式销毁)
样例4
输入
7
{
let a
{
drop a
}
}

输出
Error

说明
按行说明：
待输入的总代码行数为 777
新增第一个作用域
第一个作用域声明变量 aaa
新增第二个作用域
dropdropdrop 变量 aaa ，但是 aaa 非本作用域变量(为其父作用域变量)，出错。

▶️

#### TextSol

video solution

题目描述
在RustRustRust语言中，变量的生命周期与其作用域绑定，退出作用域时自动销毁。我们用一个简化模型来模拟这一过程：

“{” 和 “}” 表示新开和结束一个作用域；

每行要么是

let name：在当前作用域声明变量 name，
drop name：在当前作用域手动销毁变量 name。

离开一个作用域时，若有未被 $drop$ 的变量，则自动按“后声明先销毁”顺序销毁。

出错情况：
1.1.1. 销毁了一个未在同一作用域中声明的变量；
2.2.2. 已声明的变量被 drop 超过一次。
输出要求：按销毁顺序依次输出变量名，用空格分隔；若出错，则输出已成功销毁的变量，后跟一个空格和字符串 "Error"，然后终止。

思路

使用一个栈来管理作用域，每个作用域对应一个栈帧，栈帧内部维护一个按声明顺序的列表。

维护一个全局哈希表，记录每个变量所属的栈帧层级以及是否已被销毁。

逐行处理输入：

遇到 {，压入新的空栈帧；

遇到 }，弹出当前栈帧，按逆序自动销毁其中所有未被 drop 的变量；

遇到 let name，将 $name$ 加入当前栈帧尾部，并在哈希表中标注层级及“未销毁”；

遇到 drop name，检查哈希表：

若不存在或层级不匹配，则报错；
若已销毁，则报错；
否则标记为已销毁，输出该变量。

若中途报错，停止处理并输出 "Error"；否则最终完成所有行后输出结果。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N;
cin >> N;              // 读取总行数 N
string line;
vector<vector<string>> scopeStack;  // 作用域栈
unordered_map<string, pair<int,bool>> info; // 变量 -> (层级, 已销毁)
vector<string> output;  // 记录销毁顺序
bool error = false;

getline(cin, line); // 吸收行末

for (int i = 0; i < N; i++) {
getline(cin, line);
// 去除前导空格
int pos = line.find_first_not_of(' ');
if (pos == string::npos) continue;
line = line.substr(pos);

if (line == "{") {
// 新作用域
scopeStack.emplace_back();
}
else if (line == "}") {
// 结束当前作用域，自动销毁未 drop 的变量
int lvl = scopeStack.size() - 1;
auto &frame = scopeStack.back();
for (int k = frame.size() - 1; k >= 0; k--) {
const string &v = frame[k];
if (!info[v].second) {
output.push_back(v);
info[v].second = true;
}
}
scopeStack.pop_back();
}
else if (line.rfind("let ", 0) == 0) {
// let 操作
string var = line.substr(4);
int lvl = scopeStack.size() - 1;
scopeStack.back().push_back(var);
info[var] = {lvl, false};
}
else if (line.rfind("drop ", 0) == 0) {
// drop 操作
string var = line.substr(5);
if (!info.count(var) || info[var].first != (int)scopeStack.size() - 1) {
// 未声明或不在本层
error = true;
} else if (info[var].second) {
// 重复 drop
error = true;
} else {
// 合法 drop
output.push_back(var);
info[var].second = true;
}
}

if (error) {
break;
}
}

// 输出结果
for (auto &v : output) {
cout << v << ' ';
}
if (error) {
cout << "Error";
}
return 0;
}

Python
import sys

def main():
N = int(sys.stdin.readline().strip())  # 读取总行数 N
scope_stack = []  # 作用域栈，每层是变量列表
info = {}        # 变量 -> (层级, 已销毁)
output = []
error = False

for _ in range(N):
line = sys.stdin.readline().lstrip()
if line.startswith('{'):
scope_stack.append([])
elif line.startswith('}'):
lvl = len(scope_stack) - 1
frame = scope_stack.pop()
# 自动销毁
for var in reversed(frame):
if not info[var][1]:
output.append(var)
info[var] = (lvl, True)
elif line.startswith('let '):
var = line.split()[1]
lvl = len(scope_stack) - 1
scope_stack[-1].append(var)
info[var] = (lvl, False)
elif line.startswith('drop '):
var = line.split()[1]
if var not in info or info[var][0] != len(scope_stack) - 1:
error = True
elif info[var][1]:
error = True
else:
output.append(var)
info[var] = (info[var][0], True)
if error:
break

# 打印输出
print(' '.join(output), end='')
if error:
print('Error')

if __name__ == '__main__':
main()

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int N = Integer.parseInt(br.readLine().trim()); // 读取总行数 N
List<List<String>> scopeStack = new ArrayList<>();  // 作用域栈
Map<String, Pair> info = new HashMap<>();           // 变量 -> (层级, 已销毁)
List<String> output = new ArrayList<>();
boolean error = false;

for (int i = 0; i < N; i++) {
String line = br.readLine().replaceAll("^\\s+", "");
if (line.equals("{")) {
scopeStack.add(new ArrayList<>());
} else if (line.equals("}")) {
int lvl = scopeStack.size() - 1;
List<String> frame = scopeStack.remove(lvl);
// 自动销毁
for (int k = frame.size() - 1; k >= 0; k--) {
String var = frame.get(k);
Pair p = info.get(var);
if (!p.destroyed) {
output.add(var);
p.destroyed = true;
}
}
} else if (line.startsWith("let ")) {
String var = line.substring(4);
int lvl = scopeStack.size() - 1;
scopeStack.get(lvl).add(var);
info.put(var, new Pair(lvl, false));
} else if (line.startsWith("drop ")) {
String var = line.substring(5);
if (!info.containsKey(var) || info.get(var).level != scopeStack.size() - 1) {
error = true;
} else if (info.get(var).destroyed) {
error = true;
} else {
output.add(var);
info.get(var).destroyed = true;
}
}
if (error) break;
}

// 输出结果
for (String v : output) {
System.out.print(v + " ");
}
if (error) {
System.out.print("Error");
}
}

// 存储变量信息的辅助类
static class Pair {
int level;
boolean destroyed;
Pair(int level, boolean destroyed) {
this.level = level;
this.destroyed = destroyed;
}
}
}

---

### 第2题-故障路径查询（P3305）
- 链接：https://codefun2000.com/p/P3305

> 页面标题：#P3305. 第2题-故障路径查询

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

网络路由图由 nnn 个点(编号从 111 开始依次递增)和 mmm 条边(编号从 111 开始依次递增)构成，业务的流量由 sss 点走到 ttt 点。
现在网络发生了 qqq 次故障，每次故障给出一个整数 iii ，表示第 iii 条边发生了故障，业务将不能再经过这条边。
每次故障发生后，输出 sss 到 ttt 的哪些简单路径被断开了。
sss 到 ttt 的简单路径是一条点和边都不重复出现的路径。
sss 到 ttt 的简单路径由一个边序列 eid1,eid2,...,eidkeid1,eid2,...,eidkeid1,eid2,...,eidk 构成，eideideid 代表 edgeldedgeldedgeld
为避免输出量过大，我们将原始图中的路径(故障发生前)按照边序列的字典序从小到大排序，依次编号为 1,2,3,...1,2,3,...1,2,3,...
每次故障发生后，只需要输出这些边的编号即可(从小到大排序)
在比较数组的字典序时，遵循以下规则：
1.从第一个元素开始，逐个比较数组对应位置的元素。
2.如果某个位置的元素不相同，较小的元素所在的数组排在前面。
3.如果所有比较位置的元素都相同，则较短的数组排在前面。
例如，给定两个数组 [1,2,3][1,2,3][1,2,3] 和 [1,2,4][1,2,4][1,2,4] ，由于在第三个位置上 3<43<
43<4 ，因此 [1,2,3][1,2,3][1,2,3] 在字典序中排在 [1,2,4][1,2,4][1,2,4] 之前。
如果比较 [1,2][1,2][1,2] 和 [1,2,0][1,2,0][1,2,0] ，由于前两个位置的元素相同，而第一个数组较短，因此 [1,2][1,2][1,2] 在字典序中排在 [1,2,0][1,2,0][1,2,0] 之前。
输入描述
第一行给出 444 个整数 n,m,s,t(2<=n<=500,1<=m<=1000,1<=s,t<=n,s<=t)n,m,s,t(2<=n<=500,1<=m<=1000,1<=s,t<=n,s<=t)n,m,s,t(2<=n<=500,1<=m<=1000,1<=s,t<=n,s<=t)
第 222 到 m+1m+1m+1 行每行两个整数 u,vu,vu,v 表示点 uuu 和点 vvv 之间有一条无向边,边按输入顺序编号为 1,2,...,m1,2,...,m1,2,...,m
第 m+2m+2m+2 行给出一个整数 q(1<=q<=m)q(1<=q<=m)q(1<=q<=m) 表示故障的发生次数
接下来 qqq 行每行一个整数 eid(edgeld)eid(edgeld)eid(edgeld) 表示编号为 eld(1<=eld<=m)eld(1<=eld<=m)eld(1<=eld<=m) 的边发生了故障，保证所有的 eldeldeld 互不相同
输入保证 sss 到 ttt 的简单路径不超过 100000010000001000000 条,保证以 sss 为起点不经过点 ttt 的简单路径不超过 100000001000000010000000 条
输出描述
输出 qqq 行，每行依次对应该次故障的答案
每行首先输出一个整数 xxx 表示本次故障共有 xxx 条路径被断开，接下来 xxx 整数为这些被断开的路径的编号(升序输出)，单空格间隔
样例1
输入
2 2 1 2
1 2
1 2
2
2
1

输出
1 2
1 1

说明
样例2
输入
5 6 1 2
1 2
1 3
3 2
3 4
4 2
1 5
3
6
2
1

输出
0
2 2 3
1 1

说明
如图：

从 111 到 222 一共有 333 条简单路径：1−>2，1−>3−>2，1−>3−>4−>21->2，1->3->2，1->3->4->21−>2，1−>3−>2，1−>3−>4−>2
333 条路径的边序列分别为：111, 222 333, 222 444 555
因此按照字典序依次编号为：1,2,31,2,31,2,3
当断掉第 666 条边 (1−>5)(1->5)(1−>5)，没有路径被断开
断掉第 222 条边，路径 222 和 333 被断开
断掉第 111 条边，路径 111 被断开

#### TextSol

题目描述
给定一个网络路由图，包含nnn 个节点（编号1∼n1\sim n1∼n）和mmm条无向边（编号1∼m1\sim m1∼m）。业务从源点sss走到汇点ttt。
现发生qqq次故障，每次故障给出一个边编号eideideid，表示这条边失效，之后业务不能再经过它。
在每次故障发生后，需要输出“原始图中”（故障前）所有从sss到ttt的简单路径中，有哪些路径被断开，并按以下方式编号输出：

将所有s→ts\to ts→t 的简单路径按「边编号序列」的字典序从小到大排序，依次编号为1,2,…1,2,\dots1,2,…；
每次故障后，输出包含故障边的那些路径的编号（升序）。

问题本质分析

我们要枚举所有从sss 到ttt 的简单路径，并按边编号序列的字典序排序、编号。
随后针对每条边eee，需要快速知道哪些路径经过了eee，以便在故障时输出对应的路径编号。

由于简单路径总数上限为10610^6106，我们可以：

DFS 枚举：从sss开始深度优先搜索到ttt，沿途记录所经过的边编号序列。
因为要按字典序枚举，需对每个节点的邻边按“边编号”升序预先排序。
当 DFS 走到ttt 时，当前的路径编号自增为pidpidpid，并将pidpidpid 加入到该路径上每条边的关联列表 edge_paths[e] 中。
最终，edge_paths[e] 即存储了所有经过边eee的原始路径编号（自然按发现时的pidpidpid 升序）。

查询时直接访问对应 edge_paths[eid]，输出其大小和内容即可。

思路步骤

读入数据，构建邻接表，把边 (u,v) 同时加入 adj[u] 与 adj[v]，并记录边编号。

对每个节点的邻接列表按“边编号”升序排序，确保 DFS 按字典序遍历。

初始化全局变量 pid=0，一个 visited[n+1] 标记节点访问，一个 path_edges 存当前路径的边编号序列，一个 vector<int> edge_paths[m+1] 记录每条边对应的路径编号列表。

从sss开始 DFS：

若到达ttt，则 pid++，并对 path_edges 中的每个边编号eee做 edge_paths[e].push_back(pid)。
否则遍历每条邻边eee到达未访问的下一个节点，继续 DFS。

DFS 完毕后，针对每次故障查询，直接输出 edge_paths[eid] 的 size() 及其元素。

C++
#include <bits/stdc++.h>
using namespace std;

int n, m, s, t;
vector<vector<pair<int,int>>> adj;      // adj[u] = list of (v, edge_id)
vector<bool> visited;                  // 访问标记
vector<int> path_edges;                // 当前 DFS 路径上的边编号
vector<vector<int>> edge_paths;        // edge_paths[e] 存经过边 e 的所有路径编号
int pid = 0;                           // 路径编号

void dfs(int u) {
if (u == t) {
// 到达 t，记录当前路径编号
pid++;
for (int e : path_edges) {
edge_paths[e].push_back(pid);
}
return;
}
for (auto [v, eid] : adj[u]) {
if (!visited[v]) {
visited[v] = true;
path_edges.push_back(eid);
dfs(v);
path_edges.pop_back();
visited[v] = false;
}
}
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

cin >> n >> m >> s >> t;
adj.assign(n+1, {});
for (int eid = 1; eid <= m; eid++) {
int u, v;
cin >> u >> v;
// 无向图
adj[u].emplace_back(v, eid);
adj[v].emplace_back(u, eid);
}
// 邻边按边编号升序，保证字典序遍历
for (int u = 1; u <= n; u++) {
sort(adj[u].begin(), adj[u].end(),
[](auto &a, auto &b){ return a.second < b.second; });
}

visited.assign(n+1, false);
edge_paths.assign(m+1, {});
visited[s] = true;
dfs(s);

int q;
cin >> q;
while (q--) {
int eid;
cin >> eid;
auto &vec = edge_paths[eid];
cout << vec.size();
for (int pid : vec) {
cout << ' ' << pid;
}
cout << '\n';
}
return 0;
}

Python
import sys
sys.setrecursionlimit(10**7)

def main():
input = sys.stdin.readline
n, m, s, t = map(int, input().split())
adj = [[] for _ in range(n+1)]     # 邻接表
for eid in range(1, m+1):
u, v = map(int, input().split())
adj[u].append((v, eid))
adj[v].append((u, eid))
# 按边编号排序，保证字典序
for u in range(1, n+1):
adj[u].sort(key=lambda x: x[1])

visited = [False] * (n+1)
path_edges = []                     # 当前路径上的边
edge_paths = [[] for _ in range(m+1)]
pid = 0

def dfs(u):
nonlocal pid
if u == t:
pid += 1
for e in path_edges:
edge_paths[e].append(pid)
return
for v, eid in adj[u]:
if not visited[v]:
visited[v] = True
path_edges.append(eid)
dfs(v)
path_edges.pop()
visited[v] = False

visited[s] = True
dfs(s)

q = int(input())
for _ in range(q):
eid = int(input())
vec = edge_paths[eid]
# 输出断开路径数及其编号
print(len(vec), *vec)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
static int n, m, s, t;
static List<int[]>[] adj;           // adj[u]: list of {v, eid}
static boolean[] visited;
static List<Integer> pathEdges = new ArrayList<>();
static List<List<Integer>> edgePaths;
static int pid = 0;

static void dfs(int u) {
if (u == t) {
pid++;
for (int e : pathEdges) {
edgePaths.get(e).add(pid);
}
return;
}
for (int[] ve : adj[u]) {
int v = ve[0], eid = ve[1];
if (!visited[v]) {
visited[v] = true;
pathEdges.add(eid);
dfs(v);
pathEdges.remove(pathEdges.size() - 1);
visited[v] = false;
}
}
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
n = Integer.parseInt(st.nextToken());
m = Integer.parseInt(st.nextToken());
s = Integer.parseInt(st.nextToken());
t = Integer.parseInt(st.nextToken());

adj = new ArrayList[n+1];
for (int i = 1; i <= n; i++) adj[i] = new ArrayList<>();
for (int eid = 1; eid <= m; eid++) {
st = new StringTokenizer(br.readLine());
int u = Integer.parseInt(st.nextToken());
int v = Integer.parseInt(st.nextToken());
adj[u].add(new int[]{v, eid});
adj[v].add(new int[]{u, eid});
}
// 按边编号排序
for (int i = 1; i <= n; i++) {
adj[i].sort(Comparator.comparingInt(a -> a[1]));
}

visited = new boolean[n+1];
edgePaths = new ArrayList<>();
for (int i = 0; i <= m; i++) edgePaths.add(new ArrayList<>());

visited[s] = true;
dfs(s);

int q = Integer.parseInt(br.readLine());
StringBuilder sb = new StringBuilder();
while (q-- > 0) {
int eid = Integer.parseInt(br.readLine());
List<Integer> vec = edgePaths.get(eid);
sb.append(vec.size());
for (int id : vec) {
sb.append(' ').append(id);
}
sb.append('\n');
}
System.out.print(sb);
}
}

---

### 第2题-最大化安全评分（P3313）
- 链接：https://codefun2000.com/p/P3313

> 页面标题：#P3313. 第2题-最大化安全评分

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

安全分析师小王正在开发一款先进的入侵检测系统 （IDS），旨在实时监控网络流量并失败潜在的恶意活动；如何在一个复杂的网络环境中，从起始节点出发，到达终端节点（即最后一个监控点），同时最大化累积的安全评分。
在这个系统中，整个网络被抽象为一个下标从 000 开始的整数数组 nodenodenode _scoresscoresscores ，其中每个元素代表对应位置的安全评分。正值表示该位置是安全的或有正面的安全措施，而负值则表示存在潜在风险或威胁。分析师开始于位置 000 （入口节点），每一步可以前进最多 k 步，但不能超出数组边界。也就是说，如果当前位于下标 iii  ，则可以选择跳到 [i+1,min(n−1,i+k)][i+1,min(n-1,i+k)][i+1,min(n−1,i+k)] 包含两个端点的任意位置。目标是到达数组的最后一个位置（即最后一个监控点，下标为 n−1n-1n−1 ），并且在此过程中最大化累积的安全评分得分。这里的得分可以是正也可以是负，取决于路径上遇到的安全状况。
具体任务是编写一个算法，给定一个整数数组 nodenodenode _scoresscoresscores 和一个整数 kkk ，该算法应返回能够获得的最大得分。这个得分是通过选将一条从起点到终点的最佳路径来实现的，这条路径上的所有数字之和即为最大得分，即使某些位置的安全评分为负。
输入描述
每组数据第一行为最大的进步数 kkk ，第二行为节点数量 nnn ，第三行的 nnn 个数为每个节点的安全得分
输入范围限制：

1<=node1 <= node1<=node _scores.length,k<=100000scores.length,k <=100000scores.length,k<=100000

−10000<=node-10000<= node−10000<=node _scores[i]<=10000scores[i]<= 10000scores[i]<=10000

输出描述
到达最后一个节点时可以获得的最大安全得分
样例1
输入
2
8
3 -5 -10 2 -1 5 -6 -5

输出
0

说明
最多可前进步数 k=2k=2k=2 ，安全评分数组长度 n=8n=8n=8 ，数组 nodesnodesnodes _corescorescores 的具体值为 =[3,−5,−10,2,−1,5,−6,−5]=[3,-5,-10,2,-1,5,-6,-5]=[3,−5,−10,2,−1,5,−6,−5] ，可使安全评分最大的子字列 [3,−5,2,5,−5][3,-5,2,5,-5][3,−5,2,5,−5] ，因此最大安全得到为 000
样例2
输入
3
6
1 -5 -2 4 0 7

输出
12

说明
最多可前进步数 k=3k=3k=3 ，安全评分数组长度 n=6n=6n=6 ，数组 nodesnodesnodes _corescorescores 的具体值为 =[1,−5,−2,4,0,7]=[1,-5,-2,4,0,7]=[1,−5,−2,4,0,7] ，可使安全评分最大的子字列 [1,4,7][1,4,7][1,4,7] ，因此最大安全得到为 121212
样例3
输入
2
6
1 -3 -2 4 -7 5

输出
8

说明
最多可前进步数 k=2k=2k=2 ，安全评分数组长度 n=6n=6n=6 ，数组 nodesnodesnodes _corescorescores 的具体值为 =[1,−3,−2,4,−7,5]=[1,-3,-2,4,-7,5]=[1,−3,−2,4,−7,5] ，可使安全评分最大的子字列 [1,−2,4,5][1,-2,4,5][1,−2,4,5] ，因此最大安全得到为 888

#### TextSol

题面描述
安全分析师小王正在开发一款先进的入侵检测系统（IDS），旨在实时监控网络流量并识别潜在的恶意活动。系统将网络抽象为一个下标从000开始的整数数组 node_scores，其中每个元素代表对应位置的安全评分：正值表示安全或有正面安全措施，负值表示存在潜在风险或威胁。
分析师从入口节点（下标000）开始，每一步最多可以前进KKK步，但不能超出数组边界。也就是说，如果当前位于下标iii，则可以跳到任意下标jjj，满足
i+1≤j≤min(n−1,i+K)i+1 \le j \le min(n-1,i+K)i+1≤j≤min(n−1,i+K)
目标是到达下标n−1n-1n−1（最后一个监控点），并使累积的安全评分总和最大。注意：路径上的评分可能为正也可能为负。
思路

记dp[i]dp[i]dp[i]为到达节点iii时的最大累积安全得分，则期望：
dp[i]dp[i]dp[i] =maxj∈[i−K,i−1](dp[j])max_{j \in [i-K,i-1]}(dp[j])maxj∈[i−K,i−1]​(dp[j]) +node_scores[i].

直接计算会导致每个iii遍历KKK个前驱，整体时间O(nK)O(nK)O(nK)，在n,Kn,Kn,K均可达10510^5105 时不可行。

使用「单调队列」优化滑动窗口最大值的维护：维护一个双端队列 dq，其中保存候选下标，并保持对应的dpdpdp值递减。

维护队首始终是窗口内最大的dpdpdp下标；
当处理到iii时，将不在窗口 [i−K,i−1][i-K,i-1][i−K,i−1] 的下标从队首或队尾剔除；
利用队首的dpdpdp值计算 dp[i]dp[i]dp[i]，再将iii插入队列时，从队尾剔除所有dpdpdp值不大于 dp[i]dp[i]dp[i]的下标，保证队列单调递减。

这样每个元素进出队列各一次，整体时间O(n)O(n)O(n)，空间O(n)O(n)O(n)。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int K, n;
cin >> K >> n;
vector<int> node_scores(n);
for (int i = 0; i < n; i++) {
cin >> node_scores[i];
}

// dp[i] 表示到达节点 i 时的最大安全得分
vector<long long> dp(n, LLONG_MIN);
dp[0] = node_scores[0];

deque<int> dq;
dq.push_back(0);  // 双端队列中存放下标，并保持 dp[dq] 递减

for (int i = 1; i < n; i++) {
// 剔除队首中不在窗口 [i-K, i-1] 的下标
while (!dq.empty() && dq.front() < i - K) {
dq.pop_front();
}
// 当前 dp 转移：使用窗口最大值 + 当前节点分数
dp[i] = dp[dq.front()] + node_scores[i];

// 插入 i，保持队列单调递减
while (!dq.empty() && dp[dq.back()] <= dp[i]) {
dq.pop_back();
}
dq.push_back(i);
}

cout << dp[n-1] << "\n";
return 0;
}

Python
import sys
from collections import deque

def max_score(node_scores, K):
n = len(node_scores)
dp = [-10**18] * n  # 初始化为足够小的值
dp[0] = node_scores[0]

dq = deque([0])  # 存放下标，维护 dp 递减

for i in range(1, n):
# 移除过期的窗口左侧下标
while dq and dq[0] < i - K:
dq.popleft()
# 转移方程
dp[i] = dp[dq[0]] + node_scores[i]
# 维护单调队列
while dq and dp[dq[-1]] <= dp[i]:
dq.pop()
dq.append(i)

return dp[-1]

if __name__ == "__main__":
data = sys.stdin.read().split()
K = int(data[0])
n = int(data[1])
scores = list(map(int, data[2:2+n]))
print(max_score(scores, K))

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
int K = Integer.parseInt(br.readLine().trim());
int n = Integer.parseInt(br.readLine().trim());
StringTokenizer st = new StringTokenizer(br.readLine());

long[] dp = new long[n];
int[] nodeScores = new int[n];
for (int i = 0; i < n; i++) {
nodeScores[i] = Integer.parseInt(st.nextToken());
}

// 初始化 dp 数组
Arrays.fill(dp, Long.MIN_VALUE);
dp[0] = nodeScores[0];

Deque<Integer> dq = new ArrayDeque<>();
dq.addLast(0);  // 存放下标，dp 递减

for (int i = 1; i < n; i++) {
// 移除窗口外的下标
while (!dq.isEmpty() && dq.peekFirst() < i - K) {
dq.pollFirst();
}
// 状态转移
dp[i] = dp[dq.peekFirst()] + nodeScores[i];
// 维护单调队列
while (!dq.isEmpty() && dp[dq.peekLast()] <= dp[i]) {
dq.pollLast();
}
dq.addLast(i);
}

System.out.println(dp[n-1]);
}
}

---

### 第2题-将军分配物资方案（P3310）
- 链接：https://codefun2000.com/p/P3310

> 页面标题：#P3310. 第2题-将军分配物资方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

古代战争时期，各县向前线战场运送粮食，各县提供的粮食车数不一样，到达前线后需排队进入军营，一次只能进入一个县车队，同时军营中的多个副将排队领取粮食，排在第 111 名的为 L1L1L1 ，第 222 名为 L2L2L2 ，以此类推。
将军制定了一套发放规则:
假设当前进入营寨的县车队运来的粮食车数为 KKK
1、若 KKK 等于当前副将的需求，则直接领走，县车队跟随副将一起离开队伍。继续下一轮】
2、若 KKK 大于当前副将 L1L1L1 的需求，则把后续营的需求纳入进来一起看，即找一个数字，使领取。前 iii 个副将的总需求刚好小于等于 KKK ，但前 i+1i+1i+1 个副将的总需求大于 KKK 。此时将该县车队粮食全部分给这 iii 个副将，然后下一个县车队进入军营，下一个副将(即编号 i+1i+1i+1 的副将)作为队首开始下一轮领取。
3、若 KKK 小于当前副将需求，则该营放弃本次领取，走到队尾重新排队。
问按照此规则发放，最终有多少个副将不能领导粮食?
输入描述
输入为两行：
第 111 行为各县粮车数的数组 carscarscars ，空格分隔，carcarcar 表示编号 i(i<=1000)i(i<=1000)i(i<=1000) 的县运来的粮食车数 (1<=car[i]<=100)(1<=car[i]<=100)(1<=car[i]<=100)。例如： 333 555 777 999 333 222 111
第 222 行为各副将需求数组 generalRequiresgeneralRequiresgeneralRequires 数，空格分隔，generalRequires[j]generalRequires[j]generalRequires[j] 表示编号
jjj (j<=1000j<=1000j<=1000)的副将的需求数(1<=generalRequires[i]<=1001<=generalRequires[i]<=1001<=generalRequires[i]<=100)。
例如：111 222 444 555 222
非法输入返回 −1-1−1
输出描述
输出不能分到粮食的副将人数。
例如：
000 表示没有副将不能分到粮食
111 表示有 111 名副将不能够分到足够的粮食
222 表示有 222 名副将不能分到粮食，以此类推
样例1
输入
1
5 6

输出
2

说明
没有车数能够满足副将需求，所有副将均未能领到粮食，输出未领取粮食副将个数 222
样例2
输入
3 5 7 3 4
2 4 8 5 2

输出
1

说明
1、01、01、0 号车队(333 车粮食)被 000 号副将( 111 车需求)领走：

[3],5,7,3,4[3],5,7,3,4[3],5,7,3,4

[1],4,8,5,2[1],4,8,5,2[1],4,8,5,2

2、12、12、1 号车队被 111 号副将领走：

[3],[5],7,3,4[3], [5],7,3,4[3],[5],7,3,4

[1],[4],8,5,2[1], [4],8,5,2[1],[4],8,5,2

3、23、23、2 号车队( 777 车粮食)不能满足 222 号副将( 888 车需求)，因此 222 号副将重新排队：

[3],[5],7,3,4[3], [5], 7,3,4[3],[5],7,3,4

[1],[4],5,2,[8][1],[4],5,2,[8][1],[4],5,2,[8]

3、23、23、2 号车队( 777 车粮食)被下 222 个副将( 5+25+25+2 车需求)领走：

[3],[5],[7],3,4[3],[5],[7],3,4[3],[5],[7],3,4

4、84、84、8 车需求的副将始终领不到粮食，因此输出副将个数为 111
样例3
输入
3 5 7 9 3 2 1
1 2 4 5 2

输出
0

说明
1、01、01、0 号车队被 0、10、10、1 号副将领走：

[3],5,7,9,3,2,1[3],5,7,9,3,2,1[3],5,7,9,3,2,1

[1,2],4,5,2[1,2],4,5,2[1,2],4,5,2

2、12、12、1 号车队被 222 号副将领走：

[3],[5],7,9,3,2,1[3], [5], 7,9,3,2,1[3],[5],7,9,3,2,1

[1,2],[4],5,2[1,2] ,[4], 5,2[1,2],[4],5,2

3、23、23、2 号车队被 3、43、43、4 号副将领走：
[3],[5],[7],9,3,2,1[3], [5], [7],9,3,2,1[3],[5],[7],9,3,2,1
4、4、4、所有副将都领取到了粮食，返回结果 000

#### TextSol

题面描述

有一队粮食车队，每队运来KKK辆粮车；

有若干副将按序排队，每人需求若干辆粮车；

规则：

当前车队粮车数为KKK。
若K=当前副将需求K={当前副将需求}K=当前副将需求，则该副将和车队同时出列。
若K>当前副将需求K>{当前副将需求}K>当前副将需求，设前iii名副将总需求
Si=sumj=1irj.S_i=sum_{j=1}^i r_j.Si​=sumj=1i​rj​.
找最大iii使得
Si≤K<Si+1S_i\le K<S_{i+1}Si​≤K<Si+1​
则前iii 名副将和车队同时出列。
若K<当前副将需求K<{当前副将需求}K<当前副将需求，则该副将移到队尾，车队保留在队首，继续本车队的领取尝试。

重复直到车队或副将任意一方耗尽，输出最终剩余未领到粮食的副将人数。

思路

准备两条队列，一条存储各县的粮车数，一条存储各副将的需求数。
每次取出队首的粮车数KKK，记录下要“看”副将队列的最大次数（即当前副将人数），防止无限循环。
在不超过这次数的尝试中，如果遇到第一位需求不超过KKK的副将，就开始连续为后续所有需求累计之和，直到总和超过KKK为止；被满足的副将全部出队，该车队也出队。
若某位副将需求大于KKK，就将其移到队尾，继续让同一车队尝试下一个副将；若尝试次数用尽仍无人匹配，则直接丢弃该车队。
重复上述过程，直到车队或副将队列为空，剩余副将数量即为未领到粮食的人数。

C++
#include <bits/stdc++.h>
using namespace std;

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

string line;
// 读取并校验两行输入
if(!getline(cin, line) || line.empty()){ cout << -1; return 0; }
istringstream sc(line);
vector<int> cars;
int x;
while(sc >> x){
if(x < 1 || x > 100){ cout << -1; return 0; }
cars.push_back(x);
}
if(!getline(cin, line) || line.empty()){ cout << -1; return 0; }
istringstream sg(line);
vector<int> req;
while(sg >> x){
if(x < 1 || x > 100){ cout << -1; return 0; }
req.push_back(x);
}

deque<int> carQ(cars.begin(), cars.end()), genQ(req.begin(), req.end());

// 模拟发放
while(!carQ.empty() && !genQ.empty()){
int K = carQ.front();
carQ.pop_front();

int attempts = genQ.size();
bool fed = false;
// 尝试最多“看”所有副将一次
while(attempts--){
if(genQ.front() <= K){
// 找到第一个需求 ≤ K 的副将，开始累计喂养
int sum = 0;
while(!genQ.empty() && sum + genQ.front() <= K){
sum += genQ.front();
genQ.pop_front();
}
fed = true;
break;
} else {
// 当前需求大于 K，移到队尾再试
int v = genQ.front(); genQ.pop_front();
genQ.push_back(v);
}
}
// 如果 attempts<0 且未 fed，则该车无人可喂，直接丢弃
}

// 剩余副将数即为未能领到粮食的数量
cout << genQ.size();
return 0;
}

Python
import sys
from collections import deque

def main():
data = sys.stdin.read().strip().splitlines()
if len(data) != 2:
print(-1); return

try:
cars = list(map(int, data[0].split()))
req  = list(map(int, data[1].split()))
if any(x<1 or x>100 for x in cars+req):
print(-1); return
except:
print(-1); return

carQ = deque(cars)
genQ = deque(req)

while carQ and genQ:
K = carQ.popleft()
attempts = len(genQ)
fed = False

# 每辆车尝试“看”所有副将一次
for _ in range(attempts):
need = genQ[0]
if need <= K:
total = 0
# 累计喂到最大 i，使 sum ≤ K
while genQ and total + genQ[0] <= K:
total += genQ.popleft()
fed = True
break
else:
genQ.rotate(-1)  # 当前副将移到队尾

# 若未 fed，则该车无人可喂，直接丢弃（不 re-enqueue）

# 输出剩余副将数
print(len(genQ))

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
String l1 = br.readLine(), l2 = br.readLine();
if(l1 == null || l2 == null){ System.out.println(-1); return; }

Queue<Integer> carQ = new LinkedList<>(), genQ = new LinkedList<>();
try {
for(String s : l1.trim().split("\\s+")) {
int v = Integer.parseInt(s);
if(v<1 || v>100){ System.out.println(-1); return; }
carQ.offer(v);
}
for(String s : l2.trim().split("\\s+")) {
int v = Integer.parseInt(s);
if(v<1 || v>100){ System.out.println(-1); return; }
genQ.offer(v);
}
} catch(Exception e){
System.out.println(-1);
return;
}

while(!carQ.isEmpty() && !genQ.isEmpty()){
int K = carQ.poll();
int attempts = genQ.size();
boolean fed = false;

for(int i=0; i<attempts; i++){
int need = genQ.peek();
if(need <= K){
int sum = 0;
// 累计喂养前 i 名副将，使 sum ≤ K
while(!genQ.isEmpty() && sum + genQ.peek() <= K){
sum += genQ.poll();
}
fed = true;
break;
} else {
// 当前副将需求过大，移到队尾
genQ.offer(genQ.poll());
}
}
// 若始终未 fed，则车队丢弃
}

// 副将队列剩余大小即为未领取数量
System.out.println(genQ.size());
}
}

---

### 第2题-积木塔（P2337）
- 链接：https://codefun2000.com/p/P2337

> 页面标题：#P2337. 第2题-积木塔

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述:
塔子哥在玩积木塔游戏，按照特定规则添加标有正整数的积木块。当他添加新的积木时，如果新积木的数字与塔顶积木的数字相同，他会取下这两块积木，将它们的数字相加后乘以二，然后放回一块新积木；如果塔顶的数字等于下面连续几块积木的和，他也会进行相同操作。若两个条件都不满足，他就将新积木简单放在塔顶。最终，请输出游戏结束后积木塔上从顶到底的数字序列。
思路
这题是一道模拟题，抽象一下题意，每次元素入栈时，判断一下：

如果栈顶元素 xxx 等于第二个元素，则删除最顶上的两个元素，并将 2∗x2 * x2∗x 入栈。

如果栈顶元素 xxx 等于前面若干元素之和，则删除前面若干的元素，并将 2∗x2 * x2∗x 入栈。

否则不进行操作

由于数据范围只有 1000，每次插入一个新的 xxx 时，可以暴力判断一下当前是否满足题目条件，并模拟即可，具体操作可看代码。
题解
这道题目是一个模拟题，要求我们根据特定规则处理一个整数序列。具体规则如下：

条件一：如果栈顶元素xxx等于当前添加的元素yyy，则删除栈顶的两个元素，并将2∗x2*x2∗x入栈。
条件二：如果栈顶元素xxx等于栈中若干元素的和，删除栈中的若干元素，并将2∗x2*x2∗x入栈。
默认情况：如果上述条件都不满足，则直接将元素yyy放入栈中。

在实现上，我们使用一个动态数组（vector）来模拟栈的操作。对于每个新的元素，我们需要判断是否满足上述条件，利用累加和和栈的结构来进行操作。由于数据量限制在 1000 以内，可以使用暴力的方法逐一检查。
AC代码
cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
vector<int> a; // 用于存储输入的数字
int val;

// 从输入中读取数字，直到没有输入
while (cin >> val) {
a.push_back(val);
}

vector<int> stack; // 用于模拟栈操作
for (int x : a) { // 遍历每个输入的数字
bool ok = true; // 标志变量，用于判断条件是否满足

// 当栈不为空且当前栈中元素的和大于等于 x 时，进行循环
while (ok && accumulate(stack.begin(), stack.end(), 0) >= x) {
int s = 0; // 用于累加栈中的元素
int cnt = 0; // 计数器，记录参与累加的元素个数

// 从栈顶向下遍历，检查当前元素和
for (int i = stack.size() - 1; i >= 0; --i) {
s += stack[i]; // 累加栈中元素
cnt++; // 增加计数

// 如果累加和等于 x
if (s == x) {
// 删除栈顶的 cnt 个元素，并将 2 * x 入栈
for (int j = 0; j < cnt; ++j) {
x += stack.back(); // 将栈顶元素加到 x 上
stack.pop_back(); // 移除栈顶元素
}
break; // 结束当前循环
}
// 如果累加和超过 x，则不满足条件
else if (s > x) {
ok = false; // 设置标志为 false，退出循环
break;
}
}
}
stack.push_back(x); // 将当前元素 x 放入栈中
}

// 从栈顶到栈底输出结果
for (int i = stack.size() - 1; i >= 0; --i) {
cout << stack[i] << " "; // 输出栈中的每个元素
}
cout << endl; // 输出换行符

return 0; // 程序结束
}

java
import java.util.*;

class Main {
public static void main(String args[]) {
// 创建一个 Scanner 对象用于读取输入
Scanner s = new Scanner(System.in);

// 读取一行输入，并将其拆分成字符串数组，然后转换为长整型数组
long[] arr = Arrays.stream(s.nextLine().split(" ")).mapToLong(Long::valueOf).toArray();

// 初始化一个栈，用于存储当前的积木块
long[] stack = new long[arr.length];

// 当前栈的有效元素数量
int cur = 1;

// 将第一个输入元素放入栈中
stack[0] = arr[0];

// 从第二个元素开始处理
for (int i = 1; i < arr.length; ) {
// 从栈顶开始向下遍历
int j = cur - 1;
long sum = 0; // 初始化当前和

// 检查栈中元素的和是否小于等于当前元素
while (j >= 0 && sum + stack[j] <= arr[i]) {
sum += stack[j]; // 累加栈中的元素
j--; // 向下移动到下一个元素
}

// 如果累加和等于当前元素
if (sum == arr[i]) {
// 将当前元素更新为两倍的累加和
arr[i] = sum << 1; // 左移一位相当于乘以 2
// cur = j + 2; // 不再使用的行
cur = j + 1; // 更新当前有效元素的数量
} else {
// 如果不满足条件，则将当前元素入栈
stack[cur++] = arr[i]; // 将当前元素放入栈中并更新 cur
i++; // 处理下一个输入元素
}
}

// 定义字符串数组，用于格式化输出
String[] str = {"%d ", "%d"};

// 从栈顶到栈底输出最终的结果
for (int i = cur - 1; i >= 0; --i) {
// 输出格式化字符串，最后一个元素输出后换行
System.out.printf(i != 0 ? str[0] : str[1], stack[i]);
}
}
}

python
# 读取输入并将其转换为整数列表
a = list(map(int, input().split()))

# 初始化一个空列表作为栈
st = []

# 遍历输入的每个数字
for x in a:
flg = True  # 标志变量，用于控制内部循环
# 当栈的和大于等于当前元素 x 时，继续循环
while flg and sum(st[:]) >= x:
s = 0  # 初始化累加和
cnt = 0  # 初始化计数器

# 反向遍历栈中的元素
for t in st[::-1]:
s += t  # 累加栈中的元素
cnt += 1  # 增加计数器

# 如果累加和等于当前元素 x
if s == x:
# 从栈中弹出 cnt 个元素并将其累加到 x 上
for i in range(cnt):
x += st.pop()
break  # 退出当前循环
# 如果累加和超过了当前元素 x
elif s > x:
flg = False  # 设置标志为 False，退出循环
break

# 将当前元素 x 添加到栈中
st.append(x)

# 输出结果，从栈顶到栈底
print(*st[::-1])

javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
const input = await readline();
const arr = input.split(' ').map(BigInt); // 使用BigInt处理大整数

const stack = new Array(arr.length).fill(0n);
let cur = 1;
stack[0] = arr[0];

for (let i = 1; i < arr.length;  ) {
let j = cur - 1;
let sum = 0n;

// 逆向遍历栈计算可合并区间
while (j >= 0 && sum + stack[j] <= arr[i]) {
sum += stack[j];
j--;
}

if (sum === arr[i]) {
arr[i] = sum << 1n; // 位运算实现乘2
cur = j + 1;        // 截断栈顶
} else {
stack[cur++] = arr[i];
i++;
}
}

// 构造输出结果
const output = [];
for (let i = cur - 1; i >= 0; i--) {
output.push(stack[i].toString());
}
console.log(output.join(' '));

rl.close();
})();

问题描述
小明在玩积木塔游戏。他有一系列的积木块，每块上标有一个正整数。他按照特定的规则堆积这些积木块：每次小明添加一块新的积木时，如果这块积木上的数字与塔顶的积木数字相同，他会取下两块积木，将上面的数字相加后，然后放回一块新的积木。此外，如果塔顶的积木数字等于下面连续几块积木数字之和，他同样会取下这些积木，进行相同的操作。如果这两个条件都不符合，他就会简单地将新的积木放在塔顶。现在，小明按照一定顺序添加了一系列的积木，请你计算游戏结束后积木塔各块上的数字。
输入格式
第一行输入为一个由空格分隔的正整数序列，表示小明按顺序添加到积木塔中的积木块上的数字。
输出格式
输出为一个由空格分隔的正整数序列，从左到右依次表示游戏结束后从塔顶到塔底的积木块上的数字。
样例输入
55 66 121 5 5

样例输出
10 242

评测数据与规模

每个正整数的范围为 111 到 231−12^{31}-1231−1。
正整数的个数范围为 111 到 100010001000。

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (3)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 73ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-相似度计算（P2334）
- 链接：https://codefun2000.com/p/P2334

> 页面标题：#P2334. 第2题-相似度计算

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述:
塔子哥想要对一批图片进行分类，依据它们之间的相似度矩阵进行处理。给定一个N∗NN*NN∗N 的相似度矩阵，矩阵中的元素表示任意两张图片的相似度，若相似度大于 0，则认为两张图片相似；通过间接相似的方式，形成的相似类会将所有间接相似的图片归为一类。如果某张图片与其他图片均无相似度，则其自成一类。最终，要求输出每个相似类的相似度之和，并按从大到小的顺序排列。
思路
题意需要将相似的图片归为一类，很容易想到是并查集的解法，并查集也有路径压缩的方法，所以可以将相似度的和都存在集合的根节点上。
将所有相似的图片归类到一个集合中，并对图片矩阵aaa进行遍历，如果ai,j!=0a_{i,j}!=0ai,j​!=0，那么就获取其所在集合的根节点fafafa，使ans[fa]+=a[i][j]ans[fa]+=a[i][j]ans[fa]+=a[i][j]。为了防止重复计算，令a[i][j]=a[j][i]=0a[i][j]=a[j][i]=0a[i][j]=a[j][i]=0。
最后对ansansans进行排序，再倒序输出即可。
题解
本题的核心在于将相似的图片归为一类，可以使用并查集（Union-Find）数据结构来实现。并查集能够有效地管理并合并集合，使得我们可以快速查找和合并相似的图片。通过路径压缩和按秩合并，查找和合并的效率得到了大幅提升。下面是具体的思路：

初始化并查集：每张图片自成一类，初始化时将每张图片的父节点指向自己。
构建相似度关系：遍历相似度矩阵，如果两张图片的相似度大于 0，则将它们合并到同一个集合中。
计算相似度之和：在合并过程中，我们将相似度的和累加到根节点的相似度和数组中。为了避免重复计算，合并后将对应的相似度值置为 0。
输出结果：最后，对相似度之和进行排序，并输出时按从大到小的顺序。

代码注释解析

数据结构定义：

a[1000][1000] 用于存储相似度矩阵。
fa[1000] 用于记录每个节点的父节点，构建并查集。
ans[1000] 用于存储每个相似类的相似度之和。

路径压缩的查找函数：

find(int x) 函数使用路径压缩来提高查找效率。

合并过程：

在读取相似度矩阵时，如果发现相似度不为 0，则合并对应的两张图片。

相似度和的计算：

遍历相似度矩阵，如果两个图片属于同一类，就将其相似度累加到对应的根节点。

结果输出：

对相似度和进行排序，并倒序输出，确保从大到小排列。

代码
C++
#include <bits/stdc++.h>
using namespace std;

int n;                     // 图片数量
int a[1000][1000];        // 相似度矩阵
int fa[1000];             // 并查集的父节点
int ans[1000];            // 每个相似类的相似度之和

// 查找函数，带路径压缩
int find(int x) {
return x == fa[x] ? x : fa[x] = find(fa[x]);
}

int main() {
std::ios::sync_with_stdio(false);
cin >> n;

// 初始化并查集
for (int i = 1; i <= n; ++i) {
fa[i] = i;         // 每个节点的父节点指向自己
}

// 读取相似度矩阵并构建并查集
for (int i = 1; i <= n; ++i) {
for (int j = 1; j <= n; ++j) {
cin >> a[i][j];
if (a[i][j] != 0) {
int fax = find(i), fay = find(j); // 找到各自的根节点
if (fax != fay) {
fa[fax] = fay;  // 合并两个集合
}
}
}
}

// 计算每个相似类的相似度之和
for (int i = 1; i <= n; ++i) {
for (int j = 1; j <= n; ++j) {
if (a[i][j] && find(i) == find(j)) { // 如果存在相似度并且属于同一类
ans[find(i)] += a[i][j]; // 将相似度累加到根节点的相似度和中
a[i][j] = 0;              // 为防止重复计算，将相似度置为0
a[j][i] = 0;              // 对称位置也置为0
}
}
}
// 把每个类的相似度记录在根节点上，其它节点设为-1防止多余输出
for(int i = 1; i <= n; i++){
if(find(i) != i)ans[i] = -1;
}
// 输出相似度之和，先排序
sort(ans + 1, ans + n + 1);
for (int i = n; i > 0; --i) { // 倒序输出
if(ans[i] == -1)break;
cout << ans[i] << " ";
}

return 0;
}

python
# 并查集类定义
class UnionFind:
def __init__(self, n):
self.fa = list(range(n + 1))  # 初始化父节点

def find(self, x):
if x != self.fa[x]:
self.fa[x] = self.find(self.fa[x])  # 路径压缩
return self.fa[x]

def main():
n = int(input().strip())  # 读取图片数量
a = [list(map(int, input().strip().split())) for _ in range(n)]  # 读取相似度矩阵
uf = UnionFind(n)  # 创建并查集实例
ans = [0] * (n + 1)  # 每个相似类的相似度之和

# 读取相似度矩阵并构建并查集
for i in range(1, n + 1):
for j in range(1, n + 1):
if a[i - 1][j - 1] != 0:  # 注意索引从0开始
fax = uf.find(i)  # 找到第i个图片的根节点
fay = uf.find(j)  # 找到第j个图片的根节点
if fax != fay:
uf.fa[fax] = fay  # 合并两个集合

# 计算每个相似类的相似度之和
for i in range(1, n + 1):
for j in range(1, n + 1):
if a[i - 1][j - 1] != 0 and uf.find(i) == uf.find(j):
ans[uf.find(i)] += a[i - 1][j - 1]  # 将相似度累加到根节点的相似度和中
a[i - 1][j - 1] = 0  # 为防止重复计算，将相似度置为0
a[j - 1][i - 1] = 0  # 对称位置也置为0
# 把每个类的相似度记录在根节点上，其它节点设为-1防止多余输出
for i in range(1,n+1):
if uf.find(i) != i:
ans[i] = -1
# 输出相似度之和，先排序
sorted_ans = sorted(ans[1:], reverse=True)  # 排序并去掉第0个元素
for score in sorted_ans:
if score == -1:
break
print(score, end=' ')  # 打印相似度和

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main {
static class UnionFind {
int[] fa;

public UnionFind(int n) {
fa = new int[n + 1]; // 初始化父节点数组
for (int i = 0; i <= n; i++) {
fa[i] = i;
}
}

public int find(int x) {
if (fa[x] != x) {
fa[x] = find(fa[x]); // 路径压缩
}
return fa[x];
}

public void union(int x, int y) {
int fax = find(x);
int fay = find(y);
if (fax != fay) {
fa[fax] = fay; // 合并集合
}
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = Integer.parseInt(scanner.nextLine()); // 读取图片数量
int[][] a = new int[n][n]; // 相似度矩阵
for (int i = 0; i < n; i++) {
String[] line = scanner.nextLine().split(" ");
for (int j = 0; j < n; j++) {
a[i][j] = Integer.parseInt(line[j]);
}
}

UnionFind uf = new UnionFind(n);
int[] ans = new int[n + 1]; // 每个相似类的相似度之和

// 读取相似度矩阵并构建并查集
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
if (a[i - 1][j - 1] != 0) { // 注意索引从 0 开始
uf.union(i, j);
}
}
}

// 计算每个相似类的相似度之和
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= n; j++) {
if (a[i - 1][j - 1] != 0 && uf.find(i) == uf.find(j)) {
ans[uf.find(i)] += a[i - 1][j - 1];
a[i - 1][j - 1] = 0; // 避免重复计算
a[j - 1][i - 1] = 0;
}
}
}
// 把每个类的相似度记录在根节点上，其它节点设为-1防止多余输出
for(int i = 1; i <= n;i ++){
if(uf.find(i) != i)ans[i] = -1;
}
// 排序并输出
List<Integer> sortedList = new ArrayList<>();
for (int i = 1; i <= n; i++) {
if(ans[i] == -1)continue;
sortedList.add(ans[i]);
}
sortedList.sort(Collections.reverseOrder()); // 按降序排序

for (int score : sortedList) {
System.out.print(score + " ");
}
scanner.close();
}
}

javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
class UnionFind {
constructor(n) {
this.fa = Array.from({ length: n + 1 }, (_, i) => i);
}

find(x) {
if (this.fa[x] !== x) {
this.fa[x] = this.find(this.fa[x]); // 路径压缩
}
return this.fa[x];
}

union(x, y) {
let fax = this.find(x);
let fay = this.find(y);
if (fax !== fay) {
this.fa[fax] = fay; // 合并集合
}
}
}

let n = parseInt(await readline()); // 读取图片数量
let a = [];

for (let i = 0; i < n; i++) {
a.push((await readline()).split(" ").map(Number));
}

let uf = new UnionFind(n);
let ans = Array(n + 1).fill(0); // 存储相似度之和

// 读取相似度矩阵并构建并查集
for (let i = 1; i <= n; i++) {
for (let j = 1; j <= n; j++) {
if (a[i - 1][j - 1] !== 0) {
uf.union(i, j);
}
}
}

// 计算每个相似类的相似度之和
for (let i = 1; i <= n; i++) {
for (let j = 1; j <= n; j++) {
if (a[i - 1][j - 1] !== 0 && uf.find(i) === uf.find(j)) {
ans[uf.find(i)] += a[i - 1][j - 1];
a[i - 1][j - 1] = 0; // 避免重复计算
a[j - 1][i - 1] = 0;
}
}
}
// 把每个类的相似度记录在根节点上，其它节点设为-1防止多余输出
for(int i = 1; i <= n;i ++){
if(uf.find(i) != i)ans[i] = -1;
}
// 过滤并排序相似度和
let sortedAns = ans.slice(1).filter(x => x >= 0).sort((a, b) => b - a);

console.log(sortedAns.join(" "));

rl.close();
})();

题目描述
小明想要处理一批图片，将相似的图片分类。他首先对图片的特征采样，得到图片之间的相似度，然后按照以下规则判断图片是否可以归为一类:
1.相似度>0表示两张图片相似;
2.如果A和B相似，B和C相似，但A和C不相似。那么认为A和C间接相似，可以把ABC归为一类，但不计算AC的相似度;
3.如果A和所有其他图片都不相似，则A自己归为一类，相似度为0。
给定一个大小为N×NN\times NN×N的矩阵MMM存储任意两张图片的相似度，M[i][j]即为第iii个图片和第jjj个图片的相似度，请按照"从大到小"的顺序返回每个相似类中所有图片的相似度之和。
输入描述

第一行一个数N(1≤N≤900)N(1\le N\le 900)N(1≤N≤900)，代表矩阵MMM中有NNN个图片。下面跟着NNN行，每行有NNN列数据，空格分隔(为了显示整齐，空格可能为多个)，代表NNN个图片之间的相似度。
其中0≤M[i][j]≤1000\le M[i][j]\le 1000≤M[i][j]≤100，输入保证M[i][j]=M[j][i]M[i][j]=M[j][i]M[i][j]=M[j][i]
输入的矩阵分隔符为1个或多个连续空格

输出描述

每个相似类的相似度之和。格式为:一行数字，分隔符为1个空格

样例1
输入
5
0 0 50 0 0
0 0 0 25 0
50 0 0 0 15
0 25 0 0 0
0 0 15 0 0

输出
65 25

说明
把1~5看成A,B,C,D,E
矩阵显示，A和C相似度为50，C和E的相似度为15:B和D相似度为25。划分出2个相似类，分别为
1.{A,C,E}，相似度之和为65
2.{B,D}，相似度之和25
排序输出相似度之和，结果为:65 25

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (3)

Statistics

Related

In following contests: 塔子周赛（一）华为暑期实习-2024年4月10号场

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 80ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-云上服务（P2331）
- 链接：https://codefun2000.com/p/P2331

> 页面标题：#P2331. 第2题-云上服务

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述:
在这道题目中，给定了一组以树形结构表示的云服务，每个节点记录着不同级别的问题及其数量。通过计算每个云服务的DI值（遗留问题缺陷密度），公式为 DI值=5∗严重问题数+2∗一般问题数 \text{DI值} = 5 * \text{严重问题数} + 2 * \text{一般问题数}DI值=5∗严重问题数+2∗一般问题数，判断其是否大于阈值，从而评估该云服务是否为风险服务。输入包括一个阈值和若干节点的信息，要求输出被评定为风险云服务的数量。
思路
给定一个森林（多棵树），要求统计所有节点的计算值的和超过阈值的树的数量。
我们从树的根节点出发，遍历树的每一个子节点，在回溯时将其严重问题和一般问题的数量记录到父节点上。这样在遍历完一棵树后，根节点就包含了整棵树严重问题和一般问题的数量。按照公式计算是否超过阈值即可。
判断某个节点为根节点，可以在读入数据时记录每个点的入度。如果一个点没有入度，那么其是根节点。
另一个方案是，将所有根节点都挂载“*”节点下作为子节点，后续对第一层的每个节点作为根遍历即可。
题解扩展
在这道题中，我们需要处理一个森林（由多棵树组成），并统计所有节点的计算值超过给定阈值的树的数量。计算值是通过对每棵树的根节点及其所有子节点的严重问题和一般问题数量进行累加计算得出的。
具体步骤如下：

树的表示：我们使用邻接表表示树的结构。每个节点的子节点存储在一个映射中。
节点属性：每个节点有两个属性：严重问题数和一般问题数。我们使用两个映射分别存储这些信息。
识别根节点：通过记录每个节点的入度，可以识别出根节点。入度为0的节点即为根节点。
深度优先搜索（DFS）：从根节点开始遍历树，递归计算每个节点的严重问题和一般问题数量，并在回溯过程中累加到父节点上。
计算和判断：在遍历过程中，如果根节点的计算值超过阈值，则统计该树为风险树。

代码
C++
#include<bits/stdc++.h>

using namespace std;

// 使用映射来存储每个节点的子节点
map<string, vector<string>> edg;
// 用于存储每个节点的严重问题数
map<string, int> v1;
// 用于存储每个节点的一般问题数
map<string, int> v2;
// 统计超过阈值的树的数量
int res = 0;
// n为节点数量，m为阈值
int n, m;

// 深度优先搜索函数
void dfs(string u) {
// 遍历当前节点u的所有子节点
for (string v : edg[u]) {
dfs(v); // 递归遍历子节点
v1[u] += v1[v]; // 累加子节点的严重问题数到父节点u
v2[u] += v2[v]; // 累加子节点的一般问题数到父节点u
// 如果u为根节点且其计算值超过阈值，则统计该树
if (u == "*" && v1[v] * 5 + v2[v] * 2 > m) {
res++;
}
}
}

int main() {
cin >> m >> n; // 输入阈值和节点数量
for (int i = 0; i < n; i++) {
string a, b, c; // a为服务节点，b为父节点，c为问题级别
int d; // d为问题数量
cin >> a >> b >> c >> d; // 输入节点信息
// 根据问题级别更新相应的数量
if (c == "0") {
v1[a] += d; // 严重问题
} else {
v2[a] += d; // 一般问题
}
// 构建树的结构
// 确保每个父节点只记录子节点一次
if (find(edg[b].begin(), edg[b].end(), a) == edg[b].end()) {
edg[b].push_back(a); // 将节点a添加为b的子节点
}
}

// 以“*”节点为根开始深度优先搜索
dfs("*");
cout << res << endl; // 输出风险树的数量

return 0;
}

python
from collections import defaultdict

# 使用defaultdict来存储每个节点的子节点
edg = defaultdict(list)
# 用于存储每个节点的严重问题数
v1 = defaultdict(int)
# 用于存储每个节点的一般问题数
v2 = defaultdict(int)
# 统计超过阈值的树的数量
res = 0

# 深度优先搜索函数
def dfs(u):
global res
# 遍历当前节点u的所有子节点
for v in edg[u]:
dfs(v)  # 递归遍历子节点
v1[u] += v1[v]  # 累加子节点的严重问题数到父节点u
v2[u] += v2[v]  # 累加子节点的一般问题数到父节点u
# 如果u为根节点且其计算值超过阈值，则统计该树
if u == "*" and (v1[v] * 5 + v2[v] * 2) > m:
res += 1

# 主程序
if __name__ == "__main__":
m, n = map(int, input().split())  # 输入阈值和节点数量
for _ in range(n):
a, b, c, d = input().split()  # 输入节点信息
d = int(d)  # 将问题数量转换为整数
# 根据问题级别更新相应的数量
if c == "0":
v1[a] += d  # 严重问题
else:
v2[a] += d  # 一般问题
# 构建树的结构
# 确保每个父节点只记录子节点一次
if a not in edg[b]:
edg[b].append(a)  # 将节点a添加为b的子节点

# 以“*”节点为根开始深度优先搜索
dfs("*")
print(res)  # 输出风险树的数量

java
import java.util.*;

public class Main {

// 使用Map来存储每个节点的子节点
private static Map<String, List<String>> edg = new HashMap<>();
// 用于存储每个节点的严重问题数
private static Map<String, Integer> v1 = new HashMap<>();
// 用于存储每个节点的一般问题数
private static Map<String, Integer> v2 = new HashMap<>();
// 统计超过阈值的树的数量
private static int res = 0;
// 阈值
private static int m;

// 深度优先搜索函数
private static void dfs(String u) {
// 遍历当前节点u的所有子节点
for (String v : edg.getOrDefault(u, new ArrayList<>())) {
dfs(v);  // 递归遍历子节点
v1.put(u, v1.getOrDefault(u, 0) + v1.getOrDefault(v, 0)); // 累加子节点的严重问题数
v2.put(u, v2.getOrDefault(u, 0) + v2.getOrDefault(v, 0)); // 累加子节点的一般问题数
// 如果u为根节点且其计算值超过阈值，则统计该树
if (u.equals("*") && (v1.getOrDefault(v, 0) * 5 + v2.getOrDefault(v, 0) * 2) > m) {
res++;
}
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
m = scanner.nextInt();  // 输入阈值
int n = scanner.nextInt();  // 输入节点数量
scanner.nextLine();  // 读取行结束符

for (int i = 0; i < n; i++) {
String line = scanner.nextLine();
String[] parts = line.split(" ");
String a = parts[0];  // 节点名
String b = parts[1];  // 父节点
int c = Integer.parseInt(parts[2]);  // 问题级别
int d = Integer.parseInt(parts[3]);  // 问题数量

// 根据问题级别更新相应的数量
if (c == 0) {
v1.put(a, v1.getOrDefault(a, 0) + d);  // 严重问题
} else {
v2.put(a, v2.getOrDefault(a, 0) + d);  // 一般问题
}

// 构建树的结构
edg.putIfAbsent(b, new ArrayList<>());
if (!edg.get(b).contains(a)) {
edg.get(b).add(a);  // 将节点a添加为b的子节点
}
}

// 以“*”节点为根开始深度优先搜索
dfs("*");
System.out.println(res);  // 输出风险树的数量
}
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
let edg = new Map(); // 存储树结构（父节点 -> 子节点列表）
let v1 = new Map();  // 存储每个节点的严重问题数
let v2 = new Map();  // 存储每个节点的一般问题数
let res = 0; // 统计超过阈值的树数量

let [m, n] = (await readline()).split(" ").map(Number);

// 读取所有节点信息
for (let i = 0; i < n; i++) {
let [a, b, c, d] = (await readline()).split(" ");
c = parseInt(c); // 问题级别
d = parseInt(d); // 问题数量

// 根据问题级别更新相应的数量
if (c === 0) {
v1.set(a, (v1.get(a) || 0) + d); // 严重问题
} else {
v2.set(a, (v2.get(a) || 0) + d); // 一般问题
}

// 构建树结构
if (!edg.has(b)) edg.set(b, []);
if (!edg.get(b).includes(a)) {
edg.get(b).push(a); // 添加节点 a
}
}

// 深度优先搜索计算问题数
function dfs(u) {
if (!edg.has(u)) return; // 若无子节点，直接返回

for (let v of edg.get(u)) {
dfs(v);
v1.set(u, (v1.get(u) || 0) + (v1.get(v) || 0)); // 累加子节点的严重问题数
v2.set(u, (v2.get(u) || 0) + (v2.get(v) || 0)); // 累加子节点的一般问题数

// 判断是否超出阈值
let totalRisk = ((v1.get(v) || 0) * 5) + ((v2.get(v) || 0) * 2);
if (u === "*" && totalRisk > m) {
res++;
}
}
}

// 以 `*` 作为根节点执行 DFS
dfs("*");

console.log(res); // 输出风险树的数量
rl.close();
})();

题目描述
\qquad要是你认为小明只做网站，那就大错特错了。其实小明还做点云服务，最近，小明忙着维护云服务器，没空跟你开黑。为了上分，你打算出手。
\qquad小明将云服务看做一棵树，每个云服务在发布前尚未解决的问题称为云服务的遗留问题（云服务的遗留问题包含以该云服务为根节点的树上所有节点的问题），DI值（遗留问题缺陷密度）可以作为评估云服务发布的指标，当云服务DI值小于等于阈值时才准许云服务发布，否则视为风险云服务，需要问题整改完成后重新进行发布评估。现有一批云服务树，已给出云服务树各节点的问题数量，请通过计算输出风险云服务的个数。
\qquad计算公式：DI值=5×严重问题数＋2×一般问题数，其中每个节点的不同级别问题数量需要将该节点及该节点为根节点的所有子节点的相应级别问题数量求和。
输入描述
\qquad第一行输入MMM和NNN(M≤100000M \le 100000M≤100000，N≤1000N \le 1000N≤1000)，使用空格分隔，M表示代表云服务阈值，N表示接下来有N行问题统计数据；
\qquad接下来输入一个N∗4N∗4N∗4的矩阵表，行内使用空格分隔，第一列AiA_iAi​为服务节点，第二列BiB_iBi​为AiA_iAi​的父节点，如果AiA_iAi​为云服务则无父节点，此时Bi用∗号表示(AiA_iAi​和BiB_iBi​取值为字符串，1≤1 \le1≤字符串长度≤5≤5≤5，均由小写英文字母或∗号组成)，第三列CiC_iCi​为问题级别（CiC_iCi​取值为{0,1}，0表示严重问题，1表示一般问题），第四列DiD_iDi​为该节点该级别的问题数量(Di≤1000)。
\qquad说明：输入保证只出现树的关系，不会出现连通图的情况。
输出描述
\qquad输出一个整数，表示风险云服务个数。
样例一
输入
40 12
a * 0 2
a * 1 2
b a 0 3
b a 1 5
c a 1 3
d a 0 1
d a 1 3
e b 0 2
f * 0 8
f * 1 10
g f 1 2
h * 0 4

输出
2

解释
\qquad（a * 0 2）表示节点a有2个严重问题，*表示无父节点，即a为云服务。（b a 1 5）表示节点b有5个一般问题，b的父节点是a。可以看出，该样例有3个云服务a、f、h。云服务a的子节点有b、c、d、e，严重问题个数为2+3+0+1+2=82+3+0+1+2=8，一般问题个数为2+5+3+3+0=132+5+3+3+0=13，DI值=8∗5+13∗2=66>阈值40，故云服务a是风险云服务；云服务f严重问题个数为8+0=88+0=8，一般问题个数为10+2=1210+2=12，DI值=8∗5+12∗2=64>阈值40，故云服务f也是风险云服务；云服务h严重问题个数为44，一般问题个数为00，DI值=4∗5+0∗2=20<=阈值40，故云服务h不是风险云服务；因此该样例有2个风险云服务。
样例二
输入
50 10
b a 1 5
a * 0 2
b a 0 3
c a 1 3
d a 0 1
a * 1 2
d a 1 3
e b 0 2
f b 1 1
g c 1 2

输出
1

Limitation
1s, 1024KiB for each test case.

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (3)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 76ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-足球队（P2328）
- 链接：https://codefun2000.com/p/P2328

> 页面标题：#P2328. 第2题-足球队

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
塔子哥的足球队有nnn个队员，参加了mmm次点球射门，每次射中用1表示，射失用0表示。为了评估队员的射门能力，塔子哥制定了四个排序标准：首先比较进球总数，其次比较最多一次连续进球的个数，再者比较第一次射失的顺序，最后若以上都相同，则按队员编号从小到大排序。输入包括两个整数nnn和mmm，以及每个队员的射门结果，输出队员编号按能力强弱排序。
思路
自定义排序实现。
本质就是一个自定义的实现。

第一关键字是每个字符串中 1 的数量，从大到小

第二关键字是每个字符串中最长的连续 1 的数量，从大到小

第三关键字：

此时两个比较的串 A 和 B 中 0 的索引数量必然相同，假设数量为 k
依次比较两个串中的第一个为 0 的索引，第二个为 0 的索引，... ，第 k 个为 0 的索引
如果对于串 A 和串 B ，前 i 个索引均一一对应相同，第 i+1 个索引满足 indexA[i] != indexB[i]

如果 indexA[i] > indexB[i] ，则 A 串为 0 的这个索引更靠后，则 A 串排序后更靠前
如果 indexA[i] < indexB[i] ，则 B 串为 0 的这个索引更靠后，则 B 串排序后更靠前
如果 indexA[i] = indexB[i] ，则继续比较之后的索引，如果 A 和 B 所有为 0 的索引均相同，则比较 A 和 B 的编号，即第四关键字

第四关键字是每个字符串的编号，从小到大

需要预处理出前两个关键字，第三关键字的比较需要至多 O(m)O(m)O(m) 次，最终都相同则按编号从小到大即可。
时间复杂度：O(nmlog⁡n)O(nm\log n)O(nmlogn)
具体步骤
本题的核心是根据给定的点球射门结果，对队员的射门能力进行自定义排序。我们需要定义几个关键字来实现这一排序，具体步骤如下：

定义数据结构：
我们定义一个结构体 StringInfo 来存储每个队员的射门信息，主要包含以下内容：

index: 队员的原始编号
one_count: 队员进球的总数（字符串中1的数量）
max_con: 队员最多连续进球的次数（最长连续1的长度）
zeros: 队员每次射失的索引位置（字符串中0的位置列表）

输入读取：
首先，读取队员的数量 n 和训练次数 m，接着逐个读取每个队员的射门结果字符串，并计算各项指标。

计算指标：
对于每个队员的射门结果字符串：

统计其中 1 的数量，得到 one_count。
遍历字符串以计算 max_con，即最长的连续 1 的长度。
同时记录每个 0 的位置，以便后续的比较。

自定义排序：
使用 C++ 的 sort 函数对 StringInfo 结构体的数组进行排序，排序的优先级依次为：

按照 one_count 从大到小。
若 one_count 相同，则按照 max_con 从大到小。
若 max_con 仍然相同，比较 zeros 列表中的索引，依次判断哪个队员在早期射失。
若 zeros 也相同，则根据队员的原始编号升序排序。

输出结果：
最后，将排序后的队员编号按顺序输出。

代码
Java
import java.util.*;

class StringInfo implements Comparable<StringInfo> {
int index;          // 字符串的原始索引
int oneCount;       // '1'的数量
int maxCon;         // 最大连续'1'的长度
List<Integer> zeros; // '0'的位置列表

// 构造函数
public StringInfo() {
zeros = new ArrayList<>();
}

// 自定义排序规则
@Override
public int compareTo(StringInfo other) {
if (this.oneCount != other.oneCount)
return Integer.compare(other.oneCount, this.oneCount);  // 按照'1'的数量降序排序
if (this.maxCon != other.maxCon)
return Integer.compare(other.maxCon, this.maxCon);  // 按照连续'1'的最大长度降序排序
for (int i = 0; i < Math.min(this.zeros.size(), other.zeros.size()); i++) {
if (!this.zeros.get(i).equals(other.zeros.get(i))) {
return Integer.compare(other.zeros.get(i), this.zeros.get(i));  // 按照'0'的位置列表进行排序
}
}
return Integer.compare(this.index, other.index);  // 最后按照原始索引升序排序
}
}

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();  // 读取n的值
int m = scanner.nextInt();  // 读取m的值

List<StringInfo> infos = new ArrayList<>(n);  // 存储每个字符串的信息

for (int i = 0; i < n; ++i) {
String s = scanner.next();  // 读取每个字符串

StringInfo info = new StringInfo();
info.index = i;  // 记录字符串的原始索引
info.oneCount = 0;
info.maxCon = 0;

// 计算'1'的数量和'0'的位置
for (int j = 0; j < m; ++j) {
if (s.charAt(j) == '1') {
info.oneCount++;
} else {
info.zeros.add(j);
}
}

// 计算连续'1'的最大长度
int j = 0;
while (j < m) {
if (s.charAt(j) == '0') {
j++;
continue;  // 跳过'0'
}
int k = j + 1;
while (k < m && s.charAt(k) == '1') {
k++;
}
info.maxCon = Math.max(info.maxCon, k - j);  // 更新最大长度
j = k;
}

infos.add(info);  // 将计算结果保存到数组中
}

// 对所有字符串信息进行排序
Collections.sort(infos);

// 输出排序后的结果
for (StringInfo info : infos) {
System.out.print((info.index + 1) + " ");
}
System.out.println();
}
}

C++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// 定义一个结构体来封装每个字符串的相关信息
struct StringInfo {
int index;          // 字符串的原始索引
int one_count;      // '1'的数量
int max_con;        // 最大连续'1'的长度
vector<int> zeros;  // '0'的位置列表

// 自定义排序规则
bool operator<(const StringInfo& other) const {
if (one_count != other.one_count)
return one_count > other.one_count;  // 按照'1'的数量降序排序
if (max_con != other.max_con)
return max_con > other.max_con;  // 按照连续'1'的最大长度降序排序
if (zeros != other.zeros) {
for(int i=0;i<zeros.size();i++){
if(zeros[i] < other.zeros[i]){
return false;
}else if(zeros[i] > other.zeros[i]){
return true;
}
}
}
return index < other.index;  // 最后按照原始索引升序排序
}
};

int main() {
int n, m;
cin >> n >> m;  // 读取n和m的值

vector<StringInfo> infos(n);  // 存储每个字符串的信息

for (int i = 0; i < n; ++i) {
string s;
cin >> s;  // 读取每个字符串

StringInfo info;
info.index = i;  // 记录字符串的原始索引
info.one_count = 0;
info.max_con = 0;

// 计算'1'的数量和'0'的位置
for (int j = 0; j < m; ++j) {
if (s[j] == '1') {
info.one_count++;
} else {
info.zeros.push_back(j);
}
}

// 计算连续'1'的最大长度
int j = 0;
while (j < m) {
if (s[j] == '0') {
j++;
continue;  // 跳过'0'
}
int k = j + 1;
while (k < m && s[k] == '1') {
k++;
}
info.max_con = max(info.max_con, k - j);  // 更新最大长度
j = k;
}

infos[i] = info;  // 将计算结果保存到数组中
}

// 对所有字符串信息进行排序
sort(infos.begin(), infos.end());

// 输出排序后的结果
for (const auto& info : infos) {
cout << info.index + 1 << " ";
}
cout << endl;

return 0;
}

Python
n, m = map(int, input().split())
lst = input().split()

one = [0] * n
con = [0] * n
zero = [[] for _ in range(n)]

for i in range(n):
s = lst[i]
for j in range(m):
if s[j] == '1':
one[i] += 1
else:
zero[i].append(j)

j = 0
while j < m:
if s[j] == '0':
j += 1
continue
k = j + 1
while k < m and s[k] == '1':
k += 1
con[i] = max(con[i], k - j)
j = k

a = list(range(n))
a.sort(key=lambda x: (-one[x], -con[x], [-z for z in zero[x]], x))

print(*[x + 1 for x in a])

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
let [n, m] = (await readline()).split(" ").map(Number); // 读取 n 和 m
let lst = (await readline()).split(" "); // 读取字符串列表

let infos = []; // 存储每个字符串的信息

for (let i = 0; i < n; i++) {
let s = lst[i];

let oneCount = 0;
let maxCon = 0;
let zeros = []; // 存储 '0' 的索引

// 计算 '1' 的数量和 '0' 的索引
for (let j = 0; j < m; j++) {
if (s[j] === '1') {
oneCount++;
} else {
zeros.push(j);
}
}

// 计算最长连续 '1' 的长度
let j = 0;
while (j < m) {
if (s[j] === '0') {
j++;
continue;
}
let k = j + 1;
while (k < m && s[k] === '1') {
k++;
}
maxCon = Math.max(maxCon, k - j);
j = k;
}

infos.push({ index: i, oneCount, maxCon, zeros });
}

// 排序
infos.sort((a, b) => {
if (a.oneCount !== b.oneCount) return b.oneCount - a.oneCount; // '1' 的数量降序
if (a.maxCon !== b.maxCon) return b.maxCon - a.maxCon; // 最长连续 '1' 的降序
if (a.zeros.length !== b.zeros.length) return b.zeros.length - a.zeros.length; // '0' 数量多的排前
for (let i = 0; i < a.zeros.length; i++) {
if (a.zeros[i] !== b.zeros[i]) return b.zeros[i] - a.zeros[i]; // '0' 位置降序
}
return a.index - b.index; // 原始索引升序
});

console.log(infos.map(info => info.index + 1).join(" "));

rl.close();
})();

题目描述
\qquad话说小明带ACM队已经征战沙场多年，又又又又是时候拓展业务面了，你猜怎么着，当上足球领队了，现在正在进行紧张的备赛，冲击篮球杯金牌。
\qquad小明的足球队一共有nnn个队员，小明安排他们参与mmm次点球射门，每次射中用111表示，射失（没射中）用000表示，小明为他的球员能力强弱拟定了如下标准：
\qquad（1）进球总数更多的队员射门能力更强；
\qquad（2）若进球总数一样多，则比较最多一次连续进的个数，更多的队员能力更强；
\qquad（3）若最多一次连续进球个数一样多，则比较第一次射失的先后顺序，其中后射失的队员更强，若第一次射失顺序相同，则按继续比较第二次射失的顺序，后丢球的队员能力更强，依次类推；
\qquad（4）若前3个规则排序后还能力相等，则队员编号更小的能力更强。
输入描述
\qquad第一行输入两个整数nnn和mmm，分别表示足球队中队员的数量，以及射门训练的次数。（队员编号从1开始，依次递增）2n−12^n-12n−1个整数，表示整棵满二叉搜索树。其中1≤n≤101 \le n \le 101≤n≤10，整数之间用空格分割。
\qquad第二行，第111~nnn个队员从第111到mmm次训练的进球情况，每个队员进球情况为连续的111和000的组合，不同队员的情况用空格分隔
\qquad规定：所有nnn和mmm均为整数1≤n,m≤10001 \le n, m \le 10001≤n,m≤1000。
输出描述
\qquad所有球员射门能力从强到弱的队员编号，用空格分隔每个编号
样例一
输入
4 5
11100 00111 10111 01111

输出
4 3 1 2

解释
4个队员，射门训练5次，队员3和4进球数均为4个，比队员1H和2的3个更多，队员3连续进球故最多一次为3个，而队员4最大为4。因此队员4射门能力强于队员3，另外队员2比队员1先丢球，因此队员1射门能力强于队员2，顺序为4 3 1 2。
样例二
输入
2 10
1011100111 1011101101

输出
2 1

解释
2个队员，射门训练10次，两个队员的进球总数均为7个，连续进球最多的均为3个，且第前两次丢球顺序均为第2次和第6次训练射门，而队员2第三次丢球为第9次训练，队员1为第7次训练，因此队员2的射门能力强于队员1，顺序为2 1
Limitation
1s, 1024KiB for each test case.

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (3)

Statistics

Related

In following contests: 塔子周赛（二）华为暑期实习-2024年4月24号场

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 73ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-计网实验（P2325）
- 链接：https://codefun2000.com/p/P2325

> 页面标题：#P2325. 第2题-计网实验

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

思路
本题的原题是力扣460题。
本题的目标是实现一个具有LFU（最近不常使用）策略的缓存系统。为此，我们设计了一个名为Node的数据结构，以及结合哈希表和红黑树（通过std::set）的复合数据结构来支持缓存操作。
数据结构定义

Node 结构：每个Node包含以下字段：

cnt：表示节点被访问的次数。
time：表示节点最近一次被访问的时间。
key：节点的键，用于标识缓存项。
value：节点的值，即缓存项的数据内容。

这个结构既用于哈希表中的值，也用于红黑树中的元素。

哈希表：使用std::unordered_map存储键和指向节点的指针，以实现快速查找。

平衡二叉树：使用std::set来维护一个按(cnt, time)排序的节点集合，确保可以快速访问和删除最少使用的缓存项。

核心操作

读取（Read）操作：

检查键是否存在于哈希表中。
如果存在，则更新节点的cnt和time，重新插入到红黑树中以保持排序。
返回节点的值。

写入（Write）操作：

如果键存在，更新其值及访问的元数据（cnt和time），并更新红黑树。
如果键不存在，创建一个新的节点，加入哈希表和红黑树。
如果缓存已满（即达到预设的最大容量），则先从红黑树中移除最少使用的缓存项，然后移除对应的哈希表条目。

查询（Query）操作：

直接通过哈希表检查键是否存在，并返回相应的值或-1（不存在的标志）。

在这个实现中，我们通过组合哈希表和红黑树来维护LRU缓存，这不仅确保了操作的效率，也简化了最少使用元素的管理。这种策略适用于需要频繁读写且对性能要求较高的场景。
代码
Python
import collections
import time

# 定义一个名为 Node 的类，类似于C++中的结构体
class Node:
def __init__(self, cnt, tim, key, value):
self.cnt = cnt  # 计数器，用于记录某个键的访问次数
self.tim = tim  # 时间戳，用于记录某个键最后一次被访问的时间
self.key = key  # 键
self.value = value  # 键对应的值

# 定义小于操作符，用于比较两个 Node 对象
def __lt__(self, other):
# 如果计数器相同，按时间戳排序；否则按计数器排序
if self.cnt == other.cnt:
return self.tim < other.tim
return self.cnt < other.cnt

# 定义全局变量
n = 0  # 缓存的容量
tim = 0  # 全局时间戳
mapp = {}  # 存储键和值的映射
S = set()  # 用于存储所有的 Node 对象

# 获取某个键对应的值
def get(key):
global tim
if n == 0 or key not in mapp:  # 如果缓存容量为0或键不在映射中，返回-1
return -1
cache = mapp[key]  # 获取对应的缓存节点
S.remove(cache)  # 从集合中删除旧节点
cache.cnt += 1  # 增加访问计数器
tim += 1  # 更新全局时间戳
cache.tim = tim  # 更新节点的时间戳
S.add(cache)  # 将更新后的节点重新插入集合
mapp[key] = cache  # 更新映射中的节点
return cache.value  # 返回节点的值

# 插入或更新某个键值对
def put(key, value):
global tim
if n == 0:  # 如果缓存容量为0，直接返回
return
if key not in mapp:  # 如果键不在映射中
if len(mapp) == n:  # 如果映射中的元素数量等于缓存容量
oldest = min(S)  # 获取集合中最小的节点（即要被替换的节点）
S.remove(oldest)  # 从集合中删除该节点
del mapp[oldest.key]  # 从映射中删除该节点
tim += 1  # 更新全局时间戳
cache = Node(1, tim, key, value)  # 创建一个新的节点
mapp[key] = cache  # 将节点插入映射
S.add(cache)  # 将节点插入集合
else:  # 如果键已经在映射中
cache = mapp[key]  # 获取对应的缓存节点
S.remove(cache)  # 从集合中删除旧节点
cache.cnt += 1  # 增加访问计数器
tim += 1  # 更新全局时间戳
cache.tim = tim  # 更新节点的时间戳
cache.value = value  # 更新节点的值
S.add(cache)  # 将更新后的节点重新插入集合
mapp[key] = cache  # 更新映射中的节点

# 主函数
if __name__ == "__main__":
s = input()  # 读取操作类型
n = int(input())  # 读取缓存容量
while True:
try:
s = input()  # 读取操作类型
if s[0] == 'w':  # 如果操作是写入
m = int(input())  # 读取写入操作的数量
for _ in range(m):  # 逐个读取并写入键值对
a, b = map(int, input().split())
put(a, b)
elif s[0] == 'r':  # 如果操作是读取
x = int(input())  # 读取要查询的键
get(x)
else:  # 如果操作是查询当前缓存的值
x = int(input())  # 读取要查询的键
if x in mapp:  # 如果键在映射中
print(mapp[x].value)  # 打印对应的值
else:
print(-1)  # 如果键不在映射中，打印-1
except EOFError:
break  # 读取结束后，退出循环

C++
#include <bits/stdc++.h>

using namespace std;

struct Node {
int cnt, tim, key, value;
Node() {}
Node(int a, int b, int c, int d):cnt(a), tim(b), key(c), value(d){}
bool operator < (const Node& nod) const {
return cnt == nod.cnt ? tim < nod.tim : cnt < nod.cnt;
}
};
int n, tim;
unordered_map<int, Node> mapp;
set<Node> S;
int get(int key) {
if (n == 0 || mapp.find(key) == mapp.end()) {
return -1;
}
Node cache = mapp[key];
S.erase(cache);
cache.cnt += 1;
cache.tim = ++tim;
S.insert(cache);
mapp[key] = cache;
return cache.value;
}

void put(int key, int value) {
if (n == 0) return;
auto it = mapp.find(key);
if (it == mapp.end()) {
if (mapp.size() == n) {
mapp.erase(S.begin()->key);
S.erase(S.begin());
}
Node cache = Node(1, ++tim, key, value);
mapp[key] = cache;
S.insert(cache);
} else {
Node cache = it->second;
S.erase(cache);
cache.cnt += 1;
cache.tim = ++tim;
cache.value = value;
S.insert(cache);
it->second = cache;
}
}

int main() {
string s;cin >> s;
cin >> n;
int x;
while (cin >> s) {
if (s[0] == 'w') {
int m;
cin >> m;
while (m --) {
int a, b;
cin >> a >> b;
put(a, b);
}
} else if(s[0] == 'r') {
cin >> x;
get(x);
} else while (cin >> x) {
if (mapp.count(x)) cout << mapp[x].value << endl;
else cout << -1 << endl;
}
}
}

Java
import java.util.*;

class Node implements Comparable<Node> {
int cnt, tim, key, value;

Node(int cnt, int tim, int key, int value) {
this.cnt = cnt;
this.tim = tim;
this.key = key;
this.value = value;
}

@Override
public int compareTo(Node nod) {
return this.cnt == nod.cnt ? this.tim - nod.tim : this.cnt - nod.cnt;
}
}

public class Main {
static int n, tim;
static Map<Integer, Node> mapp = new HashMap<>();
static TreeSet<Node> S = new TreeSet<>();

// 获取缓存值
static int get(int key) {
if (n == 0 || !mapp.containsKey(key)) {
return -1;
}
Node cache = mapp.get(key);
S.remove(cache);
cache.cnt += 1;
cache.tim = ++tim;
S.add(cache);
mapp.put(key, cache);
return cache.value;
}

// 插入缓存值
static void put(int key, int value) {
if (n == 0) return;
if (!mapp.containsKey(key)) {
if (mapp.size() == n) {
Node firstNode = S.first();
mapp.remove(firstNode.key);
S.remove(firstNode);
}
Node cache = new Node(1, ++tim, key, value);
mapp.put(key, cache);
S.add(cache);
} else {
Node cache = mapp.get(key);
S.remove(cache);
cache.cnt += 1;
cache.tim = ++tim;
cache.value = value;
S.add(cache);
mapp.put(key, cache);
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
String s = scanner.next();
n = scanner.nextInt();

while (scanner.hasNext()) {
s = scanner.next();
if (s.charAt(0) == 'w') {
int m = scanner.nextInt();
for (int i = 0; i < m; i++) {
int a = scanner.nextInt();
int b = scanner.nextInt();
put(a, b);
}
} else if (s.charAt(0) == 'r') {
int x = scanner.nextInt();
get(x);
} else {
while (scanner.hasNextInt()) {
int x = scanner.nextInt();
System.out.println(mapp.containsKey(x) ? mapp.get(x).value : -1);
}
}
}
scanner.close();
}
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

// LRU 缓存类
class LRUCache {
constructor(capacity) {
this.n = capacity;
this.tim = 0;
this.mapp = new Map();
this.set = new Set();
}

// 获取缓存值
get(key) {
if (this.n === 0 || !this.mapp.has(key)) {
return -1;
}
let cache = this.mapp.get(key);
this.set.delete(cache);
cache.cnt += 1;
cache.tim = ++this.tim;
this.set.add(cache);
return cache.value;
}

// 插入缓存值
put(key, value) {
if (this.n === 0) return;
if (!this.mapp.has(key)) {
if (this.mapp.size === this.n) {
let firstNode = [...this.set].sort((a, b) => a.cnt === b.cnt ? a.tim - b.tim : a.cnt - b.cnt)[0];
this.mapp.delete(firstNode.key);
this.set.delete(firstNode);
}
let cache = { cnt: 1, tim: ++this.tim, key, value };
this.mapp.set(key, cache);
this.set.add(cache);
} else {
let cache = this.mapp.get(key);
this.set.delete(cache);
cache.cnt += 1;
cache.tim = ++this.tim;
cache.value = value;
this.set.add(cache);
this.mapp.set(key, cache);
}
}
}

// 处理输入
(async function () {
let cache;
while (line = await readline()) {

let parts = line.split(":");
let command = parts[0].trim();

if (command === "capacity") {
cache = new LRUCache(parseInt(await readline()));
} else if (command === "write") {
let count = parseInt(await readline());
for (let i = 0; i < count; i++) {
let [key, value] = (await readline()).split(" ").map(Number);
cache.put(key, value);
}
} else if (command === "read") {
let key = parseInt(await readline());
cache.get(key); // 这里仅用于更新 LRU 访问顺序
} else if (command === "query") {
let key = parseInt(await readline());
console.log(cache.get(key));
}
else{
break;
}
}

rl.close();
})();

题目描述
\qquad这学期的小明的计网老师教学水平真是一言难尽，还要用ensp来做一些繁琐的模拟实验，但是计网实验跟写代码有什么关系呢？来不及为赶不完的DDL哀悼了，有一个实验描述如下：
\qquad无线通信移动性需要在基站上配置邻区(本端基站的小区LocalCell与周边邻基站的小区NeighborCelI映射)关系，为了能够加速无线算法的计算效率，设计一个邻区关系缓存表，用于快速的通过本小区LocalCell查询到邻小区NeighborCell。但是缓存表有一定的规格限制，因此到达规格并且需要插入新的数据时，需要删除邻区数据，选择删除邻区数据对象的策略为：
\qquad（1）使用次数最少的；
\qquad（2）如果（1）返回有多个对象,则选择最久未使用的。
\qquad请设计并实现一个满足以上要求的数据结构和算法实现。
\qquad注:假设每个LocalCell至多只有一个NeighborCell。
输入描述
\qquad 1、首行以字符"capacity:"标识设置一个整数容量;
\qquad 2、以"write:"标识开始进行若干组[LocalCell,NeighborCell]邻区数据的输入,每组数据为一行;如果"write:"已经存在的LocalCell数据,更新其对
应的NeighborCell,并刷新使用时间和次数加1;如果某邻区数据被删除,缓存表不再保留其记录;
\qquad 3、以"read:"标识进行一次读取LocalCell的使用操作,刷新使用时间和次数加1;
\qquad 4、最后以"query:"标识查询输出操作，输入正整数LocalCell，查询NeighborCell；
\qquad注:
\qquad\qquad（1）写入和读取都表示对LocalcelI的使用操作;
\qquad\qquad（2）capacity、LocalCellI和NeighborCelI都是正整数，范围在[1,10000];
\qquad\qquad（3）输入的总行数不超过30000行。
输出描述
\qquad每个查询输入正整数LocalCell对应NeighborCell，表示在邻区关系缓存表中的记录。
\qquad 1、找到，则返回NeighborCell；
\qquad 2、没有找到，则返回-1;
样例一
输入
capacity:
3
write:
3
1 2
4 3
2 3
read:
2
write:
1
3 1
query:
1

输出
-1

解释
\qquad 1、设定容量capacity为3
\qquad 2、write输入3组数据，
\qquad 3、read读取2使用,刷新该邻区对使用时间和次数;
\qquad 4、再write输入1组数据,因为已经超了容量3,所以把最早输入且未使用的数据”12”剔除;
\qquad 5、最后进行query查询1因为已经被剔除了,所以返回-1;
Limitation
1s, 1024KiB for each test case.

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (4)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 73ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-编译原理实验（P2322）
- 链接：https://codefun2000.com/p/P2322

> 页面标题：#P2322. 第2题-编译原理实验

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
塔子哥在学习编译原理课程时需要将C语言翻译成汇编程序，为此他决定使用正则表达式来完成文本的切词任务。已知一种字符串解析语法，包括N匹配单个数字(0-9)，A匹配单个字母(a-z或A-Z)，以及n(...)表示分组，其中分组包含至少一个N或A，n是一个数字，表示该分组重复的次数(1<=n<=200)。输入包括两行，第一行为解析语法，第二行为目标字符串。要求找到第一个匹配解析语法的子字符串并输出，如果没有匹配到则输出!。
思路：模拟+KMP
本题的模式串可以展开，使用栈来模拟即可，每次一个(放入栈中对应的位置以及前面的数量，每次)弹出栈顶元素，然后将栈顶元素的数量乘以当前的字符串加上栈顶元素的前面的字符串加入到模式串中即可。
需要注意有可能模式串非常长，所以中间需要判断是否已经超过了匹配串的长度，超过则直接返回。
有了模式串和匹配串之后，就可以直接使用KMP算法来进行匹配了。
解析模式字符串
模式字符串的解析需要遵循以下规则：

数字：代表后面括号中的内容需要重复的次数。
字母：单个字母（包括小写和大写）直接加入到模式字符串中。
左括号 (：表示一个新的分组开始，此时我们需要记录当前的重复次数和之前的字符串状态。
右括号 )：表示分组结束，此时我们从栈中弹出最近的分组信息，并将当前构建的字符串根据重复次数进行扩展。

在具体实现中，我们使用一个栈 st 存储分组的重复次数和之前构建的字符串。在遇到右括号时，我们从栈中获取这些信息，并根据重复次数来构建新的模式字符串。如果在构建过程中发现模式字符串的长度超过了目标字符串的长度，我们就可以提前返回 !，表示无法匹配。
KMP 算法
一旦我们完成了模式字符串的展开，就可以使用 KMP 算法进行匹配。KMP 算法的核心思想是通过构建一个 next 数组来优化匹配过程，从而避免重复比较。next 数组的每个位置记录了当前字符不匹配时应该跳转到的位置，避免了无效的字符比较。
在进行匹配时，我们还需要定义一个检查函数 check，来判断目标字符串中的字符是否符合模式字符串中的规定（即 A 匹配字母，N 匹配数字）。如果匹配成功，我们输出匹配的子字符串。如果在整个目标字符串中没有找到匹配，则输出 !。
代码
Python
# 导入正则表达式模块
import re

def expand_pattern(t):
# 模式串展开
st = []  # 用于存储数字和之前的字符串
num = 0  # 记录当前的数字
res = ""  # 记录当前的字符串

# 遍历模式串 t
for c in t:
if '0' <= c <= '9':  # 如果当前字符是数字
num = num * 10 + int(c)  # 更新数字
elif c == '(':  # 如果当前字符是左括号
st.append((num, res))  # 将数字和之前的字符串入栈
num = 0  # 重置数字
res = ""  # 重置字符串
elif c == ')':  # 如果当前字符是右括号
n, a = st.pop()  # 获取栈顶的数字和字符串
# 将当前字符串重复 n 次,并拼接到之前的字符串 a 上
res = a + res * n
else:  # 如果当前字符是普通字母
res += c  # 添加到当前字符串
return res  # 返回展开后的字符串

def build_next(t):
# 构建 next 数组
next = [0]  # next 数组的首位必定为 0
j = 0
for i in range(1, len(t)):
while j > 0 and t[j] != t[i]:
j = next[j - 1]
if t[i] == t[j]:
j += 1
next.append(j)
return next

def check(a, b):
# 自定义检查函数,用于判断当前字符是否满足要求
if b == 'A' and a.isalpha():
return True
if b == 'N' and a.isdigit():
return True
return False

def kmp_match(t, s):
# 使用 KMP 算法进行匹配
next = build_next(t)
j = 0
for i in range(len(s)):
while j > 0 and not check(s[i], t[j]):
j = next[j - 1]
if check(s[i], t[j]):
j += 1
if j == len(t):
return s[i - len(t) + 1:i + 1]  # 返回匹配的子串
return "!"  # 未找到匹配返回 "!"

def main():
t = input().strip()  # 读取模式串
s = input().strip()  # 读取匹配串
expanded_t = expand_pattern(t)  # 展开模式串
if len(expanded_t) > len(s):  # 检查展开后的长度
print("!")
else:
result = kmp_match(expanded_t, s)  # 执行 KMP 匹配
print(result)

if __name__ == "__main__":
main()

Java
import java.util.*;
import java.util.function.BiFunction; // 导入 BiFunction

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String t = sc.next(); // 输入模式串
String s = sc.next(); // 输入匹配串

// 模式串展开
Stack<Pair<Integer, String>> st = new Stack<>(); // 用于存储数字和之前的字符串
int num = 0; // 记录当前的数字
String res = ""; // 记录当前的字符串

// 遍历模式串 t
for (char c : t.toCharArray()) {
if (Character.isDigit(c)) { // 如果当前字符是数字
num = num * 10 + (c - '0'); // 更新数字
} else if (c == '(') { // 如果当前字符是左括号
st.push(new Pair<>(num, res)); // 将数字和之前的字符串入栈
num = 0; // 重置数字
res = ""; // 重置字符串
} else if (c == ')') { // 如果当前字符是右括号
int n = st.peek().getKey(); // 获取栈顶的数字
String a = st.peek().getValue(); // 获取栈顶的字符串
st.pop(); // 弹出栈顶元素
if (n * res.length() + a.length() > s.length()) { // 检查长度是否超过匹配串
System.out.println("!");
return;
}
// 将当前字符串重复 n 次,并拼接到之前的字符串 a 上
StringBuilder sb = new StringBuilder(a);
for (int i = 0; i < n; i++) sb.append(res);
res = sb.toString();
} else { // 如果当前字符是普通字母
res += c; // 添加到当前字符串
if (res.length() > s.length()) { // 检查长度是否超过匹配串
System.out.println("!");
return;
}
}
}

// KMP 匹配
t = res; // 将展开后的模式串赋给 t
List<Integer> next = new ArrayList<>();
next.add(0); // next 数组的首位必定为 0

// 构建 next 数组
for (int i = 1, j = 0; i < t.length(); i++) {
while (j > 0 && t.charAt(j) != t.charAt(i)) {
j = next.get(j - 1);
}
if (t.charAt(i) == t.charAt(j)) {
j++;
}
next.add(j);
}

// 自定义检查函数,用于判断当前字符是否满足要求
BiFunction<Character, Character, Boolean> check = (a, b) -> {
if (b == 'A' && Character.isAlphabetic(a)) return true;
if (b == 'N' && Character.isDigit(a)) return true;
return false;
};

// 使用 KMP 算法进行匹配
for (int i = 0, j = 0; i < s.length(); ++i) {
while (j > 0 && !check.apply(s.charAt(i), t.charAt(j))) j = next.get(j - 1);
if (check.apply(s.charAt(i), t.charAt(j))) j++;
if (j == t.length()) {
System.out.println(s.substring(i - t.length() + 1, i + 1));
return;
}
}

System.out.println("!");
}

// Pair 类，Java 没有内置的 Pair 类，可以使用这种简单的实现
static class Pair<K, V> {
private final K key;
private final V value;

public Pair(K key, V value) {
this.key = key;
this.value = value;
}

public K getKey() {
return key;
}

public V getValue() {
return value;
}
}
}

C++
#include <bits/stdc++.h>

using namespace std;

int main()
{
string t, s;
cin >> t >> s;

// 模式串展开
stack<pair<int, string>> st; // 用于存储数字和之前的字符串
int num = 0; // 记录当前的数字
string res = ""; // 记录当前的字符串

// 遍历模式串 t
for (auto c : t) {
if (c >= '0' && c <= '9') { // 如果当前字符是数字
num = num * 10 + (c - '0'); // 更新数字
}
else if (c == '(') { // 如果当前字符是左括号
st.emplace(make_pair(num, res)); // 将数字和之前的字符串入栈
num = 0; // 重置数字
res = ""; // 重置字符串
}
else if (c == ')') { // 如果当前字符是右括号
int n = st.top().first; // 获取栈顶的数字
string a = st.top().second; // 获取栈顶的字符串
st.pop(); // 弹出栈顶元素
if (n * res.size() + a.size() > s.size()) { // 检查长度是否超过匹配串
cout << "!" << endl;
return 0;
}
// 将当前字符串重复 n 次,并拼接到之前的字符串 a 上
for (int i = 0; i < n; i++) a += res;
res = a;
}
else { // 如果当前字符是普通字母
res += c; // 添加到当前字符串
if (res.size() > s.size()) { // 检查长度是否超过匹配串
cout << "!" << endl;
return 0;
}
}
}

// KMP 匹配
t = res; // 将展开后的模式串赋给 t
vector<int> next;
next.push_back(0); // next 数组的首位必定为 0

// 构建 next 数组
for (int i = 1, j = 0; i < t.length(); i++)
{
while (j > 0 && t[j] != t[i])
{
j = next[j - 1];
}
if (t[i] == t[j])
{
j++;
}
next.push_back(j);
}

// 自定义检查函数,用于判断当前字符是否满足要求
auto check = [](char a, char b) -> bool {
if (b == 'A' && isalpha(a)) return true;
if (b == 'N' && isdigit(a)) return true;
return false;
};

// 使用 KMP 算法进行匹配
for (int i = 0, j = 0; i < s.size(); ++i) {
while (j && !check(s[i], t[j])) j = next[j-1];
if (check(s[i], t[j])) ++j;
if (j == t.size()) {
cout << s.substr(i - t.size() + 1, t.size() ) << endl;
return 0;
}
}

cout << "!" << endl;
return 0;
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

// 解析模式串并展开
function expandPattern(t, s) {
let stack = []; // 用于存储数字和之前的字符串
let num = 0; // 记录当前的数字
let res = ""; // 记录当前的字符串

for (let c of t) {
if (!isNaN(c)) { // 如果当前字符是数字
num = num * 10 + Number(c);
} else if (c === "(") { // 左括号，入栈
stack.push([num, res]);
num = 0;
res = "";
} else if (c === ")") { // 右括号，出栈
if (stack.length === 0) return "!";
let [n, a] = stack.pop();
if (n * res.length + a.length > s.length) return "!";

res = a + res.repeat(n);
} else { // 普通字符
res += c;
if (res.length > s.length) return "!";
}
}
return res;
}

// 构建 KMP 的 next 数组
function buildKMPTable(pattern) {
let next = Array(pattern.length).fill(0);
for (let i = 1, j = 0; i < pattern.length; i++) {
while (j > 0 && pattern[i] !== pattern[j]) {
j = next[j - 1];
}
if (pattern[i] === pattern[j]) j++;
next[i] = j;
}
return next;
}

// KMP 匹配
function kmpMatch(t, s) {
let next = buildKMPTable(t);

// 自定义匹配规则
const check = (a, b) => {
if (b === "A" && /[a-zA-Z]/.test(a)) return true;
if (b === "N" && /\d/.test(a)) return true;
return false;
};

for (let i = 0, j = 0; i < s.length; i++) {
while (j > 0 && !check(s[i], t[j])) {
j = next[j - 1];
}
if (check(s[i], t[j])) j++;
if (j === t.length) {
return s.substring(i - t.length + 1, i + 1);
}
}
return "!";
}

// 处理输入
(async function () {
let t = await readline(); // 读取模式串
let s = await readline(); // 读取匹配串
rl.close();

let expandedPattern = expandPattern(t, s);
if (expandedPattern === "!") {
console.log("!");
return;
}

let result = kmpMatch(expandedPattern, s);
console.log(result);
})();

题目描述
\qquad小明这学期有一门压力巨大的专业课，编译原理，这到底是谁在听懂啊？啊？！还要做恁多实验。有一个实验要求小明将C语言翻译成对应的汇编程序，这就需要对文本进行切词，聪明的小明决定使用正则表达式来完成切词任务。
\qquad已知存在种字符串解析语法,其中的语法元素如下
\qquad N：用于匹配单个数字(0-9)
\qquad A：用于匹配单个字母(a-z，A-Z)
\qquad n()：用于表示一个分组，分组中至少有一个N语法元素或者A语法元素，n为个数值,表示匹配n次，1<=n<=200
\qquad 输入给定的解析语法和字符串，要求从中找到第一个满足解析语法的字符串。
输入描述
\qquad输入两行数据，第一行是给定的解析语法，第二行是目标字符串。
输出描述
\qquad输出匹配的子字符串内容，如果没有匹配中任何字符串，输出!（英文感叹号）
样例一
输入
2(AN)
BA3A3ABB

输出
A3A3

样例二
输入
2(A2(N))
A3322A33P20BB

输出
A33P20

Limitation
1s, 1024KiB for each test case.

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 74ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-排列组合的回文字符串（P2319）
- 链接：https://codefun2000.com/p/P2319

> 页面标题：#P2319. 第2题-排列组合的回文字符串

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
塔子哥最近迷上了一个字符串重排的游戏。游戏规则是给定一个由小写字母组成的字符串 ( s )，通过重新排列 ( s ) 中的字母，看看最多能组成多少个不同的回文字符串。如果无法组成任何回文字符串，则输出 ( 0 )。请编写一个程序来实现这个功能。输入格式为一行包含字符串 ( s )，输出格式为一个整数，表示可以组成的不同回文字符串的数量。例如，输入 "aabb" 时，输出应为 ( 2 )。
思路
如果存在两个以上的个数为奇数的字符显然不能构成回文。
对于其他为偶数的情况，因为是回文串，所以我们只需考虑其中半边的情况即可。
现在问题变成了，有 K 种字母，每个字母的个数为 cnticnt_icnti​ 个，问有多少种情况
假设 K 种字母的和为 nnn
那么计算公式为：
对此我们只需预处理阶层即可 O(1)O(1)O(1) 计算单个结果，由于涉及到大数运算，这里采用 python 来实现。
关键点分析

回文字符串的特性：

对于一个字符串能构成回文，最多只能有一个字符出现奇数次。因为在回文的中心可以放置这个字符，而其他字符必须成对出现。
如果存在两个或以上的字符出现奇数次，则无法构成回文串，直接输出 ( 0 )。

字符计数：

统计字符串中每个字符的出现次数，分为奇数和偶数。
只需要考虑每个字符的一半的数量来计算不同的回文串，因为回文的前半部分决定了整个回文。

排列计算：

计算回文的一半所需的字符的排列方式。假设我们有 ( K ) 种字符，每种字符的数量为 ( cnt_i )，我们需要计算总的排列数。
总的排列数为所有字符的一半的总数的阶乘，然后除以每种字符的一半的数量的阶乘，以避免重复排列。

解决方案步骤

统计字符频率：使用哈希表统计每个字符的出现次数。
判断奇数字符的数量：遍历统计结果，记录出现奇数次的字符数量。

如果奇数字符的数量大于 1，则输出 ( 0 )。

计算字符的半数：将每个字符的计数除以 2，存储这些值。
预处理阶乘：计算并存储从 ( 0 ) 到 ( n ) 的阶乘，以便后续快速计算。
计算回文串的数量：根据公式计算可能的排列数，输出结果。

AC代码
Python
from collections import Counter

s = input().strip()
mp = Counter(s)  # 统计字符串中各个字符的个数
cnt = 0
v = []

# 统计奇数字符个数和偶数字符个数
for value in mp.values():
if value % 2 == 1:
cnt += 1
v.append(value // 2)

# 如果奇数字符个数大于1，则无法构成回文串
if cnt > 1:
print(0)
exit(0)

# 计算回文串数量
total = sum(v)  # 总的字符数量的一半
f = [1] * (total + 1)  # 预处理阶乘值
for i in range(1, total + 1):
f[i] = f[i - 1] * i

res = f[total]  # 计算全部字符的排列数
for i in v:
res //= f[i]  # 除去各个字符的排列数

print(res)

java
import java.math.BigInteger;
import java.util.*;

public class Main {
private static BigInteger palindromeNum(String str) {
// 将字符串转换为字符数组
char[] s = str.toCharArray();
// 创建一个长度为26的数组，存储每个字母出现的次数
int[] map = new int[26];
for (char c : s) {
map[c - 'a']++;
}
// 判断是否有超过一个的奇数字符
boolean odd = false;
for (int i = 0; i < 26; i++) {
if (map[i] % 2 == 1) {
if (odd) {
// 如果有超过一个奇数字符，则无法构成回文串，返回0
return new BigInteger("0");
} else {
odd = true;
}
}
// 将每个字母的个数除以2，因为回文串中每个字母出现的次数必须是偶数
map[i] /= 2;
}
// 计算回文串的数量
int n = s.length / 2;
// 预先计算阶乘值，以便后续使用
BigInteger[] f = new BigInteger[n + 1];
f[0] = new BigInteger("1");
for (int i = 1; i <= n; i++) {
f[i] = f[i - 1].multiply(new BigInteger(String.valueOf(i)));
}
// 除去每种字符的排列数
for (int i = 0; i < 26; i++) {
if (map[i] > 0) {
f[n] = f[n].divide(f[map[i]]);
}
}
return f[n];
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
String s = in.nextLine();
System.out.println(palindromeNum(s));
}
}

C++
塔子哥的tips:这题确实对C++不公平。同样的思路却需要自己实现大整数，而其他语言都有对大整数模拟的封装。但是也没办法，因为C++实现大整数需要100+行代码。如果真的追求完美，C++这题起码写200行。所以碰到这种出题人，只能认栽。写个正常的算法看看能过多少就算了。赶快去其他题拿分。
#include <iostream>
#include <unordered_map>
#include <vector>

using namespace std;

int main() {
string s;
cin >> s;

// 统计字符串中各个字符的个数
unordered_map<char, int> mp;
for (char c : s) {
mp[c]++;
}

int cnt = 0;
vector<int> v;

// 统计奇数字符个数和偶数字符个数
for (auto [_, value] : mp) {
if (value % 2 == 1) {
cnt++;
}
v.push_back(value / 2);
}

// 如果奇数字符个数大于1，则无法构成回文串
if (cnt > 1) {
cout << 0 << endl;
return 0;
}

// 计算回文串数量
int total = 0;
for (int x : v) {
total += x;
}

vector<long long> f(total + 1, 1);  // 预处理阶乘值
for (int i = 1; i <= total; i++) {
f[i] = f[i - 1] * i;
}

long long res = f[total];  // 计算全部字符的排列数
for (int x : v) {
res /= f[x];  // 除去各个字符的排列数
}

cout << res << endl;
return 0;
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

// 计算回文排列数量
function palindromeNum(str) {
let s = str.split("");
let map = Array(26).fill(0);

for (let c of s) {
map[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;
}

let odd = false;
for (let i = 0; i < 26; i++) {
if (map[i] % 2 === 1) {
if (odd) return BigInt(0); // 超过一个奇数字符，无法构成回文
odd = true;
}
map[i] = Math.floor(map[i] / 2);
}

let n = Math.floor(s.length / 2);
let f = Array(n + 1).fill(BigInt(1));

for (let i = 1; i <= n; i++) {
f[i] = f[i - 1] * BigInt(i);
}

let result = f[n];
for (let i = 0; i < 26; i++) {
if (map[i] > 0) {
result /= f[map[i]];
}
}

return result;
}

// 处理输入
(async function () {
let s = await readline();
console.log(palindromeNum(s).toString()); // 输出结果
rl.close();
})();

问题描述
小明最近迷上了一个字符串重排的游戏。游戏规则如下:给定一个由小写字母组成的字符串 sss,通过重新排列 sss 中的字母,看看最多能组成多少个不同的回文字符串。回文字符串是指一个字符串正着读和反着读完全一样,例如"level"和"noon"都是回文字符串,而"code"不是。
请你帮小明写一个程序,计算给定字符串 sss 经过重排后最多能组成的不同回文字符串数量。
输入格式
输入一行,包含一个由小写字母组成的字符串 sss,表示小明手中的初始字符串。
输出格式
输出一个整数,表示字符串 sss 经过重排后最多能组成的不同回文字符串数量。如果无法组成任何回文字符串,则输出 000。
样例输入
aabb

样例输出
2

评测数据与规模

1≤∣s∣≤10001 \leq |s| \leq 10001≤∣s∣≤1000
字符串 sss 只包含小写字母

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 72ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-购物系统的降级策略（P2396）
- 链接：https://codefun2000.com/p/P2396

> 页面标题：#P2396. 第2题-购物系统的降级策略

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在一个购物APP中，有一个核心购物系统，它的接口被 NNN 个客户端调用。这些客户端负责处理来自不同渠道的交易请求，并将这些请求发送给核心购物系统。每个客户端有不同的调用量 R=[R1,R2,...,RN]R=[R_1,R_2,...,R_N]R=[R1​,R2​,...,RN​]，表示在一定时间内，这个客户端向核心购物系统发送的交易请求的数量。核心购物系统必须能够及时响应所有的请求，以确保交易顺利进行。
然而，最近核心购物系统出现了集群故障，导致交易请求的处理速度变慢。为了避免系统崩溃，必须临时降级并限制调用量。具体而言，核心购物系统能接受的最大调用量为 cntcntcnt，如果客户端发送的请求总量超过 cntcntcnt，则必须限制一些系统的请求数量，以确保核心购物系统不会超负荷工作。
现在需要一个降级规则，来限制客户端的请求数量。规则如下：

如果 sum(R1,R2,...,RN)sum(R_1,R_2,...,R_N)sum(R1​,R2​,...,RN​) 小于等于 cntcntcnt ，则全部可以正常调用，返回 −1-1−1；
如果 sum(R1,R2,...,RN)sum(R_1,R_2,...,R_N)sum(R1​,R2​,...,RN​) 大于 cntcntcnt，则必须设定一个阈值 valuevaluevalue，如果某个客户端发起的调用量超过 valuevaluevalue，则该客户端的请求数量必须限制为 valuevaluevalue。其余未达到 valuevaluevalue 的系统可以正常发起调用。要求求出最大的 valuevaluevalue（valuevaluevalue 可以为0）。

为了保证交易的顺利进行，必须保证客户端请求的数量不会超过核心购物系统的最大调用量，同时最大的 valuevaluevalue 要尽可能的大。需要高效地解决这个问题，以确保购物系统的高效性。
输入描述
第一行：每个客户端的调用量(整型数组)
第二行：核心购物系统的最大调用量
0<R.length≤1050 < R.length\le 10^50<R.length≤105 ， 0≤R[i]≤1050\le R[i]\le 10^50≤R[i]≤105 ， 0≤cnt≤1090\le cnt \le 10^90≤cnt≤109
输出描述
调用量的阈值 valuevaluevalue
样例
样例一
输入
1 4 2 5 5 1 6
13

输出
2

样例解释
因为 1+4+2+5+5+1+6>131+4+2+5+5+1+6>131+4+2+5+5+1+6>13 ，将 valuevaluevalue 设置为 222 ，则 1+2+2+2+2+1+2=12<131+2+2+2+2+1+2=12<131+2+2+2+2+1+2=12<13 。所以 valuevaluevalue 为 222 。
样例二
输入
1 7 8 8 1 0 2 4 9
7

输出
0

样例解释
因为即使 valuevaluevalue 设置为 111 , 1+1+1+1+1+1+1+1=8>71+1+1+1+1+1+1+1=8>71+1+1+1+1+1+1+1=8>7 也不满足，所以 valuevaluevalue  只能为 000 。

#### TextSol

题目大意
在一个购物APP中，有一个核心购物系统，该系统的接口被多个客户端调用。每个客户端有不同的请求数量，系统能接受的最大调用量是一个给定的值。要求设定一个阈值 value，如果某个客户端的请求量超过该阈值，则将其请求数量限制为这个阈值。我们的目标是求出最大的 value 值，确保所有客户端的请求总量不会超过核心购物系统的最大调用量。
思路
二分答案
要求在保证客户端请求的数量不会超过核心购物系统的最大调用量的情况下，使得阈值 valuevaluevalue 尽可能大。一般该类问题可以尝试使用二分答案加验证答案正确性的方法尝试求解。
使用二分答案的方法，一般要考虑两个因素：

二分值(本题中为阈值valuevaluevalue)的变化，对模型整体的评估(本题中为∑1≤i≤nRi\sum_{1\le{i}\le{n}}{R_i}∑1≤i≤n​Ri​)是具有单调性的
当确定二分值时，我们会借助该二分值去计算模型整体的评估值，该计算方法应该具有让人可以接收的复杂度

单调性
本题中的单调性依据题意应当是显而易见的：

当阈值 valuevaluevalue 变小时，更多的客户端发起的请求量会被限制，因此总的请求量就会减小
当阈值 valuevaluevalue 变大时，更少的客户端发起的请求量会被限制，许多客户端都能满足其发起的所有请求，于是总的请求量就会变大.

所以，答案随着阈值单调递增 ， 可以使用二分答案！
答案验证
当获得了阈值 valuevaluevalue 后，依据题意验证答案的时间复杂度是 O(N)O(N)O(N)，其与二分答案所带来的时间复杂度叠加后，总的时间复杂度为 O(NlogN)O(NlogN)O(NlogN)(二分答案引入的时间复杂度应当是 O(log(max(Ri)))O(log(max(R_i)))O(log(max(Ri​)))，但是RiR_iRi​的最大范围与NNN的范围是相同的，所以时间复杂度可以简化为该结果)，这是该题能够接收的时间复杂度，因此二分答案的做法是可行的。
代码说明
整体代码流程
1.输入读取：
读取所有客户端的请求量，并存储在数组中。
读取最大调用量 th，作为验证的上限。
2.初步检查：
计算所有请求量的总和，如果总和小于等于最大调用量 th，直接输出 -1，表示不存在有效的阈值。
3.二分查找：
定义查找的区间，初始左边界为 -1，右边界为 100001。
进行二分查找，在每次迭代中计算中间值 mid 并使用 check 函数验证其合法性。
如果 check(mid) 返回 true，更新左边界为 mid，否则更新右边界。
4.输出结果：
最终输出 l，表示在满足条件下能达到的最大阈值。
时间复杂度：O(NlogN)O(NlogN)O(NlogN)
代码
CPP
#include <iostream>
#include <cstdio>
using namespace std;

#define ll long long // 定义 ll 为 long long 类型

ll a[100010], n; // 数组 a 用于存储请求量，n 为请求数量
ll th; // 最大调用量

// 验证当前阈值 value 的有效性
bool check(ll value) {
ll sum = 0; // 初始化总和
for (int i = 1; i <= n; ++i) {
if (a[i] <= value)
sum += a[i]; // 如果请求量未超出阈值，累加实际请求量
else
sum += value; // 如果请求量超出阈值，累加阈值
}
return sum <= th; // 返回总和是否在最大调用量以内
}

int main() {
// freopen("test.in","r",stdin); // 可选：用于调试时从文件读取输入

ll sum = 0; // 用于计算总请求量
n++; // 从 1 开始计数
// 读取数据直到 EOF
while (scanf("%lld", &a[n]) != EOF) {
++n; // 增加请求数量
}
n--; // 调整 n 的值
th = a[n]; // 最后一个输入值作为最大调用量
n--; // 调整 n 的值
for (int i = 1; i <= n; ++i)
sum += a[i]; // 计算所有请求的总和

// 检查如果总请求量不超过最大调用量，输出 -1
if (sum <= th) {
puts("-1");
return 0;
}

// 二分答案，采用开区间的二分方式
int l = -1, r = 100001, mid; // 初始化二分查找的边界
while (l + 1 < r) {
mid = (l + r) >> 1; // 计算中间值
if (check(mid))
l = mid; // 如果当前 mid 合法，更新左边界
else
r = mid; // 否则更新右边界
}

// check 函数能够保证 mid 的值是合法的，因此最终 l 即为答案
printf("%lld\n", l); // 输出结果，l 为最大合法阈值
return 0; // 程序结束
}

python
# 定义一个足够大的数组来存储请求量
a = [0] * 100010
n = 0  # 请求数量
th = 0  # 最大调用量

# 验证当前阈值 value 的有效性
def check(value):
sum_val = 0  # 初始化总和
for i in range(1, n + 1):  # 遍历所有请求
if a[i] <= value:
sum_val += a[i]  # 如果请求量未超出阈值，累加实际请求量
else:
sum_val += value  # 如果请求量超出阈值，累加阈值
return sum_val <= th  # 返回总和是否在最大调用量以内

if __name__ == "__main__":
sum_val = 0  # 用于计算请求量的总和
n += 1  # 从 1 开始计数

# 读取数据
while True:
try:
a[n] = int(input())  # 读取请求量
n += 1  # 增加请求数量
except EOFError:  # 处理 EOF
break  # 退出循环
n -= 1  # 调整 n 的值
th = a[n]  # 将最后一个输入值作为最大调用量
n -= 1  # 调整 n 的值

# 计算所有请求的总和
for i in range(1, n + 1):
sum_val += a[i]

# 检查如果总请求量不超过最大调用量，输出 -1
if sum_val <= th:
print("-1")  # 输出 -1
exit(0)  # 退出程序

# 二分答案，采用开区间的二分方式
l = -1  # 左边界
r = 100001  # 右边界
while l + 1 < r:
mid = (l + r) // 2  # 计算中间值
if check(mid):  # 如果当前 mid 合法
l = mid  # 更新左边界
else:
r = mid  # 更新右边界

# check 函数能够保证 mid 的值是合法的，因此最终 l 即为答案
print(l)  # 输出结果

Java
import java.util.Scanner;

public class Main {
static long[] a; // 存储请求量
static int n; // 请求数量
static long th; // 最大调用量

// 验证当前阈值 value 的有效性
static boolean check(long value) {
long sum = 0; // 初始化总和
for (int i = 1; i <= n; ++i) { // 遍历所有请求
if (a[i] <= value)
sum += a[i]; // 如果请求量未超出阈值，累加实际请求量
else
sum += value; // 如果请求量超出阈值，累加阈值
}
return sum <= th; // 返回总和是否在最大调用量以内
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in); // 创建扫描器以读取输入
a = new long[100010]; // 初始化请求量数组
n = 0; // 请求数量初始化

// 读取数据直到输入结束
while (scanner.hasNext()) {
a[++n] = scanner.nextLong(); // 将输入的请求量存入数组
}
th = a[n]; // 将最后一个输入值作为最大调用量
long sum = 0; // 初始化请求量总和

// 计算所有请求的总和
for (int i = 1; i < n; ++i)
sum += a[i];

// 检查如果总请求量不超过最大调用量，输出 -1
if (sum <= th) {
System.out.println("-1"); // 输出 -1
return; // 结束程序
}

// 二分答案，采用开区间的二分方式
int l = -1, r = 100001, mid; // 初始化二分查找的边界
while (l + 1 < r) {
mid = (l + r) >> 1; // 计算中间值
if (check(mid)) // 如果当前 mid 合法
l = mid; // 更新左边界
else
r = mid; // 否则更新右边界
}

// check 函数能够保证 mid 的值是合法的，因此最终 l 即为答案
System.out.println(l); // 输出结果
}
}

Go
package main

import (
"fmt"
)

// 定义变量
var a []int64 // 存储请求量
var n int     // 请求数量
var th int64  // 最大调用量

// 验证当前阈值 value 的有效性
func check(value int64) bool {
sum := int64(0) // 初始化总和
for i := 1; i <= n; i++ { // 遍历所有请求
if a[i] <= value {
sum += a[i] // 如果请求量未超出阈值，累加实际请求量
} else {
sum += value // 如果请求量超出阈值，累加阈值
}
}
return sum <= th // 返回总和是否在最大调用量以内
}

func main() {
var num int64
// 读取数据
for {
_, err := fmt.Scanf("%d", &num) // 读取请求量
if err != nil { // 处理 EOF
break
}
a = append(a, num) // 将输入的请求量添加到数组中
}
n = len(a) - 2 // 设置请求数量（排除最后两个元素）
th = a[n+1]    // 将最后一个输入值作为最大调用量
sum := int64(0) // 初始化请求量总和

// 计算所有请求的总和
for i := 1; i <= n; i++ {
sum += a[i]
}

// 检查如果总请求量不超过最大调用量，输出 -1
if sum <= th {
fmt.Println("-1") // 输出 -1
return // 结束程序
}

// 二分答案，采用开区间的二分方式
l, r := -1, 100001 // 初始化二分查找的边界
for l+1 < r { // 当 l + 1 < r 时继续查找
mid := (l + r) / 2 // 计算中间值
if check(int64(mid)) { // 如果当前 mid 合法
l = mid // 更新左边界
} else {
r = mid // 否则更新右边界
}
}

// check 函数能够保证 mid 的值是合法的，因此最终 l 即为答案
fmt.Println(l) // 输出结果
}

Js
const readline = require('readline'); // 引入 readline 模块，用于处理输入

// 验证当前阈值 value 的有效性
function check(value) {
let sum = 0; // 初始化总和
for (let i = 1; i <= n; i++) { // 遍历所有请求
if (a[i] <= value)
sum += a[i]; // 如果请求量未超出阈值，累加实际请求量
else
sum += value; // 如果请求量超出阈值，累加阈值
}
return sum <= th; // 返回总和是否在最大调用量以内
}

function main() {
const rl = readline.createInterface({
input: process.stdin, // 设置输入流
output: process.stdout // 设置输出流
});

let a = []; // 用于存储请求量
let n = 0; // 请求数量
let th = 0; // 最大调用量

// 读取数据
rl.on('line', (line) => {
a.push(parseInt(line)); // 将输入的请求量转换为整数并存入数组
n++; // 请求数量加一
});

rl.on('close', () => {
n -= 2; // 调整请求数量（排除最后两个元素）
th = a[n + 1]; // 将最后一个输入值作为最大调用量
let sum = 0; // 初始化请求量总和

// 计算所有请求的总和
for (let i = 1; i <= n; i++)
sum += a[i];

// 检查如果总请求量不超过最大调用量，输出 -1
if (sum <= th) {
console.log("-1"); // 输出 -1
return; // 结束程序
}

// 二分答案，采用开区间的二分方式
let l = -1, r = 100001, mid; // 初始化二分查找的边界
while (l + 1 < r) { // 当 l + 1 < r 时继续查找
mid = Math.floor((l + r) / 2); // 计算中间值
if (check(mid)) // 如果当前 mid 合法
l = mid; // 更新左边界
else
r = mid; // 否则更新右边界
}

// check 函数能够保证 mid 的值是合法的，因此最终 l 即为答案
console.log(l); // 输出结果
});
}

main(); // 调用主程序

---

### 第2题-出城（P2398）
- 链接：https://codefun2000.com/p/P2398

> 页面标题：#P2398. 第2题-出城

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明居住在数据结构之城，如果将这个城市的路口看做点，两个路口之间的路看做边，那么该城市的道路能够构成一棵由市中心路口向城市四周生长的树，树的叶子节点即是出城口。
小明今天想要出城办事，但不巧的是，有几个路口堵车了，小明无法从一个正常的路口前往堵车的路口。假定小明从一个正常的路口出发，请问小明能否顺利出城（到达出城口）？如果可以，请帮小明找到最省油的路径（经过路口最少的路径），否则请输出“NULL”。
输入描述
第一行给出数字n，表示这个城市有n个路口，路口从0开始依次递增，0固定为根节点，1<=n<10000
第二行给出数字m，表示接下来有m行，每行是一条道路
接下来的m行是边: x，y，表示x和y路口有一条道路连接。保证是一颗树
道路信息结束后接下来的一行给出数d，表示接下菜有d行，每行是一个堵车的路口
接下来的d行是堵车路口k，表示路口k已堵车
输出描述
如果小明能够顺利出城，请输出小明能够到达任意一个出城口的最短路径（通过路口最少），比如小明从0经过1到达2 (出城口) ，那么输出“0->1->2”;否则输出“NULL”。注意如果存在多条最短路径，请按照节点序号排序输出，比如 0->1 和 0-> 3两条路径，第一个节点0一样，则比较第二个节点1和3，1比3小，因此输出0->1这条路径。再如0->5->2->3和 0->5->1->4，则输出 0->5->1->4。
样例
样例1
输入
4
3
0 1
0 2
0 3
2
2
3

输出
0->1

说明
n=4, edge=[[0,1],[0,2], [0.3], block=[2, 3]] 表示一个有4个节点，3条边的树，其中节点2和节点3上有障碍物，小猴子都能从01到达叶子节点1（节点1只有一条边[0,1]和它连接，因此也是叶子节点），即可以跑出这个树，所以输出为0->1.
样例2
输入
7
6
0 1
0 3
1 2
3 4
1 5
5 6
1
4

输出
0->1->2

说明
节点4上有障碍物，因此0-3-4这条路不通，节点2和节点6都是叶子节点，但0->1->2比0->1->5->6路径短 (通过的边最少) ，因此输出为0->1->2。

#### TextSol

思路
树上dfs/bfs
题意化简:给定一棵树，其中有些点无法访问。需要找一条从根节点到叶子结点的路径，要求满足长度最短且字典序最小。
做法1:dfs
1.数据结构选择：
使用邻接表来表示树的结构，其中每个节点连接的路口作为其邻居。
2.输入处理：
读取城市的路口数、道路数及其连接信息，构建树的邻接表。
读取堵车路口的信息，并使用一个布尔数组标记这些堵车路口。
3.深度优先搜索（DFS）：
从根节点开始进行 DFS，寻找所有可能的出城口（叶子节点）。
在 DFS 的过程中，忽略被堵车的路口。
对于每次到达叶子节点，记录当前路径并更新最优路径（经过路口最少且字典序最小）。
4。路径记录和输出：
如果找到有效的出城路径，输出该路径；如果没有找到，则输出“NULL”。
做法2:bfs
由于要满足长度最短，所以想到bfs也是比较自然的。对于字典序最小的性质，我们只需要对同一层的结点编号进行升序排序即可。复杂度O(nlogn)O(nlogn)O(nlogn)
代码说明
1.输入读取：
读取节点数和边数，构建树的邻接表。
读取堵车路口并进行标记。
2.DFS 初始化：
使用一个数组记录当前路径。
使用一个布尔数组标记已经访问的节点。
3.DFS 遍历：
对当前节点进行遍历，检查邻接节点。
如果邻接节点没有堵车且没有被访问，继续深入 DFS。
如果到达叶子节点，记录当前路径并更新最优路径。
4.输出结果：
如果找到路径，格式化并输出路径；否则，输出“NULL”。
代码
以下皆为DFSDFSDFS做法。BFSBFSBFS做法见题解区
CPP
#include<bits/stdc++.h>
#include <vector>
using namespace std;
int n, m;
vector<vector<int>> edges;
vector<int> blocks;
vector<int> path;  // 当前路径
vector<int> res; // 答案路径
int tmp = INT_MAX;
vector<bool> used; // 标记是否被访问.
bool judge = false;
// idx 为当前所在点 , num 为深度
void dfs(int idx, int num){
// 到叶子节点，更新答案
if(edges[idx].size() == 0){
if(num < tmp){
tmp = num;
res = path;
}
judge = true;
}
//对同一层进行排序。这样保证了最先遇到的最短的答案也是字典序最小的
sort(edges[idx].begin(), edges[idx].end());
// 递归
for(auto & a : edges[idx]){
if(blocks[a] == 0 && used[a] == false){
used[a] = true;
path.push_back(a);
dfs(a, num + 1);
path.pop_back();
used[a] = false;
}
}
}
int main(){
// 读入
cin >> n >> m;
edges.resize(n + 1);
for(int i = 0; i < m; i ++){
int a, b;
cin >> a >> b;
edges[a].push_back(b);
}
// 标记 不能访问的点
int k;
cin >> k;
blocks.resize(n + 1, 0);
for(int i = 0; i < k; i ++){
int k1;
cin >> k1;
blocks[k1] = 1;
}
used.resize(n + 1, false);
path.push_back(0);
used[0] = true;
// dfs
dfs(0, 1);
// 输出
if(judge){
for(int i = 0; i < res.size(); i ++){
cout << res[i];
if(i != res.size() - 1){
cout << "->";
}
}
}
else cout << "NULL" << endl;
return 0;
}

python

import sys

# 递归函数，idx 表示当前所在的节点，num 表示深度
def dfs(idx: int, num: int):
global tmp, path, res, judge
# 到达叶子节点，更新答案
if not edges[idx]:
if num < tmp:
tmp = num
res = path.copy() #列表复制
judge = True
# 对同一层进行排序。这样保证了最先遇到的最短的答案也是字典序最小的
edges[idx].sort()
# 递归搜索子节点
for a in edges[idx]:
if (blocks[a] == 0 and not used[a]):
used[a] = True
path.append(a)
dfs(a, num + 1)
path.pop() # 回溯
used[a] = False

# 读入
n = int(input())
m = int(input())
edges = [[] for i in range(n+1)]
for i in range(m):
a, b = map(int, sys.stdin.readline().strip().split())
edges[a].append(b)
# 标记不能访问的点
k = int(sys.stdin.readline().strip())
blocks = [0] * (n + 1)
for i in range(k):
k1 = int(sys.stdin.readline().strip())
blocks[k1] = 1
used = [False] * (n + 1)
path = [0]
used[0] = True
# dfs
tmp = 0x7fffffff # 设置一个最大值
res = []
judge = False
dfs(0, 1)
# 输出
if judge:
for i in range(len(res)):
print(res[i], end='')
if i != len(res) - 1:
print("->", end='')
else:
print("NULL", end='')

Java
import java.util.*;

class Main {
static int ans=Integer.MAX_VALUE/2;
static ArrayList<Integer> path=new ArrayList<>();
static ArrayList<Integer> []map;
static boolean []arrive;
public static void main(String[] args) {
Scanner sc=new Scanner(System.in);

int n=sc.nextInt();
//邻接表
map=(ArrayList<Integer>[]) new ArrayList<?>[n];
for(int i=0;i<n;i++){
map[i]=new ArrayList<Integer>();
}
int m=sc.nextInt();

for(int i=0;i<m;i++){
int a=sc.nextInt();
int b=sc.nextInt();
map[a].add(b);
}
// 每个节点的子节点排序
for(int i=0;i<n;i++){
if(map[i].size()!=0){
Collections.sort(map[i]);
}
}

int k=sc.nextInt();

//每个点是否可达
arrive=new boolean[n];
Arrays.fill(arrive, true);
for(int i=0;i<k;i++){
arrive[sc.nextInt()]=false;
}
// dfs求解
ArrayList<Integer> cur_path=new ArrayList<>();
cur_path.add(0);
dfs(0,cur_path);

if(ans!=Integer.MAX_VALUE/2){
for(int i=0;i<path.size()-1;i++){
System.out.printf("%d->",path.get(i));
}
System.out.println(path.get(path.size()-1));
}else{
System.out.println("NULL");
}

}

public static void dfs(int cur_node,ArrayList<Integer> cur_path){
// 叶子节点更新答案
if(cur_path.size()>ans){
return;
}
if(map[cur_node].size()==0 && cur_path.size()!=0 && cur_path.size()<ans){
ans=Math.min(ans, cur_path.size());
path=new ArrayList<>(cur_path);
return;
}
// 递归搜索
for(int i=0;i<map[cur_node].size();i++){
int next_node=map[cur_node].get(i);
if(arrive[next_node]){
cur_path.add(next_node);
dfs(next_node,cur_path);
cur_path.remove(cur_path.size()-1);
}

}
}
}

Go

package main

import (
"bufio"
"fmt"
"os"
"sort"
)

var (
edges  [][]int
blocks []int
used   []bool
path   []int
tmp    int
res    []int
judge  bool
)
// dfs
func dfs(idx int, num int) {
// 到叶子节点，更新答案
if len(edges[idx]) == 0 {
if num < tmp {
tmp = num
res = append([]int(nil), path...) // slice复制
}
judge = true
}
//对同一层进行排序。这样保证了最先遇到的最短的答案也是字典序最小的
sort.Ints(edges[idx])
for _, a := range edges[idx] {
if blocks[a] == 0 && !used[a] {
used[a] = true
path = append(path, a)
dfs(a, num+1)
path = path[:len(path)-1]
used[a] = false
}
}
}

func main() {
in := bufio.NewReader(os.Stdin)

var n, m , k int
fmt.Fscan(in, &n)
fmt.Fscan(in, &m)

edges = make([][]int, n+1)
for i := 0; i < m; i++ {
var a, b int
fmt.Fscan(in, &a, &b)
edges[a] = append(edges[a], b)
}

fmt.Fscan(in, &k)

blocks = make([]int, n+1)
for i := 0; i < k; i++ {
var k1 int
fmt.Fscan(in, &k1)
blocks[k1] = 1
}

used = make([]bool, n+1)
path = []int{0}
used[0] = true

tmp = 0x7fffffff
dfs(0, 1)

if judge {
for i := 0; i < len(res); i++ {
fmt.Printf("%d", res[i])
if i != len(res)-1 {
fmt.Printf("->")
}
}
} else {
fmt.Println("NULL")
}
}

Js
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void async function () {
// 结点总数 例如 4个节点 即 0 - 3
let nodeTotal = Number(await readline())
// 0 - 3  头节点
let edges = new Array(nodeTotal)
for(let i = 0; i < nodeTotal ; i++){
edges[i] = []
}
// 这边先读取变，然后 sort一下
// 前者小的在前 ，后者在前面的基础上 也小的在前
let edgeNum = Number(await readline())
let edgeArr = []
for(let i = 0; i < edgeNum; i++)
edgeArr.push((await readline()).split(" ").map(Number))
// sort
edgeArr.sort((a, b) => {
if (a[0] === b[0]) {
return a[1] - b[1];
}
return a[0] - b[0];
});
for(let i = 0; i < edgeNum; i++){
let [beginNode, endNode] = edgeArr[i]
edges[beginNode].push(endNode)
}
// 有几条边 例如 3条

// 禁止的节点个数
let forbiddenNum = Number(await readline())
// let forbiddenNodes = []
let forbiddenNodes = new Array(nodeTotal).fill(true)
// 这些点被禁用 存储一下
for(let j = 0; j < forbiddenNum; j++)
forbiddenNodes[Number(await readline())] = false

let temp = []
let minLen = Infinity
let result = ""
function dfs(currNode){
temp.push(currNode)
let useEdge = edges[currNode]
let useEdgeFilter = useEdge.filter( node => forbiddenNodes[node])
// 叶子节点更新答案
if(useEdge.length == 0){
if(minLen > temp.length){
minLen = temp.length
result = temp.join("->")
}
return;
}
// 递归搜索
for(let i = 0; i < useEdgeFilter.length; i++){
dfs(useEdgeFilter[i])
temp.pop()
}
}
dfs(0)
if(minLen == Infinity)
console.log("NULL")
else
console.log(result)
}()
// by kaikaichaoren2

---

### 第2题-分配资源ID（P2393）
- 链接：https://codefun2000.com/p/P2393

> 页面标题：#P2393. 第2题-分配资源ID

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你是一名网络工程师，你正在为一家云计算公司开发一个虚拟机管理系统。你的系统需要为每个虚拟机分配一个唯一的ID，用来标识和通信。为了实现这个功能，你设计了一个管理ID的资源池，可以从资源池中分配资源ID和释放资源ID，分配方式有动态分配和指定分配。
动态分配是从资源池的开始分配一个资源ID，这种方式适用于新创建的虚拟机。指定分配是指定一个资源ID进行分配，这种方式适用于恢复或迁移的虚拟机。无论哪种分配方式释放资源ID时都需要放到资源池的尾部，这样可以保证资源ID的重用和均衡。
现在，你已经执行了一系列操作，你需要知道资源池的第一个空闲资源ID应该是多少，以便为下一个虚拟机分配。
注意：
资源池的初始顺序是从小到大。
资源池中空闲资源ID不足时，动态分配失败，对资源池不进行任何操作。指定分配资源ID已经被占用或者不在资源池范围内时，对资源池不进行任何操作。
释放资源ID不在资源池范围内时或者已经是空闲资源ID时，对资源池不进行任何操作。
保证每个用例最后都有空闲资源ID。
输入描述
输入第一行为两个整数 lll 和 rrr ，表示资源池的范围;
输入第二行为一个整数 ttt ，表示操作个数。
第三行开始，第一个数字代表操作类型 opopop ， 111 表示动态分配， 222 表示指定分配， 333 表示释放；
如果输入的第一个数字是 111 ，第二个表示分配的个数 numnumnum ；
如果输入的第一个数字是 222 ，第二个表示分配的资源ID；
如果输入的第一个数字是 333 ，第二个表示释放的资源ID。
1≤l<r≤1000001\le l\lt r \le 1000001≤l<r≤100000 ，1≤t≤1000001\le t \le 1000001≤t≤100000 ；
1≤op≤31\le op \le 31≤op≤3 ， 1≤num≤2001\le num\le 2001≤num≤200 。
输出描述
资源池的第一个空闲资源ID。
样例
样例一
输入
1 3
2
1 1
3 1

输出
2

样例解释
第一行资源池范围是 [1,3][1,3][1,3] ，资源池的初始顺序是 1−>2−>31->2->31−>2−>3 。
第二行操作个数有 222 个。
第三行动态分配 111 个资源ID，资源池中剩余的资源ID顺序是 2−>32->32−>3 。
第四行释放 111 个资源ID、资源ID是 111 ，资源池中剩余的资源ID顺序是 2−>3−>12->3->12−>3−>1 。
执行以上操作后，资源池的第一个空闲资源ID是 222 。
样例二
输入
1 3
3
2 2
3 2
1 1

输出
3

样例解释
第一行资源池范围是 [1,3][1,3][1,3] ，资源池的初始顺序是 1−>2−>31->2->31−>2−>3 。
第二行操作个数有 333 个。
第三行指定分配 111 个资源ID，资源ID是 222 ，资源池中剩余的资源ID顺序是 1−>3−>21->3->21−>3−>2 。
第四行释放 111 个资源ID，资源ID是 222 ，资源池中剩余的资源ID顺序是 1−>3−>21->3->21−>3−>2 。
第五行动态分配  111 个资源ID，分配的资源ID是 111 ，资源池中剩余的资源D顺序是 3−>23->23−>2 。
执行以上操作后，资源池的第一个空闲资源ID是 333 。

#### TextSol

题目描述
你是一名网络工程师，正在开发一个虚拟机管理系统，需要管理虚拟机的资源ID。为了确保每个虚拟机的ID唯一且可复用，你设计了一个资源池，支持三种操作：
动态分配：从资源池中按顺序分配指定数量的资源ID，适用于新创建的虚拟机。
指定分配：指定一个资源ID进行分配，适用于恢复或迁移的虚拟机。
释放资源：释放已经分配的资源ID，使其可再次使用。
每当资源ID被分配或释放时，资源池的管理会调整顺序，使得资源ID能够合理复用。你需要在执行操作后输出资源池的第一个空闲资源ID。
思路
数组模拟双向链表
思路步骤
1.初始化资源池：
给定资源池的范围 [l, r]，我们需要用两个数组分别表示每个资源ID的左邻居和右邻居，同时还需要一个数组表示某个资源ID是否被占用。
2.动态分配资源ID：
根据要求，动态分配会从资源池的开始位置，按顺序分配指定数量的ID。每次分配一个ID后，我们将其从可用资源链表中移除，并更新链表的头部指针。
3.指定分配资源ID：
如果指定分配的ID在资源池范围内且未被占用，则将其从可用链表中移除。如果该ID正好是资源池的头或尾，还需要特别处理。
4.释放资源ID：
释放的资源ID需要重新加入到资源池的尾部，同时恢复它与前后节点的连接。
5.操作执行后：
每次操作结束后，输出资源池中第一个空闲的资源ID。
引入链表后，带来新的问题:对于后两个操作，我们也需要同时删除/插入一个节点。单纯用链表是无法快速做到这一点的。
解决方法:直接使用数组ccc来模拟链表，具体实现见代码。
注意:华为OJ只给了100ms。这意味着你需要在极低的常数下通过这题。所以只有C/C++可能过这题。而且不仅需要使用C/C++，也不允许使用STL中的List，而是需要手写链表 。 这直接导致了本场成为华为春招最难的一场，通过率极低，估计只有10%。
代码说明
1.初始化链表：创建两个数组 L 和 R，分别表示每个资源ID的左邻居和右邻居；另一个数组 ud 用于标记每个资源ID是否被使用。
2.动态分配：
检查是否有足够的可用资源；
按顺序从链表中取出 num 个资源ID；
移除这些ID，并更新链表的头部。
3.指定分配：
检查指定的资源ID是否在范围内且未被占用；
将其从链表中移除，更新其前后连接。
4.释放资源ID：
检查释放的资源ID是否在范围内且已经被占用；
将其加入链表的尾部，更新链表的连接关系。
5.输出结果：
输出当前链表的第一个空闲资源ID，即当前的链表头部。
代码
C++
AC
#include <iostream>

using namespace std;

const int N = 100010;
int l, r;
int n;

// 每个节点的左节点和右节点
int L[N], R[N];
// 节点是否已经被使用
int ud[N];
// 剩余节点数量，当前起始节点，当前末尾节点
int remain, beg, ed;

int main()
{
cin >> l >> r;

// 建立“链表”关系
for(int i=l; i<=r; i++) {
L[i] = i-1;
R[i] = i+1;
}

cin >> n;

beg = l, ed = r;
remain = r-l+1;

for(int i=0; i<n; i++) {
int op, v;
cin >> op >> v;
if(op == 1) {
// 不够分配
if(remain < v) continue;
while(v--) {
// “孤立”当前节点
R[L[beg]] = R[beg];
L[R[beg]] = L[beg];
ud[beg] = 1;
remain--;
// 更新起始节点
beg = R[beg];
}
} else if(op == 2) {
if(v < l || v > r || ud[v]) continue;
// “孤立”当前节点
R[L[v]] = R[v];
L[R[v]] = L[v];
// 如果指定分配的节点是首尾节点，要特殊处理一下
if(v == beg) beg = R[v];
else if(v == ed) ed = L[v];

ud[v] = 1;
remain--;
} else {
if(v < l || v > r || !ud[v]) continue;
if(remain == 0) {
// 当前资源全部用完，特殊处理
beg = ed = v;
} else {
// 把当前节点放到最后，建立前后关系
R[ed] = v;
L[v] = ed;
ed = v;
}
ud[v] = 0;
remain++;
}
}
cout << beg << endl;
}
// by JAY

python
超时
class Node:
def __init__(self, r_id=None) -> None:
self.pre = None
self.next = None
self.r_id = r_id

dummy_head = Node() # 头部存储最近没使用过的结点
dummy_tail = Node() # 尾部存储最近刚使用过的结点
dummy_head.next = dummy_tail
dummy_tail.pre = dummy_head

id2node = {}

def addTail(node:Node):
global dummy_tail
dummy_tail.pre.next = node
node.pre = dummy_tail.pre
node.next = dummy_tail
dummy_tail.pre = node

def removeNode(node:Node):
node.pre.next = node.next
node.next.pre = node.pre

r1, r2 = [int(item) for item in input().split()]
for r_id in range(r1, r2+1):
node = Node(r_id)
id2node[r_id] = node
addTail(node)
t = int(input())

for _ in range(t):
op = [int(item) for item in input().split()]
# 动态删除最前面的多个
if op[0]==1:
delete_num = op[1]
if delete_num>len(id2node): # 资源池中空闲资源不足时，动态分配失败，对资源池不进行任何操作。
continue
node = dummy_head.next
while node is not None and node.r_id is not None and delete_num>0:
removeNode(node)
del id2node[node.r_id]
delete_num-=1
node = node.next
# 删除指定的某个
elif op[0]==2:
delete_id = op[1]
if delete_id>=r1 and delete_id<=r2 and delete_id in id2node:
node = id2node[delete_id]
removeNode(node)
del id2node[node.r_id]
# 添加一个到尾部
elif op[0]==3:
add_id = op[1]
if add_id not in id2node:
node = Node(add_id)
addTail(node)
id2node[add_id] = node
print(dummy_head.next.r_id)

Java
超时
import java.util.*;

public class Main {
public void solution(){
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
int[] inDegree = new int[n + 1];
inDegree[0] = -1;
ArrayList<Integer>[] outDegree = new ArrayList[n + 1];
for(int i = 1; i <= n; ++i){
int m = scanner.nextInt();
inDegree[i] += m;
for(int j = 0; j < m; ++j){
int from = scanner.nextInt();
if(outDegree[from] == null)
outDegree[from] = new ArrayList<>();
outDegree[from].add(i);
}
}
scanner.close();
int res = 0;
boolean check;
Queue<Integer> queue = new LinkedList<>();
do {
check = false;
for(int i = 1; i < inDegree.length; ++i){
if(inDegree[i] == 0){
inDegree[i] = -1;
check = true;
queue.offer(i);
}
}
if(check)
res += 1;
while(!queue.isEmpty()){
int from = queue.poll();
if(outDegree[from] == null)
continue;
for(int i = 0; i < outDegree[from].size(); ++i)
--inDegree[outDegree[from].get(i)];
}
}while(check);
for(int i = 1; i < inDegree.length; ++i){
if(inDegree[i] != -1){
System.out.println(-1);
return;
}
}
System.out.println(res);
}
public static void main(String[] args) {
Main m = new Main();
m.solution();
}
}

Go
能够AC，出自233大佬之手！
package main

import "io/ioutil"
import "os"

func read(buf []byte) (int, []byte) {
for buf[0] < '0' || buf[0] > '9' {
buf = buf[1:]
}
ans := 0
for len(buf) > 0 && buf[0] >= '0' && buf[0] <= '9' {
ans = ans * 10 + int(buf[0]) - '0'
buf = buf[1:]
}
return ans, buf
}

func write(out []byte, x int) []byte {
cnt := 0
for x != 0 {
out = append(out, byte(x % 10 + '0'))
x /= 10
cnt++
}
s := out[len(out) - cnt:]
l, r := 0, cnt - 1
for l < r {
s[l], s[r] = s[r], s[l]
l++
r--
}
return out
}

func endl(out []byte) []byte {
return append(out, '\n')
}

const maxn int = 3000001
var nxt, pre, val, id [maxn]int

func main() {
buf, err := ioutil.ReadAll(os.Stdin)
if err != nil {
return
}
out := make([]byte, 0)

l, buf := read(buf)
r, buf := read(buf)
t, buf := read(buf)
head, curr, total := 0, 0, 0
mem := r - l + 1
for i := l; i <= r; i++ {
total++
val[total] = i
id[i] = total
pre[total] = curr
nxt[curr] = total
curr = total
}
total++
tail := total
nxt[total - 1] = tail
pre[tail] = total - 1

for i := 1; i <= t; i++ {
var op, num int
op, buf = read(buf)
num, buf = read(buf)
if op == 1 {
if mem >= num {
mem -= num
for i := nxt[head]; num > 0; num-- {
id[val[i]] = 0
val[i] = 0
nxt[pre[i]] = nxt[i]
pre[nxt[i]] = pre[i]
nxtnode := nxt[i]
nxt[i], pre[i] = -1, -1
i = nxtnode
}
}
} else if op == 2 {
if id[num] != 0 {
node := id[num]
pre[nxt[node]] = pre[node]
nxt[pre[node]] = nxt[node]
id[num] = 0
val[node] = 0
nxt[node], pre[node] = -1, -1
mem--
}
} else {
if id[num] == 0 && num >= l && num <= r {
total++
id[num] = total
val[total] = num
pre[total] = pre[tail]
nxt[pre[tail]] = total

nxt[total] = tail
pre[tail] = total
mem++
}
}
}
out = write(out, val[nxt[head]])
out = endl(out)
os.Stdout.Write(out)
}

Js
超时...
/* JavaScript Node ACM模式 控制台输入获取 */
const readline = require("readline");

const rl = readline.createInterface({
input: process.stdin,
output: process.stdout,
});

const lines = [];
// 资源池范围
let start, end;
// 操作个数
let n;
rl.on("line", (line) => {
lines.push(line);

if (lines.length == 1) {
[start, end] = lines[0].split(" ").map(Number);
}

if (lines.length == 2) {
n = lines[1] - 0;
}

if (n && lines.length == n + 2) {
// 资源池
const link = new Set();
for (let i = start; i <= end; i++) link.add(i);
// 操作
const operates = lines.slice(2).map((line) => line.split(" ").map(Number));
console.log(getResult(start, end, link, operates));
lines.length = 0;
}
});

function getResult(start, end, link, operates) {
// 操作类型,操作数
for (let [type, val] of operates) {
switch (type) {
case 1:
// 如果操作类型是1，即动态分配，那么操作数含义就是：分配次数
// 【资源池中空闲资源ID不足时，动态分配失败，对资源池不进行任何操作】
// while (link.size > 0 && val > 0) {
//   const [num] = link;
//   link.delete(num);
//   val--;
// }

if (val >= link.size) link.clear();
else {
link = new Set([...link].slice(val));
}

break;
case 2:
// 如果操作类型是2，即指定分配，那么操作数含义就是：分配的资源ID
// 【指定分配资源ID已经被占用或者不在资源池范围内时，对资源池不进行任何操作】
link.delete(val);
break;
case 3:
// 如果操作类型是3，即释放，那么操作数含义就是：释放的资源ID
// 【释放资源ID不在资源池范围内时或者已经是空闲资源ID时，对资源池不进行任何操作】
if (start <= val && val <= end) link.add(val);
break;
}
}

const [ans] = link;
return ans;
}

注意：
100ms，基本就意味着除cpp以外，其他语言不太能通过了。
--------------------4-27更新----------------
根据群友消息，由于本场题目确实太难，相较通过率太低，所以华子HR决定这次没过的可以重考，参加下次的5.6的笔试!

---

### 第2题-加法（P2390）
- 链接：https://codefun2000.com/p/P2390

> 页面标题：#P2390. 第2题-加法

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一个喜欢数学的小学生，他经常在课余时间玩一些有趣的数学游戏。有一天，他收到了一封神秘的信件，信上写着一个两个数的加法表达式，这个表达式中不止有阿拉伯数字，还有可能包含小数点字符与特殊字符，特殊字符包括 !@# 。信上还附有一张纸条，上面写着特殊字符加法的规则。
信上还说，如果小明能正确地计算出表达式的结果，并在三天内回信，就能得到一个惊喜的礼物。小明才刚刚学会个位数加法，所以他现在有些没办法解决这个问题，但是他很想得到这份礼物，所以你能帮他解决这个问题吗？
特殊字符的加法运算规则如下：
!+!=0 !+@=13 !+#=4 @+@=7 @+#=20 #+#=5
注意： 题目保证输入表达式有解。
输入描述
输入第一行为一个整数 lenlenlen ，表示加法表达式的长度。（ 1≤len≤10001\le len \le 10001≤len≤1000 ）
输入第二行为一个长度为 lenlenlen 的字符串，表示加法表达式。
输出描述
输出为一个整数 ansansans ，表示表达式的运算结果。（输出结果忽略前导零和后导零，并且当小数点后面为0时只需要输出整数）
样例一
输入
14
#9.@527+#4.!19

输出
64.3717

样例解释
由#+#=5 ,@+!=13，得列竖式有
#9.@527
+  #4.!19
——————————
64.3717

样例二
输入
13
9#.#95+9@.@65

输出
202.16

样例解释
由#+@=20，得列竖式有
9#.#95
+ 9@.@65
————————
202.160

#### TextSol

题面解释：塔子哥是一个喜欢数学的小学生，他在课余时间经常玩一些有趣的数学游戏。有一天，他收到了一个神秘的信件，信中写着一个包含阿拉伯数字、小数点和特殊字符的加法表达式。这些特殊字符包括 !、@ 和 #，并且它们之间的加法运算规则如下：! + ! = 0、! + @ = 13、! + # = 4、@ + @ = 7、@ + # = 20 和 # + # = 5。为了能够正确计算出这个表达式的结果并在三天内回信，塔子哥需要你的帮助。输入的第一行为一个整数 len，表示加法表达式的长度（1≤len≤10001 \leq len \leq 10001≤len≤1000）；第二行为一个长度为 len 的字符串，表示加法表达式。输出一个整数或小数 ans，表示表达式的运算结果，输出结果应忽略前导零和后导零，并且当小数点后面为0时只需要输出整数部分。
题解
这道题目要求我们模拟两个数的加法，其中数的形式包含阿拉伯数字、小数点及特殊字符（!、@、#）。由于这些特殊字符之间有特定的加法规则，我们需要根据这些规则进行处理。
解决思路

解析输入：首先读取表达式长度和表达式字符串，找到加号 + 的位置，将表达式分为两个部分。
处理小数点：为了方便后续计算，我们确保两个数都有小数部分。如果没有小数部分，则在后面加上 .0。
分离整数部分和小数部分：分别提取出整数部分和小数部分。
模拟加法：

小数部分加法：从小数部分开始逐位相加，并处理进位。
整数部分加法：同样逐位相加，注意进位。

格式化输出：在输出结果时，去掉不必要的前导零和后导零，并根据规则决定是否输出小数点后面的零。

代码分析
这段代码实现了对包含阿拉伯数字、小数点和特殊字符（!、@、#）的加法表达式的模拟加法运算。主要步骤包括：

变量定义：使用了 n 来存储输入的表达式长度，s 用于存储加法表达式，t 用于追踪进位。

特殊字符加法规则：get 函数处理特殊字符之间的加法运算，根据字符组合返回相应的结果。

小数部分加法：suf_add 函数从小数部分逐位加法，调用 get 函数处理特殊字符，并在计算过程中管理进位。

整数部分加法：pre_add 函数与小数部分类似，从整数部分进行逐位加法，并在结束后处理剩余的进位。

主函数逻辑：主函数读取输入，查找加号并分割字符串，确保每部分都有小数点，最后调用相应的加法函数计算结果，并格式化输出，去除多余的零。

Python代码
_ = input()  # 读取输入长度，实际未使用
a, b = input().split('+')  # 读取加法表达式，分割成两个部分 a 和 b

# 分割整数部分和小数部分
if '.' in a:
a_int, a_dec = a.split('.')  # 如果 a 中有小数点，分割为整数和小数部分
else:
a_int, a_dec = a, ''  # 如果没有小数点，小数部分为空

if '.' in b:
b_int, b_dec = b.split('.')  # 如果 b 中有小数点，分割为整数和小数部分
else:
b_int, b_dec = b, ''  # 如果没有小数点，小数部分为空

# 分别对齐整数部分和小数部分
if len(a_int) > len(b_int):
# 如果 a 的整数部分较长，则在 b 的整数部分前补零
b_int = '0' * (len(a_int) - len(b_int)) + b_int
else:
# 如果 b 的整数部分较长，则在 a 的整数部分前补零
a_int = '0' * (len(b_int) - len(a_int)) + a_int

# 对齐小数部分
if len(a_dec) > len(b_dec):
# 如果 a 的小数部分较长，则在 b 的小数部分后补零
b_dec = b_dec + '0' * (len(a_dec) - len(b_dec))
else:
# 如果 b 的小数部分较长，则在 a 的小数部分后补零
a_dec = a_dec + '0' * (len(b_dec) - len(a_dec))

# 定义一位的加法运算函数, carry为进位
def sym_add(x, y, carry):
# 定义特殊字符的加法规则
rule = {
'!!': 0,
'!@': 13, '@!': 13,
'!#': 4, '#!': 4,
'@@': 7,
'@#': 20, '#@': 20,
'##': 5
}

if x in '!@#':  # 如果 x 是特殊字符
s = str(rule[x+y] + carry)  # 根据规则计算加法结果
else:
s = str(int(x) + int(y) + carry)  # 否则直接进行数字加法

# 如果结果只有一位，返回结果和进位0
if len(s) == 1:
return s, 0
else:
return s[1], int(s[0])  # 否则返回当前位和进位

# 计算小数部分
ans, carry = '', 0  # 初始化结果和进位
for i in reversed(range(len(a_dec))):  # 从小数部分的最后一位开始计算
res, carry = sym_add(a_dec[i], b_dec[i], carry)  # 进行加法运算
ans = res + ans  # 结果前插入当前位

# 添加小数点
ans = '.' + ans  # 在结果前添加小数点

# 计算整数部分
for i in reversed(range(len(a_int))):  # 从整数部分的最后一位开始计算
res, carry = sym_add(a_int[i], b_int[i], carry)  # 进行加法运算
ans = res + ans  # 结果前插入当前位

if carry != 0:  # 如果最后还有进位，添加到结果前面
ans = str(carry) + ans

# 去除前导0和后导0
ans = ans.strip('0')  # 去除结果中的前导0

# 有可能整数部分只有0, 去除前导0后就没有整数部分了, 因此要补一个0
if ans[0] == '.':  # 如果结果以小数点开头
ans = '0' + ans  # 在前面补零

# 如果没有小数部分, 那么小数点也应该去掉
if ans[-1] == '.':  # 如果结果以小数点结尾
ans = ans[:-1]  # 去掉小数点

print(ans)  # 输出最终结果

Java
import java.util.ArrayList;
import java.util.Scanner;

public class Main {

public static ArrayList<Character> A = new ArrayList<>(), B = new ArrayList<>(), res = new ArrayList<>();
public static ArrayList<Character> A1 = new ArrayList<>(), B1 = new ArrayList<>(), res1 = new ArrayList<>();

static int flag = 0;

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int n = in.nextInt();
String s = in.next();
String[] split = s.split("\\+");
String a = split[0];
String b = split[1];
if(a.contains(".") && b.contains(".")){
String[] sa = a.split("\\.");
String[] sb = b.split("\\.");
String s1 = sa[1].length() >= sb[1].length() ? sa[1] : sb[1];
String s2 = sa[1].length() >= sb[1].length() ? sb[1] : sa[1];
int x = s1.length()-s2.length();
for(int i=1;i<=x;i++){
s2 = s2 + "0";
}
for (int i = s1.length()-1; i >= 0; i--){
A1.add(s1.charAt(i));
B1.add(s2.charAt(i));
}
add1();
s1 = sa[0].length() >= sb[0].length() ? sa[0] : sb[0];
s2 = sa[0].length() >= sb[0].length() ? sb[0] : sa[0];
//这里就是反着装进list
for (int i = s1.length()-1; i >= 0; i--) A.add(s1.charAt(i));
for (int i = s2.length()-1; i >= 0; i--) B.add(s2.charAt(i));
add();
}else if(a.contains(".")){
String[] sa = a.split("\\.");
String s1 = sa[0].length() >= b.length() ? sa[0] : b;
String s2 = sa[0].length() >= b.length() ? b : sa[0];
//这里就是反着装进list
for (int i = s1.length()-1; i >= 0; i--) A.add(s1.charAt(i));
for (int i = s2.length()-1; i >= 0; i--) B.add(s2.charAt(i));
add();
for (int i = sa[1].length()-1; i >=0; i--) {
res1.add(sa[1].charAt(i));
}
}else if(b.contains(".")){
String[] sa = b.split("\\.");
String s1 = sa[0].length() >= a.length() ? sa[0] : a;
String s2 = sa[0].length() >= a.length() ? a : sa[0];
//这里就是反着装进list
for (int i = s1.length()-1; i >= 0; i--) A.add(s1.charAt(i));
for (int i = s2.length()-1; i >= 0; i--) B.add(s2.charAt(i));
add();
for (int i = sa[1].length()-1; i >=0; i--) {
res1.add(sa[1].charAt(i));
}
}else{
for (int i = a.length()-1; i >= 0; i--) A.add(a.charAt(i));
for (int i = b.length()-1; i >= 0; i--) B.add(b.charAt(i));
add();

}

// 先算小数
StringBuilder string = new StringBuilder();

//因为是反着装进list的，输出就得从末尾开始输出，例如751->157
//        for (int i = res.size()-1; i>=0; i--) System.out.print(res.get(i));
//        System.out.print(".");
//        for (int i = res1.size()-1; i>=0; i--) System.out.print(res1.get(i));

for (int i = res.size()-1; i>=0; i--){
string.append(res.get(i));
}
string.append('.');
for (int i = res1.size()-1; i>=0; i--){
string.append(res1.get(i));
}
while(string.charAt(string.length()-1)=='0'){
string.deleteCharAt(string.length()-1);
}
if(string.charAt(string.length()-1)=='.')
string.deleteCharAt(string.length()-1);
while(string.charAt(0)=='0'&&string.length()>1){
string.deleteCharAt(0);
}
System.out.println(string.toString());

}

//这里就是最基础的十进制加法，将A和B的当前位加在一起，需要进位就靠t/=10来判断进位
public static void add() {
//如果之前一位进位了，那么t就是1，没进位t就是0
int t = flag;
for (int i = 0; i < B.size(); i++) {
char num1 = A.get(i);
char num2 = B.get(i);
if(num1>='0'&&num1<='9'&&num2>='0'&&num2<='9')t+=num2-'0'+num1-'0';
else if(num1=='!'&&num2=='!')t=t;
else if(num1=='!'&&num2=='@'||num1=='@'&&num2=='!')t+=13;
else if(num1=='!'&&num2=='#'||num1=='#'&&num2=='!')t+=4;
else if(num1=='@'&&num2=='#'||num1=='#'&&num2=='@')t+=20;
else if(num1=='@'&&num2=='@')t+=7;
else if(num1=='#'&&num2=='#')t+=5;
res.add( (char)((t % 10) + '0') );
t /= 10;
}
for (int i = B.size(); i < A.size(); i++) {
int num= A.get(i);
t = num - '0' + t;
res.add((char)((t % 10) + '0'));
t /= 10;
}
//特判，如果a和b长度一样且a的最高位加b的最高位进位的话，t还保留着进位信息，加到res就好
if (t > 0) res.add((char)(t+'0'));
}
public static void add1() {
//如果之前一位进位了，那么t就是1，没进位t就是0
int t = 0;
for (int i = 0; i < A1.size(); i++) {
char num1 = A1.get(i);
char num2 = B1.get(i);
if(num1>='0'&&num1<='9'&&num2>='0'&&num2<='9')t+=num2-'0'+num1-'0';
else if(num1=='!'&&num2=='!')t=t;
else if(num1=='!'&&num2=='@'||num1=='@'&&num2=='!')t+=13;
else if(num1=='!'&&num2=='#'||num1=='#'&&num2=='!')t+=4;
else if(num1=='@'&&num2=='#'||num1=='#'&&num2=='@')t+=20;
else if(num1=='@'&&num2=='@')t+=7;
else if(num1=='#'&&num2=='#')t+=5;
res1.add((char)((t % 10) + '0') );
t /= 10;
}
//特判，如果a和b长度一样且a的最高位加b的最高位进位的话，t还保留着进位信息，加到res就好
if (t > 0) flag = t;
}
}

Cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>

#define x first
#define y second

using namespace std;

typedef long long ll;
typedef pair<int, int> pii;

const int N = 1010;

int n;              // 表达式的长度
string s;          // 存储输入的加法表达式
int t = 0;         // 全局变量，记录进位

// 处理特殊字符的加法运算
int get(char a, char b) {
if (a == '!' && b == '!') return 0;
else if (a == '!' && b == '@') return 13;
else if (a == '!' && b == '#') return 4;
else if (a == '@' && b == '@') return 7;
else if (a == '@' && b == '#') return 20;
else if (a == '#' && b == '#') return 5;
return get(b, a);  // 如果找不到规则，调换字符顺序
}

// 小数部分加法
string suf_add(string a, string b) {
string res = ""; // 存储结果
for (int i = max(a.size(), b.size()) - 1; ~i; i--) {
char c = '0', d = '0'; // 默认字符为'0'
if (i < (int)a.size()) c = a[i]; // 取出当前位
if (i < (int)b.size()) d = b[i]; // 取出当前位

// 判断是否是特殊字符并进行加法计算
if (!isdigit(c) && !isdigit(d)) t += get(c, d);
else t += c - '0' + d - '0'; // 阿拉伯数字相加

res += to_string(t % 10); // 结果的当前位
t /= 10; // 更新进位
}
reverse(res.begin(), res.end()); // 反转结果
while (res.size() > 1 && res.back() == '0') res.pop_back(); // 去除末尾零
return res;
}

// 整数部分加法
string pre_add(string a, string b) {
reverse(a.begin(), a.end()); // 反转字符串以便从低位开始加
reverse(b.begin(), b.end());
string res = "";
for (int i = 0; i < (int)a.size() || i < (int)b.size(); i++) {
char c = '0', d = '0';
if (i < (int)a.size()) c = a[i]; // 取出当前位
if (i < (int)b.size()) d = b[i]; // 取出当前位

// 判断是否是特殊字符并进行加法计算
if (!isdigit(c) && !isdigit(d)) t += get(c, d);
else t += c - '0' + d - '0';

res += to_string(t % 10); // 结果的当前位
t /= 10; // 更新进位
}
// 处理最后的进位
while (t) {
res += to_string(t % 10);
t /= 10;
}
while (res.size() > 1 && res.back() == '0') res.pop_back(); // 去除末尾零
reverse(res.begin(), res.end()); // 反转回原来的顺序
return res;
}

int main() {
cin >> n >> s; // 输入长度和表达式
int pos = s.find('+'); // 查找加号的位置
string a = s.substr(0, pos), b = s.substr(pos + 1); // 分割成两部分
if (a.find('.') == a.npos) a += ".0"; // 若没有小数点，加上.0
if (b.find('.') == b.npos) b += ".0"; // 若没有小数点，加上.0
int pos_a = a.find('.'), pos_b = b.find('.'); // 找到小数点的位置
string pre_a = a.substr(0, pos_a), suf_a = a.substr(pos_a + 1); // 分离整数和小数部分
string pre_b = b.substr(0, pos_b), suf_b = b.substr(pos_b + 1);

// 先计算小数部分，再计算整数部分
string suf_res = suf_add(suf_a, suf_b);
string pre_res = pre_add(pre_a, pre_b);

// 输出结果
cout << pre_res;
if (suf_res != "0") cout << '.' << suf_res; // 如果小数部分不为零，则输出
return 0;
}

javaScript
const readline = require("readline");

const rl = readline.createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readLine = async () => (await iter.next()).value;

let A = [], B = [], res = [];
let A1 = [], B1 = [], res1 = [];
let flag = 0;

async function main() {
let n = parseInt(await readLine());
let s = await readLine();
let [a, b] = s.split("+");

if (a.includes(".") && b.includes(".")) {
let [intA, fracA] = a.split(".");
let [intB, fracB] = b.split(".");

let s1 = fracA.length >= fracB.length ? fracA : fracB;
let s2 = fracA.length >= fracB.length ? fracB : fracA;

let x = s1.length - s2.length;
s2 = s2.padEnd(s1.length, "0");

for (let i = s1.length - 1; i >= 0; i--) {
A1.push(s1[i]);
B1.push(s2[i]);
}
add1();

s1 = intA.length >= intB.length ? intA : intB;
s2 = intA.length >= intB.length ? intB : intA;

for (let i = s1.length - 1; i >= 0; i--) A.push(s1[i]);
for (let i = s2.length - 1; i >= 0; i--) B.push(s2[i]);

add();
} else if (a.includes(".")) {
let [intA, fracA] = a.split(".");
let s1 = intA.length >= b.length ? intA : b;
let s2 = intA.length >= b.length ? b : intA;

for (let i = s1.length - 1; i >= 0; i--) A.push(s1[i]);
for (let i = s2.length - 1; i >= 0; i--) B.push(s2[i]);

add();
for (let i = fracA.length - 1; i >= 0; i--) {
res1.push(fracA[i]);
}
} else if (b.includes(".")) {
let [intB, fracB] = b.split(".");
let s1 = intB.length >= a.length ? intB : a;
let s2 = intB.length >= a.length ? a : intB;

for (let i = s1.length - 1; i >= 0; i--) A.push(s1[i]);
for (let i = s2.length - 1; i >= 0; i--) B.push(s2[i]);

add();
for (let i = fracB.length - 1; i >= 0; i--) {
res1.push(fracB[i]);
}
} else {
for (let i = a.length - 1; i >= 0; i--) A.push(a[i]);
for (let i = b.length - 1; i >= 0; i--) B.push(b[i]);
add();
}

let resultString = [];

for (let i = res.length - 1; i >= 0; i--) {
resultString.push(res[i]);
}
resultString.push('.');
for (let i = res1.length - 1; i >= 0; i--) {
resultString.push(res1[i]);
}

while (resultString[resultString.length - 1] === '0') {
resultString.pop();
}

if (resultString[resultString.length - 1] === '.') {
resultString.pop();
}

while (resultString[0] === '0' && resultString.length > 1) {
resultString.shift();
}

console.log(resultString.join(""));
rl.close();
}

// 执行大数加法
function add() {
let t = flag;
for (let i = 0; i < B.length; i++) {
let num1 = A[i], num2 = B[i];
if (num1 >= '0' && num1 <= '9' && num2 >= '0' && num2 <= '9') t += parseInt(num1) + parseInt(num2);
else if (num1 === '!' && num2 === '@' || num1 === '@' && num2 === '!') t += 13;
else if (num1 === '!' && num2 === '#' || num1 === '#' && num2 === '!') t += 4;
else if (num1 === '@' && num2 === '#' || num1 === '#' && num2 === '@') t += 20;
else if (num1 === '@' && num2 === '@') t += 7;
else if (num1 === '#' && num2 === '#') t += 5;
res.push((t % 10).toString());
t = Math.floor(t / 10);
}
for (let i = B.length; i < A.length; i++) {
t += parseInt(A[i]);
res.push((t % 10).toString());
t = Math.floor(t / 10);
}
if (t > 0) res.push(t.toString());
}

// 处理小数部分的加法
function add1() {
let t = 0;
for (let i = 0; i < A1.length; i++) {
let num1 = A1[i], num2 = B1[i];
if (num1 >= '0' && num1 <= '9' && num2 >= '0' && num2 <= '9') t += parseInt(num1) + parseInt(num2);
else if (num1 === '!' && num2 === '@' || num1 === '@' && num2 === '!') t += 13;
else if (num1 === '!' && num2 === '#' || num1 === '#' && num2 === '!') t += 4;
else if (num1 === '@' && num2 === '#' || num1 === '#' && num2 === '@') t += 20;
else if (num1 === '@' && num2 === '@') t += 7;
else if (num1 === '#' && num2 === '#') t += 5;
res1.push((t % 10).toString());
t = Math.floor(t / 10);
}
if (t > 0) flag = t;
}

main();

---

### 第2题-解密（P2386）
- 链接：https://codefun2000.com/p/P2386

> 页面标题：#P2386. 第2题-解密

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在全球恐怖主义危机下，一组间谍团队接收到了来自地下工作者的一串神秘代码。这组代码可以帮助他们访问恐怖分子的服务器，但是他们需要先解密代码才能使用它。代码是由数字000 - 999 组成的字符串 MMM，而解密过程需要一个秘钥数字 NNN 和一个运算符 kkk (加减乘中的一个)。
解密过程分为三个步骤：
第一步，团队成员需要使用秘钥数字 NNN 对 MMM 进行一系列 kkk 运算，并尝试截取其中的一段数字 xxx。如果 xxx 和 NNN 的运算结果是一个所有位数相同的数字，那么这段数字就有可能是真正的密码。例如，如果 xxx 为 111111111，NNN 为 222，kkk 为乘法，那么计算结果是 111×2=222111 \times 2 = 222111×2=222，满足条件，因此 111111111 就是所寻找的目标密码串之一。
第二步，如果存在多种满足第一点条件的情况，那么团队成员需要选择计算结果最大的一种作为真正的密码。
第三步，团队成员们需要在 MMM （MMM的长度不超过100） 中找到长度为 333 到 121212 位的密码串，并尝试使用秘钥数字 NNN 和运算符 kkk （kkk 为 +++ 或 −-− 或 ∗*∗的一种）进行解密。由于秘钥数字 NNN 可能非常大，因此需要确保 NNN 不大于 999999999999999999999999999999。另外，在乘法场景下，团队成员们约定乘数最大为 333 位数，以避免数据过于庞大。
如果没有找到符合条件的密码串，则输出 −1-1−1，表示密码串不存在。
输入描述
输入第一行为加密后的字符串MMM
输入第二行为密钥数字NNN
输入第三行为运算符kkk
输出
满足计算结果所有位数相同，且计算结果最大的值。
样例1
输入
6833023887793076998810418710
2211
-

输出
9988

解释：通过计算， 887788778877 - 221122112211= 666666666666 而 998899889988 - 221122112211 = 777777777777，因为777777777777 > 666666666666，则目标密码串为998899889988。
样例2
输入
68846787793076946788418710
4210
+

输出
884678

解释:通过计算，符合条件有两个，884678884678884678 + 421042104210 = 888888888888888888，467846784678 + 421042104210 = 888888888888。则目标密码串为884678884678884678。
样例3
输入
139804444677899222
2
*

输出
4444

解释:作为乘法场景，乘数最大值为 333 位数，本用例乘数为 222 。按要求，444444444444 * 222 = 888888888888， 222222222 * 222 = 444444444，均符合基本条件，从中选择结果最大值则目标密码串是444444444444。

#### TextSol

题解思路
本题要求从一个由数字组成的字符串 M 中找到一个子串，与一个给定的数字 N 进行运算（加、减、乘），使得运算结果符合以下条件：

结果的所有数位相同：即运算结果的每一位数都相同（例如 4444、77777 等）。
选择最大值：若有多个符合条件的子串，则选择运算结果最大的一个子串作为最终答案。

运算规则要求子串长度在 3 到 12 之间，并且在乘法运算的情况下，子串最多 3 位，以防止结果过大。
详细步骤

遍历子串：由于密码串的长度限制在 3 到 12 之间，因此我们可以枚举从 M 中提取不同长度的子串。以长度从 12 到 3 的顺序枚举，可以在找到符合要求的结果后提前结束遍历。

计算运算结果：

对每一个提取出的子串，根据运算符 k（加、减、乘），与密钥数字 N 进行计算，得到运算结果。
运算结果需要满足所有位数相同。为此，检查结果的各位数，判断其是否符合条件。

结果筛选：

如果运算结果的各位数相同且比当前最大值大，则更新最终结果。
若有多个符合条件的子串，则选择其中运算结果最大的子串。

终止条件：如果在当前长度的子串中找到满足要求的最大值，则直接输出结果。否则，继续尝试较短的子串，直到找到符合条件的结果。

复杂度分析

时间复杂度：对于字符串长度 N，子串的长度上限为 12，因此枚举子串的复杂度约为 O(N * 12)。对于每个子串，进行一次运算和检测符合条件的操作，时间复杂度为常数级。因此，整体时间复杂度为 O(N)。
空间复杂度：仅需常数空间存储运算结果和遍历子串，不涉及额外的复杂数据结构，因此空间复杂度为 O(1)。

代码实现
Python代码
def is_uniform(num):
"""检查一个数字的所有位是否相同"""
if num < 0:
return False  # 负数不符合条件
num_str = str(num)
return all(digit == num_str[0] for digit in num_str)

def main():
import sys

# 读取输入
M = sys.stdin.readline().strip()
N_str = sys.stdin.readline().strip()
k = sys.stdin.readline().strip()

# 尝试将 N 转换为整数，并进行基本验证
try:
N = int(N_str)
except ValueError:
print(-1)
return

# 检查 N 是否在有效范围内
if N < 0 or N > 9999999999:
print(-1)
return

# 如果运算符是乘法，检查 N 是否不超过 999
if k == '*':
if N > 999:
print(-1)
return

max_result = -1
target_password = -1

# 遍历子串长度从3到12
for length in range(3, min(len(M), 12) + 1):
for i in range(len(M) - length + 1):
substring = M[i:i + length]

# 跳过以0开头且长度大于1的子串
if substring[0] == '0' and length > 1:
continue

x = int(substring)

# 执行运算
if k == '+':
result = x + N
elif k == '-':
result = x - N
if result < 0:
continue  # 结果为负数，不符合条件
elif k == '*':
result = x * N
else:
continue  # 无效的运算符，跳过

# 检查结果是否所有位相同
if is_uniform(result):
if result > max_result:
max_result = result
target_password = substring

# 输出结果
print(target_password if target_password != -1 else -1)

if __name__ == "__main__":
main()

C++代码
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

// 检查一个数字的所有位是否相同
bool is_uniform(long long num) {
if (num < 0) return false; // 负数不符合条件
string num_str = to_string(num);
char first_digit = num_str[0];
for(char c : num_str){
if(c != first_digit){
return false;
}
}
return true;
}

int main(){
string M;
long long N;
char k;
cin >> M >> N >> k;

// 检查秘钥数字 N 是否在有效范围内
if(N < 0 || N > 9999999999){
cout << "-1" << endl;
return 0;
}

// 如果运算符是乘法，检查 N 是否不超过 999
if(k == '*' && N > 999){
cout << "-1" << endl;
return 0;
}

string target_password = "-1"; // 默认输出为 -1
long long max_result = -1; // 初始化最大结果为 -1
int len = M.length();

// 遍历所有可能的子串长度，从3到12
for(int length = 3; length <= min(12, len); length++){
for(int i = 0; i <= len - length; i++){
string substring = M.substr(i, length);

// 跳过以 '0' 开头且长度大于1的子串
if(substring[0] == '0' && length > 1){
continue;
}

long long x;
try{
x = stoll(substring);
}
catch(...){
continue; // 如果转换失败，跳过该子串
}

long long result;
if(k == '+'){
result = x + N;
}
else if(k == '-'){
result = x - N;
if(result < 0){
continue; // 结果为负数，不符合条件
}
}
else if(k == '*'){
result = x * N;
}
else{
continue; // 无效的运算符，跳过
}

// 检查运算结果是否所有位相同
if(is_uniform(result)){
if(result > max_result){
max_result = result;
target_password = substring;
}
}
}
}

cout << target_password << endl; // 输出结果
return 0;
}

Java代码
import java.util.Scanner;

public class Main {
/**
* 检查一个数字的所有位是否相同。
* @param num 要检查的数字。
* @return 如果所有位相同且非负，返回 true；否则返回 false。
*/
public static boolean isUniform(long num) {
if (num < 0) return false; // 负数不符合条件
String numStr = Long.toString(num);
char firstDigit = numStr.charAt(0);
for(int i = 1; i < numStr.length(); i++) {
if(numStr.charAt(i) != firstDigit){
return false;
}
}
return true;
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
String M = scanner.next();
long N;
try {
N = scanner.nextLong();
} catch(Exception e){
System.out.println("-1");
return;
}
String kStr = scanner.next();
if(kStr.length() == 0){
System.out.println("-1");
return;
}
char k = kStr.charAt(0);

// 检查秘钥数字 N 是否在有效范围内
if(N < 0 || N > 9999999999L){
System.out.println("-1");
return;
}

// 如果运算符是乘法，检查 N 是否不超过 999
if(k == '*' && N > 999){
System.out.println("-1");
return;
}

long maxResult = -1;
String targetPassword = "-1";
int len = M.length();

// 遍历所有可能的子串长度，从3到12
for(int length = 3; length <= Math.min(12, len); length++) {
for(int i = 0; i <= len - length; i++) {
String substring = M.substring(i, i + length);

// 跳过以 '0' 开头且长度大于1的子串
if(substring.charAt(0) == '0' && length > 1){
continue;
}

long x;
try {
x = Long.parseLong(substring);
} catch(NumberFormatException e){
continue; // 如果转换失败，跳过该子串
}

long result;
if(k == '+'){
result = x + N;
}
else if(k == '-'){
result = x - N;
if(result < 0){
continue; // 结果为负数，不符合条件
}
}
else if(k == '*'){
result = x * N;
}
else{
continue; // 无效的运算符，跳过
}

// 检查运算结果是否所有位相同
if(isUniform(result)){
if(result > maxResult){
maxResult = result;
targetPassword = substring;
}
}
}
}

System.out.println(targetPassword);
}
}

javascript
const readline = require("readline");

const rl = readline.createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readLine = async () => (await iter.next()).value;

/**
* 检查一个数字的所有位是否相同。
* @param {number} num 要检查的数字。
* @return {boolean} 如果所有位相同且非负，返回 true；否则返回 false。
*/
function isUniform(num) {
if (num < 0) return false; // 负数不符合条件
let numStr = num.toString();
let firstDigit = numStr[0];
return numStr.split("").every(digit => digit === firstDigit);
}

async function main() {
let M = await readLine(); // 读取第一个字符串
let N;

try {
N = BigInt(await readLine()); // 读取秘钥数字 N，使用 BigInt 以避免超出范围
} catch (e) {
console.log("-1");
return;
}

let kStr = await readLine();
if (kStr.length === 0) {
console.log("-1");
return;
}
let k = kStr[0]; // 获取运算符

// 检查秘钥数字 N 是否在有效范围内
if (N < 0 || N > 9999999999n) {
console.log("-1");
return;
}

// 如果运算符是乘法，检查 N 是否不超过 999
if (k === '*' && N > 999n) {
console.log("-1");
return;
}

let maxResult = -1n;
let targetPassword = "-1";
let len = M.length;

// 遍历所有可能的子串长度，从 3 到 12
for (let length = 3; length <= Math.min(12, len); length++) {
for (let i = 0; i <= len - length; i++) {
let substring = M.substring(i, i + length);

// 跳过以 '0' 开头且长度大于1的子串
if (substring[0] === '0' && length > 1) {
continue;
}

let x;
try {
x = BigInt(substring); // 使用 BigInt 处理大数
} catch (e) {
continue; // 如果转换失败，跳过该子串
}

let result;
if (k === '+') {
result = x + N;
} else if (k === '-') {
result = x - N;
if (result < 0) {
continue; // 结果为负数，不符合条件
}
} else if (k === '*') {
result = x * N;
} else {
continue; // 无效的运算符，跳过
}

// 检查运算结果是否所有位相同
if (isUniform(result)) {
if (result > maxResult) {
maxResult = result;
targetPassword = substring;
}
}
}
}

console.log(targetPassword);
rl.close();
}

// 运行主函数
main();

示例解释
对于输入示例：

若 M = "6833023887793076998810418710", N = 2211, k = '-'：

符合条件的子串有 8877 和 9988。 9988 - 2211 = 7777 是最大结果。

若 M = "68846787793076946788418710", N = 4210, k = '+'：

符合条件的子串为 884678，884678 + 4210 = 888888 是最大结果。

---

### 第2题-河流水质监测（P2383）
- 链接：https://codefun2000.com/p/P2383

> 页面标题：#P2383. 第2题-河流水质监测

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥接到一项任务，需要在一条长为 NNN 公里的河流上监测水质。河流沿线有 KKK 个候选地点适合建设水质监测站，每个监测站的覆盖半径为 RRR 公里，建设一个监测站的成本为 MMM。任务是计算出最少需要多少经费才能覆盖整条河流，如果无法通过在所有候选地点建设监测站来实现覆盖，则输出 "-1"。输入包括河流长度、覆盖半径、建设成本以及候选地点的具体位置，输出则是最少经费或 "-1"。
思路
区间覆盖模板题目，这道题和区间覆盖的区别在于区间固定，我们使用贪心去解决对应的问题。
对于地址iii，假设地址小于iii的都已经被覆盖，那么如果我们需要覆盖它，我们可以选择的基站位置在范围[i−R,i+R][i-R,i+R][i−R,i+R]内。假设现在存在两个基站xxx和yyy(y>x)(y>x)(y>x)都满足对应的要求，那么我们更偏向于选择yyy基站，因为y>xy>xy>x，这样yyy的基站可以比xxx基站覆盖更多后面的地址。
因此，我们对于每一个地址iii，我们都要进行for  j=min(N,i+R)  to   i−R+1，j−=1for~~ j = min(N, i+R)~~ to~~~ i-R+1，j-=1for  j=min(N,i+R)  to   i−R+1，j−=1的循环（这里枚举到i−R+1i-R+1i−R+1，而不枚举到i−Ri-Ri−R的原因在于一旦选择i−Ri-Ri−R这个基站，那么肯定存在大于jjj的部分实数地址无法被覆盖），从min(N,i+R)min(N,i+R)min(N,i+R)开始找基站，一旦找到就调用对应的基站。调用基站jjj后，那么我们范围[j−R,j+R][j-R,j+R][j−R,j+R]的所有地址都会被覆盖，因此，下一次我们需要枚举的地址应该从j+Rj+Rj+R开始（不是j+R+1j+R+1j+R+1，因为我们需要保证所有实数地址被覆盖，而不是所有整数地址被覆盖）。
代码
CPP
#include <bits/stdc++.h>
using namespace std;

int N, R, M; // 河流长度、监测站覆盖半径、单个监测站建设成本
int arr[3005]; // 用于记录候选基站位置

int main() {
cin >> N >> R >> M; // 输入河流长度、覆盖半径和建设成本
int num;
while (cin >> num) {
arr[num] = 1; // 将候选基站位置标记为1
}

int ans = 0; // 用于记录总费用
for (int i = 0; i <= N; i++) { // 遍历所有地址
bool f = false; // 标记当前地址是否找到可用基站
// 从当前地址向右寻找能够覆盖该地址的基站
for (int j = min(N, i + R); j >= i - R + 1; j--) { // 逆序查找
if (arr[j] == 1) { // 找到可用的基站
ans += M; // 增加建设成本
i = j + R - 1; // 更新下一个需要查找的地址为j+R
if (i + 1 == N) { // 特例处理：覆盖到N即可
cout << ans << endl; // 输出总费用
return 0;
}
f = true; // 标记找到基站
break; // 跳出内层循环
}
}
if (!f) { // 如果当前地址没有找到可用基站
cout << -1 << endl; // 输出-1表示无法覆盖
return 0;
}
}
cout << ans << endl; // 输出最终所需的总费用
return 0;
}

python
N, R, M = map(int, input().split())
arr = [0] * 3005
line = [int(i) for i in input().split()]#输入
for i in line:
arr[i] = 1
ans = 0
i = 0

while i <= N:#枚举所有地址
f = False
for j in range(min(i + R, N), i - R, -1):#找对应的基站
if arr[j] == 1:
ans += M
i = j + R - 1#下一次我们需要枚举的地址为j+R
if i + 1 == N:#特例，因为我们不需要覆盖大于N的部分实数地址，所以只要覆盖到N即可
print(ans)
exit(0)
f = True#一旦找到就记录，并且推出循环。
break
if not f:#没找到输出-1
print(-1)
exit(0)
i += 1
print(ans)

Java
import java.util.Scanner;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int N = scanner.nextInt();
int R = scanner.nextInt();
int M = scanner.nextInt();//输入
int[] arr = new int[3005];

for (int i = 0; i < 3005; i++) {
arr[i] = 0;
}
int num;
while(scanner.hasNext()){
num = scanner.nextInt();
arr[num] = 1;
}

int ans = 0;
int i = 0;

while (i <= N) { // 枚举所有地址
boolean f = false;

for (int j = Math.min(i + R, N); j >= Math.max(i - R + 1, 0); j--) { // 确保 j 不小于 0
if (arr[j] == 1) {
ans += M;
i = j + R - 1; // 下一次我们需要枚举的地址为 j+R

if (i + 1 >= N) { // 特例，因为我们不需要覆盖大于 N 的部分地址，所以只要覆盖到 N 即可
System.out.println(ans);
System.exit(0);
}

f = true; // 一旦找到就记录，并且退出循环。
break;
}
}

if (!f) { // 没找到输出 -1
System.out.println(-1);
System.exit(0);
}

i++;
}

System.out.println(ans);
}
}

Go
package main

import (
"fmt"
)

func main() {
var N, R, M int
fmt.Scan(&N, &R, &M)
arr := make([]int, 3005)//输入

var num int
for {
_, err := fmt.Scan(&num)
if err != nil {
break
}
arr[num] = 1
}

ans := 0
i := 0

for i <= N {//枚举所有地址
f := false

for j := min(N, i+R); j >= i - R + 1; j-- {//找对应的基站
if arr[j] == 1 {
ans += M
i = j + R - 1//下一次我们需要枚举的地址为j+R

if i+1 == N {//特例，因为我们不需要覆盖大于N的部分实数地址，所以只要覆盖到N即可
fmt.Println(ans)
return
}

f = true//一旦找到就记录，并且退出循环。
break
}
}

if !f {//没找到输出-1
fmt.Println(-1)
return
}

i++
}

fmt.Println(ans)
}

func min(a, b int) int {
if a < b {
return a
}
return b
}

Js
const readline = require('readline');

const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

let N, R, M;
let arr = new Array(3005).fill(0);

rl.question('', (line1) => {
const input1 = line1.trim().split(' ').map(Number);
N = input1[0];
R = input1[1];
M = input1[2];

rl.question('', (line2) => {
const input2 = line2.trim().split(' ').map(Number);
for (let i = 0; i < input2.length; i++) {
arr[input2[i]] = 1;
}//输入

let ans = 0;
let i = 0;

while (i <= N) {//枚举所有地址
let f = false;

for (let j = Math.min(i + R, N); j >= i - R + 1; j--) {//找对应的基站
if (arr[j] === 1) {
ans += M;
i = j + R - 1;//下一次我们需要枚举的地址为j+R

if (i + 1 === N) {//特例，因为我们不需要覆盖大于N的部分实数地址，所以只要覆盖到N即可
console.log(ans);
process.exit(0);
}

f = true;//一旦找到就记录，并且退出循环。
break;
}
}

if (!f) {//没找到输出-1
console.log(-1);
process.exit(0);
}

i++;
}

console.log(ans);
process.exit(0);
});
});

题目描述
小明接到一个新课题，监测一整条河流的水质。
目前小明选择了一条河流进行水质监测，长度为 NNN 公里。经过专业人员勘察，河流沿线有 KKK 个候选地点适合安装水质监测站，每个监测站可以覆盖的长度为半径 RRR 公里，单个监测站建设成本为 MMM 。
假设小明知道的河流是一条直线，请计算最少需要多少经费建设水质监测站才能完成对整条河流(也就是直线上的每一个实数点)的水质监测。
输入描述
输入第一行包含三个整数 NNN , RRR , MMM .(1≤N≤30001 \leq N \leq 30001≤N≤3000,10≤R≤200,1≤M≤10000010 \leq R \leq 200,1 \leq M \leq 10000010≤R≤200,1≤M≤100000 )
输入第二行包含 KKK 个整数 a1,a2…aKa_1,a_2…a_Ka1​,a2​…aK​ ,表示在高铁沿线的第a1，a2…aKa_1，a_2…a_Ka1​，a2​…aK​ 公里的地点可以建设基站.( 1≤K≤N,0≤ai≤N1 \leq K \leq N,0 \leq a_i \leq N1≤K≤N,0≤ai​≤N )
输出描述
输出一个整数，表示最少花费的经费，如果所有候选地点均建设了基站还是无法覆盖则输出 "-1" 。
样例1
样例输入
100 20 114514
10 30 50

样例输出
-1

样例2
样例输入
80 50 114514
0 20 40 60

样例输出
114514

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 74ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-海量日志抑制（P2380）
- 链接：https://codefun2000.com/p/P2380

> 页面标题：#P2380. 第2题-海量日志抑制

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

思路分析
本题要求设计一种算法机制来抑制重复日志，满足以下两个条件：

相同日志的抑制：如果在 10 毫秒内出现相同的日志，则只保留第一个。
相似日志的抑制：如果在 100 毫秒内出现 10 条相似的日志（去除数字后字符相同），则只保留前 9 条。

可以使用两种方法：

暴力双重循环：

遍历每个日志时，从前面已读取的有效日志中检查：

10 毫秒内的相同日志数量。
100 毫秒内的相似日志数量。

若满足抑制条件，则将日志标记为抑制日志。
时间复杂度为 O(n^2)，在最大数据量下可能存在性能问题。

滑动窗口 + 哈希表：

采用两个滑动窗口分别记录 10 毫秒和 100 毫秒内的日志信息。
使用两个哈希表分别记录 10 毫秒内相同日志的次数，以及 100 毫秒内相似日志的次数。
每次读入日志时，更新滑动窗口并维护哈希表。
根据哈希表的记录判断日志是否需要抑制。
时间复杂度为 O(n)，更适合处理大规模数据。

算法流程
步骤1：读取输入的日志数据。

遍历每一条日志，解析出时间戳和日志内容。
使用辅助函数 remove_digits 去除日志中的数字，以判断相似日志。

步骤2：维护滑动窗口和哈希表。

使用两个滑动窗口：

一个窗口记录 10 毫秒内的日志数量，以判断相同日志数量。
一个窗口记录 100 毫秒内的日志数量，以判断相似日志数量。

每次读取日志时，根据时间差更新滑动窗口，移除不在窗口范围内的日志，并更新哈希表。

步骤3：判断抑制条件。

若当前日志在 10 毫秒内有相同日志，或 100 毫秒内有 9 条相似日志，则标记为抑制日志。
否则，更新哈希表，将日志加入有效日志集合。

时间复杂度
该方法时间复杂度为 O(n)，其中 n 是日志条数，因为每个日志的判断和窗口更新操作都是常数级别。适合处理大规模数据。
代码实现
Python代码（暴力双重循环）
from collections import defaultdict

# 去除字符串中的数字，判断相似性
def remove_digits(s):
return ''.join([c for c in s if not c.isdigit()])

n = int(input())
logs = []
suppress_logs = []

# 读取每条日志
for _ in range(n):
s = input()
time, content = s.split(':')
time = int(time)
content_no_digits = remove_digits(content)

same_count = 0
similar_count = 0

# 检查是否存在10ms内相同日志，100ms内相似日志
for log_time, log_content, log_content_no_digits in logs:
if time - log_time < 10 and log_content == content:
same_count += 1
if time - log_time < 100 and log_content_no_digits == content_no_digits:
similar_count += 1

# 若满足抑制条件，添加至抑制日志列表
if same_count == 0 and similar_count < 9:
logs.append((time, content, content_no_digits))
else:
suppress_logs.append(s)

# 输出抑制日志
if suppress_logs:
print("\n".join(suppress_logs))
else:
print("None")

Java & C++ 代码
限于篇幅问题，这里只给出提交记录链接
C++ - 双重暴力解法
Java - 双重暴力解法
Python代码（滑动窗口 + 哈希表优化）
from collections import defaultdict

# 从字符串中去除数字，用于判断相似性
def remove_digits(s):
return ''.join([c for c in s if not c.isdigit()])

n = int(input())
logs = []
suppress_logs = []

# 哈希表记录10ms和100ms内日志出现次数
mp_10 = defaultdict(int)
mp_100 = defaultdict(int)

# 滑动窗口的起点
start_10 = 0
start_100 = 0

# 读取每条日志
for _ in range(n):
raw = input()
time, content = raw.split(':')
time = int(time)
content_no_digits = remove_digits(content)

# 移除10ms和100ms窗口之外的日志
while start_10 < len(logs) and time - logs[start_10][0] >= 10:
mp_10[logs[start_10][1]] -= 1
start_10 += 1
while start_100 < len(logs) and time - logs[start_100][0] >= 100:
mp_100[logs[start_100][2]] -= 1
start_100 += 1

# 判断是否抑制
if mp_10[content] >= 1 or mp_100[content_no_digits] >= 9:
suppress_logs.append(raw)
continue

# 更新哈希表及窗口日志
mp_10[content] += 1
mp_100[content_no_digits] += 1
logs.append((time, content, content_no_digits))

# 输出抑制日志
print("\n".join(suppress_logs))

代码注释说明

remove_digits 函数：该函数用于去除字符串中的数字，以便判断相似日志。只保留字母和符号的顺序。
暴力双重循环：遍历每一条日志时，向前检查是否满足抑制条件。
滑动窗口+哈希表：mp_10 和 mp_100 分别记录 10ms 和 100ms 窗口内的相同和相似日志次数。每次更新窗口时移除超出时间范围的日志记录。
输出结果：最终输出被判定为抑制的日志。

题目描述
小明的朋友是一位从事运维工作的专业人士。有一天，他突然有急事需要请假，但是他非常担心公司的系统运行日志出现海量日志的问题。这种问题是指系统打印了大量相同或相似内容的日志，导致有效信息难以被捕捉，甚至会影响系统的运行效率。为了避免这种情况发生，小明的朋友请求小明帮助管理系统的运行日志，并确保只记录有用的信息，避免无效日志的产生。对于运维而言，系统的运行日志是非常重要的，因为它包含了系统运行时的各种细节和提示信息，能够帮助运维人员诊断和解决各种问题。
小明针对海量日志的问题，提出了一种智能算法机制。避免在系统运行时产生大量日志。在这个问题中，我们将"海量日志"定义如下：在101010毫秒内（小于101010毫秒），如果打印了222条相同的日志，只保留第一条；在 100100100 毫秒内（小于 100100100毫秒），如果打印了101010条相似的日志，只保留前9条。按时间读取日志，若被读取的日志被判定为抑制日志，则其将不会记录到日志文件中,即删去这一项。
字符串s,ts,ts,t相似的定义:去除掉两者中所有数字后(相对顺序不发生改变)逐字符相等。则s,ts,ts,t相似
为了简化题意，使得他变成一道可以做的算法题，小明给出了以下条件，确保你能写好你的代码~

给定的输入保证后一条日志的时间戳不小于前一条。时间戳的取值范围是[1,10000][1,10000][1,10000]
日志内容长度在100010001000以内
所有数字均为正整数。

输入描述
本用例中的日志条数（最多不超过100010001000条）和时间戳：日志打印内容
输出描述
按时间戳输出被抑制的日志。
样例1
输入
5
100:1cbbb
100:2c3a2
102:2c3a2
102:2232c
103:2232c

输出
102:2c3a2
103:2232c

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 69ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第2题-园区规划（P2377）
- 链接：https://codefun2000.com/p/P2377

> 页面标题：#P2377. 第2题-园区规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

思路：搜索+剪枝
给定一个 n∗mn*mn∗m 的矩形，我们需要从中分割出若干个正方形，要求正方形个数最少，求该个数。
这道题初看很容易认为是用分治的做法，通过枚举分割长度将矩形分成两块，分别求两块最少能分割的正方形区域再相加，并不断递归求解。
先详细说明下错误的分治的做法：
假设当前矩形的长宽分别为 a、ba、ba、b，且有 a>ba \gt ba>b

枚举分割长度 iii (1≤i<a)(1 \le i \lt a)(1≤i<a)，从而得到两个大小的矩形 i∗bi*bi∗b 和 (a−i)∗b(a-i)*b(a−i)∗b
将两个矩形当成子问题，即求解两个矩形最少能分割出多少正方形，于是又回到第一步
直到到达边界条件 a=ba=ba=b ，此时能分割一个正方形，返回
在每次子问题求解完毕后，取两个子问题和的最小值作为当前矩形的最小值

但实际上看下样例2就会发现这样的解法是错误的，其分割方法很不规则，而分治的方法得到的分割方法很规则(因为每次都是整齐的分割成两个矩形，而样例2的分割是不整齐的)。分治在样例2上求出来的答案一般来说是8而不是6(可以自己尝试一下)。
由于样例2分割的不规则性，在发现分治无效后，也难以想到其它有效的解法。于是尝试使用搜索+剪枝求解。
(这其实是一个NP问题，但是当我们在比赛时，我们既不了解该问题，也不能想到有效的解法，就只能尝试用搜索方法尽可能拿分)
搜索规则如下：
定义 matrix[i][j]={false,true}matrix[i][j]=\left\{false,true\right\}matrix[i][j]={false,true} 表示该点是否已经被分割为了一个正方形

找到一个matrix[i][j]=falsematrix[i][j]=falsematrix[i][j]=false的点，即该点未被分割为正方形
尝试以该点为正方形第一个点(即左上角点)分割正方形，即枚举正方形长度，尝试分割一个固定边长的正方形
将分割的区域标记为truetruetrue，表示已经分割了正方形
重新回到第1步，直到无法找到未被标记的点

既然用了搜索，那肯定逃不掉的就是剪枝了，剪枝的方法有很多，这里提出几个主要的剪枝，有其它更优秀剪枝方法的可以自行添加：

记录当前已经找到的最小的答案，记为ansansans，在搜索过程中，如果当前统计的分割的正方形数(记为cntcntcnt)，有cnt≥anscnt \ge anscnt≥ans，说明继续找下去答案也不会更优了，可以直接回退
枚举分割正方形的边长时，从大往小枚举，这样能够尽早找到一个较小的答案，从而在后续搜索中减少搜索量

搜索的时间复杂度很难衡量，所以这里就不进行时间复杂度的计算了。
代码
C++
#include <iostream>
#include <cstdio>
using namespace std;

bool matrix[15][15];
int m,n;
int ans=1e9;

bool check(int x,int y,int len){
for(int i=0;i<len;++i){
for(int j=0;j<len;++j){
if(matrix[x+i][y+j]) return false;
}
}
return true;
}

void fill(int x,int y,int len){// 采用异或方法进行填充/取消填充
for(int i=0;i<len;++i){
for(int j=0;j<len;++j){
matrix[x+i][y+j]^=1;
}
}
}

void dfs(int x, int y, int cnt){
if(cnt>=ans) return;// 剪枝，当前记录数已经≥已记录的最小答案，不再进行搜索
if(x==m+1){// 填充完毕，更新答案
ans=cnt;
return;
}
if(y>n) dfs(x+1,1,cnt);
bool full=true;
for(int i=y;i<=n;++i){// 从当前行的第y个格子开始枚举，找到第一个没有填充的格子
if(!matrix[x][i]){// 当前格子未填充，尝试填充正方形
full=false;
for(int j=min(n-i+1,m-x+1);j>=1;--j){// 枚举填充正方形的边长，从长边开始枚举
if(check(x,i,j)){// 判断从第x行第i个格子开始能不能填充边长为j的长方形
fill(x,i,j);// 填充
dfs(x,y+j,cnt+1);// 填充完一个正方形，尝试下一次填充
fill(x,i,j);// 取消填充
}
}
break;// 尝试在当前格子填充正方形的所有情况已经全部考虑，直接弹出
}
}
if(full) dfs(x+1,1,cnt);// 当前行都填充了，搜索下一行
}

int main(){
scanf("%d %d",&m,&n);
dfs(1,1,0);
printf("%d",ans);

return 0;
}

python
def check(x, y, length):
# 判断从第x行第y个格子开始能否填充边长为length的正方形
for i in range(length):
for j in range(length):
if matrix[x+i][y+j]:
return False
return True

def fill(x, y, length):
# 采用异或方法进行填充/取消填充
for i in range(length):
for j in range(length):
matrix[x+i][y+j] ^= 1

def dfs(x, y, cnt):
global ans
if cnt >= ans:
return  # 剪枝，当前记录数已经≥已记录的最小答案，不再进行搜索
if x == m + 1:
ans = cnt  # 填充完毕，更新答案
return
if y > n:
dfs(x + 1, 1, cnt)
full = True
for i in range(y, n + 1):
# 从当前行的第y个格子开始枚举，找到第一个没有填充的格子
if not matrix[x][i]:  # 当前格子未填充，尝试填充正方形
full = False
for j in range(min(n - i + 1, m - x + 1), 0, -1):
# 枚举填充正方形的边长，从长边开始枚举
if check(x, i, j):
fill(x, i, j)  # 填充
dfs(x, y + j, cnt + 1)  # 填充完一个正方形，尝试下一次填充
fill(x, i, j)  # 取消填充
break  # 尝试在当前格子填充正方形的所有情况已经全部考虑，直接跳出循环
if full:
dfs(x + 1, 1, cnt)  # 当前行都填充了，搜索下一行

m = int(input())
n = int(input())
matrix = [[False] * 15 for _ in range(15)]
ans = 1e9
dfs(1, 1, 0)
print(ans)

Java
import java.util.Scanner;

public class Main {
static boolean[][] matrix = new boolean[15][15];
static int m, n;
static int ans = (int) 1e9;

static boolean check(int x, int y, int len) {
// 判断从第x行第y个格子开始能否填充边长为len的正方形
for (int i = 0; i < len; ++i) {
for (int j = 0; j < len; ++j) {
if (matrix[x + i][y + j])
return false;
}
}
return true;
}

static void fill(int x, int y, int len) {
// 采用异或方法进行填充/取消填充
for (int i = 0; i < len; ++i) {
for (int j = 0; j < len; ++j) {
matrix[x + i][y + j] ^= true;
}
}
}

static void dfs(int x, int y, int cnt) {
if (cnt >= ans)
return; // 剪枝，当前记录数已经≥已记录的最小答案，不再进行搜索
if (x == m + 1) {
ans = cnt; // 填充完毕，更新答案
return;
}
if (y > n)
dfs(x + 1, 1, cnt);
boolean full = true;
for (int i = y; i <= n; ++i) { // 从当前行的第y个格子开始枚举，找到第一个没有填充的格子
if (!matrix[x][i]) { // 当前格子未填充，尝试填充正方形
full = false;
for (int j = Math.min(n - i + 1, m - x + 1); j >= 1; --j) { // 枚举填充正方形的边长，从长边开始枚举
if (check(x, i, j)) { // 判断从第x行第i个格子开始能不能填充边长为j的正方形
fill(x, i, j); // 填充
dfs(x, y + j, cnt + 1); // 填充完一个正方形，尝试下一次填充
fill(x, i, j); // 取消填充
}
}
break; // 尝试在当前格子填充正方形的所有情况已经全部考虑，直接跳出循环
}
}
if (full)
dfs(x + 1, 1, cnt); // 当前行都填充了，搜索下一行
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
m = scanner.nextInt();
n = scanner.nextInt();
dfs(1, 1, 0);
System.out.println(ans);
scanner.close();
}
}

Go
package main

import "fmt"

var matrix [15][15]bool
var m, n int
var ans = int(1e9)

func check(x, y, length int) bool {
// 判断从第x行第y个格子开始能否填充边长为length的正方形
for i := 0; i < length; i++ {
for j := 0; j < length; j++ {
if matrix[x+i][y+j] {
return false
}
}
}
return true
}

func fill(x, y, length int) {
// 采用异或方法进行填充/取消填充
for i := 0; i < length; i++ {
for j := 0; j < length; j++ {
matrix[x+i][y+j] = !matrix[x+i][y+j]
}
}
}

func dfs(x, y, cnt int) {
if cnt >= ans {
return // 剪枝，当前记录数已经≥已记录的最小答案，不再进行搜索
}
if x == m+1 {
ans = cnt // 填充完毕，更新答案
return
}
if y > n {
dfs(x+1, 1, cnt)
}
full := true
for i := y; i <= n; i++ {
// 从当前行的第y个格子开始枚举，找到第一个没有填充的格子
if !matrix[x][i] {
// 当前格子未填充，尝试填充正方形
full = false
for j := min(n-i+1, m-x+1); j >= 1; j-- {
// 枚举填充正方形的边长，从长边开始枚举
if check(x, i, j) {
fill(x, i, j)         // 填充
dfs(x, y+j, cnt+1)   // 填充完一个正方形，尝试下一次填充
fill(x, i, j)         // 取消填充
}
}
break // 尝试在当前格子填充正方形的所有情况已经全部考虑，直接跳出循环
}
}
if full {
dfs(x+1, 1, cnt) // 当前行都填充了，搜索下一行
}
}

func min(a, b int) int {
if a < b {
return a
}
return b
}

func main() {
fmt.Scan(&m, &n)
dfs(1, 1, 0)
fmt.Println(ans)
}

Js
function check(x, y, length) {
// 判断从第x行第y个格子开始能否填充边长为length的正方形
for (let i = 0; i < length; i++) {
for (let j = 0; j < length; j++) {
if (matrix[x + i][y + j]) {
return false;
}
}
}
return true;
}

function fill(x, y, length) {
// 采用异或方法进行填充/取消填充
for (let i = 0; i < length; i++) {
for (let j = 0; j < length; j++) {
matrix[x + i][y + j] = !matrix[x + i][y + j];
}
}
}

function dfs(x, y, cnt) {
if (cnt >= ans) {
return; // 剪枝，当前记录数已经≥已记录的最小答案，不再进行搜索
}
if (x === m + 1) {
ans = cnt; // 填充完毕，更新答案
return;
}
if (y > n) {
dfs(x + 1, 1, cnt);
}
let full = true;
for (let i = y; i <= n; i++) {
// 从当前行的第y个格子开始枚举，找到第一个没有填充的格子
if (!matrix[x][i]) {
// 当前格子未填充，尝试填充正方形
full = false;
for (let j = Math.min(n - i + 1, m - x + 1); j >= 1; j--) {
// 枚举填充正方形的边长，从长边开始枚举
if (check(x, i, j)) {
fill(x, i, j); // 填充
dfs(x, y + j, cnt + 1); // 填充完一个正方形，尝试下一次填充
fill(x, i, j); // 取消填充
}
}
break; // 尝试在当前格子填充正方形的所有情况已经全部考虑，直接跳出循环
}
}
if (full) {
dfs(x + 1, 1, cnt); // 当前行都填充了，搜索下一行
}
}

function main() {
const readline = require("readline");
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout,
});

rl.on("line", (line) => {
const input = line.split(" ").map(Number);
m = input[0];
n = input[1];
rl.close();
}).on("close", () => {
matrix = new Array(15).fill(false).map(() => new Array(15).fill(false));
dfs(1, 1, 0);
console.log(ans);
process.exit(0);
});
}

main();

题目描述
小明带领着一支拥有激情和创新的团队，决定建设一个全新的园区。他们经过深入调研和思考，最终选择了一块荒地，并开始了紧张而充满挑战的规划和建设工作。在大家的共同奋斗下，新园区建成了，它不仅令人刮目相看的现代化设计，更彰显着这个团队的勇气和实干精神。园区的诞生，也为附近居民和企业带来了无限机遇和福祉。
现在小明打算购买一块 mmm×\times×nnn 大小的土地，用于建设新土地。他希望将这块土地规划为尽可能少的正方形区域。他想起原先这个问题在acm竞赛中非常熟悉，但是由于他已经退役n年了，所以想寻求大家的帮助。
请注意，规划完这块土地以后，应该满足一个状态：没有任何一个正方形能放入！
输入描述
输入第一行为一个整数mmm。
输入第二行为一个整数nnn。
其中1≤\leq≤mmm≤\leq≤131313，111 ≤\leq≤ nnn ≤\leq≤131313.
输出描述
输出为一个整数，表示最少能规划块区域的数量.
样例1
输入
3
2

输出
3

解释
最少能规划块333个区域。
先规划111个222 ×\times× 222
剩下区域规划222个 111 ×\times× 111
样例2
输入
13
11

输出
6

解释
最少能规划块 666.个区域。
先规划111个777 ×\times× 777和111个666 ×\times× 666
再规划222个444 ×\times× 444和111个555 ×\times× 555
最后剩下111个111 ×\times× 111

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 72ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-救灾物资快速分配方案（P2959）
- 链接：https://codefun2000.com/p/P2959

> 页面标题：#P2959. 第3题-救灾物资快速分配方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某地发生地震道路被毁，只有一条路可走，多个市派出车队运送物资，每个市提供的物资车数不一样，到达灾区后需排队依次进入，各市车队组成一个数组cars[]cars[]cars[]，队首的市的物资车数为cars[0]cars[0]cars[0]，以此类推。
同时灾区临时营地中的多人排队领取物资，组成一个领物资队伍，表示为数组requires[]requires[]requires[]，排在第111名的需求车数为的为requires[0]requires[0]requires[0]，以此类推。
为尽快缩减营地中排队领物资队伍的长度，制定了一套发放规则:
假设当前进入营地的市车队运来的物资车数为K
1、在领取队伍中，找到需求和小于等于K的最长的一个子队伍，即子序列的和小于等于KKK的最长连续子序列(仅包含一个成员也是可以的)，将当前营地中的所有市车队物资分配给这个子序列中的所有人，此为完成一次分配。
2、若未找到任何人满足分配条件，则放入下一个市车队进入营地，与营地中已有的物资车累加起来，重新进行分配计算。问按照此规则发放，总计进行了多少次分配，有多少人不能领到物资?
输入描述
输入为两行:
第111行为各市物资车数的数组carscarscars，空格分隔，car[i]car[i]car[i]表示编号i(i<=200)i(i<=200)i(i<=200)的市运来的物资车数(1<=car[i]<=5000)(1 <= car[i] <=5000)(1<=car[i]<=5000)。例如:3 5 7 9 3 2 13\ 5\ 7\ 9\ 3\ 2\ 13 5 7 9 3 2 1
第222行为需求数组requiresrequiresrequires数，空格分隔，requires[]requires[]requires[]表示编号j(j<=105)j( j<=10^5)j(j<=105)的人的需求数(1<=requires[j]<=100)(1 <= requires[j
]<=100)(1<=requires[j]<=100)。例如:1 2 4 5 21\ 2\ 4\ 5\ 21 2 4 5 2非法输入返回−1-1−1
输出描述
输出分配总次数和不能分到物资的人数，用空格分隔。
例如:
2 02\ 02 0
表示总计分配次数为2，未分配到物资人数为000
样例1
输入
8 7 3 6 6 2 1
7 1 2 4 6 1 2 3 1 4 5

输出
4 1

说明

第111次分配:通过计算得到小于等于888的最长子序列为1,2,3,11,2,3,11,2,3,1，因此将营地中物资888车全部分配给1,2,3,11,2,3,11,2,3,1，完成第一次分配。
第222次分配:777车物资分给1 2 41\ 2\ 41 2 4
第333次分配:999车物资分给4,54,54,5
第444次分配:666车物资分给666
此时市队伍剩余2,12,12,1，且2在营地中待分配，领物资队伍剩余777。进行分配计算，得出无法进行分配，因此将下一个市进入营地，此时营地中累计物资车数为333，进行分配计算，仍无法分配且市队伍已无市可用，流程结束。
综上，总计成功分配了444次，剩余111个人，输出4 14\  14 1
样例2
输入
8
4 2 2 8 2 2 2 1

输出
1 4

说明
分析小于等于888的子序列:相对较长的有这两个，4 2 2,2 2 2 14\ 2\ 2,2\ 2\ 2\ 14 2 2,2 2 2 1，因2 2 2 12\ 2\ 2\ 12 2 2 1长度更长，因此进行实际分配，领物资队伍剩余4 2 2 84\ 2\ 2\ 84 2 2 8。累计分配了111次。输出1 41\ 41 4
样例3
输入
2 2 2 2
8 9 8 8

输出
1 3

说明
前444个市的物资分配给第一个人，只进行了111次分配，剩余333个人，因此输出1 31\ 31 3

▶️

#### TextSol

video solution

题解
题目描述
某地发生地震道路被毁，只有一条路可走，多个市派出车队运送物资，每个市提供的物资车数不一样，到达灾区后需排队依次进入，各市车队组成一个数组 cars[]cars[]cars[]，队首的市的物资车数为 cars[0]cars[0]cars[0]，以此类推。
同时灾区临时营地中的多人排队领取物资，组成一个领物资队伍，表示为数组 requires[]requires[]requires[]，排在第 111 名的需求车数为 requires[0]requires[0]requires[0]，以此类推。
为尽快缩减营地中排队领物资队伍的长度，制定了一套发放规则：

假设当前进入营地的市车队运来的物资车数为 KKK。
在领取队伍中，找到需求和小于等于 KKK 的最长的一个子队伍，即连续子序列，其和小于等于 KKK（仅包含一个成员也是可以的），将当前营地中的所有市车队物资分配给这个子序列中的所有人，此为完成一次分配。
若未找到任何满足分配条件的人，则放入下一个市车队进入营地，与营地中已有的物资车累加起来，重新进行分配计算。

问：按照此规则发放，总计进行了多少次分配，有多少人不能领到物资？
思路

维护当前可用物资：设变量 KKK 表示当前营地中累计的物资车数，初始时取 cars[0]cars[0]cars[0]。
寻找最长子序列：对于当前 KKK，在 requiresrequiresrequires 中寻找和不超过 KKK 的最长连续子数组。可使用滑动窗口：

设左右指针 l=0l=0l=0，遍历右指针 rrr 从 000 到 n−1n-1n−1，维护窗口和 sumsumsum。
当 sum+requires[r]≤Ksum + requires[r] \le Ksum+requires[r]≤K 时，扩展窗口；否则，收缩左端直到 sum+requires[r]≤Ksum + requires[r] \le Ksum+requires[r]≤K。
记录最大窗口长度 maxLenmaxLenmaxLen 及其起始位置 startstartstart。

执行分配或累加：

若 maxLen>0maxLen > 0maxLen>0，则从 requiresrequiresrequires 中删除该区间 [start,start+maxLen−1][start, start+maxLen-1][start,start+maxLen−1]，分配次数加 111，重置 K=cars[nextCity]K = cars[nextCity]K=cars[nextCity] 并继续（或若无下一市队，则退出）。
否则，将下一个市的物资加入 KKK，继续寻找，直到用完所有市车队或能分配为止。

结果统计：统计分配次数和剩余 requiresrequiresrequires 的长度即未分配人数。

时间复杂度：

外循环遍历市队 O(m)O(m)O(m)，每次查最长子序列 O(n)O(n)O(n)，总计 O(mn)O(mn)O(mn)，在 m≤200m\le200m≤200，n≤105n\le10^5n≤105 时可接受（最坏约 2×1072\times10^72×107 次操作）。

C++
#include <bits/stdc++.h>
using namespace std;
int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

vector<int> cars;
vector<int> requires;
int x;
// 读入 cars 数组
string line;
if (!getline(cin, line)) return 0;
istringstream ic(line);
while (ic >> x) cars.push_back(x);
// 读入 requires 数组
if (!getline(cin, line)) return 0;
istringstream ir(line);
while (ir >> x) requires.push_back(x);

int m = cars.size(), n = requires.size();
int city = 0;         // 当前市队索引
long long K = cars[city];  // 当前可用物资
int ops = 0;         // 分配次数

while (true) {
int l = 0;
long long sum = 0;
int maxLen = 0, start = -1;
// 滑动窗口寻找最长子序列
for (int r = 0; r < n; ++r) {
sum += requires[r];
while (l <= r && sum > K) {
sum -= requires[l++];
}
if (r - l + 1 > maxLen) {
maxLen = r - l + 1;
start = l;
}
}
if (maxLen > 0) {
// 执行一次分配
requires.erase(requires.begin() + start,
requires.begin() + start + maxLen);
n -= maxLen;
ops++;
city++;
if (city >= m) break;
K = cars[city];
} else {
// 无法分配，累加下一市资源
city++;
if (city >= m) break;
K += cars[city];
}
}
// 输出分配次数和剩余人数
cout << ops << " " << requires.size();
return 0;
}

Python
from collections import deque

# 读入
cars = list(map(int, input().split()))
requires = list(map(int, input().split()))

m, n = len(cars), len(requires)
city = 0
K = cars[city]
ops = 0

while True:
l = 0
curr_sum = 0
max_len, start = 0, -1
# 滑动窗口
for r in range(len(requires)):
curr_sum += requires[r]
while l <= r and curr_sum > K:
curr_sum -= requires[l]
l += 1
if r - l + 1 > max_len:
max_len = r - l + 1
start = l
if max_len > 0:
# 删除分配区间
del requires[start:start+max_len]
ops += 1
city += 1
if city >= m:
break
K = cars[city]
else:
city += 1
if city >= m:
break
K += cars[city]

print(ops, len(requires))

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
String[] s1 = sc.nextLine().split(" ");
String[] s2 = sc.nextLine().split(" ");
List<Integer> cars = new ArrayList<>();
List<Integer> req = new ArrayList<>();
for (String s : s1) cars.add(Integer.parseInt(s));
for (String s : s2) req.add(Integer.parseInt(s));

int m = cars.size();
int city = 0;
long K = cars.get(city);
int ops = 0;

while (true) {
int l = 0;
long sum = 0;
int maxLen = 0, start = -1;
// 滑动窗口寻找最长子序列
for (int r = 0; r < req.size(); r++) {
sum += req.get(r);
while (l <= r && sum > K) {
sum -= req.get(l);
l++;
}
if (r - l + 1 > maxLen) {
maxLen = r - l + 1;
start = l;
}
}
if (maxLen > 0) {
// 执行一次分配
for (int i = 0; i < maxLen; i++) {
req.remove(start);
}
ops++;
city++;
if (city >= m) break;
K = cars.get(city);
} else {
city++;
if (city >= m) break;
K += cars.get(city);
}
}
System.out.println(ops + " " + req.size());
}
}

---

### 第3题-爬山路线规划（P5002）
- 链接：https://codefun2000.com/p/P5002

> 页面标题：#P5002. 第3题-爬山路线规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个二维数组 mountainMapmountainMapmountainMap表示一座山的地图,数组中的每个元素 mountainMap[x][y]mountainMap[x][y] mountainMap[x][y]代表坐标(x,y)(x,y)(x,y)处山的高度。登山员从山底出发，爬到山峰。
山底的含义:mountainMapmountainMapmountainMap中高度为0的坐标点.
山峰的含义:mountainMapmountainMapmountainMap中高度最高的坐标点。
山底和山峰有且仅有一个坐标。
登山员每次移动只能从当前位置向上下左右四个方向移动一格,向高处移动时，移动到的位置的山的高度不能高于当前位置山的高度加上固定的攀爬能力值climbAbilityclimbAbilityclimbAbility；向低处移动时,移动到的位置的山的高度不能低于当前位置山的高度减去climbAbilityclimbAbilityclimbAbility。
数值取值范围:

请计算出从山底移动到山峰，最少需要移动几次?
输入描述
1.第一行为climbAbilityclimbAbilityclimbAbility的值
2.第二行为mountainMapRows mountainMapColsmountainMapRows\ mountainMapColsmountainMapRows mountainMapCols
3.从第三行开始为mountainMapRowsmountainMapRowsmountainMapRows行mountainMapColsmountainMapColsmountainMapCols列的高度
二维数组mountainMap[mountainMapRows][mountainMapCols]mountainMap[mountainMapRows][mountainMapCols]mountainMap[mountainMapRows][mountainMapCols],
每行的高度数字中间用空格分割
样例输入
111
6 66\ 66 6
4 5 6 5 5 54\ 5\ 6\ 5\ 5\ 54 5 6 5 5 5
3 4 5 6 7 73\ 4\ 5\ 6\ 7\ 73 4 5 6 7 7
2 10 10 10 8 82\ 10\ 10\ 10\ 8\ 82 10 10 10 8 8
1 1 1 10 9 91\ 1\ 1\ 10\ 9 \ 91 1 1 10 9 9
1 0 10 10 10 101\ 0\ 10\ 10\ 10\ 101 0 10 10 10 10
9 9 9 9 11 109\ 9\ 9\ 9\ 11\ 109 9 9 9 11 10
图例：
格子中的数字代表山峰高度，climbAbilityclimbAbilityclimbAbility为111，最短路线如图所示。

输出描述
从山底移动到山峰，最少移动次数。
如果无法移动至山峰，则输出−1-1−1
样例1
输入
2
3 2
1 3
0 4
5 3

输出
5

说明
攀登能力为222，333行222列的山峰坐标，山底的坐标为(1,0)(1,0)(1,0)高度000，山峰的坐标为(2,0)(2,0)(2,0)高度555。
仅有一条路线
初始位置山底(1,0)(1,0)(1,0)高度0−>(0,0)0->(0,0)0−>(0,0)高度1−>(0,1)1->(0,1)1−>(0,1)高度222->(1,1)(1,1)(1,1)高度444->(2,1)(2,1)(2,1)高度3−>(2,0)3->(2,0)3−>(2,0)高度555
共需要移动555次。
样例2
输入
1
4 5
1 1 1 1 1
1 0 1 2 1
1 1 1 3 1
1 1 1 1 1

输出
3

说明
攀登能力为111，444行555列的山峰坐标，山底的坐标为(1,1)(1,1)(1,1)，山峰的坐标为(2,3)(2,3)(2,3)。
最短路线为
初始位置山底(1,1)(1,1)(1,1)高度0−>(1,2)0->(1,2)0−>(1,2)高度1−>(1,31->(1,31−>(1,3)高度2−>2->2−>山峰(2,3)(2,3)(2,3)高度333
共需要移动333次
样例3
输入
1
4 5
1 1 1 1 1
1 0 1 2 1
1 1 1 9 1
1 1 1 1 1

输出
-1

说明
无法达到山峰，输出−1-1−1

▶️

#### TextSol

video solution

题解思路
我们可以将山脉地图看成一个二维网格，每个格子代表一个节点，相邻（上、下、左、右）格子之间有边相连。由于每步移动代价相同（均为 1），并且我们要找从山底到山峰的最少步数，最合适的算法是 广度优先搜索（BFS）。
具体步骤如下：

扫描地图，找到山底起点 start（高度为 0 的唯一坐标）和山峰终点 target（最高高度的唯一坐标）。
初始化队列，将 start 入队，并用一个与地图同型的布尔数组 vis 记录访问状态。
BFS 过程：

每次从队列取出当前格子 (x,y) 及其已走步数 d。
枚举四个方向的新坐标 (nx,ny)，判断是否越界、未访问，并且满足高度差限制：

向高处移动：grid[nx][ny] - grid[x][y] ≤ climbAbility
向低处移动：grid[x][y] - grid[nx][ny] ≤ climbAbility

若满足，则将 (nx,ny) 标记为已访问并入队，步数 d+1。
若 (nx,ny) 为 target，即可立即返回 d+1。

若 BFS 结束仍未到达山峰，返回 -1。

算法分析

正确性：BFS 保证第一次到达终点时所走步数即为最少步数。
高度限制判断：无论上坡还是下坡，实际上都可统一为 |grid[nx][ny] - grid[x][y]| ≤ climbAbility。
访问标记：防止重复入队，降低时间开销。

复杂度分析

令网格大小为 N=M行×M列，BFS 最多访问所有格子一次，每个格子检查 4 个方向。
时间复杂度：O(N×M)。
空间复杂度：O(N×M)，用于队列和访问数组。

代码实现
Python
from collections import deque

def min_steps(grid, ability):
n, m = len(grid), len(grid[0])
# 找起点（高度0）和终点（最高点）
start = target = None
max_h = -1
for i in range(n):
for j in range(m):
h = grid[i][j]
if h == 0:
start = (i, j)
if h > max_h:
max_h, target = h, (i, j)
# BFS 初始化
vis = [[False]*m for _ in range(n)]
q = deque()
q.append((*start, 0))
vis[start[0]][start[1]] = True
# 四个方向
dirs = [(-1,0),(1,0),(0,-1),(0,1)]
while q:
x, y, d = q.popleft()
if (x, y) == target:
return d
for dx, dy in dirs:
nx, ny = x+dx, y+dy
if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny]:
diff = grid[nx][ny] - grid[x][y]
if abs(diff) <= ability:
vis[nx][ny] = True
q.append((nx, ny, d+1))
return -1

# 读入与输出
if __name__ == "__main__":
ability = int(input().strip())
n, m = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(n)]
print(min_steps(grid, ability))

Java
import java.util.*;

public class Solution {
static class Node {
int x, y, d;
Node(int x, int y, int d) {
this.x = x; this.y = y; this.d = d;
}
}

public static int minSteps(int[][] grid, int ability) {
int n = grid.length, m = grid[0].length;
int sx=0, sy=0, tx=0, ty=0, maxH=-1;
// 找起点与终点
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int h = grid[i][j];
if (h == 0) { sx = i; sy = j; }
if (h > maxH) { maxH = h; tx = i; ty = j; }
}
}
boolean[][] vis = new boolean[n][m];
Queue<Node> q = new LinkedList<>();
q.add(new Node(sx, sy, 0));
vis[sx][sy] = true;
int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
while (!q.isEmpty()) {
Node cur = q.poll();
if (cur.x == tx && cur.y == ty) return cur.d;
for (int[] dir : dirs) {
int nx = cur.x + dir[0], ny = cur.y + dir[1];
if (nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny]) {
int diff = grid[nx][ny] - grid[cur.x][cur.y];
if (Math.abs(diff) <= ability) {
vis[nx][ny] = true;
q.add(new Node(nx, ny, cur.d+1));
}
}
}
}
return -1;
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int ability = Integer.parseInt(in.nextLine().trim());
String[] dims = in.nextLine().split(" ");
int n = Integer.parseInt(dims[0]), m = Integer.parseInt(dims[1]);
int[][] grid = new int[n][m];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
grid[i][j] = in.nextInt();
}
}
System.out.println(minSteps(grid, ability));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

struct Node {
int x, y, d;
};

int minSteps(vector<vector<int>>& grid, int ability) {
int n = grid.size(), m = grid[0].size();
int sx=0, sy=0, tx=0, ty=0, maxH=-1;
// 找起点与终点
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int h = grid[i][j];
if (h == 0) { sx = i; sy = j; }
if (h > maxH) { maxH = h; tx = i; ty = j; }
}
}
vector<vector<bool>> vis(n, vector<bool>(m, false));
queue<Node> q;
q.push({sx, sy, 0});
vis[sx][sy] = true;
int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
while (!q.empty()) {
auto cur = q.front(); q.pop();
if (cur.x == tx && cur.y == ty) return cur.d;
for (auto &di : dirs) {
int nx = cur.x + di[0], ny = cur.y + di[1];
if (nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny]) {
int diff = grid[nx][ny] - grid[cur.x][cur.y];
if (abs(diff) <= ability) {
vis[nx][ny] = true;
q.push({nx, ny, cur.d+1});
}
}
}
}
return -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int ability;
cin >> ability;
int n, m;
cin >> n >> m;
vector<vector<int>> grid(n, vector<int>(m));
for (int i = 0; i < n; i++)
for (int j = 0; j < m; j++)
cin >> grid[i][j];

cout << minSteps(grid, ability) << "\n";
return 0;
}

---

### 第3题-云计算服务器GPU分配（P2974）
- 链接：https://codefun2000.com/p/P2974

> 页面标题：#P2974. 第3题-云计算服务器GPU分配

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

某云计算服务商为客户提供 MMM 数量 GPUGPUGPU 核数的 GPUGPUGPU 分时租用服务，租用计费规则为：允许客户在每个时间单位按需租用不同的 GPUGPUGPU 核数，每个时间单位每个 GPUGPUGPU 核数的费用为 RRR 。
现有 NNN 个客户，每个客户有多个不重叠时间段租用一定数量的 GPUGPUGPU 核数的租用需求。对于有租用需求的客户，服务商可选择签约或不签约，若选择签约则需要满足租用需求中的所有时间段所需的 GPUGPUGPU 核数。
为了实现租金最大化收益，服务商需在确保任意时间单位内分配的 GPUGPUGPU 核数总数不超过 MMM 的基础上，选择与哪些客户签约租用协议。
请输出租金最大化收益下的租金最大值。
输入描述
第一行为 M、N、RM、N、RM、N、R 的数值，依次用空格隔开，输入格式为 MMM NNN RRR
从第二行开始，每行为一个客户的租用需求，共 NNN 行。每行的9第一个数字为该客户端的时间段个数 timeSegmentNumtimeSegmentNumtimeSegmentNum ，后续为 timeSegmentNumtimeSegmentNumtimeSegmentNum 个时间段及所需的 GPUGPUGPU 核数，时间段个数 timeSegmentNumtimeSegmentNumtimeSegmentNum 与时间段之间、多个时间段之间均用空格分割。同一个客户多个时间段不会重叠。同一个客户多个时间段已按起始时间增序排序给出
每个时间段及所需的 GPUGPU
GPU 核数格式为 starstarstar 起始时间编号：endendend 结束时间编号：needCoresneedCoresneedCores 该时间段所需的 GPUGPUGPU 核数
变量取值范围
1<=M<=1000001<=M<=1000001<=M<=100000
1<=N<=101<=N<=101<=N<=10
1<=R<=101<=R<=101<=R<=10
0<=start<=end<=1090<=start<=end<=10^90<=start<=end<=109
1<=needCores<=100001<=needCores<=100001<=needCores<=10000
1<=timeSegmentNum<=1001<=timeSegmentNum<=1001<=timeSegmentNum<=100
客户的租用需求样例 222 0:0:10:0:10:0:1 3:6:103:6:103:6:10 的含义是共有 222 个时间段，0:0:10:0:10:0:1 表示在第 000 个时间单位需要 111 个 GPUGPUGPU 核，3:6:103:6:103:6:10 表示在从 333 到 666 的时间单位(包含 333 和 666 )每个时间单位均需 101010 个GPUGPUGPU 核
图例为：

输出描述
总租金最大值。
如果任意一个客户的需求都无法满足，则输出 000
样例1
输入
10 3 2
2 0:8:5 9:23:10
2 0:8:5 9:18:10
1 0:8:5

输出
480

说明
共 333 个客户。
由于第一个客户和第二个客户在 9:189:189:18 时间范围段内总核数为 202020 超过了 101010 ，所以无法同时接受。
最大日租金方案为：接纳第一个客户和第三个客户的需求。
第一个客户共需要的 GPUGPUGPU 核数为 9∗5+15∗10=1959*5+15*10=1959∗5+15∗10=195
第三个每户共需要的 GPUGPUGPU 核数为 9∗5=459*5=459∗5=45
最大日租金值为 (195+45)∗2=480(195+45)*2=480(195+45)∗2=480
样例2
输入
10 2 1
1 0:3:6
1 3:10:6

输出
48

说明
最大 GPUGPUGPU 核数为 101010 ，共 222 个客户。
第一个客户和第二个客户在 333 时间点，总核数为 121212 超过了 101010 ，所以无法同时接受。
第一个客户共需要的 GPUGPUGPU 核数为 4∗6=244*6=244∗6=24
第二个客户共需要的 GPUGPUGPU 核数为 8∗6=488*6=488∗6=48
为满足最大租金，采纳第二个客户，最大日租金值为 48∗1=4848*1=4848∗1=48
样例3
输入
10 1 1
1 0:5:20

输出
0

说明
最大 GPUGPUGPU 核数为 101010 ，共 111 个客户。
在 000~555 时间段需要 202020 个 GPUGPUGPU 核数，无法满足。
输出 000

▶️

#### TextSol

video solution

题解
题面描述
某云计算服务商为客户提供 MMM 数量 GPU 核数的 GPU 分时租用服务，租用计费规则为：允许客户在每个时间单位按需租用不同的 GPU 核数，每个时间单位每个 GPU 核数的费用为 RRR 。
现有 NNN 个客户，每个客户有多个不重叠时间段租用一定数量的 GPU 核数的租用需求。对于有租用需求的客户，服务商可选择签约或不签约，若选择签约则需要满足其所有时间段中对 GPU 核数的需求。
为了实现租金最大化收益，服务商需在确保任意时间单位内分配的 GPU 核数总数不超过 MMM 的基础上，选择与哪些客户签约租用协议。
请输出在租金最大化收益下的总租金。
若任意一个客户的需求都无法满足，则输出 000。
思路

枚举签约方案：由于 N≤10N\leq10N≤10，可以对每个客户选择签约或不签约，枚举所有 2N2^N2N 种可能的子集。
验证可行性：对于每一个客户子集，将其所有时间段的需求汇总，检查在任意时间单位内的 GPU 核数总和是否超过 MMM。具体做法：

收集所有时间段的开始和结束边界，进行离散化，得到有序的时间点数组。
遍历相邻时间点区间，累加所有在该区间内客户的需求核数，若超过 MMM 则该子集不可行。

计算收益：若子集可行，计算总GPU*时间量 WWW：
WWW = sum客户 isum_{\text{客户}~i}sum客户 i​sum[s,e] ∈ segmentsisum_{[s,e]~\in~\mathrm{segments}_i}sum[s,e] ∈ segmentsi​​(e−s+1e-s+1e−s+1)∗*∗needCores{needCores}needCores
最终租金为 W×RW \times RW×R。
取最大值：遍历所有子集，记录最大的 W×RW\times RW×R，即为答案。

复杂度：O(2N×Klog⁡K)O(2^N \times K \log K)O(2N×KlogK)，其中 KKK 为所有考虑中的时间段总数，符合题目约束。
C++
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main() {
ios::sync_with_stdio(false);
cin.tie(NULL);

// 读入 M, N, R
ll M; int N; ll R;
cin >> M >> N >> R;

// 存储每个客户的时间段需求
vector<vector<tuple<ll,ll,ll>>> segs(N);
for (int i = 0; i < N; i++) {
int t; cin >> t;
while (t--) {
ll s, e, c;
char ch;
cin >> s >> ch >> e >> ch >> c;  // 读入格式 s:e:c
segs[i].emplace_back(s, e, c);
}
}

ll ans = 0;
// 枚举所有子集
for (int mask = 0; mask < (1<<N); mask++) {
vector<ll> xs;
ll W = 0;
// 收集边界
for (int i = 0; i < N; i++) if (mask & (1<<i)) {
for (auto &seg: segs[i]) {
ll s,e,c; tie(s,e,c) = seg;
xs.push_back(s);
xs.push_back(e+1);
W += (e - s + 1) * c;
}
}
if (xs.empty()) continue;
// 离散化
sort(xs.begin(), xs.end());
xs.erase(unique(xs.begin(), xs.end()), xs.end());
vector<ll> diff(xs.size()+1);
// 差分数组构造
for (int i = 0; i < N; i++) if (mask & (1<<i)) {
for (auto &seg: segs[i]) {
ll s,e,c; tie(s,e,c) = seg;
int l = lower_bound(xs.begin(), xs.end(), s) - xs.begin();
int r = lower_bound(xs.begin(), xs.end(), e+1) - xs.begin();
diff[l] += c;
diff[r] -= c;
}
}
// 扫描检查容量
ll cur = 0;
bool ok = true;
for (int i = 0; i+1 < (int)xs.size(); i++) {
cur += diff[i];
if (cur > M) { ok = false; break; }
}
if (ok) ans = max(ans, W * R);
}

cout << ans;
return 0;
}

Python
import sys
from itertools import combinations

def read_input():
# 读取所有输入并分割
data = sys.stdin.read().split()
M, N, R = map(int, data[:3])
idx = 3
segs = []
for _ in range(N):
t = int(data[idx]); idx += 1
arr = []
for _ in range(t):
# 按格式 start:end:needCores
s_str, e_str, c_str = data[idx].split(':')
idx += 1
s, e, c = int(s_str), int(e_str), int(c_str)
arr.append((s, e, c))
segs.append(arr)
return M, N, R, segs

def is_subset_feasible(mask, N, M, segs):
# 收集所有边界并构造差分
xs = []
W = 0
for i in range(N):
if mask & (1 << i):
for s, e, c in segs[i]:
xs.append(s)
xs.append(e + 1)
W += (e - s + 1) * c
if not xs:
return False, 0
# 离散化
xs = sorted(set(xs))
diff = [0] * (len(xs) + 1)
# 构造差分数组
for i in range(N):
if mask & (1 << i):
for s, e, c in segs[i]:
l = xs.index(s)
r = xs.index(e + 1)
diff[l] += c
diff[r] -= c
# 扫描区间可行性
cur = 0
for i in range(len(xs) - 1):
cur += diff[i]
if cur > M:
return False, 0
return True, W

def main():
M, N, R, segs = read_input()
ans = 0
# 枚举所有子集
for mask in range(1 << N):
feasible, W = is_subset_feasible(mask, N, M, segs)
if feasible:
ans = max(ans, W * R)
# 若所有子集都不行，ans 保持为 0
print(ans)

if __name__ == '__main__':
main()

Java
import java.util.*;
public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
long M = sc.nextLong();
int N = sc.nextInt();
long R = sc.nextLong();
List<List<long[]>> segs = new ArrayList<>();
for (int i = 0; i < N; i++) {
int t = sc.nextInt();
List<long[]> list = new ArrayList<>();
for (int j = 0; j < t; j++) {
String[] parts = sc.next().split(":");
long s = Long.parseLong(parts[0]);
long e = Long.parseLong(parts[1]);
long c = Long.parseLong(parts[2]);
list.add(new long[]{s, e, c});
}
segs.add(list);
}
long ans = 0;
// 枚举子集
for (int mask = 0; mask < (1<<N); mask++) {
List<Long> xs = new ArrayList<>();
long W = 0;
for (int i = 0; i < N; i++) if ((mask & (1<<i)) != 0) {
for (long[] seg: segs.get(i)) {
long s = seg[0], e = seg[1], c = seg[2];
xs.add(s);
xs.add(e + 1);
W += (e - s + 1) * c;
}
}
if (xs.isEmpty()) continue;
Collections.sort(xs);
List<Long> uni = new ArrayList<>();
for (long x: xs) if (uni.isEmpty() || uni.get(uni.size()-1) != x) uni.add(x);
long[] diff = new long[uni.size()+1];
for (int i = 0; i < N; i++) if ((mask & (1<<i)) != 0) {
for (long[] seg: segs.get(i)) {
long s = seg[0], e = seg[1], c = seg[2];
int l = Collections.binarySearch(uni, s);
int r = Collections.binarySearch(uni, e+1);
diff[l] += c;
diff[r] -= c;
}
}
long cur = 0;
boolean ok = true;
for (int i = 0; i+1 < uni.size(); i++) {
cur += diff[i];
if (cur > M) { ok = false; break; }
}
if (ok) ans = Math.max(ans, W * R);
}
System.out.println(ans);
}
}

---

### 第3题-爬山线路规划（P3281）
- 链接：https://codefun2000.com/p/P3281

> 页面标题：#P3281. 第3题-爬山线路规划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个二维数组mountainMapmountainMapmountainMap表示一座山的地图，数组中的每个元素mountainMap[x][y]mountainMap[x][y]mountainMap[x][y]代表坐标(x,y)(x,y)(x,y)处
山的高度。登山员从山底出发，爬到山峰。
山底的含义:mountainMapmountainMapmountainMap中高度为000的坐标点。
山峰的含义:mountainMapmountainMapmountainMap中高度最高的坐标点。
山底和山峰有且仅有一个坐标。
登山员每次移动只能从当前位置向上下左右四个方向移动一格，向高处移动时，移动到的位置的山的高度不能高于当前位置山的高度加上固定的攀爬能力值climbAbilityclimbAbilityclimbAbility;向低处移动时，移动到的位置的山的高度不能低于当前位置山的高度减去climbAbilityclimbAbilityclimbAbility。
数值取值范围:

请计算出从山底移动到山峰，最少需要移动几次?
输入描述
1.第一行为climbAbilityclimbAbilityclimbAbility的值
2.第二行为mountainMapRows mountainMapColsmountainMapRows\ mountainMapColsmountainMapRows mountainMapCols
3.从第三行开始为mountainMapRowsmountainMapRowsmountainMapRows行mountainMapColsmountainMapColsmountainMapCols列的高度二维数组
mountainMap[mountainMapRows][mountainMapCols]mountainMap[mountainMapRows][mountainMapCols]mountainMap[mountainMapRows][mountainMapCols]，每行的高度数字中间用空格分割
样例输入
111
6 66\ 66 6
4 5 6 5 5 54\ 5\ 6\ 5\ 5\ 54 5 6 5 5 5
3 4 5 6 7 73\ 4\ 5\ 6\ 7\ 73 4 5 6 7 7
2 10 10 10 8 82\ 10\ 10\ 10\ 8\ 82 10 10 10 8 8
1 1 1 10 9 91\ 1\ 1\ 10\ 9\ 91 1 1 10 9 9
1 0 10 10 10 101\ 0\ 10\ 10\ 10\ 101 0 10 10 10 10
9 9 9 9 11 109\ 9\ 9\ 9\ 11\ 109 9 9 9 11 10
图例：
格子中的数字代表山峰高度，climbAbilityclimbAbilityclimbAbility为111，最短路线如图所示。

输出描述
从山底移动到山峰，最少移动次数。
如果无法移动至山峰，则输出−1-1−1
样例1
输入
2
3 2
1 3
0 4
5 3

输出
5

说明
攀登能力为222，333行222列的山峰坐标，山底的坐标为(1,0)(1,0)(1,0)高度000，山峰的坐标为(2,0)(2,0)(2,0)高度555。仅有一条路线
初始位置山底(1,0)(1,0)(1,0)高度0−>(0,0)0->(0,0)0−>(0,0)高度1−>(0,1)1->(0,1)1−>(0,1)高度3−>(1,1)3->(1,1)3−>(1,1)高度4−>(2,1)4->(2,1)4−>(2,1)高度3−>(2,0)3->(2,0)3−>(2,0)高度555
共需要移动555次
样例2
输入
1
4 5
1 1 1 1 1
1 0 1 2 1
1 1 1 3 1
1 1 1 1 1

输出
3

说明
攀登能力为111，444行555列的山峰坐标，山底的坐标为(1,1)(1,1)(1,1)，山峰的坐标为(2,3)(2,3)(2,3)。
最短路线为
初始位置山底(1,1)(1,1)(1,1)高度0−>(1,2)0->(1,2)0−>(1,2)高度1−>(1,3)1->(1,3)1−>(1,3)高度2−>2->2−>山峰(2,3)(2,3)(2,3)高度333
共需要移动333次
样例3
输入
1
4 5
1 1 1 1 1
1 0 1 2 1
1 1 1 9 1
1 1 1 1 1

输出
-1

说明
无法达到山峰，输出−1-1−1
提示
111.山底和山峰有且仅有一个坐标。
222.初始位置在山底，山底不一定在数组边缘位置，见样例222
333.山峰的高度大于000

▶️

#### TextSol

video solution

题解思路
我们可以将山脉地图看成一个二维网格，每个格子代表一个节点，相邻（上、下、左、右）格子之间有边相连。由于每步移动代价相同（均为 1），并且我们要找从山底到山峰的最少步数，最合适的算法是 广度优先搜索（BFS）。
具体步骤如下：

扫描地图，找到山底起点 start（高度为 0 的唯一坐标）和山峰终点 target（最高高度的唯一坐标）。
初始化队列，将 start 入队，并用一个与地图同型的布尔数组 vis 记录访问状态。
BFS 过程：

每次从队列取出当前格子 (x,y) 及其已走步数 d。
枚举四个方向的新坐标 (nx,ny)，判断是否越界、未访问，并且满足高度差限制：

向高处移动：grid[nx][ny] - grid[x][y] ≤ climbAbility
向低处移动：grid[x][y] - grid[nx][ny] ≤ climbAbility

若满足，则将 (nx,ny) 标记为已访问并入队，步数 d+1。
若 (nx,ny) 为 target，即可立即返回 d+1。

若 BFS 结束仍未到达山峰，返回 -1。

算法分析

正确性：BFS 保证第一次到达终点时所走步数即为最少步数。
高度限制判断：无论上坡还是下坡，实际上都可统一为 |grid[nx][ny] - grid[x][y]| ≤ climbAbility。
访问标记：防止重复入队，降低时间开销。

复杂度分析

令网格大小为 N=M行×M列，BFS 最多访问所有格子一次，每个格子检查 4 个方向。
时间复杂度：O(N×M)。
空间复杂度：O(N×M)，用于队列和访问数组。

代码实现
Python
from collections import deque

def min_steps(grid, ability):
n, m = len(grid), len(grid[0])
# 找起点（高度0）和终点（最高点）
start = target = None
max_h = -1
for i in range(n):
for j in range(m):
h = grid[i][j]
if h == 0:
start = (i, j)
if h > max_h:
max_h, target = h, (i, j)
# BFS 初始化
vis = [[False]*m for _ in range(n)]
q = deque()
q.append((*start, 0))
vis[start[0]][start[1]] = True
# 四个方向
dirs = [(-1,0),(1,0),(0,-1),(0,1)]
while q:
x, y, d = q.popleft()
if (x, y) == target:
return d
for dx, dy in dirs:
nx, ny = x+dx, y+dy
if 0 <= nx < n and 0 <= ny < m and not vis[nx][ny]:
diff = grid[nx][ny] - grid[x][y]
if abs(diff) <= ability:
vis[nx][ny] = True
q.append((nx, ny, d+1))
return -1

# 读入与输出
if __name__ == "__main__":
ability = int(input().strip())
n, m = map(int, input().split())
grid = [list(map(int, input().split())) for _ in range(n)]
print(min_steps(grid, ability))

Java
import java.util.*;

public class Solution {
static class Node {
int x, y, d;
Node(int x, int y, int d) {
this.x = x; this.y = y; this.d = d;
}
}

public static int minSteps(int[][] grid, int ability) {
int n = grid.length, m = grid[0].length;
int sx=0, sy=0, tx=0, ty=0, maxH=-1;
// 找起点与终点
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int h = grid[i][j];
if (h == 0) { sx = i; sy = j; }
if (h > maxH) { maxH = h; tx = i; ty = j; }
}
}
boolean[][] vis = new boolean[n][m];
Queue<Node> q = new LinkedList<>();
q.add(new Node(sx, sy, 0));
vis[sx][sy] = true;
int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}};
while (!q.isEmpty()) {
Node cur = q.poll();
if (cur.x == tx && cur.y == ty) return cur.d;
for (int[] dir : dirs) {
int nx = cur.x + dir[0], ny = cur.y + dir[1];
if (nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny]) {
int diff = grid[nx][ny] - grid[cur.x][cur.y];
if (Math.abs(diff) <= ability) {
vis[nx][ny] = true;
q.add(new Node(nx, ny, cur.d+1));
}
}
}
}
return -1;
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int ability = Integer.parseInt(in.nextLine().trim());
String[] dims = in.nextLine().split(" ");
int n = Integer.parseInt(dims[0]), m = Integer.parseInt(dims[1]);
int[][] grid = new int[n][m];
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
grid[i][j] = in.nextInt();
}
}
System.out.println(minSteps(grid, ability));
}
}

C++
#include <bits/stdc++.h>
using namespace std;

struct Node {
int x, y, d;
};

int minSteps(vector<vector<int>>& grid, int ability) {
int n = grid.size(), m = grid[0].size();
int sx=0, sy=0, tx=0, ty=0, maxH=-1;
// 找起点与终点
for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
int h = grid[i][j];
if (h == 0) { sx = i; sy = j; }
if (h > maxH) { maxH = h; tx = i; ty = j; }
}
}
vector<vector<bool>> vis(n, vector<bool>(m, false));
queue<Node> q;
q.push({sx, sy, 0});
vis[sx][sy] = true;
int dirs[4][2] = {{-1,0},{1,0},{0,-1},{0,1}};
while (!q.empty()) {
auto cur = q.front(); q.pop();
if (cur.x == tx && cur.y == ty) return cur.d;
for (auto &di : dirs) {
int nx = cur.x + di[0], ny = cur.y + di[1];
if (nx>=0 && nx<n && ny>=0 && ny<m && !vis[nx][ny]) {
int diff = grid[nx][ny] - grid[cur.x][cur.y];
if (abs(diff) <= ability) {
vis[nx][ny] = true;
q.push({nx, ny, cur.d+1});
}
}
}
}
return -1;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int ability;
cin >> ability;
int n, m;
cin >> n >> m;
vector<vector<int>> grid(n, vector<int>(m));
for (int i = 0; i < n; i++)
for (int j = 0; j < m; j++)
cin >> grid[i][j];

cout << minSteps(grid, ability) << "\n";
return 0;
}

---

### 第3题-命令行参数提示（P3291）
- 链接：https://codefun2000.com/p/P3291

> 页面标题：#P3291. 第3题-命令行参数提示

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在使用命令行工具时，经常会出现手工输入错字母的情况，如想要输入:
git clone

输入成了
git clane

因此为了命令行工具更易用，需要从支持的子命令列表中找到最相似的子命令提示给用户。
最相似的定义为最短莱文斯坦距离:即两个字符串之间，由一个转成另一个所需的最少编辑操作次数。
允许的编辑操作包括:
1.将一个字符替换成另一个字符
2.插入一个字符
3.删除一个字符
输入描述
第一行给出可提示的最短距离DDD，第二行给出子命令数量NNN，后面N行给出所有的子命令
列表，最后一行给出用户输入的子命令。
1<=D<=51<=D<=51<=D<=5
1<=N<=300001<=N<=300001<=N<=30000
单个子命令长度2<=L<=252<=L<=252<=L<=25，子命令只包含小写字母
输出描述
输出为分三种情况:
1.用户输入的子命令正确匹配上某个子命令参数，输出原命令。
2.用户输入的子命令没有匹配上某个子命令参数，但是符合提示要求，则输出提示命令，如clonecloneclone;如果符合提示要求的子命令有多个，则按距离从小到大排序后输出，同一个距离内还有多个的按字母序从小到大输出。
3.用户输入的子命令没有匹配上某个子命令参数，且没有符合提示要求的子命令，则输出NoneNoneNone
样例1
输入
2
3
clone
checkout
switch
clane

输出
clone

说明
第一行值为2，表示当前输入不能完全正确匹配某个子命令时，则将其最短距离小于2的子命令作为提示输出
第二行为3，表示命令行实际有3个子命令，分别为后续3行
最后一行为用户实际的输入
由于用户没有命中具体的子命令，而clone与用户输入的距离为1，满足小于2的要
求，因此输出clone
样例2
输入
2
3
clone
checkout
switch
create

输出
None

说明
输入的三个子命令中没有满足与createcreatecreate距离小于等于222的，因此输出NoneNoneNone
样例3
输入
2
5
aprint
bprint
aaprint
bbprint
output
print

输出
aprint bprint aaprint bbprint

说明
子命令中有四个满足与printprintprint的距离小于等于222，其中aprintaprintaprint与bprintbprintbprint与目标的距离为111，先将其排序并输出，aaprint bbprintaaprint\ bbprintaaprint bbprint与目标的距离为222，排序后接在前面输出后继续输出

#### TextSol

解题思路与方法
算法概述
本题要求在大量已知子命令中，根据用户输入的错误命令，找到与之最相似（即编辑距离最小）的子命令并提示。
最相似的定义为Levenshtein 距离，即将一个字符串通过 替换、插入、删除 三种基本操作变为另一个字符串所需的最少步数。
详细方法

逐一计算编辑距离

对用户输入串 s 和每个候选子命令 t，使用动态规划求它们的编辑距离 d(s,t)。

定义 dp[i][j] 表示 s[0..i) 转换成 t[0..j) 的最少操作数。

初始条件：

dp[0][j]=j（s 为空，插入 j 个字符），
dp[i][0]=i（删除 i 个字符）。

转移方程：
if s[i-1]==t[j-1]:
dp[i][j]=dp[i-1][j-1]
else:
dp[i][j]=min(
dp[i-1][j]+1,   // 删除 s[i-1]
dp[i][j-1]+1,   // 插入 t[j-1]
dp[i-1][j-1]+1  // 替换为 t[j-1]
)

查找最小距离或候选集

遍历所有子命令，若距离 =0，说明恰好匹配，直接输出该命令并结束。
否则，收集所有满足 1≤d(s,t)≤D 的命令，记录距离。

排序与输出

按距离从小到大排序，相同距离下按字典序升序排列。
若候选集非空，依次输出；否则输出 None。

复杂度分析

每次编辑距离计算的时间为 O(∣s∣×∣t∣)O(|s|\times|t|)O(∣s∣×∣t∣)，最坏长度均为 LLL，则为 O(L2)O(L^2)O(L2)。

总共 NNN 个子命令，时间复杂度为 O(N×L2)O(N\times L^2)O(N×L2)。

在本题中 N≤3×104,;L≤25N\le3\times10^4,;L\le25N≤3×104,;L≤25，NL2≈1.9×107N L^2\approx1.9\times10^7NL2≈1.9×107，在常数较小的实现下可接受。

空间复杂度若使用全表为 O(L2)O(L^2)O(L2)，也可优化为 O(L)O(L)O(L) 的滚动数组。

代码实现
Python
def edit_dist(a, b):
n, m = len(a), len(b)
dp = [list(range(m+1))] + [[i]+[0]*m for i in range(1, n+1)]
for i in range(1, n+1):
for j in range(1, m+1):
if a[i-1] == b[j-1]:
dp[i][j] = dp[i-1][j-1]
else:
dp[i][j] = min(
dp[i-1][j] + 1,    # 删除
dp[i][j-1] + 1,    # 插入
dp[i-1][j-1] + 1   # 替换
)
return dp[n][m]

def main():
D = int(input().strip())
N = int(input().strip())
cmds = [input().strip() for _ in range(N)]
inp = input().strip()

# 精确匹配
if inp in cmds:
print(inp)
return

# 计算距离并筛选
cand = []
for cmd in cmds:
d = edit_dist(inp, cmd)
if 1 <= d <= D:
cand.append((d, cmd))

# 输出结果
if not cand:
print("None")
else:
cand.sort(key=lambda x: (x[0], x[1]))
print(" ".join(cmd for _, cmd in cand))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
// 计算编辑距离
static int dist(String a, String b) {
int n = a.length(), m = b.length();
int[][] dp = new int[n+1][m+1];
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a.charAt(i-1) == b.charAt(j-1)) {
dp[i][j] = dp[i-1][j-1];
} else {
dp[i][j] = Math.min(
Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1),
dp[i-1][j-1] + 1
);
}
}
}
return dp[n][m];
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int D = sc.nextInt();
int N = sc.nextInt();
List<String> cmds = new ArrayList<>();
for (int i = 0; i < N; i++) cmds.add(sc.next());
String inp = sc.next();

// 精确匹配
if (cmds.contains(inp)) {
System.out.println(inp);
return;
}

// 筛选候选
List<int[]> cand = new ArrayList<>();
for (String cmd : cmds) {
int d = dist(inp, cmd);
if (d >= 1 && d <= D) {
cand.add(new int[]{d, cmds.indexOf(cmd)});
}
}

if (cand.isEmpty()) {
System.out.println("None");
} else {
// 排序
cand.sort((a, b) -> {
int da = a[0], db = b[0];
if (da != db) return da - db;
return cmds.get(a[1]).compareTo(cmds.get(b[1]));
});
// 输出
StringJoiner sj = new StringJoiner(" ");
for (int[] p : cand) sj.add(cmds.get(p[1]));
System.out.println(sj.toString());
}
}
}

C++
#include <bits/stdc++.h>
using namespace std;

// 计算编辑距离
int editDist(const string &a, const string &b) {
int n = a.size(), m = b.size();
vector<vector<int>> dp(n+1, vector<int>(m+1));
for (int i = 0; i <= n; i++) dp[i][0] = i;
for (int j = 0; j <= m; j++) dp[0][j] = j;
for (int i = 1; i <= n; i++) {
for (int j = 1; j <= m; j++) {
if (a[i-1] == b[j-1]) dp[i][j] = dp[i-1][j-1];
else dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1});
}
}
return dp[n][m];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int D, N;
cin >> D >> N;
vector<string> cmds(N);
for (int i = 0; i < N; i++) cin >> cmds[i];
string inp;
cin >> inp;

// 精确匹配
for (auto &cmd : cmds) {
if (cmd == inp) {
cout << inp << "\n";
return 0;
}
}

// 筛选候选
vector<pair<int,string>> cand;
for (auto &cmd : cmds) {
int d = editDist(inp, cmd);
if (d >= 1 && d <= D) {
cand.emplace_back(d, cmd);
}
}

if (cand.empty()) {
cout << "None\n";
} else {
sort(cand.begin(), cand.end(), [](auto &a, auto &b) {
if (a.first != b.first) return a.first < b.first;
return a.second < b.second;
});
bool first = true;
for (auto &p : cand) {
if (!first) cout << ' ';
cout << p.second;
first = false;
}
cout << '\n';
}
return 0;
}

---

### 第3题-最大的矩形新游戏（P3288）
- 链接：https://codefun2000.com/p/P3288

> 页面标题：#P3288. 第3题-最大的矩形新游戏

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小华之前玩过一个游戏，在横轴上放了nnn 个相邻的矩形，每个矩形的宽度是 111 ，而第 i(1≦i≦n)i(1≦i≦n)i(1≦i≦n) 个矩形的高度为 hih_ihi​，这 nnn 个矩形构成了一个直方图，在直方图中找出能够勾勒出来的矩形的最大面积。
这个游戏小华已经玩得很腻了，于是小华就想增加一下难度，现在有 111 次交换任意 222 个矩形的操作，请问在交换后，能够勾勒出的最大的短形面积能达到多少呢?
输入描述
第一行包含一个整数 n(2≦n≦105)n(2≦n≦10^5)n(2≦n≦105)，表示矩形个数。
第二行包含 nnn 个整数，依次为 h1,h2,...,hn(1≦hi≦104)h_1,h_2,..., h_n(1 ≦ h_i≦ 10^4)h1​,h2​,...,hn​(1≦hi​≦104) ，表示矩形的高度。
输出描述
输出一个整数，表示在交换后能够勾勒出的最大的矩形面积。
样例1
输入
6
3 1 6 5 2 3

输出
12

说明

交换第 222 个与第 666 个元素，数组变为 [3,3,6,5,2,1][3,3,6,5,2,1][3,3,6,5,2,1] ，此时前 444 项面积最大为 121212 。
样例2
输入
7
5 5 3 5 5 2 4

输出
20

说明

交换第 333 个与第 777 个元素，数组变为 [5,5,4,5,5,2,3][5,5,4,5,5,2,3][5,5,4,5,5,2,3] ，此时前 555 项面积最大为 202
020 。

▶️

#### TextSol

video solution

题解
题目描述
在横轴上有 nnn 个宽度均为 1 的相邻矩形，第 iii 个矩形的高度为 hih_ihi​，它们共同构成了一个直方图。普通的「最大矩形面积」问题是：在不改变顺序的前提下，找到可以完全覆盖在直方图之下的、面积最大的矩形。
本题在此基础上允许你 执行一次任意两根柱子高度的交换，问：在进行至多一次交换之后，能得到的最大矩形面积是多少？

思路解析

不交换时的基准答案
首先，可以用「单调栈」算法在 O(n)O(n)O(n) 时间内求出不做任何交换时的最大矩形面积，记为 base。

交换带来的增益
对于每根柱子 iii（高度为 H=hiH=h_iH=hi​），如果我们想让以它为「高度」的矩形尽可能宽，就需要：

找到原柱子 iii 两侧向外延伸，直到遇到高度小于 HHH 的位置，这可通过「稀疏表」支持的区间最小值查询（RMQ）在 O(log⁡n)O(\log n)O(logn) 时间内完成，得到一段连续区间 [L0,R0][L_0, R_0][L0​,R0​] 内所有高度都 ≥H\ge H≥H。

由于允许一次交换，我们还可以再「引入」另外一个高度至少 HHH 的柱子到这段区间的外侧。具体做法是：

统计全局有多少柱子高度 ≥H\ge H≥H，设为 count_good。

在 [0,L0−1][0, L_0-1][0,L0​−1] 和 [R0+1,n−1][R_0+1, n-1][R0​+1,n−1] 两侧，再各自找出最长的所有高度 ≥H\ge H≥H 的连续子段，长度分别为 w_left 和 w_right。

将 iii 位置的柱子和「一端」延伸段上的某个柱子交换后，最大宽度最多可达
w=(R0−L0+1)+1+max(wleft,wright)w = (R_0 - L_0 + 1) + 1 + max(w_{left},w_{right})w=(R0​−L0​+1)+1+max(wleft​,wright​)
但由于可用的高度 ≥H\ge H≥H 的柱子总数只有 count_good 根，真实宽度要取
min(w,countgood)min(w,{count_good})min(w,countg​ood)。

这样，对于每个 iii 都算一个可达面积 Hmin(w,countgood)H min(w,{count_good})Hmin(w,countg​ood)，再与 base 取最大即可。

复杂度

构建稀疏表：O(nlog⁡n)O(n\log n)O(nlogn)
单调栈基准解：O(n)O(n)O(n)
枚举每根柱子，进行常数次 RMQ（二分查找配合 RMQ 共 O(log⁡n)O(\log n)O(logn)）：O(nlog⁡n)O(n\log n)O(nlogn)
总体：O(nlog⁡n)O(n\log n)O(nlogn)，可应对 n≤105n\le10^5n≤105。

cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct SparseTable {
int n, LOG;
vector<int> log2;
vector<vector<int>> st;

SparseTable(const vector<int>& a) {
n = a.size();
log2.resize(n + 1);
log2[1] = 0;
for (int i = 2; i <= n; i++)
log2[i] = log2[i / 2] + 1;
LOG = log2[n];

st.assign(LOG + 1, vector<int>(n));
st[0] = a;
for (int k = 1; k <= LOG; k++) {
int len = 1 << k;
int half = len >> 1;
for (int i = 0; i + len <= n; i++) {
st[k][i] = min(st[k-1][i], st[k-1][i + half]);
}
}
}

// query min on [l..r], 0-based inclusive
int query(int l, int r) const {
if (l > r) return INT_MAX;
int len = r - l + 1;
int k = log2[len];
return min(st[k][l], st[k][r - (1<<k) + 1]);
}
};

// standard largest-rectangle-in-histogram, O(n)
ll maxAreaNoSwap(const vector<int>& h) {
int n = h.size();
stack<int> st;
st.push(-1);
ll ans = 0;
for (int i = 0; i <= n; i++) {
int cur = (i == n ? 0 : h[i]);
while (st.top() != -1 && h[st.top()] >= cur) {
int height = h[st.top()];
st.pop();
int width = i - st.top() - 1;
ans = max(ans, (ll)height * width);
}
st.push(i);
}
return ans;
}

// find the smallest idx in [l..r] s.t. check(idx) is true, or -1 if none
int findLeftmost(int l, int r, const function<bool(int)>& check) {
int ans = -1;
while (l <= r) {
int m = (l + r) >> 1;
if (check(m)) {
ans = m;
r = m - 1;
} else {
l = m + 1;
}
}
return ans;
}

// find the largest idx in [l..r] s.t. check(idx) is true, or -1 if none
int findRightmost(int l, int r, const function<bool(int)>& check) {
int ans = -1;
while (l <= r) {
int m = (l + r) >> 1;
if (check(m)) {
ans = m;
l = m + 1;
} else {
r = m - 1;
}
}
return ans;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
if (!(cin >> n)) return 0;
vector<int> h(n);
for (int i = 0; i < n; i++) {
cin >> h[i];
}

// 1) baseline without any swap
ll max_area = maxAreaNoSwap(h);

// 2) build RMQ & sorted array
SparseTable st(h);
vector<int> hs = h;
sort(hs.begin(), hs.end());

// 3) for each position, consider swapping that bar outward
for (int i = 0; i < n; i++) {
int H = h[i];
// how many bars >= H
int cnt_smaller = int(lower_bound(hs.begin(), hs.end(), H) - hs.begin());
int count_good = n - cnt_smaller;

// center segment [l0..r0] where all >= H
int l0 = findLeftmost(0, i, [&](int x){
return st.query(x, i) >= H;
});
int r0 = findRightmost(i, n-1, [&](int x){
return st.query(i, x) >= H;
});
if (l0 == -1 || r0 == -1) continue;
int w0 = r0 - l0 + 1;

// possible extra on left of l0-1
int w_left = 0;
if (l0 >= 2) {
int end = l0 - 2;
int start = findLeftmost(0, end, [&](int x){
return st.query(x, end) >= H;
});
if (start != -1) {
w_left = end - start + 1;
}
}

// possible extra on right of r0+1
int w_right = 0;
if (r0 + 2 <= n-1) {
int start = r0 + 2;
int end = findRightmost(start, n-1, [&](int x){
return st.query(start, x) >= H;
});
if (end != -1) {
w_right = end - start + 1;
}
}

// by swapping h[i] with one bar outside center, width = w0 + 1 + max(w_left, w_right)
int w_swap = w0 + 1 + max(w_left, w_right);
int achievable = min(w_swap, count_good);
max_area = max(max_area, (ll)H * achievable);
}

cout << max_area << "\n";
return 0;
}

Python
import sys
import threading
def main():
import bisect
input = sys.stdin.readline

n = int(input())
h = list(map(int, input().split()))

# 1) 基准：单调栈求最大矩形
def max_area_no_swap(h):
st = [-1]
ans = 0
for i in range(len(h)+1):
cur = 0 if i==len(h) else h[i]
while st[-1] != -1 and h[st[-1]] >= cur:
H = h[st.pop()]
W = i - st[-1] - 1
ans = max(ans, H*W)
st.append(i)
return ans

base = max_area_no_swap(h)

# 2) 构建稀疏表 RMQ（区间最小值）
LOG = (n).bit_length()
st = [h[:]]
for k in range(1, LOG):
prev = st[k-1]
curr = [min(prev[i], prev[i+(1<<(k-1))]) for i in range(n-(1<<k)+1)]
st.append(curr)
log2 = [0]*(n+1)
for i in range(2, n+1):
log2[i] = log2[i//2] + 1
def rmq(l, r):
k = log2[r-l+1]
return min(st[k][l], st[k][r-(1<<k)+1])

# 3) 排序统计 >= H 的数量
hs = sorted(h)
def count_ge(x):
# 第一个 >= x 的索引
idx = bisect.bisect_left(hs, x)
return n - idx

# 二分查找辅助
def find_leftmost(L, R, H):
ans = -1
l, r = L, R
while l <= r:
m = (l+r)//2
if rmq(m, R) >= H:
ans = m
r = m-1
else:
l = m+1
return ans

def find_rightmost(L, R, H):
ans = -1
l, r = L, R
while l <= r:
m = (l+r)//2
if rmq(L, m) >= H:
ans = m
l = m+1
else:
r = m-1
return ans

ans = base
for i, H in enumerate(h):
# 中心最大区间 [l0..r0]
l0 = find_leftmost(0, i, H)
r0 = find_rightmost(i, n-1, H)
if l0==-1 or r0==-1:
continue
w0 = r0 - l0 + 1

# 左侧延伸
w_left = 0
if l0 >= 2:
end = l0 - 2
stl = find_leftmost(0, end, H)
if stl != -1:
w_left = end - stl + 1

# 右侧延伸
w_right = 0
if r0+2 <= n-1:
stp = find_rightmost(r0+2, n-1, H)
if stp != -1:
w_right = stp - (r0+2) + 1

total_good = count_ge(H)
w = w0 + 1 + max(w_left, w_right)
w = min(w, total_good)
ans = max(ans, w * H)

print(ans)

if __name__ == "__main__":
threading.Thread(target=main).start()

Java
import java.io.*;
import java.util.*;

public class Main {
static int n;
static int[] h;
static int[][] st;
static int[] log2;

public static void main(String[] args) throws IOException {
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
n = Integer.parseInt(in.readLine());
h = Arrays.stream(in.readLine().split("\\s+"))
.mapToInt(Integer::parseInt).toArray();

long base = maxAreaNoSwap();

buildSparseTable();
int[] hs = Arrays.copyOf(h, n);
Arrays.sort(hs);

long ans = base;
for (int i = 0; i < n; i++) {
int H = h[i];
int l0 = findLeftmost(0, i, H);
int r0 = findRightmost(i, n-1, H);
if (l0 < 0 || r0 < 0) continue;
int w0 = r0 - l0 + 1;

int wLeft = 0;
if (l0 >= 2) {
int end = l0 - 2;
int stl = findLeftmost(0, end, H);
if (stl >= 0) wLeft = end - stl + 1;
}

int wRight = 0;
if (r0 + 2 <= n-1) {
int str = findRightmost(r0 + 2, n-1, H);
if (str >= 0) wRight = str - (r0+2) + 1;
}

int totalGood = n - (Arrays.binarySearch(hs, H) < 0
? -Arrays.binarySearch(hs, H)-1
: Arrays.binarySearch(hs, H));
int w = w0 + 1 + Math.max(wLeft, wRight);
w = Math.min(w, totalGood);
ans = Math.max(ans, 1L * H * w);
}

System.out.println(ans);
}

// 单调栈求基准解
static long maxAreaNoSwap() {
Deque<Integer> st = new ArrayDeque<>();
st.push(-1);
long res = 0;
for (int i = 0; i <= n; i++) {
int cur = (i == n ? 0 : h[i]);
while (st.peek() != -1 && h[st.peek()] >= cur) {
int height = h[st.pop()];
int width = i - st.peek() - 1;
res = Math.max(res, 1L*height*width);
}
st.push(i);
}
return res;
}

// 构建稀疏表
static void buildSparseTable() {
log2 = new int[n+1];
for (int i = 2; i <= n; i++)
log2[i] = log2[i/2] + 1;
int K = log2[n] + 1;
st = new int[K][n];
System.arraycopy(h, 0, st[0], 0, n);
for (int k = 1; k < K; k++) {
for (int i = 0; i + (1<<k) <= n; i++) {
st[k][i] = Math.min(st[k-1][i], st[k-1][i + (1<<(k-1))]);
}
}
}

// 区间最小值查询
static int rmq(int l, int r) {
int k = log2[r-l+1];
return Math.min(st[k][l], st[k][r-(1<<k)+1]);
}

static int findLeftmost(int L, int R, int H) {
int ans = -1, l = L, r = R;
while (l <= r) {
int m = (l+r)>>1;
if (rmq(m, R) >= H) {
ans = m; r = m-1;
} else {
l = m+1;
}
}
return ans;
}

static int findRightmost(int L, int R, int H) {
int ans = -1, l = L, r = R;
while (l <= r) {
int m = (l+r)>>1;
if (rmq(L, m) >= H) {
ans = m; l = m+1;
} else {
r = m-1;
}
}
return ans;
}
}

---

### 第3题-VIP用户优先转发（P3297）
- 链接：https://codefun2000.com/p/P3297

> 页面标题：#P3297. 第3题-VIP用户优先转发

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

随着园区网络的高速发展,大带宽、大流量成了主旋律，但是当网络带宽超过设备的处理能力时，可能导致网络拥塞，挤占一些高优先级的业务(如VIPVIPVIP用户流量)，影响用户体验，所以对网络的用户体验优化成了园区网络的核心技术之一
在你接到一个用户需求，希望提升VIPVIPVIP用户的流量优先级,在网络拥时优先调度。其中用户的唯一身份标识是其MACMACMAC地址(如:00−d8−01−ef−31−3e00-d8-01-ef-31-3e00−d8−01−ef−31−3e)，所以我们需要在网络中配置所有VIPVIPVIP用户的MACMACMAC地址白名单，以便网络芯片转发引擎在执行流量转发时优先转发对应MACMACMAC地址的报文。
网络系统中VIPVIPVIP用户MACMACMAC地址配置格式为xx−xx−xx−xx−xx−xx/Mxx-xx-xx-xx-xx-xx/Mxx−xx−xx−xx−xx−xx/M，其中标识MACMACMAC地址和掩码长度
MACMACMAC地址由MACMACMAC地址48bit48bit48bit，共666字节组成，通常表示为666个十六进制数，格式为xx−xx−xx−xx−xx−xxxx-xx-xx-xx-xx-xxxx−xx−xx−xx−xx−xx。
如:00−d8−61−ef−31−3e00-d8-61-ef-31-3e00−d8−61−ef−31−3e就是一个MACMACMAC地址掩码长度表示在进行MACMACMAC地址匹配时关注的BITBITBIT位数，如:掩码长度404040转换成MACMACMAC地址掩码为ff−ff−ff−ff−f−00ff-ff-ff-ff-f-00ff−ff−ff−ff−f−00相当于MACMACMAC地址最后8bit8bit8bit不关注如:配置00−e0−fc−01−01−01/3200-e0-fc-01-01-01/3200−e0−fc−01−01−01/32，其对应的MACMACMAC地址掩码为ff−ff−f−ff−00−00ff-ff-f-ff-00-00ff−ff−f−ff−00−00,能匹配上的VIP MACVIP\ MACVIP MAC地址范围是00−e0−fc−01−00−0000-e0-fc-01-00-0000−e0−fc−01−00−00~00−e0−fc−01−ff−ff00-e0-fc-01-ff-ff00−e0−fc−01−ff−ff
输入描述
输入第一行为整数 n(1≤n≤100000)n (1 ≤n≤100000)n(1≤n≤100000)，代表需要配置为VIPVIPVIP的MACMACMAC地址及其掩码个数。
接下来nnn行是对应VIPVIPVIP用户MACMACMAC地址及其掩码长度，格式为xx−xx−xx−xx−xx−xx/Mxx-xx-xx-xx-xx-xx/Mxx−xx−xx−xx−xx−xx/M，其中M(0≤M≤48)M(0 ≤ M ≤48)M(0≤M≤48)，MAC地址由数字和小写英文字母组成
然后是转发引擎待处理的报文MACMACMAC地址数目m(1≤m≤100)m(1≤m≤100)m(1≤m≤100)
接下来mmm行是转发引擎待处理的报文MACMACMAC地址，格式为xx−xx−xx−xx−xx−xxxx-xx-xx-xx-xx-xxxx−xx−xx−xx−xx−xx
输出描述
输出mmm个转发引擎待处理的报文MACMACMAC地址是否可以优先调度，是输出YESYESYES，不是则输出NONONO
样例1
输入
2
00-d8-61-ef-31-3e/48
00-e0-fc-00-ed-50/40
2
00-e0-fc-00-ed-66
00-d8-61-ef-31-3f

输出
YES
NO

说明
00−e0−fc−00−ed−6600-e0-fc-00-ed-6600−e0−fc−00−ed−66在VIP MACVIP\  MACVIP MAC地址列表中可以匹配，因为00−e0−fc−00−ed−50/4800-e0-fc-
00-ed-50/4800−e0−fc−00−ed−50/48表示匹配范围为00−e0−fc−00−ed−xx00-e0-fc-00-ed-xx00−e0−fc−00−ed−xx,其中xxxxxx不关注。
00−d8−61−ef−31−3f00-d8-61-ef-31-3f00−d8−61−ef−31−3f在VIP MACVIP\ MACVIP MAC地址列表中无法匹配
样例2
输入
1
00-d8-61-ef-31-3e/0
1
02-12-13-14-15-16

输出
YES

#### TextSol

题面描述
随着园区网络的高速发展，大带宽、大流量成了主旋律，但是当网络带宽超过设备的处理能力时，可能导致网络拥塞，挤占一些高优先级的业务（如VIPVIPVIP用户流量），影响用户体验，所以对网络的用户体验优化成了园区网络的核心技术之一。
现有需求：希望提升VIPVIPVIP用户的流量优先级，在网络拥时优先调度。用户的唯一身份标识是其MACMACMAC地址（例如：000000-d8d8d8-010101-efefef-313131-3e3e3e），因此需要在网络中配置所有VIPVIPVIP用户的MACMACMAC地址白名单，以便网络芯片转发引擎在执行流量转发时优先转发对应MACMACMAC地址的报文。
网络系统中VIPVIPVIP用户MACMACMAC地址配置格式为 xx-xx-xx-xx-xx-xx/M，其中标识MACMACMAC地址和掩码长度。MACMACMAC地址由484848 bit，共666字节组成，通常表示为666个十六进制数，格式为 xx-xx-xx-xx-xx-xx。例如：00-d8-61-ef-31-3e 就是一个MACMACMAC地址。掩码长度表示在进行MACMACMAC地址匹配时关注的 bit 位数，如掩码长度 404040 转换成MACMACMAC地址掩码为 ff-ff-ff-ff-f0-00（高404040位关注，低888位不关注）；配置 00-e0-fc-01-01-01/323232，其对应的MACMACMAC地址掩码为 ff-ff-ff-ff-00-00（高323232位关注，低161616位不关注），能匹配的VIPMACVIP MACVIPMAC地址范围是 00-e0-fc-01-00-00 到 00-e0-fc-01-ff-ff。
思路

问题本质

这道题的本质是“前缀匹配”：给定若干个484848 位长度的地址前缀（带掩码长度MMM），然后对于每个查询地址，判断其前MMM位是否与某个前缀相同。
这与 IP 前缀匹配类似，但这里是MACMACMAC地址，共484848位，掩码长度范围000到484848。当掩码长度为000时表示不关心任何位，即可以匹配任意地址；掩码长度为484848时表示完全精确匹配。

数据表示

将每个MACMACMAC地址转换为一个484848 位的整数（可以用646464位整数类型存储）。例如：字符串 "00-d8-61-ef-31-3e" → 每个十六进制字节转换后依次左移拼成一个484848 位整数。
对于一个带掩码长度MMM的前缀 addr/M，构造其掩码：高MMM位为111，低48−M48-M48−M 位为 000。或者我们更方便的方式：我们只需要把地址右移(48−M)(48 - M)(48−M) 位，保留高MMM 位，称为“前缀值”。匹配时也将查询地址右移相同的(48−M)(48 - M)(48−M) 位，如果结果相等则匹配。
例如：掩码长度M=32M=32M=32，00-e0-fc-01-01-01 转整数后右移48−32=1648-32=1648−32=16 位，得到高 323232 位前缀。查询地址同样右移161616位再比较。

多前缀匹配加速

nnn最多可达100000100000100000，mmm可能也很大，暴力对每个查询遍历所有前缀显然不可行。

观察到掩码长度MMM的取值范围是000到484848，最多494949种可能。我们可以针对每个可能的掩码长度LLL，维护一个哈希集合（如 C++ 的 unordered_set<uint64_t>，Python 的 set，Java 的 HashSet<Long>），存储所有白名单前缀右移后的值。

具体：

读到一个前缀 addr/M，将 addr_int 右移(48−M)(48 - M)(48−M) 位得到 prefix_value，插入到对应掩码长度集合集合S[M]S[M]S[M]中。
查询时，对于当前查询地址 q_int，对每个存在白名单的掩码长度LLL（即S[L]S[L]S[L] 非空），计算 q_int >> (48 - L)，然后检查该值是否在S[L]S[L]S[L] 中。如果存在，则该查询答案为 YES，否则继续检查下一个掩码长度；若都不匹配，则为 NO。

因为掩码长度可能的值只有494949种，查询时最多做494949次哈希查找，时间是O(∣distinct masks∣)O(|distinct\ masks|)O(∣distinct masks∣)，通常远小于nnn，满足性能需求。

边界情况

掩码长度M=0M=0M=0：任何地址右移484848 位（即 >>48）得到000，如果存在一个M=0M=0M=0的前缀，则所有查询地址都匹配，答案始终 YES。
掩码长度M=48M=48M=48：需要精确匹配，右移(48−48)=0(48-48)=0(48−48)=0 位即不变，直接把完整484848 位整数存入集合，在查询时直接检查完整整数是否在集合中。
合法性：输入保证 MAC 字符串合法格式。注意要忽略大小写差异，可统一转换为小写或大写再解析。
空白和分隔：输入中 MAC 字节用 - 分隔，掩码用 / 紧跟在地址后。读取时按字符串解析即可。

时间空间复杂度

空间：需要存储nnn个前缀值在对应集合中，总数不超过nnn，所以O(n)O(n)O(n) 空间。
构造：逐条插入哈希表，平均O(1)O(1)O(1)，总O(n)O(n)O(n).
查询：每条查询最多对ddd个不同掩码长度做哈希查找，d≤49d \le 49d≤49，所以每条O(49)O(49)O(49) 平均。总共O(m×49)O(m \times 49)O(m×49)。当mmm很大时也足够快。
解析 MAC 为整数时间 O(1)O(1)O(1)，常数开销。

C++
#include <bits/stdc++.h>
using namespace std;

// 将 MAC 地址字符串解析为 48 位整数
// 格式假定为 "xx-xx-xx-xx-xx-xx"，xx 为十六进制表示的字节
uint64_t parse_mac_to_int(const string &mac_str) {
uint64_t mac = 0;
int len = mac_str.size();
// 逐段解析，中间以 '-' 分隔
// 简单方式：按 '-' 分割
uint64_t byte = 0;
int parts = 0;
size_t start = 0;
for (int i = 0; i <= len; ++i) {
if (i == len || mac_str[i] == '-') {
// mac_str[start..i-1] 是两位十六进制
string part = mac_str.substr(start, i - start);
// 转为整数
byte = std::stoul(part, nullptr, 16);
mac = (mac << 8) | (byte & 0xFF);
parts++;
start = i + 1;
if (parts == 6) break;
}
}
return mac;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int n;
cin >> n;
// 数组下标 0..48，每个位置存储该掩码长度对应的前缀集合
vector<unordered_set<uint64_t>> prefix_sets(49);
bool has_zero_mask = false;

string line;
for (int i = 0; i < n; ++i) {
cin >> line;  // 例如 "00-d8-61-ef-31-3e/48"
// 按 '/' 分割
size_t pos = line.find('/');
string mac_part = line.substr(0, pos);
int mask_len = stoi(line.substr(pos + 1));
// 解析 MAC 为整数
uint64_t mac_int = parse_mac_to_int(mac_part);
if (mask_len == 0) {
// 掩码长度为 0，匹配任意地址
has_zero_mask = true;
// 仍可在 prefix_sets[0] 中插入任意值，如 0
prefix_sets[0].insert(0ULL);
} else {
// 右移以保留高 mask_len 位
int shift = 48 - mask_len;
uint64_t prefix = (mac_int >> shift);
prefix_sets[mask_len].insert(prefix);
}
}

int m;
cin >> m;
string query_mac;
for (int qi = 0; qi < m; ++qi) {
cin >> query_mac;  // "xx-xx-xx-xx-xx-xx"
uint64_t q_int = parse_mac_to_int(query_mac);

bool matched = false;
// 如果存在掩码长度 0，则总匹配
if (has_zero_mask) {
matched = true;
} else {
// 遍历所有可能的掩码长度
for (int L = 1; L <= 48; ++L) {
if (prefix_sets[L].empty()) continue;
int shift = 48 - L;
uint64_t q_prefix = (q_int >> shift);
if (prefix_sets[L].count(q_prefix)) {
matched = true;
break;
}
}
}
if (matched) {
cout << "YES\n";
} else {
cout << "NO\n";
}
}

return 0;
}

Python
import sys

def parse_mac_to_int(mac_str: str) -> int:
# mac_str 形如 "xx-xx-xx-xx-xx-xx"
parts = mac_str.split('-')
mac_int = 0
for part in parts:
mac_int = (mac_int << 8) | int(part, 16)
return mac_int

def main():
data = sys.stdin
# 读取 n
line = data.readline().strip()
if not line:
return
n = int(line)
# prefix_sets[L] 存储掩码长度为 L 的前缀集合
prefix_sets = [set() for _ in range(49)]
has_zero_mask = False

for _ in range(n):
line = data.readline().strip()
# 可能有空行，要跳过
if not line:
continue
mac_part, mask_part = line.split('/')
mask_len = int(mask_part)
mac_int = parse_mac_to_int(mac_part)
if mask_len == 0:
has_zero_mask = True
prefix_sets[0].add(0)
else:
shift = 48 - mask_len
prefix = mac_int >> shift
prefix_sets[mask_len].add(prefix)

# 读取 m
line = data.readline().strip()
m = int(line)
for _ in range(m):
qline = data.readline().strip()
if not qline:
continue
q_int = parse_mac_to_int(qline)
matched = False
if has_zero_mask:
matched = True
else:
# 遍历所有掩码长度
for L in range(1, 49):
if not prefix_sets[L]:
continue
shift = 48 - L
q_prefix = q_int >> shift
if q_prefix in prefix_sets[L]:
matched = True
break
print("YES" if matched else "NO")

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

public class VipMacMatcher {

// 将 MAC 地址解析为 48 位整数，结果存储在 long 类型中
// 格式假定 "xx-xx-xx-xx-xx-xx"
private static long parseMacToLong(String macStr) {
String[] parts = macStr.split("-");
long mac = 0;
for (String part : parts) {
// Long.parseLong 可解析十六进制，需要指定基数 16
long byteVal = Long.parseLong(part, 16);
mac = (mac << 8) | (byteVal & 0xFF);
}
return mac;
}

public static void main(String[] args) throws IOException {
BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
String line = reader.readLine();
if (line == null || line.isEmpty()) {
return;
}
int n = Integer.parseInt(line.trim());
// prefixSets[L] 存放掩码长度为 L 的前缀集合
@SuppressWarnings("unchecked")
Set<Long>[] prefixSets = new HashSet[49];
for (int i = 0; i <= 48; i++) {
prefixSets[i] = new HashSet<>();
}
boolean hasZeroMask = false;

for (int i = 0; i < n; i++) {
line = reader.readLine().trim();
if (line.isEmpty()) {
i--;
continue;
}
String[] parts = line.split("/");
String macPart = parts[0];
int maskLen = Integer.parseInt(parts[1]);
long macInt = parseMacToLong(macPart);
if (maskLen == 0) {
hasZeroMask = true;
prefixSets[0].add(0L);
} else {
int shift = 48 - maskLen;
long prefix = macInt >>> shift;
prefixSets[maskLen].add(prefix);
}
}

line = reader.readLine().trim();
int m = Integer.parseInt(line);
for (int i = 0; i < m; i++) {
line = reader.readLine().trim();
if (line.isEmpty()) {
i--;
continue;
}
long qInt = parseMacToLong(line);
boolean matched = false;
if (hasZeroMask) {
matched = true;
} else {
for (int L = 1; L <= 48; L++) {
if (prefixSets[L].isEmpty()) {
continue;
}
int shift = 48 - L;
long qPrefix = qInt >>> shift;
if (prefixSets[L].contains(qPrefix)) {
matched = true;
break;
}
}
}
System.out.println(matched ? "YES" : "NO");
}
}
}

---

### 第3题-网络连接拒绝执行数（P3294）
- 链接：https://codefun2000.com/p/P3294

> 页面标题：#P3294. 第3题-网络连接拒绝执行数

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

有一些网络设备，其中某些设备具备互斥特性，这些设备中任意两台设备都无法直接或间接的连接在一起。
网络工程师按照给定的一系列指令将设备两两连接，可一旦网络工程师判
断连接指令触发了互斥规则，他将拒绝执行这条指令、将其记录并继续执行后续指令。
求所有指令执行完毕后，网络工程师拒绝执行指令的总数。
输入描述
N M XN\ M\ XN M X
A1...AmA1...AmA1...Am
C1 D1C1\ D1C1 D1
C2 D2C2\ D2C2 D2
...
Cx DxCx\ DxCx Dx
解释说明:
Line1:NLine1:NLine1:N:设备总量(>=1(>=1(>=1且<=1000<=1000<=1000,设备会从000开始编号)，MMM:互斥设备数量(>=2>=2>=2且<=20<=20<=20)，xxx:指令数量(>=1>=1>=1且<=1000<=1000<=1000)，固定3个数字，以空格分割。
Line2Line2Line2:互斥设备的编号列表，编号数量等于Line1Line1Line1的互斥设备数量，不会重复。AiAiAi表示互斥设备的编号，2<=i<=M2<=i<=M2<=i<=M
Line3−LineX+2Line3-LineX+2Line3−LineX+2:连接指令列表，一共XXX条指令数量，每行代表一条两两设备的连接指令，每行固定两个数字，以空格分割代表需要连接的设备编号,且指令内编号不会重复。Cj,DjCj,DjCj,Dj分别表示第j条指令中的两个设备，
1<=j<=N,Cj≠Dj1<=j<=N,Cj≠Dj1<=j<=N,Cj=Dj
输出描述
被拒绝执行的指令条数。
样例1
输入
5 2 5
1 2
0 1
1 2
2 3
0 3
1 4

输出
2

说明
第111条指令，000和111连接成功，执行成功，未触发互斥规则。此时连接状态为[0,1][0,1][0,1]

第222条指令，111和222不可连接，执行失败，直接触发了互斥规则。此时连接状态依然为[0,1][0,1][0,1]。

第333条指令，222和333连接成功，执行成功,未触发互斥规则。此时连接状态为[0.1],[2,3][0.1],[2,3][0.1],[2,3]

第444条指令，000和333不可连接，执行失败，触发了互斥规则。此时连接状杰依然为[0,1]、[2,3][0,1]、[2,3][0,1]、[2,3]。注:若连接成功,则设备111和222会由于000和333的连接产生间接连通性。

第555条指令，111和444可连接，执行成功，未触发互斥规则。此时连接状态为[0,1,4]、[2,3][0,1,4]、[2,3][0,1,4]、[2,3]。

▶️

#### TextSol

video solution

题解
问题描述
给定NNN台编号为000到N−1N-1N−1的网络设备，其中有一组大小为MMM的设备是互斥的——这MMM台设备之间任意两台都不能直接或间接相连。网络工程师收到XXX条连接指令，每条指令是将编号为 CjC_jCj​ 和DjD_jDj​的两台设备连接。如果执行某条指令会导致在互斥设备子集中出现路径相连，则该指令被拒绝并计数，但仍继续处理后续指令。
请在所有指令执行完毕后，输出被拒绝执行的指令总数。

思路分析

使用并查集维护各设备的连通分量。

初始时，任意设备都是独立的。

对于每条指令(Cj,Dj)(C_j, D_j)(Cj​,Dj​)，

先在并查集中查询CjC_jCj​和DjD_jDj​的根节点rCr_CrC​、rDr_DrD​。

如果将这条边加入，会令某互斥设备子集中存在两台设备连通，则拒绝：

预先将互斥设备列表中每台设备的根记录下来，或维护一个集合SSS，对该集合中的根做标记。
若连接后rCr_CrC​ 与 rDr_DrD​ 中至少有一个已标记为互斥设备所在根，且合并后会造成两个不同的互斥根合并，则拒绝。

否则合并rCr_CrC​ 与rDr_DrD​，并更新标记信息。

统计拒绝次数即可。

cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;
int parent[MAXN], sz[MAXN];
bool blocked[MAXN]; // 标记并查集根是否覆盖互斥设备子集

// 并查集初始化
int findp(int x) {
return parent[x] == x ? x : parent[x] = findp(parent[x]);
}

void unite(int a, int b) {
a = findp(a);
b = findp(b);
if (a == b) return;
// 按大小合并
if (sz[a] < sz[b]) swap(a, b);
parent[b] = a;
sz[a] += sz[b];
// 如果其中一个集合是互斥设备集，合并后保持标记
blocked[a] = blocked[a] || blocked[b];
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int N, M, X;
cin >> N >> M >> X;
vector<int> A(M);
for (int i = 0; i < N; i++) {
parent[i] = i;
sz[i] = 1;
blocked[i] = false;
}
for (int i = 0; i < M; i++) {
cin >> A[i];
}
// 将互斥设备标记到各自根
for (int v : A) {
blocked[findp(v)] = true;
}

int reject = 0;
while (X--) {
int u, v;
cin >> u >> v;
int ru = findp(u);
int rv = findp(v);
// 若两个集合都已有互斥标记，且不在同一集合，则拒绝
if (ru != rv && blocked[ru] && blocked[rv]) {
reject++;
} else {
unite(ru, rv);
}
}
cout << reject;
return 0;
}

python
# 并查集实现
class DSU:
def __init__(self, n):
self.parent = list(range(n))
self.sz = [1] * n
self.blocked = [False] * n  # 互斥标记

def findp(self, x):
if self.parent[x] != x:
self.parent[x] = self.findp(self.parent[x])
return self.parent[x]

def unite(self, a, b):
a = self.findp(a)
b = self.findp(b)
if a == b:
return
if self.sz[a] < self.sz[b]:
a, b = b, a
self.parent[b] = a
self.sz[a] += self.sz[b]
self.blocked[a] = self.blocked[a] or self.blocked[b]

def main():
import sys
data = sys.stdin.read().split()
N, M, X = map(int, data[:3])
A = list(map(int, data[3:3+M]))
ops = list(map(int, data[3+M:]))

dsu = DSU(N)
# 标记互斥设备根
for v in A:
dsu.blocked[dsu.findp(v)] = True

rejects = 0
idx = 0
for _ in range(X):
u, v = ops[idx], ops[idx+1]
idx += 2
ru, rv = dsu.findp(u), dsu.findp(v)
if ru != rv and dsu.blocked[ru] and dsu.blocked[rv]:
rejects += 1
else:
dsu.unite(ru, rv)
print(rejects)

if __name__ == '__main__':
main()

java
import java.io.*;
import java.util.*;

public class Main {
static int[] parent, sz;
static boolean[] blocked;

static int findp(int x) {
if (parent[x] != x) {
parent[x] = findp(parent[x]);
}
return parent[x];
}

static void unite(int a, int b) {
a = findp(a);
b = findp(b);
if (a == b) return;
if (sz[a] < sz[b]) {
int t = a; a = b; b = t;
}
parent[b] = a;
sz[a] += sz[b];
blocked[a] = blocked[a] || blocked[b];
}

public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
int N = Integer.parseInt(st.nextToken());
int M = Integer.parseInt(st.nextToken());
int X = Integer.parseInt(st.nextToken());

parent = new int[N]; sz = new int[N]; blocked = new boolean[N];
for (int i = 0; i < N; i++) {
parent[i] = i;
sz[i] = 1;
blocked[i] = false;
}
st = new StringTokenizer(br.readLine());
for (int i = 0; i < M; i++) {
int v = Integer.parseInt(st.nextToken());
blocked[findp(v)] = true;
}

int rejects = 0;
for (int i = 0; i < X; i++) {
st = new StringTokenizer(br.readLine());
int u = Integer.parseInt(st.nextToken());
int v = Integer.parseInt(st.nextToken());
int ru = findp(u), rv = findp(v);
if (ru != rv && blocked[ru] && blocked[rv]) {
rejects++;
} else {
unite(ru, rv);
}
}
System.out.println(rejects);
}
}

---

### 第3题-命令关键字统计（P3303）
- 链接：https://codefun2000.com/p/P3303

> 页面标题：#P3303. 第3题-命令关键字统计

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

在 IPIPIP 领域中对设备的操作是通过配置命令行实现，在设备的产品文档中会为该设备支持的每个命令定义格式。命令格式定义必须遵循格式定义的规范要求，规范要求如下表所示。

备注说明：
1.关键字、分组括号、分支选择符之间通过一个空格隔开。除了括号和分支选择符 ∣|∣ 外，其他都视为关键字
2.命令行最长 100010001000 个字符长度。
下面是一些正确命令格式定义示例：
1.d r { k | n k }
2.d r [ { k | n k } ]
3.d k { k | r { k m | n k } [ k r ] }

假设产品文档中的命令格式定义都经过确认是正确的，并且关键字、分支符、括号之间都已经用空格隔开了。现在需要统计某个定义中每个必选关键字至少需要出现的次数。
输入描述
输入字符串为一个命令的格式定义，命令格式定义都经过确认是正确的，并且关键字、分支符，括号之间都已经用空格隔开了。暂不需要考虑错误格式比如这种 d k rd\ k\ rd k r { a∣da | d a∣d} 。
输出描述
输出为两行，第一行为必选关键字，按单词字母顺序排序，并用一个空格隔开，第二行为对应第一行位置上必选关键字的最小出现次数，也是用一个空格隔开。
样例1
输入
d r { k | n k }

输出
d k r
1 1 1

说明
大括号分组{}表示必选，分组里面有 222 个分支，每个分支都有 kkk ，因此 kkk 是必须输入的，并且次数为 111 。
样例2
输入
d r [ { k | n k } ]

输出
d r
1 1

说明
后面的中括号是分组[]表示可选，因此里面的所有内容都可以不输入。
样例3
输入
d k { k | r { k m | n k } [ k r ] }

输出
d k
1 2

说明
后面的大括号分组{}表示必选，其中有 222 个分支，递归分析每个分支中都必须输入至少 111 个关键字 kkk 。因此整个表达式要输入的 kkk 的数量至少为 222 。
样例4
输入
d r { m | n }

输出
d r
1 1

说明
虽然，{mmm|nnn} 表示 mmm 和 nnn 二选一，合法命令可以输入 ddd rrr mmm 或者 ddd rrr nnn 。
所以必选关键就只有 ddd 和 rrr 。
必选关键字的意思是：要满足格式定义，正确命令中必须出现的关键字。
样例5
输入
n { h { a i n | n [ v ] } | s i {m | k | m n } n | r i { { n | a } | m n } | g n | u n [ d n ] } { b { c | m n } } { c { d [ e ] f { c [ d ] { c { f { d e { a { b n } } } [ d ] } } } } } [ b ] n { h { b i n | n [ v ] } | s i { m | k | w w } n | r i { n | m n } | g n | u n [ d n ] | u { n | a } [ d n ] } { b { b | m n } } { c { d [ e ] f { d [ d ] { e { f { d [ d ] { e { f { d e { a { b n } } } [ d ] } } } } } { h { b i { n | a } | n [ v ] } | s i { m | k | w w } n | r i { n | m n } | g n | u n | [ d n ] | u n [ d n ] } { b { b | m n } } { c { d [ e ] f { d [ d ] { n { f { a { a { b n } } } [ d ] } } } } } [ x ] { n | a } { h { a i n | n [ v ] } | r i { n | m n } | g n | u n [ d n ] | u n [ d n ] } { b { b | m n } } { c { d [ e ] f { d [ d ] { e { f { d e { b { b n } } } [ d ] } } } } } [ k ] { n | a } { h { a i n | n [ v ] } | s i { m | k | w w} n | r i { n | m n } | g { n | a } | u { n | a } [ d n ] | u n [ d n ] } { n | [ d ] n } { [ a b ] | [ b n ] }

输出
a b c d e f n
4 9 6 10 5 8 9

#### TextSol

题目描述
在命令格式定义字符串中，关键词（令牌）通过空格分隔，并有以下结构化标记：

大括号 { … } 表示“必选分支”，内部是若干以 | 分隔的分支，必须选择其中之一；
中括号 [ … ] 表示“可选分支”，内部内容可选出现；
分支内部又可嵌套任意深度的混合结构。

我们需要统计在任意合法命令中，每个必选关键词至少需要出现的次数。必选关键词指：无论如何选择可选分支或必选分支，都必须出现的那些关键词；其出现次数取每种最小分支组合下的最低值，再取所有分支的最大值（因为分支二选一，需对每条分支计算，然后取最小，再对并列大括号分组累加）。
思路概述

解析表达式
将输入按空格切分为令牌列表，利用递归下降或栈结构，构建语法树节点，包括：

普通关键词节点（Token）
顺序节点（Sequence），表示一系列子节点依次出现
分支节点（Branch），表示由大括号或中括号包裹的子节点，其中包含若干分支选项及“必选”或“可选”属性

计算最小出现次数
对每个节点定义函数 f(node)f(node)f(node)，返回一个映射：每个关键词到最低出现次数。

Token：f(关键词k)=k:1f(关键词k)={k:1}f(关键词k)=k:1

Sequence：f([n1,…,nm])f([n_1,\dots,n_m])f([n1​,…,nm​])=mergePlus(f(n1),…,f(nm)){mergePlus}(f(n_1),\dots,f(n_m))mergePlus(f(n1​),…,f(nm​))，即对应关键词相加出现次数，未出现视为 0。

Branch：

若“必选”分支 {b1∣…∣bp}\{b_1|\dots|b_p\}{b1​∣…∣bp​}：对每个分支 bib_ibi​ 计算 f(bi)f(b_i)f(bi​)，然后对每个关键词取“在所有分支中的最小值”，即
fmin⁡(k)=min⁡1≤i≤pfbi(k) .f_{\min}(k)=\min_{1\le i\le p}f_{b_i}(k)\,. fmin​(k)=min1≤i≤p​fbi​​(k).
若“可选”分支 [b1∣…∣bp][b_1|\dots|b_p][b1​∣…∣bp​]：可整体不选，等价于在“必选分支”基础上再与“空分支”做一次分支比较，即将映射与一个全 0 映射一并做最小值运算。

整合结果
根节点调用 f(root)f(root)f(root) 得到每个关键词的最低出现次数映射，剔除出现次数为 0 的关键词（即非必选），然后按关键词字母顺序输出。

cpp
#include <bits/stdc++.h>
using namespace std;

// 抽象基类：表达式节点
struct Node {
virtual unordered_map<string,int> calc() = 0;
virtual ~Node() = default;
};

// 普通关键词节点
struct TokenNode : Node {
string tok;
TokenNode(const string& s) : tok(s) {}
unordered_map<string,int> calc() override {
return {{tok, 1}};
}
};

// 顺序节点：依次执行多个子节点
struct SequenceNode : Node {
vector<Node*> children;
unordered_map<string,int> calc() override {
unordered_map<string,int> res;
for (auto* c : children) {
auto m = c->calc();
for (auto& [k,v] : m) {
res[k] += v;
}
}
return res;
}
~SequenceNode() { for (auto* c: children) delete c; }
};

// 分支节点：必选或可选
struct BranchNode : Node {
vector<Node*> options;
bool required; // true 表示 { … }，false 表示 [ … ]
unordered_map<string,int> calc() override {
vector<unordered_map<string,int>> ms;
for (auto* opt : options)
ms.push_back(opt->calc());
if (!required) {
// 可选：加入一个空分支
ms.push_back({});
}
// 对所有分支取关键词最小值
unordered_map<string,int> res;
// 收集所有关键词
set<string> keys;
for (auto& m: ms)
for (auto& [k,_]: m)
keys.insert(k);
for (auto& k: keys) {
int mn = INT_MAX;
for (auto& m: ms) {
mn = min(mn, m.count(k) ? m[k] : 0);
}
if (mn>0) res[k] = mn;
}
return res;
}
~BranchNode() { for (auto* c: options) delete c; }
};

// 全局变量：令牌列表及指针
vector<string> T;
int pos = 0;

// 解析一个节点（可能是序列或单一）
Node* parseNode();

// 解析分支 { … } 或 [ … ]
BranchNode* parseBranch() {
bool req = (T[pos] == "{");
pos++; // 跳过 { 或 [
BranchNode* bn = new BranchNode();
bn->required = req;
// 分支内部其实是若干选项，以 '|' 分隔
while (pos < T.size() && (req ? T[pos]!="}" : T[pos]!="]")) {
// 解析一个选项序列
SequenceNode* seq = new SequenceNode();
while (pos < T.size() && T[pos]!="|" && T[pos]!=(req? "}" : "]")) {
if (T[pos]=="{" || T[pos]=="[") {
seq->children.push_back(parseBranch());
} else {
seq->children.push_back(new TokenNode(T[pos]));
pos++;
}
}
bn->options.push_back(seq);
if (T[pos] == "|") pos++;
}
pos++; // 跳过 } 或 ]
return bn;
}

// 解析整个表达式为序列节点
Node* parseNode() {
SequenceNode* seq = new SequenceNode();
while (pos < T.size()) {
if (T[pos] == "{" || T[pos] == "[") {
seq->children.push_back(parseBranch());
} else if (T[pos] == "}" || T[pos] == "]" || T[pos] == "|") {
break;
} else {
seq->children.push_back(new TokenNode(T[pos]));
pos++;
}
}
return seq;
}

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

// 读入整行并分词
string line;
getline(cin, line);
istringstream iss(line);
string w;
while (iss >> w) T.push_back(w);

// 构建语法树
Node* root = parseNode();
// 计算最小出现次数映射
auto mp = root->calc();
delete root;

// 只保留出现次数 ≥1 的关键词
vector<pair<string,int>> ans;
for (auto& [k,v]: mp) if (v>0) ans.emplace_back(k,v);
sort(ans.begin(), ans.end(),
[](auto& a, auto& b){ return a.first < b.first; });

// 输出
for (int i = 0; i < ans.size(); i++) {
if (i) cout << ' ';
cout << ans[i].first;
}
cout << "\n";
for (int i = 0; i < ans.size(); i++) {
if (i) cout << ' ';
cout << ans[i].second;
}
cout << "\n";
return 0;
}

python
# Python 版本
import sys
sys.setrecursionlimit(10000)

# 读入并分词
tokens = sys.stdin.read().strip().split()
pos = 0

class Node:
def calc(self): pass

class TokenNode(Node):
def __init__(self, tok): self.tok = tok
def calc(self):
return {self.tok: 1}

class SequenceNode(Node):
def __init__(self): self.children = []
def calc(self):
res = {}
for c in self.children:
for k,v in c.calc().items():
res[k] = res.get(k, 0) + v
return res

class BranchNode(Node):
def __init__(self, required): self.required = required; self.options = []
def calc(self):
maps = [opt.calc() for opt in self.options]
if not self.required:
maps.append({})
keys = set(k for m in maps for k in m)
res = {}
for k in keys:
mn = min(m.get(k,0) for m in maps)
if mn>0: res[k] = mn
return res

def parse_branch():
global pos
req = tokens[pos] == '{'
pos += 1
bn = BranchNode(req)
while tokens[pos] != ('}' if req else ']'):
seq = SequenceNode()
while tokens[pos] not in ['|', '}', ']']:
if tokens[pos] in ['{','[']:
seq.children.append(parse_branch())
else:
seq.children.append(TokenNode(tokens[pos]))
pos += 1
bn.options.append(seq)
if tokens[pos] == '|': pos += 1
pos += 1
return bn

def parse_node():
global pos
seq = SequenceNode()
while pos < len(tokens) and tokens[pos] not in ['}',''] :
if tokens[pos] in ['{','[']:
seq.children.append(parse_branch())
elif tokens[pos] in ['}','|',']']:
break
else:
seq.children.append(TokenNode(tokens[pos]))
pos += 1
return seq

root = parse_node()
mp = root.calc()
ans = sorted((k,v) for k,v in mp.items() if v>0)
print(' '.join(k for k,_ in ans))
print(' '.join(str(v) for _,v in ans))

java
import java.util.*;

public class Main {
static List<String> T;
static int pos;

interface Node {
Map<String,Integer> calc();
}

static class TokenNode implements Node {
String tok;
TokenNode(String t){ tok=t; }
public Map<String,Integer> calc(){
return Collections.singletonMap(tok,1);
}
}

static class SequenceNode implements Node {
List<Node> ch = new ArrayList<>();
public Map<String,Integer> calc(){
Map<String,Integer> res = new HashMap<>();
for (Node n: ch) {
for (var e: n.calc().entrySet()){
res.put(e.getKey(), res.getOrDefault(e.getKey(),0)+e.getValue());
}
}
return res;
}
}

static class BranchNode implements Node {
boolean req;
List<Node> opts = new ArrayList<>();
BranchNode(boolean r){ req=r; }
public Map<String,Integer> calc(){
List<Map<String,Integer>> ms = new ArrayList<>();
for (Node n: opts) ms.add(n.calc());
if (!req) ms.add(new HashMap<>());
Set<String> keys = new HashSet<>();
for (var m: ms) keys.addAll(m.keySet());
Map<String,Integer> res = new HashMap<>();
for (String k: keys){
int mn = Integer.MAX_VALUE;
for (var m: ms) mn = Math.min(mn, m.getOrDefault(k,0));
if (mn>0) res.put(k,mn);
}
return res;
}
}

static Node parseNode(){
SequenceNode seq = new SequenceNode();
while (pos < T.size()) {
String tk = T.get(pos);
if (tk.equals("{") || tk.equals("[")) {
seq.ch.add(parseBranch());
} else if (tk.equals("}")||tk.equals("]")||tk.equals("|")) {
break;
} else {
seq.ch.add(new TokenNode(tk));
pos++;
}
}
return seq;
}

static BranchNode parseBranch(){
boolean req = T.get(pos).equals("{");
pos++;
BranchNode bn = new BranchNode(req);
while (!(T.get(pos).equals(req? "}" : "]"))) {
SequenceNode seq = new SequenceNode();
while (!T.get(pos).equals("|") && !T.get(pos).equals("}") && !T.get(pos).equals("]")) {
if (T.get(pos).equals("{")||T.get(pos).equals("[")){
seq.ch.add(parseBranch());
} else {
seq.ch.add(new TokenNode(T.get(pos)));
pos++;
}
}
bn.opts.add(seq);
if (T.get(pos).equals("|")) pos++;
}
pos++;
return bn;
}

public static void main(String[] args){
Scanner sc = new Scanner(System.in);
T = Arrays.asList(sc.nextLine().split("\\s+"));
pos = 0;
Node root = parseNode();
Map<String,Integer> mp = root.calc();
List<String> keys = new ArrayList<>();
for (var e: mp.entrySet()) if (e.getValue()>0) keys.add(e.getKey());
Collections.sort(keys);
for (int i=0;i<keys.size();i++){
if (i>0) System.out.print(" ");
System.out.print(keys.get(i));
}
System.out.println();
for (int i=0;i<keys.size();i++){
if (i>0) System.out.print(" ");
System.out.print(mp.get(keys.get(i)));
}
System.out.println();
}
}

---

### 第3题-无线网络设备覆盖区域数量（P3300）
- 链接：https://codefun2000.com/p/P3300

> 页面标题：#P3300. 第3题-无线网络设备覆盖区域数量

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你负责一个大型办公园区的无线网络部署。园区可以视作一个 m∗nm*nm∗n 的网格，每个网格位置可以放置个无线接入点。每个无线接入点可以覆盖其所在位置。如果两个无线接入点的覆盖区域相连，则它们构成一个子网(一个接入点的上下左右、上左、上右、下左、下右如果有其他接入点则认为相连构成子网)，现在需要通过光纤将不同的子网俩俩相连。
你的任务是计算所有子网俩俩相连需要多少条光纤链路（如 A、B、CA、B、CA、B、C 三个子网应该建立 AB、AC、BCAB、AC、BCAB、AC、BC 三条链路）
输入描述
第一行：两个整数 mmm 和 nnn ，分别表示网格的行数和列数 (1≤m,n<2000)(1≤m,n<2000)(1≤m,n<2000)
接下来的 mmm 行，每行有 nnn 个整数 000 或 111 ，表示网格中每个位置的状态
111：表示该位置放置了无线接入点
000：表示该位置未放置无线接入点
输出描述
输出一个整数，表示所有子网俩俩相连需要的光纤链路数量
样例1
输入
4 5
1 1 0 0 0
0 0 0 0 0
0 0 1 1 0
0 0 0 1 0

输出
1

说明
网格中有两个子网：
第一个区域由位置 (0,0)(0,0)(0,0) 和 (1,0)(1,0)(1,0) 等组成，属于同一个子网。
第二个区域由位置 (2,2)、(2,3)、(3,3)(2,2)、(2,3)、(3,3)(2,2)、(2,3)、(3,3) 等组成，属于另一个子网
故使用一个链路可以达成俩俩相连的目标
样例2
输入
2 2
1 0
0 1

输出
0

说明
网格中有一个子网：
由位置 (0,0)(0,0)(0,0) 和 (1,1)(1,1)(1,1) 等组成，属于同一个子网。
一个子网不需要使用光纤连接故结果为 000

▶️

#### TextSol

video solution

题面描述
给定一个大小为m∗nm*nm∗n 的网格，每个格子上可能放置一个无线接入点（用值 1 表示）或不放置（用值 0 表示）。如果两个无线接入点的覆盖区域相连，则它们属于同一个子网。邻接关系包括上下左右以及四个对角方向（共 8 个方向）。现要求通过光纤将不同的子网两两相连，即如果共有kkk个子网，则需要建立k(k−1)2{k(k-1)}{2}k(k−1)2 条链路。请计算给定网格中所有子网两两相连需要多少条光纤链路。
问题本质分析
本质上是一个典型的「在二维网格中统计连通分量」问题，但邻接方式为 8 方向（包括对角线方向）。在网格中，每个放置了接入点的位置相当于一个「节点」，在 8 个方向上如果相邻也是放置的位置，则二者相连。目标是统计网格中有多少个这样的连通子网（连通分量），记为kkk，然后输出子网两两相连所需链路数：
答案=(k2)=k(k−1)2.
\text{答案} = \binom{k}{2} = \frac{k(k-1)}{2}.
答案=(2k​)=2k(k−1)​.

网格规模最大可达m∗nm*nm∗n，其中m,n<2000m,n<2000m,n<2000，故格子总数可达近4×1064\times10^64×106。需要在时间上做到O(mn)O(mn)O(mn) 复杂度，空间上也需O(mn)O(mn)O(mn) 较低常数额外空间。

统计连通分量常用的方法有 DFS/BFS 或并查集（DSU）。

DFS 递归可能会因为深度过大而栈溢出，不推荐使用递归方式。可用显式栈的迭代 DFS，但 BFS 同样可行。
BFS 需额外队列，最坏情况下队列可能很大，但此场景常见可以接受。
并查集需要对每个“1”节点进行编号，并在遍历时与已访问到的相邻“1”进行合并；并查集结构大小为总格子数（或仅“1”的个数），常数略高，但也可行。不过简单 BFS 更直观。

由于只需最终的连通分量个数kkk，可以在遍历时对每个未访问的“1”启动一次 BFS，将该连通分量中的所有“1”标记为已访问，计数加一。遍历完成后得到kkk，再计算k(k−1)2{k(k-1)}{2}k(k−1)2，使用 64 位整数保存结果。

思路

读入：读取整数m,nm,nm,n，再读入mmm 行、每行nnn个0/1，存入二维数组（或扁平一维数组）。

初始化：准备同样尺寸的布尔访问数组 visited，用于标记哪些格子已被纳入某个连通分量。

遍历网格：双重循环遍历每个位置(i,j)(i,j)(i,j)：

如果该位置值为 1 且未被访问：

启动一次 BFS/DFS，将此连通分量中所有可达位置遍历并标记访问。
连通方向为 8 个方向：dx = {-1,-1,-1,0,0,1,1,1}, dy = {-1,0,1,-1,1,-1,0,1}
BFS 典型做法：用队列存储待访问节点，对每个出队节点，对 8 个方向进行越界检查、是否为 1、是否未访问，若满足则标记并入队。
BFS 结束后，连通分量计数器 count 增加 1。

遍历结束后得到子网数量k=countk={count}k=count。

计算答案：使用 64 位整数，ans=k×(k−1)2{ans} = \frac{k \times (k-1)}{2}ans=2k×(k−1)​。注意可能 kkk 很大（最坏每个“1”都孤立时），但k≤mn≈4×106k\le mn \approx 4\times10^6k≤mn≈4×106，k(k−1)/2≈8×1012k(k-1)/2 \approx 8\times10^{12}k(k−1)/2≈8×1012，符合 64 位范围。

输出 答案。

时间复杂度：O(mn)O(mn)O(mn)，每个格子最多进队和出队一次，访问常数方向。
空间复杂度：存储网格需O(mn)O(mn)O(mn)，访问数组O(mn)O(mn)O(mn)，BFS 队列最坏O(mn)O(mn)O(mn)。总体在题目给定内存限制内（C++ 256MB，其他语言 512MB 足够）。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int m, n;
cin >> m >> n;
// 存储网格，0/1
vector<vector<char>> grid(m, vector<char>(n));
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
int x;
cin >> x;
grid[i][j] = (char)x;
}
}
// 访问标记
vector<vector<char>> visited(m, vector<char>(n, 0));
// 8 个方向偏移
const int dx[8] = {-1,-1,-1, 0, 0, 1, 1, 1};
const int dy[8] = {-1, 0, 1,-1, 1,-1, 0, 1};

long long count = 0; // 子网计数
queue<pair<int,int>> q;

for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
// 如果是接入点且未访问，则启动 BFS
if (grid[i][j] == 1 && !visited[i][j]) {
count++;
visited[i][j] = 1;
q.emplace(i, j);
while (!q.empty()) {
auto [x, y] = q.front();
q.pop();
// 遍历 8 个方向
for (int dir = 0; dir < 8; dir++) {
int nx = x + dx[dir];
int ny = y + dy[dir];
// 边界检查
if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
// 如果该位置是接入点且未访问
if (grid[nx][ny] == 1 && !visited[nx][ny]) {
visited[nx][ny] = 1;
q.emplace(nx, ny);
}
}
}
}
}
}
}
// 计算需要的光纤链路数量：k 个子网需要 k*(k-1)/2 条
long long k = count;
long long ans = k * (k - 1) / 2;
cout << ans;
return 0;
}

Python
import sys
from collections import deque

def main():
data = sys.stdin.readline().split()
if not data:
return
m, n = map(int, data)
grid = [None] * m
for i in range(m):
# 读取一行 n 个整数
row = sys.stdin.readline().split()
# 转为整数 0/1
grid[i] = [int(x) for x in row]

visited = [[False] * n for _ in range(m)]
dirs = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]
count = 0
dq = deque()

for i in range(m):
for j in range(n):
if grid[i][j] == 1 and not visited[i][j]:
count += 1
visited[i][j] = True
dq.append((i, j))
# BFS 遍历连通分量
while dq:
x, y = dq.popleft()
for dx, dy in dirs:
nx, ny = x + dx, y + dy
if 0 <= nx < m and 0 <= ny < n:
if grid[nx][ny] == 1 and not visited[nx][ny]:
visited[nx][ny] = True
dq.append((nx, ny))
k = count
# 使用 Python 整数自动大整数支持
ans = k * (k - 1) // 2
print(ans)

if __name__ == "__main__":
main()

Java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;
import java.util.ArrayDeque;
import java.util.Deque;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(br.readLine());
int m = Integer.parseInt(st.nextToken());
int n = Integer.parseInt(st.nextToken());
// 读取网格
int[][] grid = new int[m][n];
for (int i = 0; i < m; i++) {
st = new StringTokenizer(br.readLine());
for (int j = 0; j < n; j++) {
grid[i][j] = Integer.parseInt(st.nextToken());
}
}
boolean[][] visited = new boolean[m][n];
// 8 个方向
int[] dx = {-1,-1,-1, 0, 0, 1, 1, 1};
int[] dy = {-1, 0, 1,-1, 1,-1, 0, 1};

long count = 0;
Deque<int[]> queue = new ArrayDeque<>();

for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
if (grid[i][j] == 1 && !visited[i][j]) {
// 新连通分量
count++;
visited[i][j] = true;
queue.add(new int[]{i, j});
while (!queue.isEmpty()) {
int[] cur = queue.poll();
int x = cur[0], y = cur[1];
// 遍历 8 方向
for (int dir = 0; dir < 8; dir++) {
int nx = x + dx[dir];
int ny = y + dy[dir];
if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
if (grid[nx][ny] == 1 && !visited[nx][ny]) {
visited[nx][ny] = true;
queue.add(new int[]{nx, ny});
}
}
}
}
}
}
}
long k = count;
long ans = k * (k - 1) / 2;
System.out.println(ans);
}
}

---

### 第3题-无线网络覆盖计划（P3306）
- 链接：https://codefun2000.com/p/P3306

> 页面标题：#P3306. 第3题-无线网络覆盖计划

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

你正在设计一个大型无线网络覆盖计划，目标是通过布置多个无线接入点来覆盖一个区域。每个接入点都有不同的信号覆盖范围，安装成本。在预算有限的情况下，保证网络覆盖需求满足，并且总成本不超过预算。
约束条件：
信号覆盖范围：每个接入点能够覆盖一定的区域，区域面积单位为 m2m^2m2 。
安装成本：每个接入点有一定的安装成本，单位为元，总成本不应超过预算。
区域需求：你知道整个区域的总覆盖面积需求，单位为 m2m^2m2。
输入描述
1、第一行包含三个数字
areaRequirementareaRequirementareaRequirement：所需的区域覆盖面积(单位：m20<areaRequirement<=100000m^20<areaRequirement<=100000m20<areaRequirement<=100000)。
budgetbudgetbudget：总预算（单位：元 0<budget<=100000<budget<=100000<budget<=10000 budgetbudgetbudget 为 101010 的整数倍）。
nnn ：接入点的数量 (0<n<=10000)(0<n<= 10000)(0<n<=10000) 。
2、接下来的 nnn 行每行包含两个数字，分别是：
coveragecoveragecoverage ：接入点的信号覆盖范围（单位：m20<coverage<=100000m^20<coverage<=100000m20<coverage<=100000）。
costcostcost ：接入点的安装成本(单位：元 0<cost=1000000<cost=1000000<cost=100000 costcostcost 为 101010 的整数倍)。
输出描述
1、输出在给定成本内能满足区域覆盖需求的最小预算以及此时的覆盖面积，如果有多个解预算都能满足覆盖范围要求，输出预算最小时最大的覆盖面积
2、如果给出的站点无法满足要求则输出 000 000
样例1
输入
2000 500 3
1000 200
1500 250
800 180

输出
430 2300

说明
1、第一行表示：目标是需要一个信号覆盖范围至少为 200020002000 m2m^2m2的区域，总预算为 500500500 元，共有 333 个接入点可供选择
2、接下来 333 行表示：
接入点 111：覆盖范围 100010001000 m2m^2m2，成本 200200200 元
接入点 222：覆盖范围 150015001500 m2m^2m2，成本 250250250 元
接入点 333：覆盖范围 800800800 m2m^2m2，成本 180180180 元
可选接入点 222 和接入点 333 成本最低 430430430 元能满足覆盖范围 230023002300m2m^2m2
样例2
输入
3000 500 3
1000 200
1500 250
800 180

输出
0 0

说明
1、第一行表示：目标是需要一个信号覆盖范围至少为 300030003000 m2m^2m2的区域，总预算为 500500500 元，共有 333 个接入点可供选择
2、接下来 333 行表示：
接入点 111：覆盖范围 100010001000 m2m^2m2，成本 200200200 元
接入点 222：覆盖范围 150015001500 m2m^2m2，成本 250250250 元
接入点 333：覆盖范围 800800800 m2m^2m2，成本 180180180 元
无论选择哪些接入点，都无法满足 在不超过预算 500500500 的情况下满足 300030003000 m2m^2m2的区域覆盖需求
所以输出 000 000

#### TextSol

题面描述
给定区域覆盖需求面积areaRequirementareaRequirementareaRequirement（单位：m²）和总预算budgetbudgetbudget（单位：元），以及 nnn 个可选接入点。第iii个接入点的信号覆盖范围为coverageicoverage_icoveragei​（m²），安装成本为 costicost_icosti​（元）。在不超过总预算的前提下，选择若干接入点，使得覆盖总面积至少为 areaRequirementareaRequirementareaRequirement。如果有多种选择方式都满足覆盖需求，则选取总成本最小；若成本相同，则取覆盖总面积最大的方案。如果无法满足需求，则输出000。

思路
这是一个典型的「0-1 背包」变形问题：

“重量” 对应 每个接入点的成本costicost_icosti​
“价值” 对应 每个接入点的覆盖面积coverageicoverage_icoveragei​
背包容量 即 总预算budgetbudgetbudget
目标是保证价值总和geareaRequirementge areaRequirementgeareaRequirement，同时最小化所用“重量”，并在相同重量下最大化价值。

常规做法：

使用一维数组 dp[j] 表示在预算不超过jjj时，所能获得的最大覆盖面积。

初始化 dp[0…budget] = 0。

对于每个接入点，倒序遍历预算jjj从budgetbudgetbudget到costicost_icosti​，更新：
dp[j]=max(dp[j],dp[j−costi]+coveragei)dp[j]=max(dp[j],dp[j - cost_i] + coverage_i)
dp[j]=max(dp[j],dp[j−costi​]+coveragei​)

最后线性扫描 dp[j]，找到最小的jjj满足dp[j]geareaRequirementdp[j] ge areaRequirementdp[j]geareaRequirement，并输出该jjj 及对应的dp[j]dp[j]dp[j]。

时间优化

budgetbudgetbudget 最大可达100001000010000，nnn最大100001000010000，直接O(n×budget)O(n \times budget)O(n×budget) 最坏 10810^8108 次，Python 可能超时。
由于所有成本均为101010的倍数，可将成本先除以101010，使新背包容量 budget′=budget/10<=1000budget' = budget / 10<=1000budget′=budget/10<=1000，将复杂度降为O(n×budget′)<=107O(n \times budget')<=10^7O(n×budget′)<=107，在大多数语言中均可接受。

问题本质分析
本质上是「0-1 背包」问题的双目标优化：

主目标：覆盖面积geareaRequirementge areaRequirementgeareaRequirement
次目标：总成本最小；若成本相同，则覆盖面积最大

通过一维动态规划记录在不同预算下的最大覆盖面积，即可同时兼顾这两点：最小预算优先被遍历到，覆盖面积又被最大化维护。

C++
#include <bits/stdc++.h>
using namespace std;

int main(){
ios::sync_with_stdio(false);
cin.tie(nullptr);

int areaRequirement, budget, n;
cin >> areaRequirement >> budget >> n;

// 将预算缩放：除以10
int B = budget / 10;
vector<int> dp(B + 1, 0);

for(int i = 0; i < n; i++){
int coverage, cost;
cin >> coverage >> cost;
int c = cost / 10;  // 缩放后的成本
// 倒序遍历保证每个物品只选一次
for(int j = B; j >= c; j--){
dp[j] = max(dp[j], dp[j - c] + coverage);
}
}

// 在缩放后容量范围内查找最优解
for(int j = 0; j <= B; j++){
if(dp[j] >= areaRequirement){
// 输出时记得将成本乘回10
cout << j * 10 << " " << dp[j] << "\n";
return 0;
}
}
// 无解
cout << 0 << "\n";
return 0;
}

Python
import sys

# 读取输入
a, b, n = map(int, sys.stdin.readline().split())
# 将预算缩放：除以10
B = b // 10
# dp[j] 表示预算不超过 j*10 时最大覆盖面积
dp = [0] * (B + 1)

for _ in range(n):
coverage, cost = map(int, sys.stdin.readline().split())
c = cost // 10  # 缩放后的成本
# 倒序遍历，保证0-1性质
for j in range(B, c - 1, -1):
dp[j] = max(dp[j], dp[j - c] + coverage)

# 查找最小预算满足覆盖需求
for j in range(B + 1):
if dp[j] >= a:
# 输出时将成本乘回10
print(j * 10, dp[j])
break
else:
# 无解
print(0)

Java
import java.io.*;
import java.util.*;

public class Main {
public static void main(String[] args) throws IOException {
BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
StringTokenizer st = new StringTokenizer(in.readLine());
int areaRequirement = Integer.parseInt(st.nextToken());
int budget = Integer.parseInt(st.nextToken());
int n = Integer.parseInt(st.nextToken());

// 将预算缩放：除以10
int B = budget / 10;
int[] dp = new int[B + 1];

for (int i = 0; i < n; i++) {
st = new StringTokenizer(in.readLine());
int coverage = Integer.parseInt(st.nextToken());
int cost = Integer.parseInt(st.nextToken());
int c = cost / 10;  // 缩放后的成本

// 倒序遍历，确保0-1背包
for (int j = B; j >= c; j--) {
dp[j] = Math.max(dp[j], dp[j - c] + coverage);
}
}

// 查找最小预算满足覆盖需求
for (int j = 0; j <= B; j++) {
if (dp[j] >= areaRequirement) {
// 输出时将成本乘回10
System.out.println((j * 10) + " " + dp[j]);
return;
}
}
// 无解
System.out.println(0);
}
}

---

### 第3题-调整储能集装箱（P3314）
- 链接：https://codefun2000.com/p/P3314

> 页面标题：#P3314. 第3题-调整储能集装箱

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

储能工厂在发货时，一次同时发两个储能集装箱。每个集装箱中均 MMM 个电芯，用两个数组 bms1，bms2bms1，bms2bms1，bms2 表示每个集箱中的电芯的电量，为了保证两个集装箱电芯电量的均衡，需要调整两个集装箱中的电芯，使得两个集装箱中的电芯电最完全均衡(根据集装箱中电芯的电量进行排序，如果排序后的结果完全相同，则认为两个集装箱的电芯电量完全均衡)。调整的代价如下：比如交换电芯 bms1[i]和bms2[j]bms1[i]和bms2[j]bms1[i]和bms2[j]，代价为 min(bms1[i]，bms2[j])min(bms1[i]，bms2[j])min(bms1[i]，bms2[j]) 。可以多次调整，请返回调整的最小代价。如果无法使得两个集装箱中的电芯电量完全均衡，返回 −1-1−1
输入描述
第一行是一个整数 MMM ，表示集装箱内电芯的数量。1<=M<=1051 <= M <= 10^51<=M<=105。
接下两行是长度均为 MMM 的整数数组 bms1bms1bms1 和 bms2bms2bms2 ，分别代表两个集装箱内电芯的电量
1<=bms1[i],bms2[j]<=1081 <= bms1[i], bms2[j] <= 10^81<=bms1[i],bms2[j]<=108
输出描述
调整的代价(用例保证不会超过 2642^{64}264)
样例1
输入
4
4 5 6 3
5 4 6 2

输出
-1

说明
无论怎么调整，都无法使得两个储能柜的电芯相同
样例2
输入
5
5 2 3 5 6
2 3 3 3 6

输出
3

说明
交换 bms1[0]bms1[0]bms1[0] 和 bms2[1]bms2[1]bms2[1] ，代价为 333 ，交换后，bms1=3bms1=3bms1=3 222 333 555 666 ，bms2=2bms2=2bms2=2 555 333 333 666 ，排序后两个集装箱中的电芯电量完全相同，都是 222 333 333 555 666

#### TextSol

思路

可行性判定

对每个数值 vvv，合并出现次数 cnt(v)=cnt1(v)+cnt2(v)cnt(v)=cnt_1(v)+cnt_2(v)cnt(v)=cnt1​(v)+cnt2​(v)。若存在 cnt(v)cnt(v)cnt(v) 为奇数，则无论如何交换都无法均衡，直接返回 −1-1−1。

需要交换的元素集合

对每个数值 vvv，计算差值 Δ(v)=cnt1(v)−cnt2(v)\Delta(v)=cnt_1(v)-cnt_2(v)Δ(v)=cnt1​(v)−cnt2​(v)。
若 Δ(v)>0\Delta(v)>0Δ(v)>0，向集合 AAA 放入 Δ(v)/2\Delta(v)/2Δ(v)/2 个 vvv（表示这些值需要从 bms1bms1bms1 移出）。
若 Δ(v)<0\Delta(v)<0Δ(v)<0，向集合 BBB 放入 −Δ(v)/2-\Delta(v)/2−Δ(v)/2 个 vvv（表示这些值需要从 bms2bms2bms2 移出）。
必有 ∣A∣=∣B∣=k|A|=|B|=k∣A∣=∣B∣=k，且至少需要交换 kkk 次。

最优配对与换法

设全局最小值 m=min⁡(min⁡(bms1),min⁡(bms2))m=\min(\min(bms1),\min(bms2))m=min(min(bms1),min(bms2))。

对于一对待交换的元素 (x∈A, y∈B)(x\in A,\,y\in B)(x∈A,y∈B)，可直接交换代价为 min⁡(x,y)\min(x,y)min(x,y)，也可通过最小元 mmm 中转（两次跨箱交换），总代价为 2m2m2m。因此单对最优代价为
min⁡(min⁡(x,y), 2m).\min(\min(x,y),\,2m).
min(min(x,y),2m).

为最小化总代价，将 AAA 升序、BBB 降序配对，使每对的较小者尽量小，从而减小 min⁡(x,y)\min(x,y)min(x,y)。

复杂度

计数与构造集合：O(M)O(M)O(M)；排序：O(Mlog⁡M)O(M\log M)O(MlogM)；总复杂度 O(Mlog⁡M)O(M\log M)O(MlogM)，空间 O(M)O(M)O(M)。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

int M;
if (!(cin >> M)) return 0;
vector<long long> a(M), b(M);
for (int i = 0; i < M; ++i) cin >> a[i];
for (int i = 0; i < M; ++i) cin >> b[i];

// 统计全局最小值m
long long m = LLONG_MAX;
for (auto &x : a) m = min(m, x);
for (auto &x : b) m = min(m, x);

// 分别统计两个数组中每个数的出现次数
unordered_map<long long, long long> cnt1, cnt2, total;
cnt1.reserve(M * 2); cnt2.reserve(M * 2); total.reserve(M * 2);
for (auto &x : a) { cnt1[x]++; total[x]++; }
for (auto &x : b) { cnt2[x]++; total[x]++; }

// 可行性判定：合并次数必须为偶数
for (auto &kv : total) {
if ((kv.second & 1LL) != 0) {
cout << -1 << "\n";
return 0;
}
}

// 构造需要移动的多重集合A、B
vector<long long> A, B;
A.reserve(M); B.reserve(M);
for (auto &kv : total) {
long long v = kv.first;
long long d = cnt1[v] - cnt2[v]; // 可能为负
if (d > 0) {
long long t = d / 2;
while (t--) A.push_back(v);
} else if (d < 0) {
long long t = (-d) / 2;
while (t--) B.push_back(v);
}
}

if (A.empty()) { // 已经均衡
cout << 0 << "\n";
return 0;
}

// 排序并配对：A升序，B降序
sort(A.begin(), A.end());
sort(B.begin(), B.end(), greater<long long>());

// 计算最小总代价：sum min(min(A[i], B[i]), 2*m)
unsigned long long ans = 0;
for (size_t i = 0; i < A.size(); ++i) {
unsigned long long direct = (unsigned long long)min(A[i], B[i]);
unsigned long long viaMin = (unsigned long long)(2LL * m);
ans += min(direct, viaMin);
}

cout << ans << "\n";
return 0;
}

Python
import sys

def main():
data = sys.stdin.read().strip().split()
if not data:
return
it = iter(data)
M = int(next(it))
a = [int(next(it)) for _ in range(M)]
b = [int(next(it)) for _ in range(M)]

# 全局最小值
m = min(min(a), min(b))

# 次数统计
from collections import Counter
cnt1 = Counter(a)
cnt2 = Counter(b)
total = cnt1 + cnt2  # 合并计数

# 可行性判定：合并次数必须为偶数
for v, c in total.items():
if c % 2 != 0:
print(-1)
return

# 构造A、B
A, B = [], []
for v in total.keys():
d = cnt1.get(v, 0) - cnt2.get(v, 0)
if d > 0:
A.extend([v] * (d // 2))
elif d < 0:
B.extend([v] * ((-d) // 2))

if not A:
print(0)
return

A.sort()           # 升序
B.sort(reverse=True)  # 降序

# 计算总代价
ans = 0
two_m = 2 * m
for x, y in zip(A, B):
ans += min(min(x, y), two_m)

print(ans)

if __name__ == "__main__":
main()

Java
import java.io.*;
import java.util.*;

/*
思路：
- 统计两个数组内每个值的出现次数，并做合并计数；若某值合并次数为奇数则返回-1
- 差值一半分别放入A和B，A表示需要从bms1移出的元素，B表示需要从bms2移出的元素
- A升序，B降序配对；每对交换代价为 min(min(x, y), 2*m)
- 复杂度 O(M log M)
*/
public class Main {
public static void main(String[] args) throws Exception {
FastScanner fs = new FastScanner(System.in);
Integer MObj = fs.nextInt();
if (MObj == null) return;
int M = MObj;

long[] a = new long[M];
long[] b = new long[M];
for (int i = 0; i < M; i++) a[i] = fs.nextLong();
for (int i = 0; i < M; i++) b[i] = fs.nextLong();

long m = Long.MAX_VALUE;
for (long x : a) m = Math.min(m, x);
for (long x : b) m = Math.min(m, x);

// 次数统计
HashMap<Long, Long> cnt1 = new HashMap<>();
HashMap<Long, Long> cnt2 = new HashMap<>();
HashMap<Long, Long> total = new HashMap<>();
for (long x : a) {
cnt1.put(x, cnt1.getOrDefault(x, 0L) + 1);
total.put(x, total.getOrDefault(x, 0L) + 1);
}
for (long x : b) {
cnt2.put(x, cnt2.getOrDefault(x, 0L) + 1);
total.put(x, total.getOrDefault(x, 0L) + 1);
}

// 可行性判定
for (Map.Entry<Long, Long> e : total.entrySet()) {
if ((e.getValue() & 1L) != 0L) {
System.out.println(-1);
return;
}
}

ArrayList<Long> A = new ArrayList<>();
ArrayList<Long> B = new ArrayList<>();
for (Long v : total.keySet()) {
long c1 = cnt1.getOrDefault(v, 0L);
long c2 = cnt2.getOrDefault(v, 0L);
long d = c1 - c2;
if (d > 0) {
long t = d / 2;
for (int i = 0; i < t; i++) A.add(v);
} else if (d < 0) {
long t = (-d) / 2;
for (int i = 0; i < t; i++) B.add(v);
}
}

if (A.isEmpty()) {
System.out.println(0);
return;
}

// A升序
Collections.sort(A);
// B降序
B.sort(Collections.reverseOrder());

long twoM = 2L * m;
long ans = 0L;
for (int i = 0; i < A.size(); i++) {
long x = A.get(i), y = B.get(i);
long direct = Math.min(x, y);
ans += Math.min(direct, twoM);
}

System.out.println(ans);
}

// 简单的快速输入
static class FastScanner {
private final InputStream in;
private final byte[] buffer = new byte[1 << 16];
private int ptr = 0, len = 0;
FastScanner(InputStream is) { in = is; }
private int read() throws IOException {
if (ptr >= len) {
len = in.read(buffer);
ptr = 0;
if (len <= 0) return -1;
}
return buffer[ptr++];
}
String next() throws IOException {
StringBuilder sb = new StringBuilder();
int c;
while ((c = read()) != -1 && c <= ' ') {}
if (c == -1) return null;
do {
sb.append((char)c);
c = read();
} while (c != -1 && c > ' ');
return sb.toString();
}
Integer nextInt() throws IOException {
String s = next();
return s == null ? null : Integer.parseInt(s);
}
Long nextLong() throws IOException {
String s = next();
return s == null ? null : Long.parseLong(s);
}
}
}

---

### 第3题-信号强度变化中的最大差值区间（P3311）
- 链接：https://codefun2000.com/p/P3311

> 页面标题：#P3311. 第3题-信号强度变化中的最大差值区间

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

给定一个整数数组 arrayarrayarray  ，代表在一系列连续时间点上检测到的信号强度值。我们需要在这一系列时间点中找出一个区间 [i,j][i,j][i,j] (其中 i<=ji<=ji<=j )，满足以下条件：
1.区间内的信号强度值先呈现单调非递減趋势(即对于 i<=k<s<=mi<= k<s<= mi<=k<s<=m，有 array[k]<=array[s]array[k]
<= array[s]array[k]<=array[s])
2.紧接着呈现单调非递增趋势(即对于 m<=n<o<=jm<=n<o<=jm<=n<o<=j，有 array[n]>=aray[o]array[n]>= aray[o]array[n]>=aray[o])
3.这里的单调非递减和非递增趋势允许存在相等的相邻值。
在满足上述条件的区间叫做“波峰区间"，在所有的“波峰区间“中，找到信号强度最大值与最小值差值最大的那个区间，并返回这个最大差值。

0<=array.length<=10000<=array.length<=10000<=array.length<=1000
array[i]≥0array[i] ≥ 0array[i]≥0
输入描述
第一行输入一个数字 mmm ，代表要输入的数组 arrayarrayarray 内的数字数量。
第二行输入 mmm 个数字，数字用空格隔开。
输出描述
输出最大差值
样例1
输入
8
1 2 3 5 4 4 8 1

输出
7

说明
[1,2,3,5,4,4][1,2,3,5,4,4][1,2,3,5,4,4] 是一个满足条件的区间，最大值是 555 ，最小值是 111 ，最大差值是 444 。
[4.8,1][4.8,1][4.8,1] 是第二个满足条件的区间，最大值是 888，最小值是 111 ，最大差值是 777 。两个区间比较，最终最大差值是 777
样例2
输入
5
15 15 15 15 15

输出
0

说明
整个数组都满足先单调非递减后单调非递增的条件(因为所有值相等)。信号强度的最大值和最小值都是 151515 ，差值为 15−15=015-15=015−15=0 。
样例3
输入
6
3 8 12 10 6 9

输出
9

说明
满足条件的区间为 [3,8,12,10,6][3,8,12,10,6][3,8,12,10,6] ，在此区间内，[3,8,12][3,8,12][3,8,12] 单调非递减，[12,10,6][12,10,6][12,10,6] 单调非递增。信号强度的最大值为 121212 ，最小值为 333 ，差值为 12−3=912-3=912−3=9 ，这是所有满足条件区间中的最大差值。

#### TextSol

题目描述
给定一个整数数组arrayarrayarray，代表一系列时间点上的信号强度值。请在这些时间点中找出一个波峰区间 [i,j][i, j][i,j]（其中i≤ji \le ji≤j），满足以下两个连续阶段：

区间前半段是单调非递减（即对于i≤k<s≤mi \le k < s \le mi≤k<s≤m，有array[k]≤array[s]array[k] \le array[s]array[k]≤array[s]）
区间后半段是单调非递增（即对于m≤n<o≤jm \le n < o \le jm≤n<o≤j，有array[n]≥array[o]array[n] \ge array[o]array[n]≥array[o]）

必须同时出现两个阶段才能构成一个合法的波峰区间！
找出所有合法波峰区间中，最大值与最小值的差值最大的那个区间，返回这个最大差值。
思路概括

枚举每个下标作为波峰的中心点（即峰顶位置midmidmid
向左扩展，找出最长的单调非递减段 [L,mid][L, mid][L,mid]
向右扩展，找出最长的单调非递增段 [mid,R][mid, R][mid,R]
判断是否L<midL < midL<mid 且 R>midR > midR>mid，只有满足才构成一个合法波峰
记录该波峰区间的最大值（峰值）和最小值（两端点中较小的），更新最大差值

问题本质分析
本题实质为枚举“山峰结构”的问题，要求找到一个先上升再下降的区间，并在所有这样的结构中找出最大高低差值。需要注意的是，必须先升再降，不能只有单调一段。使用双指针扩展判断每个点作为峰顶能延伸出的最长波峰段，最后取最大值。

C++
#include <bits/stdc++.h>
using namespace std;

int main() {
int m;
cin >> m;
vector<int> array(m);
for (int i = 0; i < m; i++) {
cin >> array[i];
}

int ans = 0;
for (int mid = 0; mid < m; mid++) {
int L = mid, R = mid;

// 向左扩展单调非递减段
while (L > 0 && array[L - 1] <= array[L]) {
L--;
}

// 向右扩展单调非递增段
while (R + 1 < m && array[R] >= array[R + 1]) {
R++;
}

// 必须左边实际扩展过且右边也扩展过，才是合法波峰
if (L < mid && R > mid) {
int peak = array[mid];
int low = min(array[L], array[R]);
ans = max(ans, peak - low);
}
}

cout << ans << endl;
return 0;
}

Python
def max_peak_diff(array):
n = len(array)
ans = 0

for mid in range(n):
L = mid
while L > 0 and array[L - 1] <= array[L]:
L -= 1

R = mid
while R + 1 < n and array[R] >= array[R + 1]:
R += 1

# 必须两边都扩展了，才是合法波峰
if L < mid and R > mid:
peak = array[mid]
low = min(array[L], array[R])
ans = max(ans, peak - low)

return ans

if __name__ == "__main__":
m = int(input())
array = list(map(int, input().split()))
print(max_peak_diff(array))

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int m = sc.nextInt();
int[] array = new int[m];
for (int i = 0; i < m; i++) {
array[i] = sc.nextInt();
}

System.out.println(maxPeakDiff(array));
sc.close();
}

// 计算最大波峰区间差值
public static int maxPeakDiff(int[] array) {
int n = array.length;
int ans = 0;

for (int mid = 0; mid < n; mid++) {
int L = mid;
// 向左扩展单调非递减段
while (L > 0 && array[L - 1] <= array[L]) {
L--;
}

int R = mid;
// 向右扩展单调非递增段
while (R + 1 < n && array[R] >= array[R + 1]) {
R++;
}

// 必须左右两边都扩展过才是合法波峰
if (L < mid && R > mid) {
int peak = array[mid];
int low = Math.min(array[L], array[R]);
ans = Math.max(ans, peak - low);
}
}

return ans;
}
}

---

### 第3题-循环依赖（P2338）
- 链接：https://codefun2000.com/p/P2338

> 页面标题：#P2338. 第3题-循环依赖

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述:
给定一组元素及其依赖关系，其中一个元素可以依赖多个其他元素，且一个元素也可以被多个其他元素所依赖。在输入中，首先给出依赖关系的数量，接着每行描述一个元素及其依赖的元素。任务是输出唯一存在的循环依赖，从最小的元素编号开始，依次输出依赖关系，最后以该最小元素结束。通过分析依赖关系，可以确定循环依赖的路径。
思路
简化题意：给出若干条边组成的有向图，找出其中唯一的环，保证环一定存在。
直接 dfs ，遍历完点 u 还未找到环，则说明点 u 不在这个环上。
当某个点已经被遍历过一次，且在 dfs 过程中再次被遍历过，说明遍历完了一整个环。
具体实现上使用一个栈来存储 dfs 过程中遍历到的点，如果一个点 u 被遍历到了两次，则说明找到了这个环，且 u 是这个环上的点。
只需要依次弹出栈中的点，直至弹出 u 为止，这就是环中所有的点。
需要注意的是：

弹出栈中的点获得的是一个倒序的环，需要反转一下
如果一个点在遍历完毕后仍然未结束，说明这个点不在环上，需要从栈中弹出

时间复杂度：O(m), m 为所有的边的数量
题解
题目要求在给定的有向图中寻找唯一的环。我们可以通过深度优先搜索（DFS）的方法来实现这个目标。具体的步骤如下：

数据结构：

使用邻接表存储图的边，h 表示每个节点的邻接边的头部，e 表示边的目标节点，nxt 用于存储每条边的下一条边的索引。
vis 数组用于标记每个节点是否已经被访问。
onpath 数组用于标记当前 DFS 路径上的节点，以帮助识别环的存在。
path 数组用于记录当前 DFS 路径上的节点顺序。
cyc 数组用于存储找到的环，nc 记录环中节点的数量。

DFS 遍历：

在 DFS 中，首先检查当前节点是否在 onpath 中。如果是，则说明找到了一个环，并记录环的路径。
如果当前节点已经被访问过（即在 vis 中标记为 1），则直接返回，避免重复搜索。
将当前节点添加到路径中，继续 DFS 遍历其所有邻接节点。

环的输出：

找到环后，从栈中弹出节点并记录，直到再次弹出起始节点，形成环。
由于弹出的顺序是倒序的，因此需要在输出之前对环进行反转。
最后输出环中的节点，并以最小的节点作为结尾。

复杂度：

整个算法的时间复杂度为 O(m)，其中 m 为图中的边数。

AC代码

java

import java.util.*;

public class Main {
static final int N = 100010; // 定义常量，最多支持的节点数
static int n, cnt = 0, nc = 0; // n为边的数量，cnt用于边的计数，nc用于环中节点数量
static int[] cyc = new int[N], path = new int[N], vis = new int[N], onpath = new int[N]; // cyc存储环，path存储当前路径，vis标记访问，onpath标记当前路径
static int[] h = new int[N], e = new int[N << 1], nxt = new int[N << 1]; // h为邻接表头，e为边的目标，nxt为下一条边的索引
static int cntv = 0; // 计数节点的数量
static int[] vert = new int[N]; // 存储节点编号

// 添加边的函数
static void add(int u, int v) {
nxt[cnt] = h[u]; // 将当前边的下一条边指向当前头部
e[cnt] = v;      // 将边的目标设置为v
h[u] = cnt++;    // 更新头部并计数
}

// 深度优先搜索函数
static void dfs(int u, int idx) {
if (onpath[u] == 1) { // 如果当前节点在路径上，说明找到了环
int i = idx - 1;
// 从路径中弹出节点，直到弹出u
while (path[i] != u) {
cyc[nc++] = path[i--];
}
cyc[nc++] = u; // 将u加入环中
return;
}
if (vis[u] == 1) return; // 如果已经访问过，直接返回
vis[u] = 1; // 标记节点为已访问
onpath[u] = 1; // 标记节点为当前路径上的节点
path[idx] = u; // 将当前节点记录到路径中

// 遍历当前节点的所有邻接节点
for (int i = h[u]; i != -1; i = nxt[i]) {
int v = e[i]; // 获取当前邻接节点
dfs(v, idx + 1); // 深度优先搜索
}
onpath[u] = 0; // DFS结束，标记该节点不在路径上
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
Arrays.fill(h, -1); // 初始化邻接表头
Arrays.fill(vis, 0); // 初始化访问标记
Arrays.fill(onpath, 0); // 初始化路径标记

n = scanner.nextInt(); // 输入边的数量
for (int i = 0; i < n; ++i) {
int ne = scanner.nextInt(); // 每个节点的邻接数量
int u = scanner.nextInt(); // 输入节点编号
vert[cntv++] = u; // 存储节点
for (int j = 1; j < ne; ++j) {
int v = scanner.nextInt(); // 输入目标节点编号
add(u, v); // 添加边
}
}

// 遍历所有节点进行DFS
for (int i = 0; i < cntv; ++i) {
dfs(vert[i], 0);
}

// 找到环中的最小节点以便输出
int minu = N, idminu = -1;
for (int i = 0; i < nc; ++i) {
if (cyc[i] < minu) { // 寻找最小值
minu = cyc[i];
idminu = i; // 记录最小值的位置
}
}

// 输出环的节点，倒序打印
for (int i = idminu, j = 0; j < nc; i = (i - 1 + nc) % nc, ++j) {
System.out.print(cyc[i] + " "); // 输出环中的节点
}
System.out.println(minu); // 输出最小值作为环的结尾
}
}

python

MAX = 10000
n = int(input())
g = [[] for i in range(MAX)]
vis = [0] * MAX
in_stk = [0] * MAX

for i in range(n):
a = list(map(int, input().split()))
for j in range(2, len(a)):
g[a[1]].append(a[j])

stk = []
t = []
def dfs(u):
# 这个点在本次遍历或者之前的某次遍历中被遍历过了
if vis[u]:
# 如果在栈中，说明本次遍历中被遍历过了
if len(stk) > 0 and in_stk[u]:
# 弹出元素直至弹出 u
while len(stk) > 0 and stk[-1] != u:
in_stk[stk[-1]] = 0
t.append(stk[-1])
stk.pop()
in_stk[u] = 0
stk.pop()
t.append(u)
# 找到环了，根据题意有且仅有一个环，直接退出
return True
else:
return False
vis[u] = 1
stk.append(u)
in_stk[u] = 1
for v in g[u]:
if dfs(v):
return True
in_stk[u] = 0
# 这个点不在环上，需要从栈中弹出
stk.pop()
return False

cnt = 0
for i in range(1, MAX):
# 依次遍历所有还未被遍历过的点
if not vis[i]:
if dfs(i):
cnt += 1

if cnt > 1:
print("oh no")

if len(t) > 0:
# 弹出栈中的点获得的是一个倒序的环，需要反转一下
t.reverse()
# 题目中说了从最小的元素开始输出这个环
minv = min(t)
i = 0
while i < len(t):
if t[i] == minv:
break
i += 1
ans = t[i:] + t[:i]
ans.append(t[i])
print(*ans)

c++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010; // 定义常量，最多支持的节点数
int n, cnt = 0, nc = 0; // n为边的数量，cnt用于边的计数，nc用于环中节点数量
int cyc[N], path[N], vis[N], onpath[N]; // cyc存储环，path存储当前路径，vis标记访问，onpath标记当前路径
int h[N], e[N << 1], nxt[N << 1]; // h为邻接表头，e为边的目标，nxt为下一条边的索引
int cntv, vert[N]; // cntv记录当前节点的数量，vert存储节点编号

// 添加边的函数
void add(int u, int v) {
nxt[cnt] = h[u]; // 将当前边的下一条边指向当前头部
e[cnt] = v;      // 将边的目标设置为v
h[u] = cnt++;    // 更新头部并计数
}

// 深度优先搜索函数
void dfs(int u, int idx) {
if (onpath[u]) { // 如果当前节点在路径上，说明找到了环
int i = idx - 1;
// 从路径中弹出节点，直到弹出u
while (path[i] != u) cyc[nc++] = path[i--];
cyc[nc++] = u; // 将u加入环中
return;
}
if (vis[u]) return; // 如果已经访问过，直接返回
vis[u] = 1; // 标记节点为已访问
onpath[u] = 1; // 标记节点为当前路径上的节点
path[idx] = u; // 将当前节点记录到路径中
// 遍历当前节点的所有邻接节点
for (int i = h[u]; ~i; i = nxt[i]) {
int v = e[i]; // 获取当前邻接节点
dfs(v, idx + 1); // 深度优先搜索
}
onpath[u] = 0; // DFS结束，标记该节点不在路径上
}

int main() {
ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); // 加速输入输出
memset(h, -1, sizeof h); // 初始化邻接表头
memset(vis, 0, sizeof vis); // 初始化访问标记
memset(onpath, 0, sizeof onpath); // 初始化路径标记
cin >> n; // 输入边的数量
for (int i = 0; i < n; ++i) {
int ne; // 每个节点的邻接数量
cin >> ne; // 输入邻接数量
int u; // 当前节点
cin >> u; // 输入节点编号
vert[cntv++] = u; // 存储节点
for (int j = 1; j < ne; ++j) {
int v; // 目标节点
cin >> v; // 输入目标节点编号
add(u, v); // 添加边
}
}

// 遍历所有节点进行DFS
for (int i = 0; i < cntv; ++i) {
dfs(vert[i], 0);
}

// 找到环中的最小节点以便输出
int minu = N, idminu = -1;
for (int i = 0; i < nc; ++i) {
if (cyc[i] < minu) { // 寻找最小值
minu = cyc[i];
idminu = i; // 记录最小值的位置
}
}

// 输出环的节点，倒序打印
for (int i = idminu, j = 0; j < nc; i = (i - 1 + nc) % nc, ++j) {
cout << cyc[i] << ' '; // 输出环中的节点
}
cout << minu; // 输出最小值作为环的结尾
}

javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
const N = 100010; // 最大节点数
let n, cnt = 0, nc = 0; // 计数器：边数、环节点数量
let cyc = new Array(N).fill(0), path = new Array(N).fill(0);
let vis = new Array(N).fill(0), onpath = new Array(N).fill(0);
let h = new Array(N).fill(-1), e = new Array(N * 2).fill(0), nxt = new Array(N * 2).fill(0);
let cntv = 0;
let vert = new Array(N).fill(0);

// 添加边
function add(u, v) {
nxt[cnt] = h[u];
e[cnt] = v;
h[u] = cnt++;
}

// 深度优先搜索
function dfs(u, idx) {
if (onpath[u] === 1) { // 找到环
let i = idx - 1;
while (path[i] !== u) {
cyc[nc++] = path[i--];
}
cyc[nc++] = u;
return;
}
if (vis[u] === 1) return; // 访问过则返回
vis[u] = 1;
onpath[u] = 1;
path[idx] = u;

// 遍历邻接节点
for (let i = h[u]; i !== -1; i = nxt[i]) {
let v = e[i];
dfs(v, idx + 1);
}
onpath[u] = 0;
}

// 读取输入
n = parseInt(await readline());
for (let i = 0; i < n; ++i) {
let inputs = (await readline()).split(" ").map(Number);
let ne = inputs[0], u = inputs[1];
vert[cntv++] = u;
for (let j = 1; j < ne; ++j) {
let v = inputs[j + 1];
add(u, v);
}
}

// 遍历所有节点进行DFS
for (let i = 0; i < cntv; ++i) {
dfs(vert[i], 0);
}

// 找到环中的最小节点
let minu = N, idminu = -1;
for (let i = 0; i < nc; ++i) {
if (cyc[i] < minu) {
minu = cyc[i];
idminu = i;
}
}

// 逆序输出环
let result = [];
for (let i = idminu, j = 0; j < nc; i = (i - 1 + nc) % nc, ++j) {
result.push(cyc[i]);
}
result.push(minu); // 最后再输出最小值

console.log(result.join(" "));
rl.close();
})();

题目描述
给定一组元素，及其依赖关系，一个元素可以依赖于多个元素(不包括自己，被依赖元素不会重复)一个元素也可被多个元素依赖。假定总是存在唯一的循环依赖，请输出该循环依赖。
输入描述
第一行一个正整数NNN，表示依赖关系的个数。
接下来每一行表示一个依赖关系，是由空格分割的多个正整数，第一个数nnn表示后面有nnn个元素，第二个数为元素编号aaa，后面多个数为aaa依赖的元素编号，任意元素iii满足0<t<100000\lt t\lt 100000<t<10000
输出描述
一串数字，代表这个循环依赖，从最小元素编号开始，按照依赖关系依次输出，以最小元素结束。
样例
输入
3
3 1 2 5
3 2 3 4
2 3 1

输出
1 2 3 1

说明

元素1依赖于2，5
元素2依赖于3，4
元素3依赖于1

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (4)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 79ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-公网下线方案（P2335）
- 链接：https://codefun2000.com/p/P2335

> 页面标题：#P2335. 第3题-公网下线方案

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题解思路与方法
建模

用一个 N×NN\times NN×N 的邻接矩阵 matrix 表示节点间的访问授权门槛：

matrix[i][j]=p（p>0） 表示从节点 iii 到节点 jjj 需要在节点 iii 上拥有至少 ppp 级权限；
matrix[i][j]=0 表示不可访问。

exposed 数组为所有直接暴露在公网的节点集合。若不下线某节点 xxx，攻击者可从所有其他暴露节点（初始权限为 10）发起多源 BFS/DFS，对可达节点进行“感染”。

算法

枚举下线节点 r∈exposedr\in exposedr∈exposed：

初始队列为所有 exposed 中除去 r 的节点，每个节点在队列中的初始权限为 10；
对每个出队状态 (u,permu)(u,perm_u)(u,permu​) 遍历所有目标节点 vvv：

若 matrix[u][v]>0 且 perm_u >= matrix[u][v]，则可访问；
到达 vvv 后，其权限变为 perm_v = matrix[u][v]；
若之前到达 vvv 时的权限小于 perm_v，则更新并将 (v,permv)(v,perm_v)(v,permv​) 入队。

BFS 结束后，统计所有被访问过的节点数 RRR。

在所有候选 rrr 中，选使 RRR 最小的节点，若多个，取编号最小者。

这种做法相当于对带状态的图做多源最优 BFS，状态数上限为 N×11N\times 11N×11（权限等级 0–10）。
复杂度分析

枚举下线节点：最多 ∣exposed∣≤N|exposed|\le N∣exposed∣≤N 次；
每次 BFS 状态空间最多 O(N×P)O(N\times P)O(N×P)，其中 P=11P=11P=11 为权限等级种类；
每个状态遍历 NNN 条边，故单次 BFS 复杂度 O(N×P×N)=O(N2)O(N\times P \times N)=O(N^2)O(N×P×N)=O(N2)（常数 PPP 可忽略）；
总体时间复杂度 O(N3)O(N^3)O(N3)，在 N≤24N\le24N≤24 时远可接受。

代码
C++
#include <bits/stdc++.h>
using namespace std;

int a[40][40]; // 存储权限矩阵
int n, m = 1;  // n 为节点数量，m 为暴露节点的计数（从 1 开始）
int e[40];     // 存储暴露节点的编号
int vis[40];   // 记录到达每个节点的最高权限，初始为 -1

// bfs 模拟攻击过程，返回“未被攻击”（安全）节点数
int bfs(int x) {
queue<pair<int,int>> q;
// 初始化 vis 为 -1（未被攻击）
for(int i = 0; i < n; i++) {
vis[i] = -1;
}
// 多源入队：除去下线节点 x
for(int i = 1; i <= m; i++) {
if(i == x) continue;
vis[e[i]] = 10;           // ROOT 权限
q.push({e[i], 10});
}
// 带状态 BFS
while(!q.empty()) {
auto [u, p] = q.front(); q.pop();
if(p < vis[u]) continue; // 已有更高权限到达过 u
for(int j = 0; j < n; j++) {
int req = a[u][j];
if(req > 0 && p >= req && vis[j] < req) {
vis[j] = req;
q.push({j, req});
}
}
}
// 统计未被攻击的节点数
int res = 0;
for(int i = 0; i < n; i++) {
if(vis[i] < 0) res++;
}
return res;
}

int main() {
ios::sync_with_stdio(false);
cin.tie(nullptr);

cin >> n;
for(int i = 0; i < n; i++)
for(int j = 0; j < n; j++)
cin >> a[i][j];

// 读取暴露节点列表
while(cin >> e[m]) m++;
m--;
sort(e + 1, e + m + 1);

int mx = -1, id = 1;
for(int i = 1; i <= m; i++) {
int now = bfs(i);
if(now > mx) {
mx = now;
id = i;
}
}
cout << e[id] << "\n";
return 0;
}

Java
import java.util.*;

public class Main {
static int[][] a = new int[40][40];
static int n, m = 1;      // m 从 1 开始计数
static int[] e = new int[40];
static int[] vis = new int[40]; // 记录到达每个节点的最高权限，初始为 -1

// bfs 模拟攻击，返回安全节点数
static int bfs(int x) {
Queue<int[]> q = new ArrayDeque<>();
// 初始化
for (int i = 0; i < n; i++) vis[i] = -1;
// 多源入队
for (int i = 1; i <= m; i++) {
if (i == x) continue;
vis[e[i]] = 10;
q.offer(new int[]{e[i], 10});
}
// 带状态 BFS
while (!q.isEmpty()) {
int[] cur = q.poll();
int u = cur[0], p = cur[1];
if (p < vis[u]) continue;
for (int v = 0; v < n; v++) {
int req = a[u][v];
if (req > 0 && p >= req && vis[v] < req) {
vis[v] = req;
q.offer(new int[]{v, req});
}
}
}
// 统计未被攻击节点数
int res = 0;
for (int i = 0; i < n; i++) {
if (vis[i] < 0) res++;
}
return res;
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
a[i][j] = sc.nextInt();
// 读取暴露节点
while (sc.hasNextInt()) {
e[m++] = sc.nextInt();
}
m--;
Arrays.sort(e, 1, m + 1);

int mx = -1, id = 1;
for (int i = 1; i <= m; i++) {
int now = bfs(i);
if (now > mx) {
mx = now;
id = i;
}
}
System.out.println(e[id]);
}
}

Python
import queue

# 输入
n = int(input())
a = [list(map(int, input().split())) for _ in range(n)]
e = list(map(int, input().split()))
e.sort()
m = len(e)

# bfs 模拟攻击，返回安全节点数
def bfs(x):
q = queue.Queue()
# vis 用作 “到达最高权限”，初始为 -1
vis = [-1] * n
for i in range(m):
if i == x: continue
vis[e[i]] = 10
q.put((e[i], 10))
while not q.empty():
u, p = q.get()
if p < vis[u]:
continue
for j in range(n):
req = a[u][j]
if req > 0 and p >= req and vis[j] < req:
vis[j] = req
q.put((j, req))
# 未被攻击的节点数
return sum(1 for v in vis if v < 0)

mx = -1
idx = 0
for i in range(m):
now = bfs(i)
if now > mx:
mx = now
idx = i

print(e[idx])

javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
// 读入节点数
let n = parseInt(await readline());
// 初始化权限矩阵 a[n][n]
let a = Array.from({ length: n }, () => Array(n).fill(0));
for (let i = 0; i < n; i++) {
let row = (await readline()).split(/\s+/).map(Number);
for (let j = 0; j < n; j++) {
a[i][j] = row[j];
}
}

// 读入并排序暴露节点列表 e
let e = (await readline()).trim().split(/\s+/).map(Number).sort((x, y) => x - y);
let m = e.length;

// vis[i] 存储到达 i 时的最高权限，初始为 -1（未被攻击）
let vis = Array(n).fill(-1);

// 模拟下线 e[x] 后的 BFS 攻击，返回安全节点数
function bfs(x) {
// 重置 vis
vis.fill(-1);
let q = [];
// 多源初始化，除去下线节点 x
for (let i = 0; i < m; i++) {
if (i === x) continue;
vis[e[i]] = 10;       // ROOT 权限
q.push([e[i], 10]);
}
// 带状态 BFS
while (q.length) {
let [u, p] = q.shift();
// 如果当前权限不是最高，则跳过
if (p < vis[u]) continue;
// 遍历所有邻接节点
for (let j = 0; j < n; j++) {
let req = a[u][j];
if (req > 0 && p >= req && vis[j] < req) {
vis[j] = req;
q.push([j, req]);
}
}
}
// 统计安全（未被攻击）节点数
return vis.reduce((cnt, v) => cnt + (v < 0 ? 1 : 0), 0);
}

// 枚举每个暴露节点下线，选安全节点数最多者
let mx = -1, best = 0;
for (let i = 0; i < m; i++) {
let safeCnt = bfs(i);
if (safeCnt > mx) {
mx = safeCnt;
best = i;
}
}

console.log(e[best]);
rl.close();
})();

题目描述
公有云的某个region内，NNN个网络节点组网情况可以使用一个n×nn\times nn×n的矩阵matrix表示，在这个组网图中，matrix[i][j]=pmatrix[i][j]=pmatrix[i][j]=p时，表示用户在编号为iii的节点访问编号为jjj的节点时，必须在iii节点上具有 ≥p\ge p≥p的权限等级(p=0p=0p=0 时表示无法通过iii节点访问jjj节点)，如果用户成功访问了jjj节点，那么它在jjj节点上的权限等级调整为ppp。
exposed为一个整数数组，表示暴露在公网上的网络节点的编号列表。某天扫描发现这批暴露在公网的节点存在被外部恶意攻击风险，且该攻击会影响到可访问的其他节点，并可以持续传递进行攻击。被恶意攻击的节点从公网访问时，攻击者获得了ROOT权限(权限等级为101010，即最大值)。
小明是一名网络安全工程师，为了在有限的时间内尽可能的减少故障带来的损失，需要立即将某个节点从公网"下线"。
假设攻击结束时，被攻击过的节点数量为RRR，请帮小明计算出将哪个节点下线能使R尽可能小，如果答案有多个节点，返回索引最小的那个节点。请注意:从公网“下线”的节点，不会受到来自公网的攻击，但仍然可能被“可访问"的其他节点传递攻击。
输入描述

输入的第一行是网络节点数量NNN
后续的NNN行，每行NNN个数字v，以空格分割，形成一个N×NN\times NN×N的矩阵，表示网络节点组网的矩阵。
最后一行，输入exposed数组，表示暴露在公网上的网络节点的编号列表数组元素不会重复。
2≤N≤242\le N\le 242≤N≤24
0≤v≤100\le v\le 100≤v≤10
0≤exposed[i]≤N−10\le exposed[i]\le N-10≤exposed[i]≤N−1

输出描述

输出在 exposed 数组中，计划“下线"的那个节点的编号。

样例1
输入
4
1 0 0 0
0 1 2 0
0 1 1 4
0 0 3 1
1 3

输出
3

说明
1,3是公网暴露的节点
1,2,3三个节点是连通的，但相互访问需要考虑权限等级限制，例如从1节点登录，访问到2节点后，权限等级不足以访问3号节点
如果将1号节点从公网下线，那3号节点可以先访问2号在访问1号，此时R的值为3。如果将3号节点从公网下线，则只能通过1号节点访问到2号节点，而2号节点无法再访问3号节点，此时R的值为2，答案选择R值更小的公网节点下线方案，因此答案为3.

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

Related

In following contests: 塔子周赛（一）华为暑期实习-2024年4月10号场

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 75ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-服务逃生（P2332）
- 链接：https://codefun2000.com/p/P2332

> 页面标题：#P2332. 第3题-服务逃生

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

video solution

题面描述:
塔子哥需要在多个业务节点之间选择最快的逃生节点，同时考虑各节点的剩余业务容量。输入包括一个网络时延矩阵，表示节点之间的通信延迟，以及一个剩余容量列表，表示每个节点的可用业务容量。在发生节点故障时，塔子哥需要找到一个或多个逃生节点，确保逃生路径的延迟最小，并且这些节点的总容量足够容纳故障节点的业务量。如果有多个合适的逃生节点，优先选择编号较小的节点；如果没有节点满足条件，则返回所有容量足够的节点。
思路
本题是个阅读理解，读懂了就应该会发现其实就是考察了最短路怎么求。
以故障点为源点求完最短路后，根据距离从小到大排序后，依次选取即可。
题解
在这道题目中，我们需要根据故障节点的信息，计算其他业务节点到故障节点的最短路径，并根据这些路径的延迟和剩余业务容量选择合适的逃生节点。解决方案主要分为以下几个步骤：

输入读取：读取节点数、延迟矩阵、剩余容量、故障节点编号和故障节点的业务量。
最短路径计算：使用 Dijkstra 算法从故障节点出发计算到其他节点的最短路径。
结果筛选：根据最短路径的长度和剩余容量筛选合适的逃生节点，并输出结果。

AC代码
C++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;

int main (){
ios::sync_with_stdio(false); // 加快输入输出速度
std::cin.tie(0);

int n;
cin >> n; // 读取节点数
vector<vector<int>> g(n, vector<int>(n)); // 创建延迟矩阵
for(int i = 0; i < n; i++)
for(int j = 0; j < n; j++)
{
cin >> g[i][j]; // 读取延迟值
if(g[i][j] == -1) // 如果没有直接连接
g[i][j] = 1e9; // 将其设为一个很大的值（无穷大）
}

vector<int> cost(n); // 创建剩余容量数组
for(int i = 0; i < n; i++)
cin >> cost[i]; // 读取每个节点的剩余容量

int wr;
cin >> wr; // 读取故障节点编号
int ned;
cin >> ned; // 读取需要迁移的业务量

vector<int> d(n + 1, 1e9); // 创建距离数组，初始化为无穷大
vector<bool> st(n + 1, false); // 创建标记数组，表示节点是否已确定最短路径

// Dijkstra 算法实现
auto dij = [&]() {
d[wr] = 0; // 故障节点到自身的距离为 0
for(int i = 0; i < n - 1; i++)
{
int t = -1; // 选择下一个节点
for(int j = 0; j < n; j++)
if(!st[j] && (t == -1 || d[j] < d[t])) // 找到距离最小的未标记节点
t = j;

for(int j = 0; j < n; j++)
d[j] = min(d[j], d[t] + g[t][j]); // 更新其他节点的距离

st[t] = true; // 标记节点 t
}
d[wr] = 1e9; // 恢复故障节点的距离为无穷大，避免再次使用
};

dij(); // 执行 Dijkstra 算法

vector<array<int, 3>> ans(n); // 存储节点的信息（距离、节点编号、剩余容量）
for(int i = 0; i < n; i++)
{
ans[i] = {d[i], i, cost[i]}; // 初始化信息
}
sort(ans.begin(), ans.end()); // 按照距离从小到大排序

int cur = 0; // 当前已选节点的总容量
vector<int> res; // 存储最终结果
for(int i = 0; i < n; i++)
{
auto t = ans[i];
if(t[0] >= 1e9) // 如果距离为无穷大，停止
break;

cur += t[2]; // 累加当前节点的剩余容量
res.push_back(t[1]); // 记录当前节点编号
if(cur >= ned) // 如果当前容量已满足要求，停止
break;
}

int sz = res.size(); // 结果数量
for(int i = 0; i < sz; i++)
cout << res[i] << " \n"[i == sz - 1]; // 输出结果，用空格分隔
return 0;
}

python
# 读取节点数
n = int(input())

# 初始化邻接矩阵
adj = []
for i in range(n):
# 读取每个节点之间的延迟，并构建邻接矩阵
adj.append(list(map(int, input().split())))

# 读取每个节点的剩余容量
cap = list(map(int, input().split()))

# 读取故障节点的编号
fault = int(input())

# 读取需要迁移的业务量
amount = int(input())

import heapq  # 导入堆（优先队列）模块

# 设置无穷大
inf = 1000000

# 初始化距离数组，默认值为无穷大
dist = [inf] * n

# 故障节点到自身的距离为 0
dist[fault] = 0

# 初始化优先队列，将故障节点加入队列
q = [[0, fault]]

# 访问标记数组，表示节点是否已确定最短路径
vis = [False] * n

# Dijkstra 算法的主循环
while q:
# 从优先队列中取出距离最小的节点
d, u = heapq.heappop(q)

# 如果当前距离不等于记录的距离，说明该节点已被更新，跳过
if d != dist[u]:
continue

# 标记当前节点为已访问
vis[u] = True

# 遍历所有邻接节点
for v in range(n):
# 如果节点 v 未访问且 u 到 v 的边存在
if not vis[v] and adj[u][v] != -1 and dist[v] > dist[u] + adj[u][v]:
# 更新 v 的最短距离
dist[v] = dist[u] + adj[u][v]
# 将更新后的节点加入优先队列
heapq.heappush(q, [dist[v], v])

# 将故障节点的距离恢复为无穷大，避免再次使用
dist[fault] = inf

# 收集所有节点的距离和编号，按照距离排序
lst = sorted([(dist[i], i) for i in range(n)])

s = 0  # 当前已选节点的总容量
ans = []  # 存储结果

# 遍历排序后的节点
for d, u in lst:
if u == fault:  # 遇到故障节点时停止
break
s += cap[u]  # 累加当前节点的剩余容量
ans.append(u)  # 记录当前节点编号
if s > amount:  # 如果当前容量已满足要求，停止
break

# 输出结果，用空格分隔
print(' '.join(map(str, ans)))

java
import java.util.*;

public class Main {
static final int INF = (int) 1e9;

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

int n = scanner.nextInt(); // 读取节点数量
int[][] g = new int[n][n]; // 创建延迟矩阵
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
g[i][j] = scanner.nextInt(); // 读取延迟值
if (g[i][j] == -1) g[i][j] = INF; // 无连接设为无穷大
}
}

int[] cost = new int[n]; // 剩余容量数组
for (int i = 0; i < n; i++) {
cost[i] = scanner.nextInt(); // 读取每个节点的剩余容量
}

int wr = scanner.nextInt(); // 故障节点编号
int ned = scanner.nextInt(); // 需要迁移的业务量

int[] d = new int[n]; // 最短路径数组
boolean[] st = new boolean[n]; // 标记数组
Arrays.fill(d, INF); // 初始化距离为无穷大

// Dijkstra 算法
d[wr] = 0;
for (int i = 0; i < n - 1; i++) {
int t = -1;
for (int j = 0; j < n; j++) {
if (!st[j] && (t == -1 || d[j] < d[t])) {
t = j;
}
}
if (t == -1 || d[t] == INF) break; // 无法继续扩展

st[t] = true; // 标记该节点

for (int j = 0; j < n; j++) {
d[j] = Math.min(d[j], d[t] + g[t][j]); // 更新最短路径
}
}
d[wr] = INF; // 恢复故障节点的距离

// 存储 (距离, 节点编号, 剩余容量)
List<int[]> ans = new ArrayList<>();
for (int i = 0; i < n; i++) {
ans.add(new int[]{d[i], i, cost[i]});
}

// 按距离排序
ans.sort(Comparator.comparingInt(a -> a[0]));

int cur = 0; // 当前已选节点的总容量
List<Integer> res = new ArrayList<>();

// 选择满足需求的节点
for (int[] t : ans) {
if (t[0] >= INF) break; // 距离无穷大时停止

cur += t[2]; // 累加当前节点的剩余容量
res.add(t[1]); // 记录当前节点编号
if (cur >= ned) break; // 如果达到需求，停止
}

// 输出结果
for (int i = 0; i < res.size(); i++) {
System.out.print(res.get(i));
if (i != res.size() - 1) System.out.print(" ");
}
System.out.println();

scanner.close();
}
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
const INF = 1e9;

// 读取节点数
let n = parseInt(await readline());

// 读取延迟矩阵
let g = Array.from({ length: n }, () => Array(n).fill(INF));
for (let i = 0; i < n; i++) {
let row = (await readline()).split(" ").map(Number);
for (let j = 0; j < n; j++) {
g[i][j] = row[j] === -1 ? INF : row[j];
}
}

// 读取剩余容量
let cost = (await readline()).split(" ").map(Number);

// 读取故障节点和需要迁移的业务量
let wr = parseInt(await readline());
let ned = parseInt(await readline());

// Dijkstra 算法
let d = Array(n).fill(INF);
let st = Array(n).fill(false);

function dijkstra() {
d[wr] = 0;

for (let i = 0; i < n - 1; i++) {
let t = -1;
for (let j = 0; j < n; j++) {
if (!st[j] && (t === -1 || d[j] < d[t])) {
t = j;
}
}

if (t === -1 || d[t] === INF) break;

st[t] = true;

for (let j = 0; j < n; j++) {
d[j] = Math.min(d[j], d[t] + g[t][j]);
}
}

d[wr] = INF; // 恢复故障节点的距离，防止被选中
}

dijkstra();

// 存储 (距离, 节点编号, 剩余容量)
let ans = [];
for (let i = 0; i < n; i++) {
ans.push([d[i], i, cost[i]]);
}

// 按照距离排序
ans.sort((a, b) => a[0] - b[0]);

let cur = 0; // 当前已选节点的总容量
let res = [];

// 选择满足需求的节点
for (let i = 0; i < n; i++) {
let [dist, node, capacity] = ans[i];
if (dist >= INF) break;

cur += capacity;
res.push(node);
if (cur >= ned) break;
}

console.log(res.join(" "));

rl.close();
})();

题目描述
小明需要多个业务节点之间选择最快的逃生节点集，并考虑每个节点的剩余业务容量。业务节点之间的关系可以看作一个图。小明有一个网络时延表，表示每个节点到其他节点的通信延迟，即小明从某节点逃到另一节点所需要的时间;还有一个剩余业务容量表，表示每个节点的剩余业务容量。在一个节点故障时，需要选择一个或多个逃生节点，确保逃生路径的时延最小，并且逃生节点集各节点剩余容量的总和足够容纳故障节点的业务量，当故障节点与多个节点最短距离相同，优先选择编号较小的节点容灾，如果逃生节点集中多个节点最短距离相同时按编号从小到大的顺序排列。
输入描述
第111行nnn表示业务节点数， 2<=n<=100002<=n<=100002<=n<=10000，节点编号从 000 开始，依次递增；
第222到1+n1+n1+n行表示业务节点间的网络时延矩阵表 delayMatrix，delayMatrix[i][j]delayMatrix[i][j]delayMatrix[i][j] 表示节点iii到节点jjj的通信时延;
1）如果节点iii和节点jjj之间没有直接相连的边，则 delayMatrix[i][j]delayMatrix[i][j]delayMatrix[i][j] 为 -1，第iii个节点和它自己也没有边，所以delayMatrix[i][i]=−1delayMatrix[i][i]=-1delayMatrix[i][i]=−1
2）节点间有边时延范围为 1<=delayMatrix[i][j]<=10001<=delayMatrix[i][j]<=10001<=delayMatrix[i][j]<=1000，矩阵元素间使用空格分割
另，输入保证 delayMatrix[i][j]==delayMatrix[j][i]delayMatrix[i][j] == delayMatrix[j][i]delayMatrix[i][j]==delayMatrix[j][i]
第2+n行表示各业务节点的剩余容量表 remainingCapacity，其中 remainingCapacity[i] 表示节点 i 的剩余业务容量，业务量的范围1<=remainingCapacity[i]<=1001<=remainingCapacity[i]<=1001<=remainingCapacity[i]<=100，数组元素间使用空格分割；
第3+n3+n3+n行表示故障业务节点编号 faultyNode，表示发生故障的节点，取值范围为 0<=faultyNode<=n−10<=faultyNode<=n−10<=faultyNode<=n−1 ；
第4+n4+n4+n行表示受损业务节点需要迁移的业务量, 受损业务量的范围 (0−1000] 。
输出描述
返回符合条件的逃生路径节点编号列表，用空格分隔。当所有节点都不够故障节点业务容灾时候，输出所有容灾节点。
样例
输入
4
-1 5 -1 8
5 -1 1 3
-1 1 -1 4
8 3 4 -1
10 20 15 25
2
12

输出
1

▶️

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 92ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-微服务群组（P2329）
- 链接：https://codefun2000.com/p/P2329

> 页面标题：#P2329. 第3题-微服务群组

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
在这道题中，我们需要处理一个包含 n 个微服务的调用关系数组 edges，其中每个微服务通过数组值指向另一个微服务。我们的目标是识别所有的微服务环群组，计算每个环的内聚值 H = L - V（L 为环中微服务的数量，V 为可以访问该环的其他微服务数量），并根据 H 值进行排序（当 H 值相同时，按环中最大微服务编号排序）。最后，输出 H 值最大的环，确保输出顺序是从环中编号最小的微服务开始。输入包含一个整数 n 和一个长度为 n 的数组 edges，输出为满足条件的微服务编号，以空格分隔。
思路:BFS遍历
1，6，3组成了微服务群组(环) a1，L1值为3，编号为4、9的2个微服务可以访问到a1，因此√1值为2，H1为L1V1 =1;
0，2，10，5组成了微服务群组 (环) a2，L2值为4，编号为7、8、11的3个微服务可以访问到2，因此v2值为3，H2为L2-V2=1；
先对比H值，H1=H2，H值相等;
再对比环中序号最大值，a1中最大数为6。a2中最大数为10，a2排前面，因此输出答案为:0 2 10 5
题解
本题要求识别微服务调用中的环（强连通分量），并计算它们的内聚值。具体步骤如下：

输入数据结构：首先，我们需要一个整数 n 表示微服务数量，以及一个数组 edges，其中 edges[i] 表示微服务 i 调用的目标微服务。

图的表示：将微服务调用关系表示为有向图。每个微服务通过调用关系指向其他微服务。

强连通分量：利用 Tarjan 算法找出所有的强连通分量（SCC），每个强连通分量内的节点可以互相到达。

计算内聚值：

对于每个强连通分量，计算环内微服务数量 L 和可访问该环的其他微服务数量 V，从而得到内聚值 H = L - V。
H 值越大，表示环的内聚性越强。

排序和输出：根据 H 值从大到小排序，若 H 值相等，则选择环中编号最大的微服务进行比较。最终输出 H 值最大的环，且按照环中最小编号的微服务开始输出。

代码
C++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 2e5 + 10; // 最大微服务数量
int n, m; // n: 微服务数量, m: 边的数量（暂未使用）
int a[maxn]; // 存储微服务调用关系
int ver[maxn << 1], Next[maxn << 1], head[maxn], tot = 1; // 图的边信息
int low[maxn], dfn[maxn], num; // Tarjan算法中的访问标记和低点
int Stack[maxn], top, ins[maxn], c[maxn]; // Tarjan算法的栈和标记
int cnt, id, ans = INT_MIN; // cnt: 强连通分量数量, id: 当前最大H值的强连通分量编号
vector<int> scc[maxn]; // 存储所有强连通分量

// 添加边到邻接表
inline void add(int x, int y) {
ver[++tot] = y;
Next[tot] = head[x];
head[x] = tot;
}

// Tarjan算法实现
void tarjan(int x) {
dfn[x] = low[x] = ++num; // 设置访问时间和最低点
Stack[++top] = x; // 将当前节点入栈
ins[x] = 1; // 标记当前节点在栈中
for (int i = head[x]; i; i = Next[i]) {
int y = ver[i]; // 访问邻接点
if (!dfn[y]) { // 如果y未被访问
tarjan(y); // 递归访问
low[x] = min(low[x], low[y]); // 更新最低点
} else if (ins[y]) {
low[x] = min(low[x], dfn[y]); // 更新最低点
}
}
// 强连通分量的根节点
if (low[x] == dfn[x]) {
++cnt; // 新的强连通分量
int y;
do {
y = Stack[top--]; // 出栈
ins[y] = 0; // 标记出栈
c[y] = cnt; // 记录所属强连通分量
scc[cnt].push_back(y); // 存储强连通分量
} while (x != y); // 直到回到根节点
}
}

// 获取强连通分量中的最大编号
int getMax(int id) {
int res = 0;
for (int x : scc[id]) {
res = max(res, x); // 比较取最大
}
return res;
}

// 计算访问到达某个强连通分量的数量
int dfs(int x, int fa) {
int tmp = 0;
for (int i = head[x], y; i; i = Next[i]) {
y = ver[i];
if (y == fa) continue; // 不回到父节点
tmp += dfs(y, x); // 递归访问
}
return tmp + 1; // 返回访问到的节点数
}

int main() {
std::ios::sync_with_stdio(false); // 加速输入输出
cin >> n; // 输入微服务数量
// 构建图
for (int i = 0; i < n; ++i) {
cin >> a[i]; // 输入每个微服务的调用关系
add(i, a[i]); // 添加边
}
// 使用Tarjan算法求解强连通分量
for (int i = 1; i <= n; ++i) {
if (!dfn[i]) {
tarjan(i);
}
}
// 新建反图的构建
for (int i = 0; i < n; ++i) {
if (scc[c[i]].size() == 1) { // 该强连通分量只有一个点
add(c[a[i]] + n, c[i] + n); // 只有不在环中的点才需要建立边
}
}
// 遍历所有强连通分量
for (int i = 1; i <= cnt; ++i) {
if (scc[i].size() != 1) { // 说明为环
int V = dfs(i + n, -1) - 1; // 计算可访问的节点数量
int H = scc[i].size() - V; // 计算内聚值
if (H > ans) { // 更新最大内聚值
id = i;
ans = H;
} else if (H == ans && getMax(id) < getMax(i)) { // H相等时，比较最大编号
id = i;
}
}
}
// 找到该强连通分量中编号最小的点的位置
int pos = 0;
for (int i = 0; i < scc[id].size(); ++i) {
if (scc[id][i] < scc[id][pos]) {
pos = i; // 更新最小编号的位置
}
}
// 求scc时，编号按遍历顺序倒着加入进scc中，所以倒序输出
for (int i = pos; i >= 0; --i) {
cout << scc[id][i] << " "; // 输出环中节点
}
for (int i = scc[id].size() - 1; i > pos; --i) {
cout << scc[id][i] << " "; // 输出环中节点
}

return 0;
}

python
import sys
sys.setrecursionlimit(10**7)
from collections import deque

def main():
data = sys.stdin.read().split()
if not data:
return
it = iter(data)
n = int(next(it))
to = [int(next(it)) for _ in range(n)]

# 构建反向图用于后续计算 V
rev = [[] for _ in range(n)]
for u, v in enumerate(to):
rev[v].append(u)

# Tarjan 算法寻找所有强连通分量
dfn = [0] * n
low = [0] * n
in_stack = [False] * n
stack = []
idx = 0
comp_id = [0] * n
sccs = []

def tarjan(u):
nonlocal idx
idx += 1
dfn[u] = low[u] = idx
stack.append(u)
in_stack[u] = True
v = to[u]
if dfn[v] == 0:
tarjan(v)
low[u] = min(low[u], low[v])
elif in_stack[v]:
low[u] = min(low[u], dfn[v])
# 如果是 SCC 根节点
if low[u] == dfn[u]:
comp = []
while True:
x = stack.pop()
in_stack[x] = False
comp_id[x] = len(sccs)
comp.append(x)
if x == u:
break
sccs.append(comp)

for i in range(n):
if dfn[i] == 0:
tarjan(i)

# 计算每个非单点 SCC（环）的 H 值并选最好
best = None  # (H, max_node, comp)
for comp in sccs:
if len(comp) <= 1:
continue  # 单点不构成环
L = len(comp)
# 统计可访问该环的其他节点数 V
visited = set(comp)
dq = deque(comp)
V = 0
while dq:
u = dq.popleft()
for w in rev[u]:
if w not in visited:
visited.add(w)
dq.append(w)
V += 1
H = L - V
m = max(comp)
if best is None or (H, m) > (best[0], best[1]):
best = (H, m, comp)

# 输出最佳环，从最小编号开始，按调用顺序
_, _, comp = best
start = min(comp)
order = [start]
nxt = to[start]
while nxt != start:
order.append(nxt)
nxt = to[nxt]
print(" ".join(map(str, order)))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {

static int n;
static int[] edges;
static int[] nums;  // 每个节点的子节点数目
static int[] inDegree;

public static void main(String[] args) {
// Input
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
edges = new int[n]; // 存储每个节点指向的下一个节点的数组
inDegree = new int[n]; // 存储每个节点的入度数组
nums = new int[n]; // 每个节点的子节点数目

// 读取每个节点的下一个节点，并更新入度数组
for (int i = 0; i < n; ++i) {
edges[i] = sc.nextInt(); // 读取每个节点的下一个节点
inDegree[edges[i]]++;
}

Queue<Integer> q = new LinkedList<>(); // 创建队列以存储所有入度为0的节点

// 将所有入度为0的节点加入队列
for (int i = 0; i < n; ++i) {
if (inDegree[i] == 0) {
q.offer(i);
}
}

// BFS遍历
while (!q.isEmpty()) {
int qSize = q.size();
for (int i = 0; i < qSize; i++) {
int curIdx = q.poll();
int curNextIdx = edges[curIdx];
inDegree[curNextIdx]--; // 当前节点指向的结点的入度减1
// nums 存储每个节点的子节点数目
nums[curNextIdx] += nums[curIdx] + 1;
if (inDegree[curNextIdx] == 0) {
q.offer(curNextIdx);
}
}
}

List<List<Integer>> circles = new ArrayList<>(); // 存储所有环的列表
List<Integer> hVal = new ArrayList<>(); // 存储每个环的内聚值H = L(环内节点数量) - V(指向环的节点数量)
List<Integer> maxIdxInCircles = new ArrayList<>(); // 存储每个环中的最大节点索引

// 找环
for (int i = 0; i < n; i++) {
if (inDegree[i] == 0) {
continue;
}
int curIdx = i, v = 0, maxIdx = i;
List<Integer> curCircle = new ArrayList<>();
while (inDegree[curIdx] > 0) {
// nums 存储每个节点的子节点数目
v += nums[curIdx];
curCircle.add(curIdx);
inDegree[curIdx] = 0;
curIdx = edges[curIdx];
maxIdx = Math.max(maxIdx, curIdx);
}
circles.add(curCircle);
maxIdxInCircles.add(maxIdx);
// 计算内聚值，并加入列表
// 每个环的内聚值H = L(环内节点数量) - V(指向环的节点数量)
hVal.add(curCircle.size() - v);
}

Integer[] idx = new Integer[hVal.size()]; // 创建索引数组
for (int i = 0; i < idx.length; ++i) idx[i] = i; // 初始化索引数组

// 对索引数组进行排序，优先根据环的内聚值排序，其次看最大节点索引
Arrays.sort(idx, (a, b) -> {
int valCompare = hVal.get(b).compareTo(hVal.get(a));
if (valCompare != 0) return valCompare;
return Integer.compare(maxIdxInCircles.get(b), maxIdxInCircles.get(a));
});

List<Integer> resCircle = circles.get(idx[0]);

int startIdx = Collections.min(resCircle);
for (int i = 0; i < resCircle.size(); i++) {
System.out.print(startIdx);
startIdx = edges[startIdx];
if (i != resCircle.size() - 1) {
System.out.print(" ");
}
}

}
}

javascript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

void (async function () {
let n = parseInt(await readline()); // 读取节点数量
let edges = new Array(n).fill(0);   // 存储每个节点指向的下一个节点
let inDegree = new Array(n).fill(0); // 存储每个节点的入度
let nums = new Array(n).fill(0); // 统计每个节点的子节点数目

// 读取边，并更新入度数组
let input = (await readline()).split(" ").map(Number);
for (let i = 0; i < n; i++) {
edges[i] = input[i];
inDegree[edges[i]]++; // 统计入度
}

let queue = []; // BFS 处理入度为 0 的节点

// 将所有入度为 0 的节点加入队列
for (let i = 0; i < n; i++) {
if (inDegree[i] === 0) queue.push(i);
}

// BFS 遍历
while (queue.length > 0) {
let curIdx = queue.shift();
let curNextIdx = edges[curIdx];
inDegree[curNextIdx]--; // 当前节点指向的结点的入度减 1
nums[curNextIdx] += nums[curIdx] + 1; // 更新子节点数
if (inDegree[curNextIdx] === 0) queue.push(curNextIdx);
}

let circles = []; // 存储所有环的列表
let hVal = []; // 存储每个环的内聚值 H = L(环内节点数量) - V(指向环的节点数量)
let maxIdxInCircles = []; // 存储每个环的最大节点索引

// 找环
for (let i = 0; i < n; i++) {
if (inDegree[i] === 0) continue;

let curIdx = i, v = 0, maxIdx = i;
let curCircle = [];

while (inDegree[curIdx] > 0) {
v += nums[curIdx];
curCircle.push(curIdx);
inDegree[curIdx] = 0; // 标记为访问过
maxIdx = Math.max(maxIdx, curIdx);
curIdx = edges[curIdx];
}

circles.push(curCircle);
maxIdxInCircles.push(maxIdx);
hVal.push(curCircle.length - v); // 计算内聚值
}

// 创建索引数组，并排序
let idx = Array.from({ length: hVal.length }, (_, i) => i);
idx.sort((a, b) => {
if (hVal[b] !== hVal[a]) return hVal[b] - hVal[a]; // 按 H 值降序
return maxIdxInCircles[b] - maxIdxInCircles[a]; // 按最大节点索引降序
});

let resCircle = circles[idx[0]]; // 选择排序后第一个环

// 输出环的最小起始节点
let startIdx = Math.min(...resCircle);
let result = [];
for (let i = 0; i < resCircle.length; i++) {
result.push(startIdx);
startIdx = edges[startIdx];
}

console.log(result.join(" "));

rl.close();
})();

题目描述
\qquad上期我们聊到，你为了帮助小明维护云服务器而大打出手。如今，云服务器已经平稳运行并给用户们提供了一系列不错的服务，但是小明仍花了很多时间在运维和数据分析上。
\qquad更形式的，小明为了调研微服务调用情况，对nnn个微服务调用数据进行了采集分析,微服务使用数字000至n−1n-1n−1进行编号，给你一个下标从000开始的数组edgesedgesedges，其中edges[i]edges[i]edges[i]表示存在一条从微服务iii到微服务edges[i]edges[i]edges[i]的接口调用。
\qquad为了更好的维护，小明将形成111个环的多个微服务称为微服务群组，一个微服务群组的所有微服务数量为LLL，能够访问到该微服务群组的微服务数量为VVV，这个微服务群组的内聚值H=L−VH=L-VH=L−V。
\qquad已知提供的数据中有111个或多个微服务群组，请按照内聚值HHH的结果从大到小的顺序对所有微服务群组(H相等时，取环中最大的数进行比较)排序，输出排在第一的做服务群组，输出时每个微服务群组输出的起始编号为环中最小的数。
输入描述
\qquad第一行输入nnn，表示有n个微服务
\qquad第二行为数组edgesedgesedges,其中edges[i]edges[i]edges[i]表示存在一条从微服务iii到微服务edges[i]edges[i]edges[i]的接口调用，数字以空格分隔。
数据范围：
\qquadnnn == edges.lengthedges.lengthedges.length
\qquad2≤n≤1052 \le n \le 10^52≤n≤105
\qquad0≤edges[i]≤n−10 \le edges[i] \le n - 10≤edges[i]≤n−1
\qquad输入保证edges[i]≠iedges[i] \ne iedges[i]=i
输出描述
\qquad输出排在第一的微服务群组的编号数组，按照环的访问顺序输出，起始编号为环中最小的数，数字以空格分隔。
样例一
输入
4
3 3 0 2

输出
0 3 2

解释
0，3，2组成了微服务群组 (环)a，他的L值为3，对于a来说，只有编号为1的1个微服务可以访问到a，因此a的为1答案输出微服务群组为0 3 2
样例二
输入
12
2 6 10 1 6 0 3 0 5 4 5 8

输出
0 2 10 5

解释
1，6，3组成了微服务群组(环) a1，L1值为3，编号为4、9的2个微服务可以访问到a1，因此√1值为2，H1为L1V1 =1;
0，2，10，5组成了微服务群组 (环) a2，L2值为4，编号为7、8、11的3个微服务可以访问到2，因此v2值为3，H2为L2-V2=1；
先对比H值，H1=H2，H值相等;
再对比环中序号最大值，a1中最大数为6。a2中最大数为10，a2排前面，因此输出答案为:0 2 10 5
Limitation
1s, 1024KiB for each test case.

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

Related

In following contests: 塔子周赛（二）华为暑期实习-2024年4月24号场

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 78ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-软工项目（P2326）
- 链接：https://codefun2000.com/p/P2326

> 页面标题：#P2326. 第3题-软工项目

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

_（未抓到题解文本；可能未开放/需要权限/或页面结构不同）_

---

### 第3题-计网实验2.0（P2323）
- 链接：https://codefun2000.com/p/P2323

> 页面标题：#P2323. 第3题-计网实验2.0

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述:
塔子哥在进行计网实验后，又收到了一周的接口板需求。他需要为两台设备配置接口板，使得每台设备的接口板转发能力之和恰好等于设备的整机转发能力。输入包括目标设备的转发能力、客户订购的接口板数量以及接口板的转发能力列表。若能够满足条件，输出两台设备配置的接口板转发能力列表（需按从小到大排列）；若无法满足，则输出-1。
思路
由于题目保证如果存在解，那么解一定是唯一的，所以接口板容量之和肯定是整机转发能力的两倍。
我们可以使用动态规划来解决这个问题，设f[i][j]表示前i个接口板能否组成转发能力为j的整机，如果能组成，那么f[i][j]定义为i表示第i个元素为结尾接口板，那么我们有状态转移方程：
f[i][j] = f[i - 1][j] or f[i - 1][j - a[i]]

其中a[i]表示第i个接口板的容量。由于需要记录路径，我们可以使用pre[i][j]来记录f[i][j]的上一个状态。
pre[i][j] = f[i - 1][j - a[i]]

由于每次只需要前一个状态，所以我们可以使用一维的f来进行优化。
最后将符合条件的路径找出，将其分成两部分，分别排序，然后对比输出即可。
题解
为了给两台设备配置接口板，使得每台设备的接口板转发能力之和恰好等于设备的整机转发能力，我们可以利用动态规划来解决这个问题。具体思路如下：

问题分析：

输入中给定的目标设备的转发能力为 m m m，并且客户订购了 n n n 块接口板。根据题目的描述，如果存在解，那么所有接口板的容量之和必定等于 2m 2m 2m（即两台设备的转发能力总和）。因此，如果这些接口板的总和不等于 2m 2m 2m，直接输出 -1。

动态规划状态定义：

我们定义 f[i][j] 表示前 i i i 个接口板能否组成转发能力为 j j j 的整机。如果能组成，那么 f[i][j] 的值为真。我们还需要使用 pre[i][j] 来记录路径，表示 f[i][j] 的上一个状态。

状态转移方程：

状态转移方程为：
f[i][j]=f[i−1][j] or f[i][j] = f[i - 1][j] \text{ or }f[i][j]=f[i−1][j] or f[i−1][j−a[i]] f[i - 1][j - a[i]]f[i−1][j−a[i]]
其中，a[i] a[i] a[i] 表示第 i i i 个接口板的容量。

优化：

由于我们只需要使用前一个状态，因此可以将 f 数组优化为一维数组，从而减少空间复杂度。

路径回溯：

一旦找到能够组成转发能力为 m m m 的方案，我们需要回溯找到所用的接口板。利用 pre 数组可以帮助我们记录并找出使用了哪些接口板。

结果输出：

将找到的两部分接口板分别排序，然后进行比较，按照题目要求的顺序输出。

代码
Python
def main():
import sys
input = sys.stdin.read
data = input().split()

m = int(data[0])  # 读取 m
n = int(data[1])  # 读取 n
a = list(map(int, data[2:2 + n]))  # 读取数组 a

# 如果数组元素的总和不等于 2m，则输出 -1 并退出
if sum(a) != m * 2:
print(-1)
return

# 初始化前驱数组 pre 和动态规划数组 f
pre = [[-1] * (m + 1) for _ in range(n)]
f = [-1] * (m + 1)
f[0] = 0

# 动态规划过程
for i in range(n):
for j in range(m, a[i] - 1, -1):
if f[j - a[i]] != -1:
pre[i][j] = f[j - a[i]]
f[j] = i

# 如果能找到一个和为 m 的子集
if f[m] != -1:
vis = [False] * n
i, j = m, f[m]
while i > 0:
vis[j] = True
k = a[j]
j = pre[j][i]
i -= k

ans1, ans2 = [], []
for i in range(n):
if vis[i]:
ans1.append(a[i])
else:
ans2.append(a[i])

# 对两个子集进行排序
ans1.sort()
ans2.sort()

# 比较两个子集，确保 ans1 是字典序较小的
if ans1[0] > ans2[0] or (ans1[0] == ans2[0] and len(ans1) < len(ans2)):
ans1, ans2 = ans2, ans1

# 输出两个子集
print(" ".join(map(str, ans1)))
print(" ".join(map(str, ans2)))

if __name__ == "__main__":
main()

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
int m = sc.nextInt();
int n = sc.nextInt();
int[] a = new int[n];
for (int i = 0; i < n; ++i) {
a[i] = sc.nextInt();  // 读取输入的数组元素
}

// 如果数组元素的总和不等于 2m，则输出 -1 并退出
if (Arrays.stream(a).sum() != m * 2) {
System.out.println(-1);
return;
}

// 初始化前驱数组 pre 和动态规划数组 f
int[][] pre = new int[n][m + 1];
for (int[] row : pre) Arrays.fill(row, -1);
int[] f = new int[m + 1];
Arrays.fill(f, -1);
f[0] = 0;

// 动态规划过程
for (int i = 0; i < n; ++i) {
for (int j = m; j >= a[i]; --j) {
if (f[j - a[i]] != -1) {
pre[i][j] = f[j - a[i]];
f[j] = i;
}
}
}

// 如果能找到一个和为 m 的子集
if (f[m] != -1) {
boolean[] vis = new boolean[n];
for (int i = m, j = f[m]; i > 0;) {
vis[j] = true;
int k = a[j];
j = pre[j][i];
i -= k;
}

List<Integer> ans1 = new ArrayList<>();
List<Integer> ans2 = new ArrayList<>();
for (int i = 0; i < n; ++i) {
if (vis[i]) ans1.add(a[i]);
else ans2.add(a[i]);
}

// 对两个子集进行排序
Collections.sort(ans1);
Collections.sort(ans2);

// 比较两个子集，确保 ans1 是字典序较小的
if (ans1.get(0) > ans2.get(0) ||
(ans1.get(0).equals(ans2.get(0)) && ans1.size() < ans2.size())) {
List<Integer> temp = ans1;
ans1 = ans2;
ans2 = temp;
}

// 输出两个子集
for (int i = 0; i < ans1.size(); ++i)
System.out.print(ans1.get(i) + (i == ans1.size() - 1 ? "\n" : " "));
for (int i = 0; i < ans2.size(); ++i)
System.out.print(ans2.get(i) + (i == ans2.size() - 1 ? "\n" : " "));
}
}
}

C++
#include <bits/stdc++.h>

using namespace std;

int main()
{
int n, m;
cin >> m >> n;
vector<int> a(n);
for (int i = 0;i < n;++ i) cin >> a[i];
if (accumulate(a.begin(), a.end(), 0) != m * 2) {
cout << -1 << endl;
return 0;
}
vector<vector<int>> pre(n, vector<int> (m + 1, -1));
vector<int> f(m + 1, -1);
f[0] = 0;
for (int i = 0;i < n;++ i) {
for (int j = m;j >= a[i];-- j) if (~f[j - a[i]]) {
pre[i][j] = f[j - a[i]];
f[j] = i;
}
}
if (~f[m]) {
vector<bool> vis(n, false);
for (int i = m, j = f[m];i > 0;) {
vis[j] = true;
int k = a[j];
j = pre[j][i];
i -= k;
}
vector<int> ans1, ans2;
for (int i = 0;i < n;++ i) {
if (vis[i]) ans1.push_back(a[i]);
else ans2.push_back(a[i]);
}
sort(ans1.begin(), ans1.end());
sort(ans2.begin(), ans2.end());
if (ans1[0] > ans2[0] || (ans1[0] == ans2[0] && ans1.size() < ans2.size())) swap(ans1, ans2);
for (int i = 0;i < ans1.size();++ i) cout << ans1[i] << " \n"[i == ans1.size() - 1];
for (int i = 0;i < ans2.size();++ i) cout << ans2[i] << " \n"[i == ans2.size() - 1];
}
return 0;
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

(async function () {
let m = parseInt(await readline()); // 读取 m
let n = parseInt(await readline()); // 读取 n
let a = (await readline()).split(" ").map(Number); // 读取数组 a

let sumA = a.reduce((sum, x) => sum + x, 0);
if (sumA !== 2 * m) {
console.log(-1);
rl.close();
return;
}

let pre = Array.from({ length: n }, () => Array(m + 1).fill(-1));
let f = Array(m + 1).fill(-1);
f[0] = 0;

for (let i = 0; i < n; i++) {
for (let j = m; j >= a[i]; j--) {
if (f[j - a[i]] !== -1 && f[j] === -1) {
pre[i][j] = f[j - a[i]];
f[j] = i;
}
}
}

if (f[m] === -1) {
console.log(-1);
rl.close();
return;
}

let vis = Array(n).fill(false);
for (let i = m, j = f[m]; i > 0 && j !== -1;) {
vis[j] = true;
let k = a[j];
j = pre[j][i];
i -= k;
}

let ans1 = [], ans2 = [];
for (let i = 0; i < n; i++) {
if (vis[i]) ans1.push(a[i]);
else ans2.push(a[i]);
}

ans1.sort((x, y) => x - y);
ans2.sort((x, y) => x - y);

if (
ans1.length > 0 && ans2.length > 0 &&
(ans1[0] > ans2[0] || (ans1[0] === ans2[0] && ans1.length < ans2.length))
) {
[ans1, ans2] = [ans2, ans1];
}

console.log(ans1.join(" "));
console.log(ans2.join(" "));

rl.close();
})();

题目描述
\qquad小明做完了上周的计网实验，但是按照一周一个的原则，他又收到了这周的份额，holy damn！
\qquad柜式路由器需要配备接口板才可以工作,接口板用于接入用户业务，且接口板转发能力的和不能大于路由器整机的转发能力。当前某客户订购了2台设备和num块接口板。请计算是否存在一种安装方法，使用户选购的接口板，刚好能装到两台设备上，且每台设备配置的口板的转发能力之和,刚好和整机的转发能力相等。
\qquad 1、设备整机转发能力的单位是Gbps,Gbps是设备单位时间内传输的比特数，代表千兆比特/秒。为了简化问题,规定值为整数,范围为[1,2000]。
\qquad 2、客户订购的接口板数量num,值的范围[1,200]。
\qquad 3、接口板容量的单位也是Gbps，比如1010 40 40 100，代表选购了5块接口板,转发能力分别是10Gbps, 10Gbps, 40Gbps, 40Gbps, 100Gbps，接口板转发能力的范围一般为特定枚举值，为了简化问题，规定值为正整数。
输入描述
\qquad第一行是目标设备的转发能力。第二行是客户订购的接口板数量num 。第三行是订购的包含num个接口板的转发能力的列表。
输出描述
\qquad如果存在满足要求的安装方法，请分两行输出两台设备配置的接口板的转发能力的列表，且要求每台设备的单板，按转发能力从小到大排列。两台设备的单板，第一个单板转发能力小的优先输出。如果第一个单板转发能力相同，那单板数多的优先输出。如果不存在对应的安装方案，则返回-1。用例保证在满足前面条件的情况下，不会有多种不同的结果。
样例一
输入
100
5
40 10 10 40 100

输出
10 10 40 40
100

样例二
输入
100
3
10 10 20

输出
-1

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 81ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-农田修复（P2320）
- 链接：https://codefun2000.com/p/P2320

> 页面标题：#P2320. 第3题-农田修复

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题目分析
塔子哥的农田受到地震的破坏，网点中有部分区域断开了联系。给定一个矩形农田，未被破坏的网点用 1 表示，破坏的网点用 0 表示，标记为 1 的相邻网点可以构成子网。塔子哥需要找到目标网点所在的子网，并计算离它最近的其他子网的最小距离。
思路
该题为力扣的改编题 1162. 地图分析
本题需要求当前区域到其他所有区域的最短 曼哈顿距离
我们分两次 BFS 来求出最短距离

第一次BFS的目的是标记不同的区域
第二次BFS的目的是求最短距离。

解题思路
整个问题可以通过两次广度优先搜索（BFS）来解决：

第一次 BFS：用于标记目标网点所在的子网，同时将该子网的边缘元素收集起来，方便之后第二次 BFS 的执行。边缘元素是指目标子网中，与其他子网或空白区域（0）相邻的元素。
第二次 BFS：从第一次收集的边缘元素出发，计算到其他子网的最短距离。只要找到第一个不同子网（即与目标子网不连通的子网），即可输出最短距离。

解题步骤

输入数据处理：首先读取目标网点的坐标 (sx, sy)，农田的尺寸 n 和 m，以及农田的网点状态矩阵。
第一次 BFS：标记子网：

遍历矩阵，找到所有标记为 1 的网点，使用 BFS 遍历其连通的所有网点，并将这些网点标记为一个唯一的子网编号。
如果目标网点 (sx, sy) 所在的网点被遍历到，记录下其所属的子网编号（即颜色）。
BFS 过程中收集目标子网的边缘网点，为第二次 BFS 做准备。

第二次 BFS：计算最短距离：

从第一次 BFS 收集的边缘网点出发，执行 BFS 遍历，找到距离最近的不同子网，并返回该距离。
由于 BFS 本身是层次遍历的，因此一旦遇到不同的子网，当前的距离就是最小的。

特殊情况处理：如果整个矩阵中只有一个子网，则输出 -1，因为此时不存在其他子网。

代码细节说明

第一次 BFS 标记子网：通过 BFS 遍历所有网点，找到连通的 1，并将其标记为一个子网。每发现一个新的子网，就给它一个唯一的编号。
第二次 BFS 寻找最短距离：从目标子网的所有边缘元素开始进行 BFS，层次遍历，找到第一个与目标子网不同的子网时，即输出当前的距离。
特殊情况处理：如果只有一个子网，则直接输出 -1。

AC代码
Python
from collections import deque
sx, sy = map(int, input().split())
sx -= 1
sy -= 1
n, m = map(int, input().split())
g = [list(map(int, input().split())) for _ in range(n)]
idx = 2
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 第一次 BFS 遍历,标记不同的区域
def bfs(x, y, c):
q = deque()
q.append([x, y])
g[x][y] = c
while len(q):
x, y = q.popleft()
for i in range(4):
a, b = x + dx[i], y + dy[i]
if a < 0 or a >= n or b < 0 or b >= m or g[a][b] != 1:
continue
q.append([a, b])
g[a][b] = c

for i in range(n):
for j in range(m):
if g[i][j] == 1:
bfs(i, j, idx)
idx += 1

# 如果只有陆地和海洋两种区域,则返回-1
if idx <= 3:
print(-1)
else:
color = g[sx][sy]
q = deque()
st = set()
d = [[float('inf')] * m for _ in range(n)]

# 第二次 BFS 遍历,找到最短距离
for i in range(n):
for j in range(m):
if g[i][j] == color:
q.append([i, j])
st.add((i, j))
d[i][j] = 0
res = 0
while len(q):
x, y = q.popleft()
if g[x][y] != color and g[x][y]:
res = d[x][y]
break
for i in range(4):
a, b = x + dx[i], y + dy[i]
if a < 0 or a >= n or b < 0 or b >= m or (a, b) in st:
continue
q.append([a, b])
d[a][b] = d[x][y] + 1
st.add((a, b))
print(res - 1)

Java
import java.util.*;

public class Main {
private static int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
private static Deque<int[]> queue = new ArrayDeque<>();
private static boolean[][] visited;

// 第一次 DFS 遍历,标记不同的区域
private static void infect(int[][] map, int m, int n, int i, int j) {
if (i < 0 || i == m || j < 0 || j == n || map[i][j] != 1) {
return;
}
map[i][j] = 2;
visited[i][j] = true;
queue.add(new int[]{i, j});
infect(map, m, n, i - 1, j);
infect(map, m, n, i + 1, j);
infect(map, m, n, i, j - 1);
infect(map, m, n, i, j + 1);
}

// 第二次 BFS 遍历,找到最短距离
private static int minPath(int[][] map, int m, int n) {
int step = 0;
int cnt = 0, curLevel = queue.size(), nextLevel = queue.size();
while (!queue.isEmpty()) {
int[] cur = queue.poll();
cnt++;
for (int[] direction : directions) {
int i = cur[0] + direction[0], j = cur[1] + direction[1];
if (i < 0 || i == m || j < 0 || j == n) {
continue;
}
if (map[i][j] == 1) {
return step;
}
if (!visited[i][j]) {
visited[i][j] = true;
queue.add(new int[]{i, j});
nextLevel++;
}
}
if (cnt == curLevel) {
curLevel = nextLevel;
step++;
}
}
return -1;
}

public static void main(String[] args) {
Scanner in = new Scanner(System.in);
int x = in.nextInt() - 1, y = in.nextInt() -1 ;
int m = in.nextInt(), n = in.nextInt();
int[][] map = new int[m][n];
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
map[i][j] = in.nextInt();
}
}
// 第一次 DFS 遍历,标记 xy 所在的子网
visited = new boolean[m][n];
infect(map, m, n, x, y);
System.out.println(minPath(map, m, n));
}
}

C++
#include <iostream>
#include <vector>
#include <queue>
#include <set>
using namespace std;

const int INF = 2000;
vector<int> dx = {-1, 0, 1, 0};
vector<int> dy = {0, 1, 0, -1};

int main() {
int sx, sy;
cin >> sx >> sy;
sx -= 1;
sy -= 1;

int n, m;
cin >> n >> m;
vector<vector<int>> g(n, vector<int>(m));
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
cin >> g[i][j];
}
}
int idx = 2;
// 第一次 BFS 遍历,标记不同的区域
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
if (g[i][j] == 1) {
queue<pair<int, int>> q;
q.push({i, j});
g[i][j] = idx;
while (!q.empty()) {
int x = q.front().first;
int y = q.front().second;
q.pop();
for (int k = 0; k < 4; ++k) {
int a = x + dx[k];
int b = y + dy[k];
if (a < 0 || a >= n || b < 0 || b >= m || g[a][b] != 1) continue;
q.push({a, b});
g[a][b] = idx;
}
}
idx++;
}
}
}
// 如果只有陆地和海洋两种区域,则返回-1
if (idx <= 3) {
cout << -1 << endl;
} else {
int color = g[sx][sy];
queue<pair<int, int>> q;
set<pair<int, int>> st;
vector<vector<int>> d(n, vector<int>(m, INF));
// 第二次 BFS 遍历,找到最短距离
for (int i = 0; i < n; ++i) {
for (int j = 0; j < m; ++j) {
if (g[i][j] == color) {
q.push({i, j});
st.insert({i, j});
d[i][j] = 0;
}
}
}

int res = 0;
while (!q.empty()) {
int x = q.front().first;
int y = q.front().second;
q.pop();
if (g[x][y] != color && g[x][y] != 0) {
res = d[x][y];
break;
}
for (int i = 0; i < 4; ++i) {
int a = x + dx[i];
int b = y + dy[i];
if (a < 0 || a >= n || b < 0 || b >= m || st.count({a, b})) continue;
q.push({a, b});
d[a][b] = d[x][y] + 1;
st.insert({a, b});
}
}

cout << (res - 1) << endl;
}

return 0;
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
let queue = [];
let visited;

// 第一次 DFS 遍历，标记不同的区域
function infect(map, m, n, i, j) {
if (i < 0 || i >= m || j < 0 || j >= n || map[i][j] !== 1) {
return;
}
map[i][j] = 2;
visited[i][j] = true;
queue.push([i, j]);

for (const [dx, dy] of directions) {
infect(map, m, n, i + dx, j + dy);
}
}

// 第二次 BFS 遍历，找到最短距离
function minPath(map, m, n) {
let step = 0;
let cnt = 0, curLevel = queue.length, nextLevel = queue.length;

while (queue.length > 0) {
let [x, y] = queue.shift();
cnt++;

for (const [dx, dy] of directions) {
let i = x + dx, j = y + dy;
if (i < 0 || i >= m || j < 0 || j >= n) {
continue;
}
if (map[i][j] === 1) {
return step;
}
if (!visited[i][j]) {
visited[i][j] = true;
queue.push([i, j]);
nextLevel++;
}
}

if (cnt === curLevel) {
curLevel = nextLevel;
step++;
}
}

return -1;
}

// 读取输入并执行逻辑
async function main() {
let firstLine = (await readline()).split(" ").map(Number);
let x = firstLine[0] - 1, y = firstLine[1] - 1;

let secondLine = (await readline()).split(" ").map(Number);
let m = secondLine[0], n = secondLine[1];

let map = [];
for (let i = 0; i < m; i++) {
map.push((await readline()).split(" ").map(Number));
}

// 初始化 visited 数组
visited = Array.from({ length: m }, () => Array(n).fill(false));

// 第一次 DFS 遍历，标记起点所在的区域
infect(map, m, n, x, y);

// 输出最短路径
console.log(minPath(map, m, n));
rl.close();
}

// 运行主函数
main();

问题描述
小明的农田受到地震的破坏，农田中的一些网点断开了联系。假设原本的农田网构成一个矩形，其中未被破坏的网点标记为 111，被破坏的网点标记为 000。标记为 111 的网点连在一起构成一个子网。现在，小明需要找到一个目标网点，并找出离它最近的其他子网。请注意，两个网点相连只能通过上下左右四个方向，不可以通过斜对角相连。两个网点的距离定义为从一个网点（假设网点名为 CCC）到达另一个网点（假设网点名为 DDD）需要经过相连网点的最小数目（CCC 和 DDD 这两个网点不计算在内）。两个子网（假设分别为 AAA 网和 BBB 网）不相连，AAA 网中所有的网点与 BBB 网中所有的网点的距离中最小的那个即为 AAA 网和 BBB 网的最小距离。
输入格式
第一行包含两个正整数 x,yx, yx,y，表示目标网点的坐标位置（xxx 表示行号，yyy 表示列号）。
第二行包含两个正整数 n,mn, mn,m，表示农田矩形的行数 nnn 和列数 mmm。
接下来的 nnn 行每行包含 mmm 个以空格分隔的整数 000 或 111，表示农田网点的破坏情况。
输出格式
输出一个整数，表示最近的未被破坏子网的距离。如果整网中只有一个子网，则返回 −1-1−1。
样例输入
1 1
6 6
1 1 0 0 1 0
1 1 0 0 1 1
0 0 0 0 1 0
0 1 0 1 0 0
1 1 0 0 0 0
1 1 1 0 1 1

样例输出
1

评测数据与规模

1≤n,m≤10001 \leq n, m \leq 10001≤n,m≤1000。
输入保证目标网点是未被破坏的网点，且目标网点所在子网是一个子网。

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 91ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-获取最多食物（P2397）
- 链接：https://codefun2000.com/p/P2397

> 页面标题：#P2397. 第3题-获取最多食物

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明设计的这个游戏是一个冒险类游戏，参与者需要在地图上寻找食物并获得尽可能多的食物，同时需要注意在游戏过程中所处的位置，因为不同的位置可以通过传送门到达其他位置，可能会影响食物获取的数量。
在游戏开始时，参与者会出发点选择一个方格作为起点，每个方格上至多 222 个传送门，通过传送门可将参与者传送至指定的其它方格。每个方格上都标注了三个数字：id 、 parent-id 和 value 。其中， id 代表方格的编号， parent-id 代表可以通过传送门到达该方格的方格编号， value 代表在该方格获取或失去的食物单位数。
参与者需要在地图上行进，到达每个方格并获取或失去对应的食物单位数，直到满足退出游戏的条件之一。参与者的最终得分是所获取食物单位数的总和，需要尽可能地高。
需要注意的是地图设计时保证了参与者不可能到达相同的方格两次。因此，参与者当前所处的方格无传送门，游戏将立即结束。另外，参与者在任意方格上都可以宣布退出游戏，同样会结束游戏。
请计算参与者退出游戏后，最多可以获得多少单位的食物。
输入描述
第一行：方块个数 NNN  ( N≤10000N\le 10000N≤10000 )
接下来 NNN 行，每行三个整数 id ， parent-id ， value ，具体含义见题面。
0≤id,parent−id<N0\le id,parent-id \lt N0≤id,parent−id<N ， −100≤value≤100-100\le value \le 100−100≤value≤100
特殊的 parent-id 可以取 −1-1−1 则表示没有任何方格可以通过传送门传送到此方格，这样的方格在地图中有且仅有一个。
输出描述
输出为一个整数，表示参与者退出游戏后最多可以获得多少单位的食物。
样例
样例1
输入
7
0 1 8
1 -1 -2
2 1 9
4 0 -2
5 4 3
3 0 -3
6 2 -3

输出
9

样例解释
参与者从方格 000 出发，通过传送门到达方格 444 ，再通过传送门到达方格 555 。一共获得 8+(−2)+3=98+(-2) +3=98+(−2)+3=9 个单位食物，得到食物最多或者参与者在游戏开始时处于方格 222 ，直接主动宣布退出游戏，也可以获得 999 个单位食物。
样例2
输入
3
0 -1 3
1 0 1
2 0 2

输出
5

样例解释
参与者从方格 000 出发，通过传送门到达方格 222 ，一共可以获得 3+2=53+2=53+2=5 个单位食物，此时得到食物最多。

#### TextSol

题目大意
在一个冒险类游戏中，参与者可以在一个由多个方格构成的地图上寻找食物。每个方格有一个编号、一个父方格编号和对应的食物单位数。参与者可以通过传送门从一个方格移动到另一个方格。
参与者可以选择任意方格作为起点，并可以在任何方格选择退出游戏。任务是计算参与者在退出时能够获得的最多食物单位数
思路
简单树上dp
1.数据结构设计：
使用邻接表来表示地图的结构，其中每个方格和其通过传送门可达的方格形成一个有向图。
2.输入处理：
读取方格的数量和每个方格的 id、parent-id、value，并构建邻接表。
确定根节点（parent-id 为 -1 的方格）。
3.深度优先搜索（DFS）：
使用 DFS 遍历整个树，从根节点开始，计算从每个方格出发可以获取的最多食物单位数。
对于每个方格，初始值为其自身的食物单位数。在访问子节点时，更新当前节点的食物总数为当前节点的食物数加上子节点的食物数。
在更新食物总数时，考虑子树的选择，可能会选择不访问某个子节点以达到更高的总和。
4.结果输出：
记录在 DFS 遍历过程中能获得的最大食物单位数，并在最后输出结果。
时间复杂度：O(N)O(N)O(N)
代码说明
整体代码流程
1.输入读取：
读取方格数量 N 和每个方格的 id、parent-id、value，构建树的邻接表。
2.邻接表构建：
使用数组或链表来存储每个方格可以通过传送门到达的其他方格。
3.DFS 初始化：
定义一个数组来存储每个方格可以获得的食物总和。
从根节点开始进行 DFS 遍历，计算每个节点的食物总和。
4.DFS 遍历：
递归访问每个方格，更新食物总数。
处理子节点并更新当前节点的食物总数。
5.输出结果：
输出参与者能够获得的最多食物单位数。
代码
CPP
#include <iostream>
#include <cstdio>
using namespace std;

const int maxn = 1e4 + 10; // 定义最大方格数量
int n; // 方格数量
int a[maxn], dp[maxn]; // a 用于存储每个方格的食物单位数，dp 用于存储从每个方格出发能获得的最多食物单位数
int head[maxn], ver[maxn << 1], Next[maxn << 1], tot = 1; // 图的邻接表
int ans = -1e9; // 初始化答案为负无穷大

// 添加边到邻接表
void add(int x, int y) {
ver[++tot] = y; // 将 y 加入到 x 的邻接表
Next[tot] = head[x]; // 记录原来的头节点
head[x] = tot; // 更新头节点
}

// 深度优先搜索（DFS）
void dfs(int x) {
dp[x] = a[x]; // 初始化当前节点的食物总数为其自身的食物单位数
for (int i = head[x], y; i; i = Next[i]) { // 遍历当前节点的所有邻接节点
y = ver[i]; // 获取邻接节点
dfs(y); // 递归访问邻接节点
dp[x] = max(dp[y] + a[x], dp[x]); // 更新当前节点的食物总数
ans = max(ans, dp[x]); // 更新全局最大食物单位数
}
}

int main() {
scanf("%d", &n); // 读取方格数量
int root; // 根节点
for (int i = 0, x, y; i < n; ++i) { // 读取每个方格的信息
scanf("%d %d", &x, &y); // 读取方格 id 和 parent-id
scanf("%d", &a[x]); // 读取方格的食物单位数
if (y != -1) add(y, x); // 如果 parent-id 不是 -1，添加边
else root = x; // 否则记录根节点
}
dfs(root); // 从根节点开始 DFS
printf("%d", ans); // 输出最大食物单位数

return 0; // 程序结束
}

python
# 使用链式前向星存储图
def add(x, y):
global tot
ver.append(y)  # 将节点 y 添加到邻接表中
Next.append(head[x])  # 将当前节点 x 的头指针保存到 Next 数组中
head[x] = tot  # 更新节点 x 的头指针
tot += 1  # 增加边的计数

# 深度优先搜索
def dfs(x):
global ans
dp[x] = a[x]  # 初始化当前节点的食物总数为其自身的食物单位数
i = head[x]  # 从当前节点的头指针开始遍历
while i:  # 只要 i 不为 0
y = ver[i]  # 获取当前邻接节点
dfs(y)  # 递归访问邻接节点
dp[x] = max(dp[y] + a[x], dp[x])  # 更新当前节点的食物总数
ans = max(ans, dp[x])  # 更新全局最大食物单位数
i = Next[i]  # 移动到下一个邻接节点

# 主程序开始
n = int(input())  # 读取方格数量
maxn = 10010  # 最大方格数量
a = [0] * maxn  # 存储每个方格的食物单位数
dp = [0] * maxn  # 存储从每个方格出发可获得的最多食物单位数
head = [0] * maxn  # 邻接表头指针
ver = []  # 邻接表中的节点
Next = []  # 链式存储的下一条边
tot = 1  # 边的计数
ans = -1e9  # 初始化答案为负无穷大

# 读取每个方格的信息
root = 0  # 根节点
for _ in range(n):
x, y = map(int, input().split())  # 读取方格 id 和 parent-id
a[x] = int(input())  # 读取方格的食物单位数
if y != -1:
add(y, x)  # 如果 parent-id 不是 -1，添加边
else:
root = x  # 否则记录根节点

# 从根节点开始 DFS
dfs(root)
print(ans)  # 输出最大食物单位数

Java
import java.util.Scanner;

public class Main {
static final int maxn = 10010; // 定义最大方格数量
static int n; // 方格数量
static int[] a = new int[maxn]; // 存储每个方格的食物单位数
static int[] dp = new int[maxn]; // 存储从每个方格出发可获得的最多食物单位数
static int[] head = new int[maxn]; // 邻接表的头指针
static int[] ver = new int[maxn << 1]; // 存储邻接节点
static int[] Next = new int[maxn << 1]; // 存储链式存储的下一条边
static int tot = 1; // 边的计数
static int ans = -1000000000; // 初始化答案为负无穷大

// 使用链式前向星存储图
static void add(int x, int y) {
ver[++tot] = y; // 将节点 y 添加到邻接表中
Next[tot] = head[x]; // 将当前节点 x 的头指针保存到 Next 数组中
head[x] = tot; // 更新节点 x 的头指针
}

// 深度优先搜索
static void dfs(int x) {
dp[x] = a[x]; // 初始化当前节点的食物总数为其自身的食物单位数
for (int i = head[x]; i != 0; i = Next[i]) { // 遍历当前节点的所有邻接节点
int y = ver[i]; // 获取当前邻接节点
dfs(y); // 递归访问邻接节点
dp[x] = Math.max(dp[y] + a[x], dp[x]); // 更新当前节点的食物总数
ans = Math.max(ans, dp[x]); // 更新全局最大食物单位数
}
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in); // 创建扫描器以读取输入
n = scanner.nextInt(); // 读取方格数量
int root = 0; // 初始化根节点
for (int i = 0; i < n; i++) { // 读取每个方格的信息
int x = scanner.nextInt(); // 读取方格 id
int y = scanner.nextInt(); // 读取 parent-id
a[x] = scanner.nextInt(); // 读取方格的食物单位数
if (y != -1) { // 如果 parent-id 不是 -1，添加边
add(y, x);
} else { // 否则记录根节点
root = x;
}
}
dfs(root); // 从根节点开始 DFS
System.out.println(ans); // 输出最大食物单位数
}
}

Go
package main

import "fmt"

const maxn = 10010 // 定义最大方格数量

var (
n      int              // 方格数量
a      [maxn]int        // 存储每个方格的食物单位数
dp     [maxn]int        // 存储从每个方格出发可获得的最多食物单位数
head   [maxn]int        // 邻接表的头指针
ver    [maxn << 1]int   // 存储邻接节点
Next   [maxn << 1]int   // 存储链式存储的下一条边
tot    = 1              // 边的计数
ans    = -1000000000    // 初始化答案为负无穷大
)

// 使用链式前向星存储图
func add(x, y int) {
ver[tot] = y              // 将节点 y 添加到邻接表中
Next[tot] = head[x]       // 将当前节点 x 的头指针保存到 Next 数组中
head[x] = tot             // 更新节点 x 的头指针
tot++                     // 增加边的计数
}

// 深度优先搜索
func dfs(x int) {
dp[x] = a[x] // 初始化当前节点的食物总数为其自身的食物单位数
for i := head[x]; i != 0; i = Next[i] { // 遍历当前节点的所有邻接节点
y := ver[i] // 获取当前邻接节点
dfs(y)      // 递归访问邻接节点
dp[x] = max(dp[y]+a[x], dp[x]) // 更新当前节点的食物总数
ans = max(ans, dp[x]) // 更新全局最大食物单位数
}
}

// 求最大值的辅助函数
func max(a, b int) int {
if a > b {
return a
}
return b
}

func main() {
fmt.Scan(&n) // 读取方格数量
root := 0    // 初始化根节点
for i := 0; i < n; i++ { // 读取每个方格的信息
var x, y int
fmt.Scan(&x, &y) // 读取方格 id 和 parent-id
fmt.Scan(&a[x])  // 读取方格的食物单位数
if y != -1 { // 如果 parent-id 不是 -1，添加边
add(y, x)
} else { // 否则记录根节点
root = x
}
}
dfs(root) // 从根节点开始 DFS
fmt.Println(ans) // 输出最大食物单位数
}

Js
const maxn = 10010; // 定义最大方格数量
let n; // 方格数量
const a = new Array(maxn).fill(0); // 存储每个方格的食物单位数
const dp = new Array(maxn).fill(0); // 存储从每个方格出发可获得的最多食物单位数
const head = new Array(maxn).fill(0); // 邻接表的头指针
const ver = new Array(maxn << 1).fill(0); // 存储邻接节点
const Next = new Array(maxn << 1).fill(0); // 存储链式存储的下一条边
let tot = 1; // 边的计数
let ans = -1000000000; // 初始化答案为负无穷大

// 使用链式前向星存储图
function add(x, y) {
ver[tot] = y; // 将节点 y 添加到邻接表中
Next[tot] = head[x]; // 将当前节点 x 的头指针保存到 Next 数组中
head[x] = tot; // 更新节点 x 的头指针
tot++; // 增加边的计数
}

// 深度优先搜索
function dfs(x) {
dp[x] = a[x]; // 初始化当前节点的食物总数为其自身的食物单位数
let i = head[x]; // 从当前节点的头指针开始遍历
while (i !== 0) { // 只要 i 不为 0
const y = ver[i]; // 获取当前邻接节点
dfs(y); // 递归访问邻接节点
dp[x] = Math.max(dp[y] + a[x], dp[x]); // 更新当前节点的食物总数
ans = Math.max(ans, dp[x]); // 更新全局最大食物单位数
i = Next[i]; // 移动到下一个邻接节点
}
}

// 主程序
function main() {
const readline = require('readline'); // 引入 readline 模块
const rl = readline.createInterface({
input: process.stdin, // 设置输入流
output: process.stdout // 设置输出流
});

// 读取方格数量 n
rl.question('Enter the value of n: ', (value) => {
n = parseInt(value); // 将输入值转换为整数

let root = 0; // 初始化根节点
const inputArr = []; // 用于存储输入行
rl.prompt(); // 显示提示符
rl.on('line', (line) => { // 监听输入行
inputArr.push(line.trim()); // 去除行首尾空格并存入数组
if (inputArr.length === n) { // 如果输入行数达到 n
rl.close(); // 关闭输入流
}
}).on('close', () => { // 输入流关闭后的处理
// 处理输入的方格信息
for (let i = 0; i < n; i++) {
const inputLine = inputArr[i].split(' '); // 分割输入行
const x = parseInt(inputLine[0]); // 读取方格 id
const y = parseInt(inputLine[1]); // 读取 parent-id
a[x] = parseInt(inputLine[2]); // 读取方格的食物单位数
if (y !== -1) { // 如果 parent-id 不是 -1，添加边
add(y, x);
} else { // 否则记录根节点
root = x;
}
}
dfs(root); // 从根节点开始 DFS
console.log(ans); // 输出最大食物单位数
process.exit(0); // 退出进程
});
});
}

main(); // 调用主程序

---

### 第3题-MC方块（P2394）
- 链接：https://codefun2000.com/p/P2394

> 页面标题：#P2394. 第3题-MC方块

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

MC最新版本更新了一种特殊的方块，幽匿催发体。这种方块能够吸收生物死亡掉落的经验并感染周围方块，使其变成幽匿块。Steve想要以此为基础尝试搭建一个经验仓库，他来到了创造超平坦模式，在只有草方块组成的平坦世界上进行他的实验。
在Steve的实验中，幽匿催发体可以看做每次吸收经验后会向自己平面方向上的周围八个方块进行感染，使其变成幽匿催发体。Steve任意选择了 n 个坐标点作为幽匿催发体的起始方块，接下来每天都会给予这些催发体足够使自身范围向外扩展一圈的经验。当有两个或以上的幽匿催发体的感染范围重叠时，重叠区域的方块会吸收更多的经验，吸收经验的数量为该方块所在不同幽匿催发体感染范围数量的整数倍。
如下方三张图所示，蓝色点A、B为初始幽匿催发体的位置

第二天，向周围扩散感染

第三天，两个催发体的感染范围出现重叠，重叠部分的经验倍数 M 为2，其余则为1，以此类推。

Steve想要知道多少天以后，会出现至少有一个方块的经验存储量的倍数可以达到给定的 M ？
输入描述
第一行输入整数 M。(2c= M <= n)
第二行输入幽匿催发体个数 n。 (2<= n <= 50)
后面连续 n 行输入第 i 个幽匿催发体 i 的初始位置 [xi, yi]。 (1<= xi，yi<= 10^9)
输出描述
输出找到一个方块至少同时处在 M 个幽匿催发体的感染范围的最少天数，找不到返回 0
样例
样例1
输入
2
2
2 1
6 2

输出
2

说明
说明: 在第2天，点(4.0)、(4.1)、 (4.2)与(4,3)将同时处在两个幽匿催发体发感染范围，如图红色点所示。
样例2
输入
2
3
2 1
6 2
100 100

输出
2

#### TextSol

题目大意
在Minecraft的最新版本中，增加了一种特殊的方块——幽匿催发体。该方块能够吸收生物死亡掉落的经验，并感染周围的方块。Steve决定利用这种方块建立一个经验仓库。幽匿催发体每天会扩展其感染范围，吸收周围方块的经验。如果两个或多个幽匿催发体的感染范围重叠，重叠区域的方块将吸收更多的经验。Steve希望知道多少天后，会有至少一个方块的经验存储量达到给定的倍数M。
思路：二分答案+二维差分
1.二分答案：
该问题的答案是关于天数的，随着天数的增加，幽匿催发体的感染范围会增加，重叠的区域也会增加。因此，天数与结果之间存在单调性，即天数越久，达到条件的可能性越大。
2.检查函数：
由于平面太大，无法直接模拟，所以使用二维差分数组来表示幽匿催发体的感染范围。通过离散化处理关键点，降低计算复杂度。
思路步骤
1.输入处理：
读取幽匿催发体的数量和每个幽匿催发体的初始坐标。
2.差分数组构建：
对每个幽匿催发体的位置，更新差分数组，标记感染的区域。
3.离散化：
将每个幽匿催发体的感染范围的坐标进行离散化，方便在一个小范围内进行计算。
4.前缀和计算：
在差分数组上进行前缀和操作，以获得每个点被多少个幽匿催发体感染的数量。
5.计算结果：
根据前缀和的结果计算出重叠区域的数量，判断是否达到给定的 M 倍数。
6.二分查找：
通过二分查找的方法确定达到条件所需的最小天数。
7.输出结果：
输出最终计算的结果，若无法达到，则返回 0。
代码说明
代码
C++
#include<bits/stdc++.h>
using namespace std;

const int N = 55; // 定义最大幽匿催发体数量
typedef pair<int, int> PII; // 定义坐标对的类型
#define x first
#define y second

vector<PII> w; // 存储幽匿催发体的坐标
int n, m; // n 为幽匿催发体数量，m 为目标倍数

// 检查给定天数 mid 是否能达到目标 M
int check(vector<PII>& ps, int mid) {
// 1. 统计所有左下和右上坐标
vector<long long> xs, ys; // 存储坐标的向量
for (auto &p : ps) {
auto i = p.x; // 获取幽匿催发体的 x 坐标
auto j = p.y; // 获取幽匿催发体的 y 坐标
xs.push_back(i - mid); // 左下角
xs.push_back(i + mid); // 右上角
ys.push_back(j - mid); // 左下角
ys.push_back(j + mid); // 右上角
}

// 2. 排序去重
sort(xs.begin(), xs.end()); // 对 x 坐标排序
xs.erase(unique(xs.begin(), xs.end()), xs.end()); // 去重
sort(ys.begin(), ys.end()); // 对 y 坐标排序
ys.erase(unique(ys.begin(), ys.end()), ys.end()); // 去重

// 3. 二维差分
int n = xs.size(), m = ys.size(); // 获取去重后的坐标数量
int diff[n + 2][m + 2]; // 初始化差分数组
memset(diff, 0, sizeof(diff)); // 将差分数组初始化为 0

for (auto &p : ps) {
auto i = p.x; // 获取幽匿催发体的 x 坐标
auto j = p.y; // 获取幽匿催发体的 y 坐标

// 找到影响区域的边界
int r1 = lower_bound(xs.begin(), xs.end(), i - mid) - xs.begin(); // 左边界
int r2 = lower_bound(xs.begin(), xs.end(), i + mid) - xs.begin(); // 右边界
int c1 = lower_bound(ys.begin(), ys.end(), j - mid) - ys.begin(); // 下边界
int c2 = lower_bound(ys.begin(), ys.end(), j + mid) - ys.begin(); // 上边界

// 将区域 r1<=r<=r2 && c1<=c<=c2 上的数都加上 1
// 多 +1 是为了方便求后面复原
++diff[r1 + 1][c1 + 1]; // 增加影响
--diff[r1 + 1][c2 + 2]; // 减少影响
--diff[r2 + 2][c1 + 1]; // 减少影响
++diff[r2 + 2][c2 + 2]; // 恢复影响
}

// 4. 直接在 diff 上复原，计算最大值
int ans = 0; // 初始化最大重叠数量
for (int i = 1; i <= n; ++i) {
for (int j = 1; j <= m; ++j) {
// 计算当前点的实际重叠数量
diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
ans = max(ans, diff[i][j]); // 更新最大值
}
}
return ans; // 返回最大重叠数量
}

int main() {
cin >> m >> n; // 读取目标 M 和幽匿催发体数量
for (int i = 0; i < n; i++) {
int x, y;
cin >> x >> y; // 读取每个幽匿催发体的坐标
w.push_back({x, y}); // 存储坐标
}

int l = 0, r = 1e9; // 二分查找的边界
while (l < r) {
int mid = (l + r) >> 1; // 计算中间值
if (check(w, mid) >= m) { // 检查是否能达到目标 M
r = mid; // 更新右边界
} else {
l = mid + 1; // 更新左边界
}
}

cout << l << endl; // 输出结果
return 0; // 程序结束
}

python
M = int(input())  # 读取目标倍数 M
n = int(input())  # 读取幽匿催发体的数量 n
c = []  # 存储幽匿催发体的坐标
for i in range(n):
x, y = map(int, input().split())  # 读取每个幽匿催发体的坐标
c.append((x, y))  # 将坐标添加到列表中

def check(day):
xs = set()  # 用于存储 x 坐标的集合
ys = set()  # 用于存储 y 坐标的集合
# 1. 统计所有左下和右上坐标
for x, y in c:
xs.add(x - day)  # 计算幽匿催发体左下角的 x 坐标
xs.add(x + day)  # 计算幽匿催发体右上角的 x 坐标
ys.add(y - day)  # 计算幽匿催发体左下角的 y 坐标
ys.add(y + day)  # 计算幽匿催发体右上角的 y 坐标
# 2. 排序去重
xs = sorted(xs)  # 对 x 坐标排序
ys = sorted(ys)  # 对 y 坐标排序
xs_idx = {x: i + 1 for i, x in enumerate(xs)}  # 为 x 坐标建立索引映射
ys_idx = {x: i + 1 for i, x in enumerate(ys)}  # 为 y 坐标建立索引映射

# 二维差分
diff = [[0] * (len(ys) + 2) for _ in range(len(xs) + 2)]  # 初始化差分数组
for x, y in c:
# 获取当前幽匿催发体影响的区域
x_idx = xs_idx[x - day]  # 获取左下角的 x 坐标索引
x_idx_ = xs_idx[x + day] + 1  # 获取右上角的 x 坐标索引
y_idx = ys_idx[y - day]  # 获取左下角的 y 坐标索引
y_idx_ = ys_idx[y + day] + 1  # 获取右上角的 y 坐标索引

# 更新差分数组
diff[x_idx][y_idx] += 1  # 在当前区域增加影响
diff[x_idx_][y_idx] -= 1  # 在右上角区域减少影响
diff[x_idx][y_idx_] -= 1  # 在右下角区域减少影响
diff[x_idx_][y_idx_] += 1  # 在左上角区域恢复影响

ans = 0  # 初始化最大重叠数量
# 4. 直接在 diff 上复原，计算最大值
for i in range(1, len(xs) + 1):
for j in range(1, len(ys) + 1):
# 计算当前点的实际重叠数量
diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1]
ans = max(ans, diff[i][j])  # 更新最大重叠数量
return ans  # 返回最大重叠数量

# 获取幽匿催发体坐标的最大值和最小值
max_x = max(c)[0]  # 获取 x 坐标的最大值
min_x = min(c)[0]  # 获取 x 坐标的最小值
max_y = max(c, key=lambda x: x[1])[1]  # 获取 y 坐标的最大值
min_y = min(c, key=lambda x: x[1])[1]  # 获取 y 坐标的最小值

l = 0  # 二分查找的左边界
r = max(max_x - min_x, max_y - min_y) // 2 + 2  # 二分查找的右边界

# 二分查找
while l < r:
mid = (l + r) // 2  # 计算中间值
tmp = check(mid)  # 检查当前天数的重叠数量
if tmp == M:  # 如果当前重叠数量正好等于 M
r = mid  # 更新右边界
elif tmp < M:  # 如果当前重叠数量小于 M
l = mid + 1  # 更新左边界
else:  # 如果当前重叠数量大于 M
r = mid  # 更新右边界

print(r)  # 输出结果

Java
超时
import java.util.*;

public class Main {
// LCP 74. 最强祝福力场
public static void main(String[] args) {
Scanner scan = new Scanner(System.in); // 创建扫描器以读取输入
int m = scan.nextInt(), n = scan.nextInt(); // 读取所需的点数 m 和点的数量 n
int[][] points = new int[n][2]; // 创建二维数组存储点的坐标
for (int i = 0; i < n; i++) {
points[i] = new int[]{scan.nextInt(), scan.nextInt()}; // 读取每个点的坐标
}

int l = 0, r = (int) 1e9 + 5, ans = -1; // 初始化二分查找的左右边界和结果
while (l < r) { // 二分查找
int mid = l + r >> 1; // 计算中间值
if (check(points, mid, m)) ans = r = mid; // 如果可以找到至少 m 个重叠的点，更新右边界和结果
else l = mid + 1; // 否则更新左边界
}
// 输出结果，若 ans 为 -1 则输出 0，否则输出 ans
System.out.println(ans == -1 ? 0 : ans);
}

// 检查当前的 mid 是否能满足至少 m 个点的重叠
public static boolean check(int[][] points, int mid, int m) {
int n = points.length; // 获取点的数量
List<int[]> overlaps = new ArrayList<>(); // 存储重叠区域的坐标
// 最大强度必是每个正方形的交点
for (int i = 0; i < n; i++) {
for (int j = i + 1; j < n; j++) {
// 如果两个点的距离大于 2 * mid，则不考虑这两个点
if (Math.max(Math.abs(points[i][0] - points[j][0]), Math.abs(points[i][1] - points[j][1])) > 2 * mid) continue;

// 点 i 左上角坐标
int lx1 = points[i][0] - mid, ly1 = points[i][1] - mid;
// 点 i 右下角坐标
int rx1 = points[i][0] + mid, ry1 = points[i][1] + mid;
// 点 j 左上角坐标
int lx2 = points[j][0] - mid, ly2 = points[j][1] - mid;
// 点 j 右下角坐标
int rx2 = points[j][0] + mid, ry2 = points[j][1] + mid;

// 重叠部分左上角坐标
int ox1 = Math.max(lx1, lx2), oy1 = Math.max(ly1, ly2);
// 重叠部分右下角坐标
int ox2 = Math.min(rx1, rx2), oy2 = Math.min(ry1, ry2);

// 将重叠区域的四个角添加到 overlaps 列表中
overlaps.add(new int[]{ox1, oy1});
overlaps.add(new int[]{ox1, oy2});
overlaps.add(new int[]{ox2, oy1});
overlaps.add(new int[]{ox2, oy2});
}
}
// 遍历每个重叠区域，计算覆盖这些区域的点的数量
for (int[] overlap : overlaps) {
int cnt = 0; // 当前重叠区域覆盖的点数
for (int[] point : points) {
// 如果点在当前重叠区域内，则计数
if (Math.max(Math.abs(overlap[0] - point[0]), Math.abs(overlap[1] - point[1])) <= mid) cnt++;
}
// 如果覆盖的点数达到 m，则返回 true
if (cnt >= m) return true;
}
return false; // 否则返回 false
}
}

Go
package main

import (
"fmt"
)

var M, n int            // M 为目标感染倍数，n 为幽匿催发体数量
var goast [][]int       // 存储幽匿催发体的坐标

// 定义一个点的结构体
type point struct {
x, y int // x 和 y 坐标
}

func main() {
fmt.Scan(&M, &n) // 读取目标倍数 M 和幽匿催发体数量 n
var x, y int
for i := 0; i < n; i++ {
fmt.Scan(&x, &y) // 读取每个幽匿催发体的坐标
goast = append(goast, []int{x, y}) // 将坐标添加到列表中
}

// 二分查找
l := 0                   // 左边界
r := int(1e9)           // 右边界
res := -1                // 存储结果，初始化为 -1
for l < r {
mid := (l + r) / 2 // 计算中间值
if check(mid) {     // 检查当前的 mid 是否可以达到目标 M
res = mid      // 更新结果为当前 mid
r = mid       // 更新右边界
} else {
l = mid + 1   // 更新左边界
}
}
if res == -1 {
fmt.Println(0) // 如果没有找到合适的结果，则输出 0
} else {
fmt.Println(res) // 输出找到的最小天数
}
}

// 检查当前的 mid 是否能满足至少 M 个幽匿催发体的重叠
func check(mid int) bool {
overlap := map[int]point{} // 存储重叠区域的坐标
for i := 0; i < n; i++ {
for j := i + 1; j < n; j++ {
// 如果两个幽匿催发体的距离大于 2 * mid，则跳过
if max(abs(goast[i][0]-goast[j][0]), abs(goast[i][1]-goast[j][1])) > 2*mid {
continue
}
// 计算幽匿催发体的影响区域
smallxi := goast[i][0] - mid
bigxi := goast[i][0] + mid
smallyi := goast[i][1] - mid
bigyi := goast[i][1] + mid
smallxj := goast[j][0] - mid
bigxj := goast[j][0] + mid
smallyj := goast[j][1] - mid
bigyj := goast[j][1] + mid

// 计算重叠区域的坐标
smallx := max(smallxi, smallxj)
bigx := min(bigxi, bigxj)
smally := max(smallyi, smallyj)
bigy := min(bigyi, bigyj)

// 将重叠区域的四个角添加到 overlap 映射中
var node point
node.x, node.y = smallx, smally
overlap[smallx*10+smally] = node
node.x, node.y = smallx, bigy
overlap[smallx*10+bigy] = node
node.x, node.y = bigx, smally
overlap[bigx*10+smally] = node
node.x, node.y = bigx, bigy
overlap[bigx*10+bigy] = node
}
}

// 遍历重叠区域，计算覆盖这些区域的幽匿催发体数量
for _, node := range overlap {
mcnt := 0 // 当前重叠区域覆盖的幽匿催发体数量
x := node.x
y := node.y
for i := 0; i < n; i++ {
// 如果点在当前重叠区域内，则计数
if max(abs(x-goast[i][0]), abs(y-goast[i][1])) <= mid {
mcnt += 1
if mcnt >= M { // 如果覆盖的幽匿催发体数量达到 M
return true // 满足条件，返回 true
}
}
}
}
return false // 否则返回 false
}

// 辅助函数：获取两个数中的最大值
func max(x, y int) int {
if x > y {
return x
}
return y
}

// 辅助函数：获取两个数中的最小值
func min(x, y int) int {
if x < y {
return x
}
return y
}

// 辅助函数：获取一个数的绝对值
func abs(x int) int {
if x < 0 {
return -x
}
return x
}

Js
let w = []; // 存储幽匿催发体的坐标

function check(ps, mid) {
// 1. 统计所有左下和右上坐标
let xs = [], ys = [];
for (let i = 0; i < ps.length; i++) {
let p = ps[i];
let j = p[0], k = p[1]; // 获取幽匿催发体的坐标
xs.push(j - mid); // 记录左下角坐标
xs.push(j + mid); // 记录右上角坐标
ys.push(k - mid); // 记录左下角坐标
ys.push(k + mid); // 记录右上角坐标
}

// 2. 排序去重
xs = [...new Set(xs)].sort((a, b) => a - b); // 对 x 坐标进行去重和排序
ys = [...new Set(ys)].sort((a, b) => a - b); // 对 y 坐标进行去重和排序

// 3. 二维差分
let n = xs.length, m = ys.length; // 获取去重后坐标的长度
let diff = Array.from(Array(n + 2), () => new Array(m + 2).fill(0)); // 初始化差分数组
for (let i = 0; i < ps.length; i++) {
let p = ps[i];
let j = p[0], k = p[1]; // 获取幽匿催发体的坐标
// 查找当前坐标在去重数组中的位置
let r1 = binarySearch(xs, j - mid);
let r2 = binarySearch(xs, j + mid);
let c1 = binarySearch(ys, k - mid);
let c2 = binarySearch(ys, k + mid);
// 将区域 r1<=r<=r2 && c1<=c<=c2 上的数都加上 1
// 多 +1 是为了方便后续的复原
diff[r1 + 1][c1 + 1]++;
diff[r1 + 1][c2 + 2]--;
diff[r2 + 2][c1 + 1]--;
diff[r2 + 2][c2 + 2]++;
}

// 4. 直接在 diff 上复原，计算最大值
let ans = 0; // 存储最大重叠数量
for (let i = 1; i <= n; i++) {
for (let j = 1; j <= m; j++) {
// 复原差分数组，计算当前坐标的重叠数量
diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
ans = Math.max(ans, diff[i][j]); // 更新最大重叠数量
}
}
return ans; // 返回最大重叠数量
}

// 二分查找函数，查找目标值在数组中的位置
function binarySearch(arr, target) {
let l = 0, r = arr.length - 1; // 初始化左右边界
while (l < r) {
let mid = Math.floor((l + r) / 2); // 计算中间值
if (arr[mid] >= target) { // 如果中间值大于等于目标值
r = mid; // 更新右边界
} else {
l = mid + 1; // 更新左边界
}
}
return l; // 返回目标值的位置
}

process.stdin.resume();
process.stdin.setEncoding('utf-8');
let input = '';
process.stdin.on('data', (data) => {
input += data; // 读取输入
return;
});
process.stdin.on('end', () => {
const lines = input.trim().split('\n'); // 按行分割输入
let m = Number(lines[0].trim()); // 读取目标倍数 M
let n = Number(lines[1].trim()); // 读取幽匿催发体数量 n
for (let i = 0; i < n; i++) {
let [x, y] = lines[i + 2].trim().split(' ').map(Number); // 读取每个幽匿催发体的坐标
w.push([x, y]); // 将坐标添加到列表中
}
let l = 0, r = 1e9; // 初始化二分查找的左右边界
while (l < r) {
let mid = Math.floor((l + r) / 2); // 计算中间值
if (check(w, mid) >= m) { // 检查是否可以满足条件
r = mid; // 更新右边界
} else {
l = mid + 1; // 更新左边界
}
}
console.log(l); // 输出结果
});

---

### 第3题-黄金之城寻宝（P2391）
- 链接：https://codefun2000.com/p/P2391

> 页面标题：#P2391. 第3题-黄金之城寻宝

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一名勇敢的冒险家，他一直梦想着找到传说中的黄金之城。他听说在一个遥远的沙漠中，有一个隐藏着无数宝藏的迷宫，只有最聪明和最勇敢的人才能进入并找到出路。小明决定去挑战这个迷宫，他带着一张地图和一些装备，踏上了寻宝之旅。
但是，这个迷宫并不是那么容易通过的，它充满了各种危险和难题。除了一些隐藏在地面上的陷阱之外，还有一些时隐时现的墙壁，它们会随机地出现和消失，阻挡小明的前进。小明必须小心地观察墙壁的状态循环，绕过陷阱和墙壁，或者等待合适的时机通过。这是个 n×nn\times nn×n 大小的迷宫，迷宫中存在着 kkk 个陷阱，并且每个位置都存在着一个墙壁的状态循环，状态循环以 333 个单位时间作为一个循环， 000 表示没有墙壁， 111 表示有墙壁。
小明在每个单位时间可以向上、下、左、右某个方向移动一个地图单位,当然也可以选择原地踏步。
限制:如果小明移动方向上有陷阱，或者小明移动目的地在下一个单位时间出现墙壁，则不可以朝该方向移动，同时，如果小明当前位置在下一个单位时间会出现墙壁，那小明也不可以选择停在原地。
我们需要计算出小明找到宝藏的最短时间。注意，小明可能并到不了目的地哦，这种情况输出-1
输入描述
输入第一行为一个整数 nnn ，表示迷宫的大小。（ 2<=n<=1002<= n <= 1002<=n<=100 )
输入第二行为一个整数 kkk ，表示迷宫中陷阱的数量。（ 0<k<=n×n−20<k <= n\times n-20<k<=n×n−2 ）
接下来输入一行 2×k2\times k2×k 个整数,具体为 row1 col1 row2 col2 ... rowk colkrow_1\ col_1\ row_2\ col_2\ ...\ row_k\ col_krow1​ col1​ row2​ col2​ ... rowk​ colk​ ，表示位置( rowirow_irowi​ , colicol_icoli​ )存在一个陷阱。
接下来一行为两对整数（ row1row1row1 , col1col1col1 ) 和 ( row2row2row2 , col2col2col2 )，表示宝藏的位置和小明的起始位置。
然后接下来 nnn 行: 每行 nnn 个字符串空格分开，每个字符串长度固定为 333 ，内容固定只有 000 和 111 ，表示每个位置的墙壁的状态循环。
注意 ：地图左上角为(0,0)，输入保证所有位置合法
输出描述
输出一个整数，表示小明找到宝藏的最短时间。
样例
样例一
输入
3
2
1 0 1 2
2 1 2 0
100 100 100
100 000 100
000 000 001

输出
1

样例解释
小明最快的移动顺序： [2,0] ->[2,1]
样例二
输入
3
2
1 0 2 0
0 1 2 2
000 000 001
010 101 101
110 010 000

输出
5

样例解释
小明最快的移动顺序： [2,2] ->[1,2] ->[2,2] ->[2,1] ->[1,1] ->[0,1]

#### TextSol

题面描述
塔子哥是一名勇敢的冒险家，他梦想找到传说中的黄金之城。在一个充满陷阱和随机出现墙壁的 n∗nn * nn∗n 大小的迷宫中，他需要巧妙地避开这些障碍，才能找到宝藏。迷宫中有 kkk 个陷阱，每个位置的墙壁状态以 333 个单位时间循环变化，塔子哥每个单位时间可以选择移动或原地不动，但不能停在有墙壁或陷阱的位置。我们需要计算他找到宝藏的最短时间，如果无法到达宝藏，则输出 -1。
题解
塔子哥的迷宫挑战可以用广度优先搜索（BFS）来解决，但与普通的最短路径问题不同，本题涉及到一个状态维度，即墙壁的状态在时间上是周期性变化的。每个位置在每个时间单位可能会有不同的墙壁状态，因此我们需要使用三维数组来表示距离。
我们定义一个三维数组 dist[i][j][k]，表示到达坐标 (i, j) 且状态为 k 的最短时间。状态 k 的取值为 0, 1, 2，对应于时间的三个状态循环。每次移动时，塔子哥可以选择向四个方向移动，或选择原地不动，这种情况下，状态会随时间变化。
在判断能否移动到某个位置时，我们不仅要检查该位置是否有陷阱，还要检查目标位置在下一时间单位的墙壁状态，以确保塔子哥能够顺利通过。
代码分析
这段代码实现了在一个迷宫中寻找从起始位置到目标位置的最短路径，考虑了陷阱和周期性变化的墙壁状态。以下是关键点：
1. 数据结构

dist[N][N][3]: 三维数组，用于存储到达 (i, j) 位置且状态为 k 的最短时间。
g[N][N]: 标记陷阱的位置。
state[N][N]: 存储每个位置的墙壁状态（字符串形式）。

2. BFS 函数

初始化: 将 dist 数组设为无穷大，起始位置的距离设为 0，并将其加入队列。
主循环:

从队列中取出节点，检查是否到达目标位置。
遍历五个移动方向，计算新位置和时间。
检查是否越界、是否有陷阱以及墙壁状态。

更新最短距离: 如果新位置可达且更新了最短路径，则记录并将新状态加入队列。

C++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 1010;  // 定义最大迷宫大小
int dx[5] = {-1, 1, 0, 0, 0};  // 方向数组，表示上下左右和原地不动
int dy[5] = {0, 0, 1, -1, 0};
int dist[N][N][3];  // 三维数组，存储到达 (x, y) 状态为 z 的最小距离
bool g[N][N];  // 标记陷阱的位置
string state[N][N];  // 存储每个位置的墙壁状态
int n, k, sx, sy, ex, ey;  // n 为迷宫大小，k 为陷阱数量，sx, sy 为起始位置，ex, ey 为目标位置

struct node {
int x, y, time;  // 定义节点结构，包含坐标和当前时间
};

// BFS 函数实现
int bfs() {
memset(dist, 0x3f, sizeof dist);  // 初始化距离数组为无穷大
dist[sx][sy][0] = 0;  // 起始位置的时间状态为 0 的距离为 0
queue<node> q;  // 定义队列用于 BFS
q.push({sx, sy, 0});  // 将起始位置加入队列

while (!q.empty()) {  // 当队列不为空时
auto t = q.front();  // 获取队头元素
q.pop();  // 弹出队头元素

// 如果到达目标位置，返回当前时间
if (t.x == ex && t.y == ey) return t.time;

int x = t.x, y = t.y, time = t.time;  // 当前位置和时间
for (int i = 0; i < 5; i++) {  // 遍历所有可能的移动方向
int a = dx[i] + x, b = dy[i] + y;  // 计算目标位置
int next_time = time + 1;  // 增加时间

// 检查目标位置是否越界，是否有陷阱，或者是否有墙壁
if (a < 0 || a >= n || b < 0 || b >= n || g[a][b] || state[a][b][next_time % 3] == '1')
continue;  // 不满足条件则跳过

// 更新最短距离
if (dist[a][b][next_time % 3] > dist[x][y][time % 3] + 1) {
dist[a][b][next_time % 3] = dist[x][y][time % 3] + 1;  // 更新距离
q.push({a, b, next_time});  // 将新状态加入队列
}
}
}
return -1;  // 如果无法到达目标位置，返回 -1
}

int main() {
cin >> n >> k;  // 读取迷宫大小和陷阱数量
for (int i = 0; i < k; i++) {
int a, b;
cin >> a >> b;  // 读取陷阱位置
g[a][b] = true;  // 标记陷阱
}

cin >> ex >> ey >> sx >> sy;  // 读取起始和目标位置
for (int i = 0; i < n; i++) {
for (int j = 0; j < n; j++) {
cin >> state[i][j];  // 读取每个位置的墙壁状态
}
}

cout << bfs() << endl;  // 调用 BFS 函数并输出结果
return 0;
}

Java
import java.util.*;

// 定义节点类，包含坐标和当前时间
class Node {
int x, y, time;  // x 和 y 为坐标，time 为当前时间

// 构造函数
Node(int x, int y, int time) {
this.x = x;  // 初始化坐标 x
this.y = y;  // 初始化坐标 y
this.time = time;  // 初始化时间
}
}

public class Main {
static final int N = 1010;  // 定义最大迷宫大小
// 定义移动方向：上、下、右、左、原地不动
static int[] dx = {-1, 1, 0, 0, 0}, dy = {0, 0, 1, -1, 0};
static int[][][] dist = new int[N][N][3];  // 三维数组，存储最短路径
static boolean[][] g = new boolean[N][N];  // 标记陷阱位置
static String[][] state = new String[N][N];  // 存储每个位置的墙壁状态
static int n, k, sx, sy, ex, ey;  // n 为迷宫大小，k 为陷阱数量，sx, sy 为起始位置，ex, ey 为目标位置

// BFS 函数实现
static int bfs() {
// 初始化距离数组为最大值
for (int[][] row : dist) {
for (int[] col : row) {
Arrays.fill(col, Integer.MAX_VALUE);
}
}
// 起始位置的状态距离设为 0
dist[sx][sy][0] = 0;
Queue<Node> queue = new LinkedList<>();  // 定义队列用于 BFS
queue.offer(new Node(sx, sy, 0));  // 将起始位置加入队列

// BFS 主循环
while (!queue.isEmpty()) {
Node t = queue.poll();  // 从队列中取出一个节点
// 如果到达目标位置，返回当前时间
if (t.x == ex && t.y == ey) return t.time;

int x = t.x, y = t.y, time = t.time;  // 获取当前节点的坐标和时间
// 遍历所有可能的移动方向
for (int i = 0; i < 5; i++) {
int a = dx[i] + x, b = dy[i] + y, next_time = time + 1;  // 计算新位置和下一时间
// 检查新位置是否越界、是否有陷阱或墙壁
if (a < 0 || a >= n || b < 0 || b >= n || g[a][b] || state[a][b].charAt(next_time % 3) == '1') continue;

// 更新最短距离
if (dist[a][b][next_time % 3] > dist[x][y][time % 3] + 1) {
dist[a][b][next_time % 3] = dist[x][y][time % 3] + 1;  // 记录新位置的最短路径
queue.offer(new Node(a, b, next_time));  // 将新状态加入队列
}
}
}
return -1;  // 如果无法到达目标位置，返回 -1
}

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);  // 创建 Scanner 对象读取输入
n = sc.nextInt();  // 读取迷宫的大小
k = sc.nextInt();  // 读取陷阱的数量
// 读取陷阱的位置并标记
for (int i = 0; i < k; i++) {
int a = sc.nextInt(), b = sc.nextInt();
g[a][b] = true;  // 标记陷阱
}
// 读取目标位置和起始位置
ex = sc.nextInt();
ey = sc.nextInt();
sx = sc.nextInt();
sy = sc.nextInt();
// 读取每个位置的墙壁状态
for (int i = 0; i < n; i++)
for (int j = 0; j < n; j++)
state[i][j] = sc.next();

// 调用 BFS 函数并输出结果
System.out.println(bfs());
}
}

Python3
from collections import deque  # 导入双端队列，用于 BFS
from sys import maxsize  # 导入最大整数值，用于初始化距离

N = 1010  # 定义最大迷宫大小
dx = [-1, 1, 0, 0, 0]  # 移动方向数组：上、下、右、左、原地不动
dy = [0, 0, 1, -1, 0]  # 移动方向数组
# 三维数组，dist[i][j][k] 表示到达 (i, j) 且状态为 k 的最短时间
dist = [[[maxsize]*3 for _ in range(N)] for _ in range(N)]
g = [[False]*N for _ in range(N)]  # 布尔数组，标记陷阱的位置
state = [['']*N for _ in range(N)]  # 二维数组，存储每个位置的墙壁状态
n, k, sx, sy, ex, ey = 0, 0, 0, 0, 0, 0  # 初始化迷宫大小、陷阱数量和坐标

def bfs():
# 初始化距离数组为最大值
for row in dist:
for col in row:
col[:] = [maxsize]*3
# 设置起始位置的状态距离为 0
dist[sx][sy][0] = 0
queue = deque([(sx, sy, 0)])  # 初始化队列，将起始位置加入队列
while queue:  # 当队列不为空时
x, y, time = queue.popleft()  # 弹出队头元素
# 如果到达目标位置，返回当前时间
if x == ex and y == ey:
return time
# 遍历所有可能的移动方向
for i in range(5):
# 计算新位置和下一个时间
a, b, next_time = dx[i] + x, dy[i] + y, time + 1
# 检查新位置是否越界、是否有陷阱或墙壁
if a < 0 or a >= n or b < 0 or b >= n or g[a][b] or state[a][b][next_time % 3] == '1':
continue
# 更新最短距离
if dist[a][b][next_time % 3] > dist[x][y][time % 3] + 1:
dist[a][b][next_time % 3] = dist[x][y][time % 3] + 1  # 记录新位置的最短路径
queue.append((a, b, next_time))  # 将新状态加入队列
return -1  # 如果无法到达目标位置，返回 -1

if __name__ == "__main__":
n = int(input())  # 读取迷宫的大小
k = int(input())  # 读取陷阱的数量
traps = list(map(int, input().split()))  # 读取陷阱的位置
# 标记陷阱的位置
for i in range(0, len(traps), 2):
g[traps[i]][traps[i+1]] = True
# 读取目标位置和起始位置
ex, ey, sx, sy = map(int, input().split())
# 读取每个位置的墙壁状态
for i in range(n):
state[i] = list(input().split())
# 调用 BFS 函数并输出结果
print(bfs())

javascript
const readline = require("readline");

// 创建标准输入读取接口
const rl = readline.createInterface({ input: process.stdin });
var iter = rl[Symbol.asyncIterator]();
const readLine = async () => (await iter.next()).value;

// 方向数组：上、下、右、左、原地不动
const dx = [-1, 1, 0, 0, 0];
const dy = [0, 0, 1, -1, 0];

// 迷宫最大尺寸
const N = 110; // 由于 n <= 100，所以 N 设为 110 足够
let dist, g, state;
let n, k, sx, sy, ex, ey;

async function bfs() {
// 初始化 dist 数组为无穷大
dist = Array.from({ length: n }, () => Array.from({ length: n }, () => Array(3).fill(Infinity)));

// 起点距离设为 0
dist[sx][sy][0] = 0;
let queue = [];
queue.push({ x: sx, y: sy, time: 0 });

while (queue.length > 0) {
let { x, y, time } = queue.shift();

// 如果到达目标位置，返回最短时间
if (x === ex && y === ey) return time;

// 遍历五个方向（包括原地不动）
for (let i = 0; i < 5; i++) {
let a = x + dx[i], b = y + dy[i], next_time = time + 1;

// 判断是否超出边界、是否是陷阱、是否撞墙
if (a < 0 || a >= n || b < 0 || b >= n || g[a][b] || state[a][b][next_time % 3] === '1') {
continue;
}

// 如果新状态比当前状态更优，则更新
if (dist[a][b][next_time % 3] > dist[x][y][time % 3] + 1) {
dist[a][b][next_time % 3] = dist[x][y][time % 3] + 1;
queue.push({ x: a, y: b, time: next_time });
}
}
}
return -1; // 无法到达终点
}

async function main() {
// 读取迷宫大小 n
n = parseInt(await readLine());

// 读取陷阱数量 k
k = parseInt(await readLine());

// 初始化数组
g = Array.from({ length: n }, () => Array(n).fill(false));
state = Array.from({ length: n }, () => Array(n).fill(""));

// 读取 k 组陷阱坐标
if (k > 0) {
let trapCoords = (await readLine()).split(" ").map(Number);
for (let i = 0; i < k; i++) {
let row = trapCoords[2 * i];
let col = trapCoords[2 * i + 1];
g[row][col] = true; // 标记陷阱位置
}
}

// 读取终点（宝藏）坐标 和 小明的起始位置
let [ex_, ey_, sx_, sy_] = (await readLine()).split(" ").map(Number);
ex = ex_, ey = ey_, sx = sx_, sy = sy_;

// 读取迷宫墙状态（n 行，每行 n 个 3 长度字符串）
for (let i = 0; i < n; i++) {
let row = (await readLine()).split(" ");
for (let j = 0; j < n; j++) {
state[i][j] = row[j]; // 存储墙壁的周期状态
}
}

// 计算最短时间并输出
console.log(await bfs());
rl.close();
}

// 执行主函数
main();

---

### 第3题-跑步（P2384）
- 链接：https://codefun2000.com/p/P2384

> 页面标题：#P2384. 第3题-跑步

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
塔子哥在一个 m×nm \times nm×n 的崎岖山地上进行跑步锻炼，场地的高度和减速值分别由二维数组 hhh 和 ooo 记录。塔子哥初始速度为 111，当他从高度为 h1h1h1 的位置移动到高度为 h2h2h2 的相邻位置时，速度变化为 h1−h2−o2h1 - h2 - o2h1−h2−o2，其中 o2o2o2 是目标位置的减速值。任务是计算塔子哥能够到达的速度仍为 111 的位置数量。输入包含场地的大小、塔子哥的初始位置、高度值数组和减速值数组，输出为速度为 111 的位置的个数。
思路
这是一道基于BFSBFSBFS的题目。主要考点为BFSBFSBFS。
这道题要我们找到所有速度为111的终点站的点的数量。那么我们需要知道所有终点站的速度，然后在这些速度中找到为111的点即可。

如何找到各个点的速度？

假设我们目前处于点uuu，上下左右四个邻点记为vvv，那么假设我们知道点uuu的速度，vvv的速度就可以按照题目公式计算得到。因此，这里就需要用到BFSBFSBFS，对我们目前处于的点uuu进行BFSBFSBFS，得到周围所有点速度。然后我们计算得到速度后，对于速度为111的点进行记录即可。

如何记录速度为1的点？

我们在BFSBFSBFS同时，一旦遇到点速度为111就需要判断该点对答案做不做贡献。一个点如果做贡献，那么说明在BFSBFSBFS过程中这个点第一次被判断为速度为111（即第二次和以后都不用记录贡献）。

如何处理BFSBFSBFS重复经过某点？

和传统BFSBFSBFS不一样，传统BFSBFSBFS的处理是利用mapmapmap存储(x,y)(x,y)(x,y)，只需要判断点(x,y)(x,y)(x,y)是否被经过（因为第一次到(x,y)(x,y)(x,y)和第二次到(x,y)(x,y)(x,y)并不影响(x,y)(x,y)(x,y)对于相邻点答案的影响），这道题假设我们判断又重复经过一个点(x,y)(x,y)(x,y)，但是具有不同的速度时，我们发现和传统BFSBFSBFS不一样，因为不同的速度会导致相邻点产生不一样的速度。因此这道题我们可以利用mapmapmap存储(x,y,v)(x,y,v)(x,y,v)，x,yx,yx,y为对应的位置，vvv是对应的速度，只要位置与速度都一样时，那么对相邻点的影响一定是一样的。

如何判断点对于答案做不做贡献?

我们利用上述的mapmapmap存储对应的(x,y,v)(x,y,v)(x,y,v)，一旦重复经过(x,y,z)(x,y,z)(x,y,z)，我们就跳过，这样就保证每一个(x,y,1)(x,y,1)(x,y,1)都只会被记录一次即可。

代码
C++
#include<bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int, int>;
using tp = tuple<int, int, int>; // 用于表示位置和速度的三元组
const int dirs[4][2] = { {1,0},{0,1},{-1,0},{0,-1} }; // 代表上下左右四个方向

int main() {
int ans = 0; // 记录速度为1的点的数量
char ch;
string s;

// 读取场地大小 m 和 n
cin >> s;
int m = 0, n = 0;
for (int i = 0; i < s.size() - 1; i++) {
if (s[i] >= '0' && s[i] <= '9') {
while (s[i] != ',') { // 读取 m
m = m * 10 + s[i] - '0';
++i;
}
while (i < s.size() - 1) // 读取 n
n = n * 10 + s[++i] - '0';
}
}

// 读取塔子哥的初始位置
int sx, sy;
cin >> sx >> ch >> sy;

// 初始化高度和减速值的二维数组
vector<vector<pii>> grid(m, vector<pii>(n)); // 每个元素存储高度和减速值
unordered_map<int, unordered_set<int>> mp; // 存储每个点的速度状态
vector<int> ss(m * n); // 临时存储高度和减速值

// 读取高度值
int idx = 0;
for (int i = 0; i < m * n; i++) {
cin >> ss[i];
if (i < m * n - 1)
ch = getchar(); // 处理输入中的空格
}

// 将高度值存入grid
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
grid[i][j].first = ss[idx++];
}
}

// 读取减速值
for (int i = 0; i < m * n; i++) {
cin >> ss[i];
if (i < m * n - 1)
ch = getchar(); // 处理输入中的空格
}

// 将减速值存入grid
idx = 0;
for (int i = 0; i < m; i++) {
for (int j = 0; j < n; j++) {
grid[i][j].second = ss[idx++];
}
}

// BFS初始化
queue<tp> q; // BFS队列
q.push(tp{ sx, sy, 1 }); // 将初始点加入队列，速度为1
mp[sx * n + sy].insert(1); // 记录初始点的速度

// BFS过程
while (!q.empty()) {
tp cur = q.front(); // 获取当前点
q.pop();

for (int i = 0; i < 4; i++) { // 遍历四个方向
int ni = get<0>(cur) + dirs[i][0]; // 新点的行坐标
int nj = get<1>(cur) + dirs[i][1]; // 新点的列坐标

// 检查新点是否越界
if (ni >= m || ni < 0 || nj >= n || nj < 0)
continue;

int h1 = grid[get<0>(cur)][get<1>(cur)].first; // 当前点的高度
int h2 = grid[ni][nj].first; // 新点的高度
int o2 = grid[ni][nj].second; // 新点的减速值

// 计算新点的速度
int tmp = get<2>(cur) + (h1 - h2 - o2);

// 若速度小于等于0或新点速度已记录，跳过
if (tmp <= 0 || mp[ni * n + nj].count(tmp))
continue;

// 如果新点速度为1，答案加1
if (tmp == 1)
++ans;

// 记录新点的速度
mp[ni * n + nj].insert(tmp);
// 将新点加入队列
q.push(tp{ ni, nj, tmp });
}
}

// 输出结果
std::cout << ans << endl;
return 0;
}

python
from collections import defaultdict
import queue

def solv():
dirs = [[0, 1], [1, 0], [0, -1], [-1, 0]]
q = queue.Queue()#开辟队列
visited = defaultdict(int)#开辟字典
q.put([start_x, start_y, 1])#队列put初始值
visited[(start_x, start_y, 1)] = 1#字典记录

cnt = 0
while not q.empty():
now = q.get()
x, y, v = now[0], now[1], now[2]
for dx, dy in dirs:
nx, ny = x + dx, y + dy
if nx < 0 or nx > m - 1 or ny < 0 or ny > n - 1:
continue#上述为队列经典操作
nv = v + (mat_h[x][y] - mat_h[nx][ny] - mat_o[nx][ny])#计算速度
if visited[(nx, ny, nv)] == 1 or nv < 1:#一旦发现(x,y,v)已经被记录或者v<=0时就跳过
continue
if nv == 1:#如果(x,y,1)第一次发生，答案就加1
cnt += 1
q.put([nx, ny, nv])#BFS经典操作
visited[(nx, ny, nv)] = 1#更新map，存储每一个(x,y,v)
print(cnt)

m, n = map(int, input().split(','))
start_x, start_y = map(int, input().split(','))
mat_h = [list(map(int, row.split(','))) for row in input().split(' ')]
mat_o = [list(map(int, row.split(','))) for row in input().split(' ')]
solv()
# by rivers (ps:有一定小修改)

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in);

String[] s = sc.nextLine().trim().split(",");
int n = Integer.parseInt(s[0]), m = Integer.parseInt(s[1]);
s = sc.nextLine().trim().split(",");
int sx = Integer.parseInt(s[0]), sy = Integer.parseInt(s[1]);
int[][] h = new int[n][m], o = new int[n][m];
s = sc.nextLine().trim().replace(" ", ",").split(",");
for (int i = 0, idx = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
h[i][j] = Integer.parseInt(s[idx++]);
}
}
s = sc.nextLine().trim().replace(" ", ",").split(",");
for (int i = 0, idx = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
o[i][j] = Integer.parseInt(s[idx++]);
}
}//输入

// 状态记录
Map<Integer, Set<Integer>> map = new HashMap<>();

for (int i = 0; i < n; i++) {
for (int j = 0; j < m; j++) {
map.put(i * m + j, new HashSet<>());//对于每一个点开辟一个set记录出现过的速度
}
}

Queue<int[]> q = new LinkedList<>();//开辟队列
map.get(sx * m + sy).add(1);
q.offer(new int[]{sx, sy, 1});//初始点入队列
int cnt = 0;
int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
while (!q.isEmpty()) {
int[] t = q.poll();
int x = t[0], y = t[1], v = t[2];
for (int i = 0; i < 4; i++) {
int a = x + dx[i], b = y + dy[i];
if (a < 0 || a >= n || b < 0 || b >= m) continue;//上面几句BFS经典操作
int nv = v + h[x][y] - h[a][b] - o[a][b];//求得速度
if (nv <= 0 || map.get(a * m + b).contains(nv)) continue;//一旦发现(x,y,v)已经被记录或者v<=0时就跳过

if (nv == 1) cnt++;//如果(x,y,1)第一次发生，答案就加1
map.get(a * m + b).add(nv);//更新map，存储每一个(x,y,v)
q.offer(new int[]{a, b, nv});//BFS经典操作
}
}
System.out.println(cnt);
}
}

Go
package main

import (
"bufio"
"fmt"
"os"
"strconv"
"strings"
)

var dirs = [4][2]int{{1, 0}, {0, 1}, {-1, 0}, {0, -1}}

func main() {
scanner := bufio.NewScanner(os.Stdin)
scanner.Scan()
s := scanner.Text()

m, n := 0, 0
for i := 0; i < len(s)-1; i++ {
if s[i] >= '0' && s[i] <= '9' {
for s[i] != ',' {
m = m*10 + int(s[i]-'0')
i++
}
for i < len(s)-1 {
n = n*10 + int(s[i+1]-'0')
i++
}
}
}

scanner.Scan()
s = scanner.Text()

sx, _ := strconv.Atoi(strings.Split(s, ",")[0])
sy, _ := strconv.Atoi(strings.Split(s, ",")[1])

grid := make([][][2]int, m)//记录输入数组
mp := make(map[int]map[int]bool)//开辟map

scanner.Scan()
s = scanner.Text()
nums := strings.Fields(s)
for i := 0; i < m; i++ {
for j := 0; j < n; j++ {
mp[i * n + j] = make(map[int]bool)
}
}
for i := 0; i < m; i++ {
grid[i] = make([][2]int, n)
nums2 := strings.Split(nums[i], ",")
for j := 0; j < n; j++ {
grid[i][j][0], _ = strconv.Atoi(nums2[j])
}
}
scanner.Scan()
s = scanner.Text()
nums3 := strings.Fields(s)
for i := 0; i < m; i++ {
nums4 := strings.Split(nums3[i], ",")
for j := 0; j < n; j++ {
grid[i][j][1], _ = strconv.Atoi(nums4[j])
}
}//输入

q := make([][3]int, 0)
q = append(q, [3]int{sx, sy, 1})//初始化队列
mp[sx*n+sy][1] = true//初始化map
ans := 0

for len(q) > 0 {
cur := q[0]
q = q[1:]

for i := 0; i < 4; i++ {
ni := cur[0] + dirs[i][0]
nj := cur[1] + dirs[i][1]

if ni >= m || ni < 0 || nj >= n || nj < 0 {
continue
}//BFS基本操作

h1 := grid[cur[0]][cur[1]][0]
h2 := grid[ni][nj][0]
o2 := grid[ni][nj][1]
tmp := cur[2] + (h1 - h2 - o2)//得到速度

if tmp <= 0 || mp[ni*n+nj][tmp] {//一旦发现(x,y,v)已经被记录或者v<=0时就跳过
continue
}

if tmp == 1 {//如果(x,y,1)第一次发生，答案就加1
ans++
}

mp[ni*n+nj][tmp] = true//更新map，存储每一个(x,y,v)
q = append(q, [3]int{ni, nj, tmp})//BFS经典操作
}
}

fmt.Println(ans)
}

Js
const readline = require('readline');

function main() {
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

let n, m;
let sx, sy;
let h, o;
let map = new Map();

rl.question('', (line) => {
const s = line.trim().split(',');
n = parseInt(s[0]);
m = parseInt(s[1]);

rl.question('', (line) => {
const s = line.trim().split(',');
sx = parseInt(s[0]);
sy = parseInt(s[1]);

h = new Array(n);
o = new Array(n);

rl.question('', (line) => {
const s = line.trim().replace(/ /g, ',').split(',');
let idx = 0;

for (let i = 0; i < n; i++) {
h[i] = new Array(m);
for (let j = 0; j < m; j++) {
h[i][j] = parseInt(s[idx++]);
}
}

rl.question('', (line) => {
const s = line.trim().replace(/ /g, ',').split(',');
idx = 0;

for (let i = 0; i < n; i++) {
o[i] = new Array(m);
for (let j = 0; j < m; j++) {
o[i][j] = parseInt(s[idx++]);
}
}

for (let i = 0; i < n; i++) {
for (let j = 0; j < m; j++) {
map.set(i * m + j, new Set());
}
}//输入开辟数组

let q = [];//队列
map.get(sx * m + sy).add(1);//map初始化
q.push([sx, sy, 1]);//队列初始化
let cnt = 0;
let dx = [-1, 0, 1, 0];
let dy = [0, 1, 0, -1];

while (q.length > 0) {
let t = q.shift();
let x = t[0];
let y = t[1];
let v = t[2];

for (let i = 0; i < 4; i++) {
let a = x + dx[i];
let b = y + dy[i];

if (a < 0 || a >= n || b < 0 || b >= m) {
continue;
}//BFS基本操作

let nv = v + h[x][y] - h[a][b] - o[a][b];//求得速度

if (nv <= 0 || map.get(a * m + b).has(nv)) {
continue;//一旦发现(x,y,v)已经被记录或者v<=0时就跳过
}

if (nv === 1) {
cnt++;//如果(x,y,1)第一次发生，答案就加1
}

map.get(a * m + b).add(nv);//更新map，存储每一个(x,y,v)
q.push([a, b, nv]);//BFS经典操作
}
}

console.log(cnt);
rl.close();
});
});
});
});
}

main();

题目描述
小明在一个 m∗nm*nm∗n 大小的崎岖山地上进行跑步锻炼。这个场地由一系列的上坡、下坡组成，场地各点位的高度值记录于二位数组 hhh 中，由相邻位置到达对应点位的减速值记录于二维数组 ooo中。
已知小明初始速度为 111 ，当他从高度为 h1h1h1 的位置跑到高度为 h2h2h2 、减速值为 o2o2o2 的相邻位置（可从上下左右四个方向）时，速度变化值为 h1−h2−o2h1 - h2 - o2h1−h2−o2 ( 大于 000 为加速 ，小于 000为减速)。速度不会为 000 或者负值。
请问小明到达哪些点位时速度依旧维持为 111 ？请你求出这些位置的个数是多少。
输入描述
输入第一行为场地大小 mmm,nnn（111 ≤\leq≤ m ≤\leq≤ 100100100 ,111 ≤\leq≤ nnn ≤\leq≤ 100100100）
输入第二行为选手初始位置
输入第三行为场地每个点位的高度值h[i][j]h[i] [j]h[i][j]，场地高度的范围为 [0,100][0,100][0,100]
输入第四行为每个点位的减速值o[i][j]o[i] [j]o[i][j]，减速值的范围在 [0,100][0,100][0,100]
输出描述：
输出速度为 111 的位置的个数
样例1
输入
2,2
1,1
5,0 0,6
0,6 7,0

输出
1

解释：
第一行为场地大小为 2∗22*22∗2；
第二行为小明的初始位置坐标；
第三行分别代表 h[0][0]=5;h[0][1]=0;h[1][0]=0;h[1][1]=6h[0][0] =5;h[0][1] = 0;h[1][0] = 0;h[1][1] =6h[0][0]=5;h[0][1]=0;h[1][0]=0;h[1][1]=6;
第四行分别代表 o[0][0]=0;o[0][1]=6;o[1][0]=7;o[1][1]=0o[0][0] = 0;o[0][1] = 6;o[1][0] =7;o[1][1] = 0o[0][0]=0;o[0][1]=6;o[1][0]=7;o[1][1]=0;
小明从坐标[111][111]的位置出发，此为位置高度为 666， 减速值为 000 。选手到达[000,111]处位置恰好为 111；速度的变化值为 000,初始速度为 111 ,即到达[000,111]处位置时，速度恰好为 111
样例2
输入
2,2
0,0
0,0 0,0
0,0 0,0

输出
3

解释：场地大小 2∗22*22∗2 ，选手从坐标 [000,000] 的位置出发，此位置高度为 000 ,减速值为 000 。选手到达[000,111],[111,000] , [111,111]三处位置时，速度恰好为111。

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (2)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 2, 86ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-网络升级改造（P2381）
- 链接：https://codefun2000.com/p/P2381

> 页面标题：#P2381. 第3题-网络升级改造

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

_（未抓到题面文本）_

#### TextSol

题面描述
在一个满二叉树结构的网络中，节点上标有年度维护成本的非负整数。给定节点的数量和其对应的成本值，要求通过撤销一些节点来最大化节省的维护成本，但不能同时撤销原本直接相邻的两个节点。需要根据输入的节点信息，输出能够节省的最大维护成本。
思路
这道题是洛谷P1352-没有上司的舞会一题的改版.具体做法是树形DPDPDP.
动态规划题目重点有两个:状态定义,状态转移.
状态定义
我们记dp[u][0/1]dp[u][0/1]dp[u][0/1]为当前以uuu为根节点的子树的最高维护成本,其中第二维度为0表示uuu根节点也被撤销,为1表示uuu根节点未被撤销.
状态转移
我们记arr[u]arr[u]arr[u]为uuu的权值,假设leftleftleft是uuu的左孩子,rightrightright是uuu的右孩子,那么当我们选择不撤销uuu时,leftleftleft和rightrightright必须被撤销.因此dp[u][1]=dp[left][0]+dp[right][0]+arr[u]dp[u][1] = dp[left][0]+dp[right][0]+arr[u]dp[u][1]=dp[left][0]+dp[right][0]+arr[u].
现在我们考虑如果uuu被撤销时该如何选择.
我们发现uuu被撤销后,leftleftleft和rightrightright都可以被撤销或者不被撤销.因此,按照贪心的思路,我们就判断leftleftleft和rightrightright被撤销和不被撤销的两种情况哪一个维护成本高.具体就是求max(dp[left][0],dp[left][1])max(dp[left][0],dp[left][1])max(dp[left][0],dp[left][1])和max(dp[right][0],dp[right][1])max(dp[right][0],dp[right][1])max(dp[right][0],dp[right][1]).因此最后的转移方程为$dp[u][1] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1])$
思路解析

状态定义：

我们定义 dp[u][0] 为以节点 u 为根的子树中，撤销节点 u 时所能获得的最大维护成本。
dp[u][1] 表示不撤销节点 u 时所能获得的最大维护成本。

状态转移：

对于一个节点 u，我们需要考虑它的左子节点 left 和右子节点 right。
不撤销节点 u：如果我们选择不撤销 u，那么 left 和 right 必须被撤销，因此：
[
dp[u][1] = dp[left][0] + dp[right][0]
]
撤销节点 u：如果我们选择撤销 u，那么 left 和 right 可以被撤销也可以不撤销。我们需要选择使得维护成本最大的方案：
[
dp[u][0] = arr[u] + dp[left][0] + dp[right][0]
]
其中 ( arr[u] ) 是节点 u 的维护成本。

递归遍历：

使用深度优先搜索（DFS）来遍历每个节点，计算其状态并填充 dp 数组。

代码
CPP
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

// 存储每个节点的维护成本
vector<int> arr;
// dp数组，dp[u][0]表示撤销u的情况下的最大维护成本，dp[u][1]表示不撤销u的情况下的最大维护成本
vector<vector<int>> dp;

// 深度优先搜索函数，用于计算dp值
void dfs(int u) {
int left = u * 2 + 1; // 左孩子节点
int right = u * 2 + 2; // 右孩子节点
// 如果是叶子节点
if (left >= arr.size()) {
dp[u][0] = 0; // 撤销叶子节点的维护成本为0
dp[u][1] = arr[u]; // 不撤销叶子节点的维护成本为自身的成本
return;
}
// 递归计算左子树和右子树的dp值
dfs(left); // 先计算左子树
dfs(right); // 再计算右子树
// 如果不撤销u，则u的左、右孩子都必须被撤销
dp[u][1] = dp[left][0] + dp[right][0] + arr[u];
// 如果撤销u，则可以选择左、右孩子是否撤销，取最大值
dp[u][0] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1]);
}

int main() {
int n;
cin >> n; // 输入节点数量
arr.resize(n); // 初始化维护成本数组
for (int i = 0; i < n; i++) {
cin >> arr[i]; // 输入每个节点的维护成本
}

dp.resize(n, vector<int>(2)); // 初始化dp数组

dfs(0); // 从根节点开始计算

// 输出能够节省的最大维护成本
cout << max(dp[0][0], dp[0][1]) << endl;

return 0;
}

python
n = int(input())
arr = [int(i) for i in input().split()]#处理输入
dp = [[0, 0] for i in range(len(arr))]

def dfs(u):
left = u * 2 + 1
right = u * 2 + 2
if left >= n:#如果是叶子节点,求到dp后直接return
dp[u][0] = 0
dp[u][1] = arr[u]
return
dfs(left)#非叶子节点,就要先求到左子树的最大维护成本
dfs(right)#和右子树的最大维护成本
dp[u][0] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1])#如果我们不撤销u
dp[u][1] = dp[left][0] + dp[right][0] + arr[u]#如果我们撤销u

dfs(0)
print(max(dp[0][0], dp[0][1]))

Java
import java.util.Scanner;

public class Main {
static int n;
static int[] arr;
static int[][] dp;

public static void main(String[] args) {
Scanner sc = new Scanner(System.in);
n = sc.nextInt();
arr = new int[n];
dp = new int[n][2];

for (int i = 0; i < n; i++) {
arr[i] = sc.nextInt();
}//处理输入

dfs(0);

System.out.println(Math.max(dp[0][0], dp[0][1]));
}

static void dfs(int u) {
int left = u * 2 + 1;
int right = u * 2 + 2;
if (left >= n) {//如果是叶子节点,求到dp后直接return
dp[u][0] = 0;
dp[u][1] = arr[u];
return;
}
dfs(left);//非叶子节点,就要先求到左子树的最大维护成本
dfs(right);//和右子树的最大维护成本
dp[u][0] = Math.max(dp[left][0], dp[left][1]) + Math.max(dp[right][0], dp[right][1]);//如果我们不撤销u
dp[u][1] = dp[left][0] + dp[right][0] + arr[u];//如果我们撤销u
}
}

Go
package main

import "fmt"

func dfs(u int, arr []int, dp [][]int) {
left := u*2 + 1
right := u*2 + 2
if left >= len(arr) {//如果是叶子节点,求到dp后直接return
dp[u][0] = 0
dp[u][1] = arr[u]
return
}
dfs(left, arr, dp)//非叶子节点,就要先求到左子树的最大维护成本
dfs(right, arr, dp)//和右子树的最大维护成本
dp[u][0] = max(dp[left][0], dp[left][1]) + max(dp[right][0], dp[right][1])//如果我们不撤销u
dp[u][1] = dp[left][0] + dp[right][0] + arr[u]//如果我们撤销u
}

func max(a, b int) int {
if a > b {
return a
}
return b
}

func main() {
var n int
fmt.Scan(&n)

arr := make([]int, n)
for i := 0; i < n; i++ {
fmt.Scan(&arr[i])
}//处理输入

dp := make([][]int, n)
for i := 0; i < n; i++ {
dp[i] = make([]int, 2)
}

dfs(0, arr, dp)

fmt.Println(max(dp[0][0], dp[0][1]))
}

Js
function dfs(u, arr, dp) {
const left = u * 2 + 1;
const right = u * 2 + 2;
if (left >= arr.length) {//如果是叶子节点,求到dp后直接return
dp[u][0] = 0;
dp[u][1] = arr[u];
return;
}
dfs(left, arr, dp);//非叶子节点,就要先求到左子树的最大维护成本
dfs(right, arr, dp);//和右子树的最大维护成本
dp[u][0] = Math.max(dp[left][0], dp[left][1]) + Math.max(dp[right][0], dp[right][1]);//如果我们不撤销u
dp[u][1] = dp[left][0] + dp[right][0] + arr[u];//如果我们撤销u
}

function main() {
const readline = require('readline');//处理输入
const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

let n;
let arr;

rl.on('line', (input) => {
if (!n) {
n = parseInt(input);
} else {
arr = input.split(' ').map(Number);
rl.close();
}
});

rl.on('close', () => {
const dp = new Array(n).fill(null).map(() => new Array(2).fill(0));
dfs(0, arr, dp);
console.log(Math.max(dp[0][0], dp[0][1]));
});
}

main();

题目描述
这天小明在优化他以前做过的一个网络部署的项目，由于软件技术的提升，可以撤销部署网络中的某些节点，以简化网络并降低维护成本。但是，在撤销节点时，不能同时撤销原本直接相邻的两个节点。给定一个满二叉树结构的网络，每个节点上都标有一个数值，表示该节点的年度维护成本。现在要求撤销一些节点，使得可以节省最大的维护成本。
输入的网络以广度优先遍历的方式给出，每个节点都有一个非负整数值表示其年度维护成本。若某个节点不存在，则以000表示。每个数值的范围为 000 到 100010001000。
输入描述
输入第一行为一个正整数NNN，表示后面有NNN个数值。其中1≤1 \leq 1≤N≤10000 \leq 10000≤10000
输入第二行为NNN个非负整数，表示网络节点每年的维护成本，按照满二叉树的广度优先遍历顺序给出。000 表示不存在该关联节点，000 只会存在于叶子节点上。
输出描述
输出能够节省的最大维护成本。
示例1
输入
7
5 3 5 0 6 0 1

输出
12

解释：
能够节省的最大维护成本为555 +6 6 6 + 111 = 121212。
示例2
输入
7
2 7 8 2 4 9 2

输出
19

解释：
能够节省的最大维护成本为 222 + 222 + 444 + 999 + 222 = 191919.

Open Scratchpad (Alt+E)

Quit Scratchpad (Alt+Q)

Submit

UserSolutions (1)

Statistics

关闭

本题属于以下题库，请选择所需题库进行购买

华为校招机考题库（AI软开&AI算法&算法&通软&嵌软&数据科学&测试）

关闭

关闭

Status

Judging Queue
Service Status

Development

Open Source

Support

Help
Contact Us

About

About
Privacy
Terms of Service
Copyright Complaint

Language
English한국어简体中文正體中文

Legacy mode

Theme

Light
Dark

京ICP备2025123107号-1Worker 0, 78ms

Powered by Hydro v5.0.0-beta.15 Community

---

### 第3题-太阳能发电板（P2378）
- 链接：https://codefun2000.com/p/P2378

> 页面标题：#P2378. 第3题-太阳能发电板

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明正在承包月亮市星星区的一片农场。为了提高农场的利润，小明打算选取部分区域引进高级培育技术。已知进行试点的区域的农作物价值计算公式如下：最大利润 = 选中区域中的各地块收入总和 - 区域内地块个数  ×\times× 555。
整个农场区域是一个矩形区域，被划分为 n×mn \times mn×m 个地块。在进行规划前，农场技术人员对每个地块进行了勘测，计算出每个地块的最大年产量，使用 n×mn \times mn×m 矩阵表示。
为了最大化农场的利润，并降低管理成本，小明打算选择一个矩形区域引进高级培育技术。他想知道，应该选择多少个地块进行引进高级培育技术，以获得最大的年利润。
请实现一个功能，求出应该引进高级培育技术的地块数量，以及能够获得的最大年利润。
输入描述
输入第一行为两个正整数: nnn 、mmm, 使用空格分隔。其中AAA 地区分成为 nnn ×\times× mmm 个地块： 111 ≤\leq≤ m,nm,nm,n ≤\leq≤ 100100100,
接下来 nnn行 ,每行 mmm 个正整数。表示每小块区域面积的最大利润收入。000 ≤\leq≤ 收入 ≤\leq≤ 100100100.
输出描述
输出一行为两个整数值，使用空格分隔。第一个值表示引进高级培育技术的地块数，第二个值表示最大利润。
注意：如果存在最大利润相同的情况，则输出引进高级培育技术较小的结果
如果所有地块利润都是负数，则需选择损失最少的那个地块，引进高级培育技术。
样例1
输入
3 3
2 6 9
9 4 9
8 7 3

输出
9 12

解释
全部选择
样例2
输入
3 3
2 6 1
1 4 1
8 7 3

输出
2 5

解释
可以证明，选择左下角那个8和7是最优解。面积是8+7 =15 , 大小是 15 - 5*2 = 5

#### TextSol

题解
题意简易描述
塔子哥需要在一个 n×mn \times mn×m 的农场中选择一个矩形区域进行高级培育技术的引进，以最大化农场的年利润。每个地块有一个预估的收入，选择的区域的利润计算公式为：
最大利润 = 选中区域中各地块收入总和 - 选中地块数 × 5
如果存在多个区域具有相同的最大利润，则选择引进地块数最少的区域。如果所有区域的利润都是负数，则选择损失最少的单个地块。
输入包括农场的大小和每个地块的收入，输出应为选择的地块数和对应的最大利润。
题解思路

利润计算转换：

每个地块的利润为 收入 - 5。这样，选择区域的总利润就是所有地块的 (收入 - 5) 的和。
如果全部地块的 (收入 - 5) 都为负数，意味着选择任何区域都会带来负利润，此时需要选择损失最少的单个地块。

最大子矩形和问题：

将问题转化为在二维数组中找到一个子矩形，其元素和最大。
使用Kadane算法的二维版本来解决此问题。具体步骤如下：

固定两个行边界 top 和 bottom，然后将这两行之间每列的值累加，转化为一维数组。
对这个一维数组应用Kadane算法，找到最大子数组和。
同时记录选择的地块数，以便在利润相同的情况下选择地块数更少的方案。

处理所有负利润的情况：

如果所有地块的 (收入 - 5) 都为负数，选择单个地块中损失最少的那个地块。

记录最大利润和最小地块数：

在遍历过程中，持续更新最大利润和对应的最小地块数。

复杂度分析

时间复杂度：O(n2×m)O(n^2 \times m)O(n2×m)

外层双重循环遍历所有可能的上下边界，共 O(n2)O(n^2)O(n2) 种。
内层对每一列进行累加并应用Kadane算法，时间复杂度为 O(m)O(m)O(m)。

空间复杂度：O(m)O(m)O(m)

使用一个一维数组 temp 存储每列的累加值。

代码
Python 代码
def max_profit(n, m, matrix):
# 将每个地块的收入减去5，得到modified_matrix
modified_matrix = [[cell - 5 for cell in row] for row in matrix]

max_profit = float('-inf')  # 初始化最大利润为负无穷
min_blocks = 0  # 初始化最小地块数

# 遍历所有可能的上下边界
for top in range(n):
temp = [0] * m  # 初始化临时数组
for bottom in range(top, n):
# 累加每列的收入
for col in range(m):
temp[col] += modified_matrix[bottom][col]

# 应用Kadane算法，寻找最大子数组和，并记录地块数
current_sum = 0
current_blocks = 0
for col in range(m):
if current_sum + temp[col] > temp[col]:
current_sum += temp[col]
current_blocks += (bottom - top + 1)
else:
current_sum = temp[col]
current_blocks = (bottom - top + 1)
# 更新最大利润和最小地块数
if current_sum > max_profit:
max_profit = current_sum
min_blocks = current_blocks
elif current_sum == max_profit and current_blocks < min_blocks:
min_blocks = current_blocks

# 如果最大利润小于0，选择最小的损失
if max_profit < 0:
min_loss = float('inf')
min_blocks = 1
for i in range(n):
for j in range(m):
loss = matrix[i][j] - 5
if loss > max_profit:
max_profit = loss
return min_blocks, max_profit
else:
return min_blocks, max_profit

def main():
import sys
input = sys.stdin.read
data = input().split()
n = int(data[0])
m = int(data[1])
matrix = []
idx = 2
for _ in range(n):
row = list(map(int, data[idx:idx + m]))
matrix.append(row)
idx += m
blocks, profit = max_profit(n, m, matrix)
print(blocks, profit)

if __name__ == "__main__":
main()

Java 代码
import java.util.Scanner;

public class Main {
public static int[] maxProfit(int n, int m, int[][] matrix) {
// 将每个地块的收入减去5，得到modified_matrix
int[][] modifiedMatrix = new int[n][m];
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
modifiedMatrix[i][j] = matrix[i][j] - 5;
}
}

int maxProfit = Integer.MIN_VALUE; // 初始化最大利润为负无穷
int minBlocks = 0; // 初始化最小地块数

// 遍历所有可能的上下边界
for(int top=0; top<n; top++) {
int[] temp = new int[m];
for(int bottom=top; bottom<n; bottom++) {
// 累加每列的收入
for(int col=0; col<m; col++) {
temp[col] += modifiedMatrix[bottom][col];
}

// 应用Kadane算法，寻找最大子数组和，并记录地块数
int currentSum = 0;
int currentBlocks = 0;
for(int col=0; col<m; col++) {
if(currentSum + temp[col] > temp[col]) {
currentSum += temp[col];
currentBlocks += (bottom - top + 1);
} else {
currentSum = temp[col];
currentBlocks = (bottom - top + 1);
}
// 更新最大利润和最小地块数
if(currentSum > maxProfit) {
maxProfit = currentSum;
minBlocks = currentBlocks;
}
else if(currentSum == maxProfit && currentBlocks < minBlocks) {
minBlocks = currentBlocks;
}
}
}
}

// 如果最大利润小于0，选择最小的损失
if(maxProfit < 0) {
maxProfit = Integer.MIN_VALUE;
minBlocks = 1;
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
int loss = matrix[i][j] - 5;
if(loss > maxProfit) {
maxProfit = loss;
}
}
}
}

return new int[]{minBlocks, maxProfit};
}

public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
int n = scanner.nextInt();
int m = scanner.nextInt();
int[][] matrix = new int[n][m];
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
matrix[i][j] = scanner.nextInt();
}
}
int[] result = maxProfit(n, m, matrix);
System.out.println(result[0] + " " + result[1]);
}
}

C++ 代码
#include <bits/stdc++.h>
using namespace std;

pair<int, int> maxProfit(int n, int m, vector<vector<int>> &matrix) {
// 将每个地块的收入减去5，得到modified_matrix
vector<vector<int>> modifiedMatrix(n, vector<int>(m, 0));
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
modifiedMatrix[i][j] = matrix[i][j] - 5;
}
}

int maxProfitVal = INT32_MIN; // 初始化最大利润为负无穷
int minBlocks = 0; // 初始化最小地块数

// 遍历所有可能的上下边界
for(int top=0; top<n; top++) {
vector<int> temp(m, 0);
for(int bottom=top; bottom<n; bottom++) {
// 累加每列的收入
for(int col=0; col<m; col++) {
temp[col] += modifiedMatrix[bottom][col];
}

// 应用Kadane算法，寻找最大子数组和，并记录地块数
int currentSum = 0;
int currentBlocks = 0;
for(int col=0; col<m; col++) {
if(currentSum + temp[col] > temp[col]) {
currentSum += temp[col];
currentBlocks += (bottom - top + 1);
}
else {
currentSum = temp[col];
currentBlocks = (bottom - top + 1);
}
// 更新最大利润和最小地块数
if(currentSum > maxProfitVal) {
maxProfitVal = currentSum;
minBlocks = currentBlocks;
}
else if(currentSum == maxProfitVal && currentBlocks < minBlocks) {
minBlocks = currentBlocks;
}
}
}
}

// 如果最大利润小于0，选择最小的损失
if(maxProfitVal < 0) {
maxProfitVal = INT32_MIN;
minBlocks = 1;
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
int loss = matrix[i][j] - 5;
if(loss > maxProfitVal) {
maxProfitVal = loss;
}
}
}
}

return make_pair(minBlocks, maxProfitVal);
}

int main(){
int n, m;
cin >> n >> m;
vector<vector<int>> matrix(n, vector<int>(m, 0));
for(int i=0;i<n;i++) {
for(int j=0;j<m;j++) {
cin >> matrix[i][j];
}
}
pair<int, int> result = maxProfit(n, m, matrix);
cout << result.first << " " << result.second;
return 0;
}

JavaScript 代码
function maxProfit(n, m, matrix) {
// 将每个地块的收入减去5，得到modified_matrix
let modifiedMatrix = Array.from({length: n}, () => Array(m).fill(0));
for(let i=0;i<n;i++) {
for(let j=0;j<m;j++) {
modifiedMatrix[i][j] = matrix[i][j] - 5;
}
}

let maxProfitVal = -Infinity; // 初始化最大利润为负无穷
let minBlocks = 0; // 初始化最小地块数

// 遍历所有可能的上下边界
for(let top=0; top<n; top++) {
let temp = Array(m).fill(0);
for(let bottom=top; bottom<n; bottom++) {
// 累加每列的收入
for(let col=0; col<m; col++) {
temp[col] += modifiedMatrix[bottom][col];
}

// 应用Kadane算法，寻找最大子数组和，并记录地块数
let currentSum = 0;
let currentBlocks = 0;
for(let col=0; col<m; col++) {
if(currentSum + temp[col] > temp[col]) {
currentSum += temp[col];
currentBlocks += (bottom - top + 1);
}
else {
currentSum = temp[col];
currentBlocks = (bottom - top + 1);
}
// 更新最大利润和最小地块数
if(currentSum > maxProfitVal) {
maxProfitVal = currentSum;
minBlocks = currentBlocks;
}
else if(currentSum === maxProfitVal && currentBlocks < minBlocks) {
minBlocks = currentBlocks;
}
}
}
}

// 如果最大利润小于0，选择最小的损失
if(maxProfitVal < 0) {
maxProfitVal = -Infinity;
minBlocks = 1;
for(let i=0;i<n;i++) {
for(let j=0;j<m;j++) {
let loss = matrix[i][j] - 5;
if(loss > maxProfitVal) {
maxProfitVal = loss;
}
}
}
}

return [minBlocks, maxProfitVal];
}

// 读取输入并输出结果
function main() {
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split(/\s+/);
let idx = 0;
const n = parseInt(input[idx++]);
const m = parseInt(input[idx++]);
let matrix = [];
for(let i=0;i<n;i++) {
let row = [];
for(let j=0;j<m;j++) {
row.push(parseInt(input[idx++]));
}
matrix.push(row);
}
const [blocks, profit] = maxProfit(n, m, matrix);
console.log(blocks + " " + profit);
}

main();

---

## 2023年6月14日-暑期实习 第1题-铁路线路优化 中等 第2题-小明回家去 中等 第3题-AI编程题 简单

### 第2题-小明回家去（P2374）
- 链接：https://codefun2000.com/p/P2374

> 页面标题：#P2374. 第2题-小明回家去

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

星际漫游是需要通行证的，塔子收集多年，希望来一次跨越群星的路程，去到一个叫做蓝星的星球，听说那里有一个二字游戏，非常好玩。
很不幸的是，塔子只有若干星球之间的通行证，为了尽快到达心心念念的蓝星，塔子决定找你帮忙规划一下线路。这里规定星际漫游的耗时与经历的星球数成正比。
规定，所有的星球都被编号，从1开始。
解答要求
时间限制:C/C++800msC/C++800msC/C++800ms,其他语言:1600ms1600ms1600ms
内存限制:C/C++60MBC/C++60MBC/C++60MB，其他语言: 120MB120MB120MB
输入
塔子拥有的通行证数目n以及塔子漫游的起点编号m1m1m1（0≤m1≤1000000 \leq m1 \leq 1000000≤m1≤100000）和终点编号m2m2m2（0≤m2≤1000000 \leq m2 \leq 1000000≤m2≤100000），
之后nnn行依次为nnn个通行证，每个通行证有两个数字，用空格隔开，分别表示该通行证允许通行的起点星球编号和终点星球编号。
注意，只能从起点星球飞往终点星球。
输出
计算塔子需要经过的星球数目，不包括起点星球，若无法到达目的地，则返回−1-1−1
样例
输入
1 1 2
1 2

输出
1

解释
本例表示:塔子有111个通行证，刚好直达蓝星，经过蓝星，故输出111。
样例2
输入
3 2 1
1 4
3 2
3 5

输出
-1

解释
拥有的三个通行证无法保证塔子能从编号为222的星球到达编号为111的蓝星，塔子因玩不到二字游戏悲痛欲绝，因此结果为−1-1−1

#### TextSol

题面描述
在这道题中，我们需要帮助塔子规划从起点星球到终点星球的最短路径，给定的路径由若干通行证定义。输入包括通行证的数量和起点、终点的编号，以及每个通行证的起止星球。输出应为塔子需要经过的星球数量（不包括起点），若无法到达终点，则返回 -1。我们可以使用广度优先搜索（BFS）算法来解决此问题，通过构建星球间的图结构，逐层探索可达星球，以找到最短路径或判断不可达。
思路: bfs
朴素的bfs求最短路的题
算法步骤：

图的表示：使用邻接表来表示图。对于每个通行证（边），将起点和终点加入到相应的列表中。
初始化：创建一个数组 vis 用于标记每个星球是否被访问过，以及记录到达该星球所需的步数。
BFS搜索：

初始化队列，将起点放入队列。
进行循环，直到队列为空。在每一层中，遍历当前层的所有星球，并对每个星球的相邻星球进行处理。
如果相邻星球尚未被访问，则更新其访问步数，并将其加入队列。
步数在每一层结束时自增，确保每次都能正确计算到达每个星球的最小步数。

结果输出：检查终点星球的访问步数，如果仍为 0，则表示不可达，输出 -1；否则输出访问步数。

代码
C++
#include<bits/stdc++.h>
using namespace std;

// 定义邻接表
vector<vector<int>> edge;
int vis[100010]; // 访问数组，用于记录每个星球的访问状态和步数
int m1, m2; // 起点和终点星球编号

int main()
{
edge.resize(100010); // 初始化邻接表
int n;
cin >> n >> m1 >> m2; // 输入通行证数量和起终点编号

// 读取通行证信息，构建图
for (int i = 0; i < n; i++)
{
int x, y;
cin >> x >> y; // 输入每个通行证的起点和终点
edge[x].push_back(y); // 建立有向边
}

int step = 0; // 步数计数器
queue<int> qu; // 队列用于 BFS
qu.push(m1); // 将起点加入队列

while (!qu.empty()) // 当队列不为空时继续进行 BFS
{
int sz = qu.size(); // 当前层的节点数量
for (int i = 0; i < sz; i++)
{
int top = qu.front(); // 获取队列头部元素
qu.pop(); // 弹出队列头部元素
for (int v : edge[top]) // 遍历当前节点的所有邻接节点
{
if (vis[v]) // 如果邻接节点已经被访问过
continue; // 跳过该节点
vis[v] = step + 1; // 更新访问步数
qu.push(v); // 将邻接节点加入队列
}
}
// 步数自增，准备处理下一层节点
step++;
}

// 判断终点是否被访问过
if (vis[m2] == 0)
cout << -1 << endl; // 如果没有访问到终点，输出 -1
else
cout << vis[m2] << endl; // 否则输出到达终点的步数

return 0; // 程序结束
}

Python
import sys
from collections import deque, defaultdict

# 广度优先搜索函数，返回从起点到终点的最短路径长度
def bfs(graph, start, end):
# 如果起点和终点相同，直接返回 0
if start == end:
return 0

# 初始化队列，存储当前节点和到达该节点的距离
queue = deque([(start, 0)])
# 使用集合来记录已访问的节点
visited = set([start])

# 开始 BFS 循环
while queue:
current, distance = queue.popleft()  # 弹出队列的第一个元素

# 遍历当前节点的所有邻居
for neighbor in graph[current]:
if neighbor not in visited:  # 如果邻居节点尚未被访问
if neighbor == end:  # 如果找到终点
return distance + 1  # 返回当前距离加一
visited.add(neighbor)  # 标记邻居为已访问
queue.append((neighbor, distance + 1))  # 将邻居加入队列，距离加一

return -1  # 如果队列遍历完仍未找到终点，返回 -1

# 主函数
def main():
input = sys.stdin.read  # 从标准输入读取所有数据
data = input().split()  # 将输入数据按空格分割为列表
index = 0

# 读取通行证数量、起点和终点
n = int(data[index])  # 通行证数量
index += 1
m1 = int(data[index])  # 起点编号
index += 1
m2 = int(data[index])  # 终点编号
index += 1

# 初始化图的邻接表
graph = defaultdict(list)
for _ in range(n):
u = int(data[index])  # 读取边的起点
index += 1
v = int(data[index])  # 读取边的终点
index += 1
graph[u].append(v)  # 将边添加到图中

# 调用 BFS 函数计算从 m1 到 m2 的最短路径
result = bfs(graph, m1, m2)
print(result)  # 输出结果

# 程序入口
if __name__ == "__main__":
main()  # 执行主函数

Java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner sc = new Scanner(System.in); // 创建输入扫描器

// 读取输入的通行证数量、起点和终点
int n = sc.nextInt(); // 通行证数量
int start = sc.nextInt(); // 起点编号
int end = sc.nextInt(); // 终点编号

// 使用哈希表来存储图的邻接表，键是起点，值是与之相连的终点集合
Map<Integer, Set<Integer>> map = new HashMap<>();

// 读取每个通行证的信息，构建图
for (int i = 0; i < n; i++) {
int from = sc.nextInt(); // 通行证的起点
int to = sc.nextInt(); // 通行证的终点

// 获取起点对应的终点集合，如果不存在则创建一个新的集合
Set<Integer> set = map.getOrDefault(from, new HashSet<>());
set.add(to); // 将终点添加到集合中
map.put(from, set); // 更新哈希表
}

// 如果起点在图中不存在，直接输出 -1
if(!map.containsKey(start)){
System.out.println(-1);
return;
}

// 初始化队列用于广度优先搜索
Queue<Integer> queue = new LinkedList<>();
queue.add(start); // 将起点加入队列

int cnt = 0; // 步数计数器
Set<Integer> set = new HashSet<>(); // 记录已访问的节点
set.add(start); // 将起点标记为已访问

// 开始广度优先搜索
while (!queue.isEmpty()){
int size = queue.size(); // 当前层节点数量
for (int i = 0; i < size; i++) {
int from = queue.poll(); // 从队列中取出一个节点
// 检查是否到达终点
if(from == end){
System.out.println(cnt); // 输出当前步数
return;
}
// 如果当前节点在图中有邻接节点
if(map.containsKey(from)){
for(int to : map.get(from)){ // 遍历所有邻接节点
// 如果邻接节点尚未被访问
if(!set.contains(to)){
set.add(to); // 标记为已访问
queue.add(to); // 将其加入队列
}
}
}
}
cnt++; // 步数自增，进入下一层搜索
}
System.out.println(-1); // 如果无法到达终点，输出 -1
}
}

javaScript
const readline = require("readline");

const rl = readline.createInterface({
input: process.stdin,
output: process.stdout
});

async function readInput() {
let lines = [];
for await (const line of rl) {
lines.push(line);
}
return lines;
}

(async function main() {
let lines = await readInput();
let [n, start, end] = lines[0].split(" ").map(Number);

// 边界处理
if (start === end) {
console.log(0);
return;
}

if (n === 0) {
console.log(-1);
return;
}

// 构建邻接表
let graph = Array.from({ length: 100001 }, () => []);
for (let i = 1; i <= n; i++) {
let [from, to] = lines[i].split(" ").map(Number);
graph[from].push(to);
}

// BFS 进行最短路径搜索
let queue = [start]; // BFS 队列
let visited = new Set();
visited.add(start);
let steps = 0;

while (queue.length > 0) {
let size = queue.length;
for (let i = 0; i < size; i++) {
let from = queue.shift();

// 如果到达终点
if (from === end) {
console.log(steps);
return;
}

for (let to of graph[from]) {
if (!visited.has(to)) {
visited.add(to);
queue.push(to);
}
}
}
steps++;
}

console.log(-1); // 无法到达
})();

---

### 第3题-AI编程题（P2375）
- 链接：https://codefun2000.com/p/P2375

> 页面标题：#P2375. 第3题-AI编程题

> ⚠️ 可能需要购买/会员权限，抓到的题面/题解可能不完整。

#### ZhContent

小明是一个不那么严谨的经验主义者，他在使用Stable Diffusion“图生图”功能来画好康的图片时总想要选出上一轮最好看的那几张图片作为下一次“图生图”绘画的参考。
更一般的，“图生图”功能绘画的结果是若干张好康的图片，按照生成的先后顺序由1开始向后编号；同时，小明在心里给它们打了一个分数（不同图片分数可能相同），由于AI绘图实在是不稳定，小明决定删掉分数不大于20分的图片；随后小明会根据他阅图无数的经验得到一个经验值，然后选择图片分数排名等于该经验值的图片作为下一次“图生图”绘画的参考。（注意，这里排名采用dense_rank的方式，即分数从大到小排序，相同分数排名相同）。如果不存在排名恰好经验值的，按最大的排名。
小明希望你帮他找出可以作为“图生图”绘画参考的图片，以便于设置绘图的其他参数。
解答要求
时间限制: C/C++ 1000ms，其他语言: 2000ms
内存限制:C/C++256MB，其他语言:512MB
输入
第一行输入为“图生图”绘制的结果中图片的张数SSS
第二行输入为小明自认为的经验值YYY:
第三行输入为小明给所有图片的评分，评分值以空格分隔。

1≤Y≤未被删除的图片数量≤图片总数≤104\leq Y \leq 未被删除的图片数量 \leq 图片总数 \leq 10^4≤Y≤未被删除的图片数量≤图片总数≤104:
0≤评分分值≤1000\leq 评分分值 \leq 1000≤评分分值≤100

输出
排序最靠后的那些图片的分数和编号以空格分隔。
样例
输入
1
5
98

输出
98 1

解释
小明的经验值Y=5Y=5Y=5，所有图片按照评分编号为111的图片被保留，分数为989898。因此排序最靠后的那张图片的评分为排位第111、编号为1的入围作品，但是很显然这就是排序最靠后那张图片，那么输出 989898 111
样例2
输入
14
1
11 45 14 19 19 81 0 11 45 14 19 19 81 0

输出
81 6 13

解释
被保留的图片编号分别为222，666，999，131313。按分数排序后为:
81(6) 81(13) 45(2) 45(9)
他们的排名为:
1 1 2 2
y = 1 ，则取rank = 1的输出，81 6 13
样例3
输入
14
2
11 45 14 19 19 81 0 11 45 14 19 19 81 0

输出
45 2 9

#### TextSol

题面描述
塔子哥使用Stable Diffusion的“图生图”功能生成了一些图片，并为每张图片打了分数。他希望根据自己的经验值选择出分数排名相应的图片作为下一次绘图的参考。输入包括图片的总数、塔子哥的经验值以及每张图片的评分。输出应为符合条件的图片分数和对应的编号，所有信息以空格分隔。
思路：模拟,排序,哈希表
1.我们使用一个集合 st 来记录已经出现的有效分数，和一个向量 items 来存储这些分数以便后续排序。
2.筛选:对于每一张照片的分数 x，我们首先检查它是否大于 20 分。如果不大于 20 分，则不予考虑，直接跳过。对于大于 20 分的分数，我们检查它是否已经在集合 st 中。如果在，则将其出现的下标记录到一个映射 mp 中；如果不在，则将其加入集合和 items 向量，并在映射中初始化它的下标。
3.在处理完所有照片后，我们对 items 向量进行排序，按从大到小的顺序排列，以便我们可以找到排名第y 的分数。
题解
我们需要从塔子哥生成的图片中筛选出有效的评分，以便选择合适的图片作为下一次“图生图”绘画的参考。具体步骤如下：

数据结构初始化：

使用一个集合 st 来记录已经出现的有效分数，这样可以确保分数的唯一性。
使用一个向量 items 来存储所有有效分数，以便后续的排序操作。
建立一个映射 mp，将有效分数与它们对应的图片下标关联起来，便于查找。

评分筛选：

对于每张图片的评分 x，首先判断其是否大于 20。如果不满足条件，则直接跳过这张图片。
如果评分大于 20，检查该分数是否已经在集合 st 中：

如果在集合中，说明该分数之前已出现，直接将当前图片的下标添加到映射 mp 中。
如果不在集合中，则将分数插入集合 st，同时将其加入 items 向量，并在映射 mp 中初始化该分数对应的下标。

排序与选择：

在处理完所有图片后，使用 sort 函数对 items 向量进行排序，按照分数从大到小的顺序排列，以便查找排名第 y 的分数。
最后，输出排名第 y 的分数以及所有对应的图片下标。

代码
C++代码
#include<bits/stdc++.h>
using namespace std;

int main() {
int s, y; // s: 图片总数, y: 塔子哥的经验值
cin >> s >> y;

// 记录出现过的有效分数——用于去重
unordered_set<int> st;
// 记录所有有效分数——用于后续排序
vector<int> items;
// 建立映射：有效分数 -> 出现下标（图片编号）
unordered_map<int, vector<int>> mp;

for (int i = 1; i <= s; i++) {
int x; // 当前图片的评分
cin >> x;

// 筛选出不大于20分的照片
if (x <= 20)
continue; // 如果分数不符合条件，跳过

// 如果该分数已经出现过，记录当前图片的下标
if (st.count(x)) {
mp[x].push_back(i);
} else {
// 否则，将该分数插入集合并初始化映射
st.insert(x);
items.push_back(x);
mp[x] = vector<int>{ i }; // 初始化下标为当前图片
}
}

// 将所有有效分数进行排序（从大到小）
sort(items.begin(), items.end(), greater<int>());

// 筛选符合经验值的分数
int ans = min((int)items.size(), y); // 确保排名不会超出有效范围
cout << items[ans - 1] << " "; // 输出排名第y的分数

// 输出对应的所有图片下标
int n = mp[items[ans - 1]].size(); // 获取当前分数对应的下标数量
for (int i = 0; i < n; i++) {
cout << mp[items[ans - 1]][i] << ((i < n - 1) ? ' ' : '\n'); // 逐个输出下标，最后一个后换行
}

return 0;
}

Python
def main():
import sys
from collections import defaultdict

# 读取输入
input = sys.stdin.read
data = input().splitlines()

s = int(data[0])  # 图片总数
y = int(data[1])  # 塔子哥的经验值
scores = list(map(int, data[2].split()))  # 图片评分列表

# 记录出现过的有效分数——用于去重
st = set()
# 记录所有有效分数——用于后续排序
items = []
# 建立映射：有效分数 -> 出现下标（图片编号）
mp = defaultdict(list)

for i in range(s):
x = scores[i]  # 当前图片的评分

# 筛选出不大于20分的照片
if x <= 20:
continue  # 如果分数不符合条件，跳过

# 如果该分数已经出现过，记录当前图片的下标
if x in st:
mp[x].append(i + 1)  # 图片编号从1开始
else:
# 否则，将该分数插入集合并初始化映射
st.add(x)
items.append(x)
mp[x].append(i + 1)  # 初始化下标为当前图片编号

# 将所有有效分数进行排序（从大到小）
items.sort(reverse=True)

# 筛选符合经验值的分数
ans = min(len(items), y)  # 确保排名不会超出有效范围
print(items[ans - 1], end=" ")  # 输出排名第y的分数

# 输出对应的所有图片下标
indices = mp[items[ans - 1]]  # 获取当前分数对应的下标列表
print(" ".join(map(str, indices)))  # 逐个输出下标

if __name__ == "__main__":
main()

java
import java.util.*;

public class Main {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);

int s = scanner.nextInt(); // 图片总数
int y = scanner.nextInt(); // 塔子哥的经验值

// 记录出现过的有效分数——用于去重
Set<Integer> st = new HashSet<>();
// 记录所有有效分数——用于后续排序
List<Integer> items = new ArrayList<>();
// 建立映射：有效分数 -> 出现下标（图片编号）
Map<Integer, List<Integer>> mp = new HashMap<>();

for (int i = 1; i <= s; i++) {
int x = scanner.nextInt(); // 当前图片的评分

// 筛选出不大于20分的照片
if (x <= 20) {
continue; // 如果分数不符合条件，跳过
}

// 如果该分数已经出现过，记录当前图片的下标
if (st.contains(x)) {
mp.get(x).add(i);
} else {
// 否则，将该分数插入集合并初始化映射
st.add(x);
items.add(x);
mp.put(x, new ArrayList<>(Arrays.asList(i))); // 初始化下标为当前图片
}
}

// 将所有有效分数进行排序（从大到小）
Collections.sort(items, Collections.reverseOrder());

// 筛选符合经验值的分数
int ans = Math.min(items.size(), y); // 确保排名不会超出有效范围
System.out.print(items.get(ans - 1) + " "); // 输出排名第y的分数

// 输出对应的所有图片下标
List<Integer> indices = mp.get(items.get(ans - 1)); // 获取当前分数对应的下标列表
for (int i = 0; i < indices.size(); i++) {
System.out.print(indices.get(i) + (i < indices.size() - 1 ? " " : "\n")); // 逐个输出下标，最后一个后换行
}

scanner.close(); // 关闭扫描器
}
}

javaScript
const rl = require("readline").createInterface({ input: process.stdin  });
var iter = rl[Symbol.asyncIterator]();
const readline = async () => (await iter.next()).value;

async function main() {
// 读取输入
const s = parseInt(await readline()); // 图片总数
const y = parseInt(await readline()); // 塔子哥的经验值
const scores = (await readline()).split(' ').map(Number); // 图片评分列表

// 记录出现过的有效分数——用于去重
const st = new Set();
// 记录所有有效分数——用于后续排序
const items = [];
// 建立映射：有效分数 -> 出现下标（图片编号）
const mp = new Map();

for (let i = 0; i < s; i++) {
const x = scores[i]; // 当前图片的评分

// 筛选出不大于20分的照片
if (x <= 20) {
continue; // 如果分数不符合条件，跳过
}

// 如果该分数已经出现过，记录当前图片的下标
if (st.has(x))  {
mp.get(x).push(i  + 1); // 图片编号从1开始
} else {
// 否则，将该分数插入集合并初始化映射
st.add(x);
items.push(x);
mp.set(x,  [i + 1]); // 初始化下标为当前图片编号
}
}

// 将所有有效分数进行排序（从大到小）
items.sort((a,  b) => b - a);

// 筛选符合经验值的分数
const ans = Math.min(items.length,  y); // 确保排名不会超出有效范围
process.stdout.write(items[ans  - 1] + " "); // 输出排名第y的分数

// 输出对应的所有图片下标
const indices = mp.get(items[ans  - 1]); // 获取当前分数对应的下标列表
process.stdout.write(indices.join(" ") + "\n"); // 逐个输出下标
}

main().catch(err => console.error(err));

---

