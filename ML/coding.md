题目内容
在自动驾驶系统中，车道线识别是核心功能之一。车道线通常具有连续性，从图像左侧到右侧逐渐展开。

为了识别出最可能的车道线路径，我们可以在图像中找到一条路径，使得路径上所有像素的信号值与策略矩阵的乘积之和最大。

现定义每个位置的能量值为策略矩阵与该位置周边信号值的乘积和。

给定一个 
H
×
W
H×W 的图像以及一个 
K
×
K
K×K 的策略矩阵，用于模拟不同方向的路径选择策略。

你需要从图像的第一列任意像素出发，走到最后一列任意像素，每一步只能向右、右上、右下移动一格。

在行进的过程中，需要实时的收集能量值，请找到一条路径，使得路径上的能量值之和最大。

输入描述
第一行输入 
H
H 
W
W 
K
K 
K
K ，分表表示给定图像及策略矩阵的维度

接下来

H
H 行输入图像矩阵

K
K 行输入策略矩阵

输出描述
输出最大能量值

样例1
输入

1 1 1 1
5
1
输出

5.0
说明

有且仅有一条路径，最大能量值为 
5
∗
1
5∗1 为 
5.0
5.0

样例2
输入

3 3 3 3
1 2 3
4 5 6
7 8 9
1 2 2
1 1 1
1 1 1
输出

119.0
说明

输入第一行是一个 
3
×
3
3×3 的图像以及 
3
×
3
3×3 的策略矩阵

每个位置的能量图：

[
[
12.21.16.
]
[[12.21.16.]

[
30.50.36.
]
[30.50.36.]

[
33.50.34.
]
]
[33.50.34.]]

最大能量路径的值：
119.0
119.0 最大能量路径：
(
2
,
0
)
−
>
(
1
,
1
)
−
>
(
1
,
2
)
(2,0)−>(1,1)−>(1,2)

提示
1.
1.策略矩阵为奇数，边缘处用零填充

2.
2.输出保留一位小数

思路：
当然可以，我把这题用“非常直白的两步”讲清楚，你再回头看代码就会觉得它其实在做两件事：

---

## 这题到底要你干嘛？（一句话版）

1. 先把原图像 `I` 变成一个“能量图” `E`（每个像素位置都有一个能量值）
2. 再在能量图 `E` 上找一条从**第一列走到最后一列**的路径（每步只能 →、↗、↘），让沿途能量和最大

输出这个最大值（保留 1 位小数）。

---

## Step 1：什么是“能量值 E[i][j]”？

题目说：**每个位置的能量 = 策略矩阵 P 与该位置周边信号值的乘积和**。

这其实就是一个“卷积/滑动加权求和”的东西：

* `I` 是 H×W 图像（二维数表）
* `P` 是 K×K 策略矩阵（K 是奇数，比如 3、5…）
* 对每个位置 (i,j)，拿它周围一个 K×K 小窗口（以它为中心）
* 把窗口里的值和 `P` 对应位置逐项相乘再求和
* **窗口超出图像边界的地方按 0 处理（零填充）**

公式写成：

[
E[i][j]=\sum_{u=0}^{K-1}\sum_{v=0}^{K-1} P[u][v]\cdot I[i+(u-r)][j+(v-r)]
]
其中 (r=\lfloor K/2\rfloor)，如果 (I[\cdot][\cdot]) 越界，就当作 0。

### 一个超小例子（K=1）

如果 K=1，那么窗口就只有自己：

* (E[i][j]=P[0][0]\cdot I[i][j])

样例1就是这样：5 × 1 = 5.0

---

## Step 2：在能量图 E 上走“最大能量路径”

现在你有了一个 H×W 的能量图 `E`。

你要从**第 0 列**任意一行出发，走到**第 W-1 列**任意一行。
每一步列数 +1，行数可以：

* 不变（→）
* -1（↗）
* +1（↘）

所以路径长度一定是 W（每列踩一个格子）。

### 动态规划怎么写？

定义：

* (f[i][j])：走到第 j 列、第 i 行时，能拿到的**最大累计能量**

**初始（第一列）**：
[
f[i][0]=E[i][0]
]

**转移（从 j-1 列到 j 列）**：
[
f[i][j]=E[i][j]+\max\Big(f[i][j-1],\ f[i-1][j-1],\ f[i+1][j-1]\Big)
]
（注意 i-1、i+1 要在 0..H-1 范围内）

**答案**：
[
\max_{0\le i < H} f[i][W-1]
]

---

## 用样例2把 DP 走一遍（你会立刻懂）

题目给的能量图是：

[
E=
\begin{bmatrix}
12 & 21 & 16\
30 & 50 & 36\
33 & 50 & 34
\end{bmatrix}
]

### 第 0 列（初始化）

`f[:,0] = E[:,0]`：

* f[0,0]=12
* f[1,0]=30
* f[2,0]=33

### 第 1 列

* f[0,1] = 21 + max(f[0,0], f[1,0]) = 21 + max(12,30)=51
* f[1,1] = 50 + max(f[1,0], f[0,0], f[2,0]) = 50 + max(30,12,33)=83
* f[2,1] = 50 + max(f[2,0], f[1,0]) = 50 + max(33,30)=83

### 第 2 列

* f[0,2] = 16 + max(f[0,1], f[1,1]) = 16 + max(51,83)=99
* f[1,2] = 36 + max(f[1,1], f[0,1], f[2,1]) = 36 + max(83,51,83)=119 ✅
* f[2,2] = 34 + max(f[2,1], f[1,1]) = 34 + max(83,83)=117

最后一列最大值是 **119**，对应路径就是题目说的：
(2,0) → (1,1) → (1,2)

---

## 你这段代码在干什么（对照讲解）

### 1）读入

第一行是 `H W K K`（题面写了两次 K，通常相等），所以你代码读了 4 个数：

```python
H = int(next(it)); W = int(next(it)); K1 = int(next(it)); K2 = int(next(it))
K = K1
```

### 2）算能量图 E（零填充卷积）

```python
r = K // 2
for i in range(H):
  for j in range(W):
    s = 0
    for u in range(K):
      ii = i + (u-r)
      if 0<=ii<H:
        for v in range(K):
          jj = j + (v-r)
          if 0<=jj<W:
            s += P[u][v] * I[ii][jj]
    E[i][j] = s
```

这就是上面那个公式，只是把越界的格子直接跳过（等价于乘 0）。

### 3）DP 找最大路径（滚动数组省空间）

`prev[i]` 表示上一列的 f[i][j-1]，`cur[i]` 是当前列的 f[i][j]：

```python
prev[i] = E[i][0]          # 初始化第一列

for j in range(1, W):
  for i in range(H):
    best = max(prev[i], prev[i-1], prev[i+1])  # 边界判断
    cur[i] = E[i][j] + best
  prev = cur

ans = max(prev)
```

最后格式化输出 1 位小数：

```python
print(f"{ans:.1f}")
```

---

## 你现在只要记住这句就不会迷糊了

> **先把原图按策略矩阵算成能量图（卷积），再在能量图上做“只能往右走”的最大路径 DP。**

---

如果你愿意，我也可以用一个 **2×4、K=3 的超小手算例子**带你把“能量怎么算出来 + DP 怎么滚动更新”完整走一遍（你会彻底掌握）。

答案：
import sys

def main():
    data = sys.stdin.read().strip().split()
    it = iter(data)
    H = int(next(it)); W = int(next(it)); K1 = int(next(it)); K2 = int(next(it))
    K = K1  # 题面给了两个K，这里取第一个；通常两者相等

    # 读图像矩阵
    I = [[float(next(it)) for _ in range(W)] for _ in range(H)]
    # 读策略矩阵
    P = [[float(next(it)) for _ in range(K)] for _ in range(K)]

    # 计算能量图（零填充卷积）
    r = K // 2
    E = [[0.0]*W for _ in range(H)]
    for i in range(H):
        for j in range(W):
            s = 0.0
            for u in range(K):
                ii = i + (u - r)
                if 0 <= ii < H:
                    rowI = I[ii]
                    rowP = P[u]
                    for v in range(K):
                        jj = j + (v - r)
                        if 0 <= jj < W:
                            s += rowP[v] * rowI[jj]
            E[i][j] = s

    # 动态规划
    NEG = -1e300
    prev = [NEG]*H
    for i in range(H):
        prev[i] = E[i][0]

    for j in range(1, W):
        cur = [NEG]*H
        for i in range(H):
            best = prev[i]
            if i-1 >= 0:
                best = max(best, prev[i-1])
            if i+1 < H:
                best = max(best, prev[i+1])
            cur[i] = E[i][j] + best
        prev = cur

    ans = max(prev)
    print(f"{ans:.1f}")

if __name__ == "__main__":
    main()
